# -*- coding: utf-8 -*-

# write the data as python dict
# implement the write protocol
def encode(s): return s.encode('utf-8')
f = None

init_file = None

def WRITE_DATA(value, type_):
	if type_ == "default":
		if isinstance(value, bool):
			type_ = "bool"
		elif isinstance(value, int ):
			type_ = "int"
		elif isinstance(value, float):
			type_ = "float"
		elif isinstance(value, (str, unicode)):
			type_ = "str"
		else:
			print type(value)
			print ">>> [E] type error:(%s,%s)"%(value, type_)

	notStrType = ["str_list", "dict"]
	if not isinstance(value, (str, unicode)) and not type_ in notStrType:
		value = str(value)

	if type_ == "str":
		f.write( "'" + encode(value).replace("'", "\\'").replace("\n", "") + "'" )
	elif type_ == "int":
		try:
			f.write( str(int(float(value))) )
		except:
			f.write("0")
	elif type_ == "float":
		if len(value) == 0:
			f.write(str(float(0.0)))
		else:
			f.write(str(float(value)))
	elif type_ == "bool":
		if value:
			f.write("true")
		else:
			f.write("false")
	elif type_ == "py":
		f.write( encode(value) )
	elif type_ == "lua":
		f.write( encode(value) )
	elif type_ == "text":
		f.write("TEXT('"+encode(value).replace("'", "\\'").replace("\n", "")+"')")
	elif type_ == "text_str_list":
		if len(value) > 0:
			ls = value.split("@")
		else:
			ls = []
		write_list(ls, "\t\t", "text")
	elif type_ == "lua_formula_function":
		f.write(encode(value))
	elif type_ == "lua_lvar_function":
		f.write(encode(value))
	elif type_ == "skill_damage_formula_function":
		f.write(encode(value))
	elif type_ == "lua_skill_lvar_function":
		f.write(encode(value))
	elif type_ == "lua_cond_function":
		f.write(encode(value))
	elif type_ == "format_str":
		f.write(encode(value))
	elif type_ == "format_text":
		f.write("TEXT('"+encode(value)+"')")
	elif type_ == "str_list":
		if isinstance(value, list): 
			write_list(value, "\t\t", "text")
		else:
			value = value.split(",")
			write_list(value, "\t\t", "str")
	elif type_ == "int_list":
		if isinstance(value, list): 
			write_list(value, "\t\t", "int")
		else:
			value = value.split(",")
			write_list(value, "\t\t", "int")
	elif type_ == "dict":
		write_dict(value, "\t\t")
	elif type_ == "macro":
		if len(value) == 0:
			f.write("''")
		else:
			f.write(encode(value))
	else:
		print type(value)
		print ">>> [E] type error:(%s,%s)"%(value, type_)
		
def START_DATA(xls_file, file_, sheet):
	import os
	global f, init_file

	file_ += ".lua"
	dir_ = os.path.dirname(file_)
	if not os.path.exists(dir_):
		os.makedirs(dir_)

	"""
	if init_file == None:
		init_file = open( dir_ + "/init.lua", "w" )

	init_file.write( "fs_require(\"%s\", \"%s/%s\")\n" %("script/data", "info", os.path.basename(file_)) )
	"""

	f = open( file_, 'w')
	f.write( "-- ------------------------------\n" )
	f.write( "-- desc: generated by xls2data.py\n" )
	f.write( "-- source: " )
	f.write( os.path.basename(xls_file).decode('utf-8').encode('utf-8') )
	f.write( "\n" )
	f.write( "-- sheet: %s\n"%encode(sheet) )
	f.write( "-- ------------------------------\n" )

def START_DATA_FILE(fd):
	global f
	f = fd

def START_DICT(dict_):
	#f.write( "\n\n%s = table.protect({\n" % dict_ )
	f.write( "\n\n%s = {\n" % dict_ )

def START_DICT_PROTECT(dict_):
	f.write( "\n\n%s = table.protect({\n" % dict_ )

def START_ROW(id_, type_):
	f.write( "\t[" )
	WRITE_DATA(id_, type_)
	f.write( "] = {\n" )

def WRITE_ATTR(key, value, type_):
	#print key,value, type_
	try:
		f.write( "\t\t[" )
		WRITE_DATA( key, "str" )
		f.write( "] = " )
		WRITE_DATA( value, type_ )
		f.write( ",\n" )
	except UnicodeEncodeError:
		print u">>> [E] 导表出错, 字符串编码出错", key
		raise
		

def END_ROW():
	f.write( "\t},\n" )

def END_DATA():
	#f.write( "})\n" )
	f.write( "}\n" )

def END_DATA_PROTECT():
	f.write( "})\n" )

def write_variable(value, indent, t="default"):
	if isinstance(value, dict):
		write_dict(value, indent)
	elif isinstance(value, list) or isinstance(value, tuple):
		write_list(value, indent)
	else:
		WRITE_DATA(value, t)

def write_list(value, indent, t="default"):
	f.write( "{\n")
	for v in value:
		f.write( indent + "\t")
		write_variable(v, indent + "\t", t)
		f.write(",\n")
	f.write( indent + "}")

def write_dict(value, indent):
	f.write( "{\n")
	for key in value.iterkeys():
		f.write( indent + "\t[")
		write_variable(key, indent)
		f.write("]=")
		write_variable(value[key], indent + "\t")
		f.write(",\n")
	f.write( indent + "}")

def WRITE_VAR(name, var):
	f.write("\n\n%s = "%name)
	write_variable(var, "")

def END():
	f.close()


