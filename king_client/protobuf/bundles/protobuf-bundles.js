var $protobuf = window.protobuf;
$protobuf.roots.default=window;
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.pb = (function() {

    /**
     * Namespace pb.
     * @exports pb
     * @namespace
     */
    var pb = {};

    pb.TreasureReadAdsArg = (function() {

        /**
         * Properties of a TreasureReadAdsArg.
         * @memberof pb
         * @interface ITreasureReadAdsArg
         * @property {number|null} [TreasureID] TreasureReadAdsArg TreasureID
         * @property {boolean|null} [IsConsumeJade] TreasureReadAdsArg IsConsumeJade
         */

        /**
         * Constructs a new TreasureReadAdsArg.
         * @memberof pb
         * @classdesc Represents a TreasureReadAdsArg.
         * @implements ITreasureReadAdsArg
         * @constructor
         * @param {pb.ITreasureReadAdsArg=} [properties] Properties to set
         */
        function TreasureReadAdsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureReadAdsArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.TreasureReadAdsArg
         * @instance
         */
        TreasureReadAdsArg.prototype.TreasureID = 0;

        /**
         * TreasureReadAdsArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.TreasureReadAdsArg
         * @instance
         */
        TreasureReadAdsArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new TreasureReadAdsArg instance using the specified properties.
         * @function create
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {pb.ITreasureReadAdsArg=} [properties] Properties to set
         * @returns {pb.TreasureReadAdsArg} TreasureReadAdsArg instance
         */
        TreasureReadAdsArg.create = function create(properties) {
            return new TreasureReadAdsArg(properties);
        };

        /**
         * Encodes the specified TreasureReadAdsArg message. Does not implicitly {@link pb.TreasureReadAdsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {pb.ITreasureReadAdsArg} message TreasureReadAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureReadAdsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified TreasureReadAdsArg message, length delimited. Does not implicitly {@link pb.TreasureReadAdsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {pb.ITreasureReadAdsArg} message TreasureReadAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureReadAdsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureReadAdsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TreasureReadAdsArg} TreasureReadAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureReadAdsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TreasureReadAdsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                case 2:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureReadAdsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TreasureReadAdsArg} TreasureReadAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureReadAdsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureReadAdsArg message.
         * @function verify
         * @memberof pb.TreasureReadAdsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureReadAdsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return TreasureReadAdsArg;
    })();

    pb.TreasureReadAdsReply = (function() {

        /**
         * Properties of a TreasureReadAdsReply.
         * @memberof pb
         * @interface ITreasureReadAdsReply
         * @property {number|null} [RemainTime] TreasureReadAdsReply RemainTime
         */

        /**
         * Constructs a new TreasureReadAdsReply.
         * @memberof pb
         * @classdesc Represents a TreasureReadAdsReply.
         * @implements ITreasureReadAdsReply
         * @constructor
         * @param {pb.ITreasureReadAdsReply=} [properties] Properties to set
         */
        function TreasureReadAdsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureReadAdsReply RemainTime.
         * @member {number} RemainTime
         * @memberof pb.TreasureReadAdsReply
         * @instance
         */
        TreasureReadAdsReply.prototype.RemainTime = 0;

        /**
         * Creates a new TreasureReadAdsReply instance using the specified properties.
         * @function create
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {pb.ITreasureReadAdsReply=} [properties] Properties to set
         * @returns {pb.TreasureReadAdsReply} TreasureReadAdsReply instance
         */
        TreasureReadAdsReply.create = function create(properties) {
            return new TreasureReadAdsReply(properties);
        };

        /**
         * Encodes the specified TreasureReadAdsReply message. Does not implicitly {@link pb.TreasureReadAdsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {pb.ITreasureReadAdsReply} message TreasureReadAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureReadAdsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified TreasureReadAdsReply message, length delimited. Does not implicitly {@link pb.TreasureReadAdsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {pb.ITreasureReadAdsReply} message TreasureReadAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureReadAdsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureReadAdsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TreasureReadAdsReply} TreasureReadAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureReadAdsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TreasureReadAdsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureReadAdsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TreasureReadAdsReply} TreasureReadAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureReadAdsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureReadAdsReply message.
         * @function verify
         * @memberof pb.TreasureReadAdsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureReadAdsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return TreasureReadAdsReply;
    })();

    pb.DailyTreasureReadAdsArg = (function() {

        /**
         * Properties of a DailyTreasureReadAdsArg.
         * @memberof pb
         * @interface IDailyTreasureReadAdsArg
         * @property {boolean|null} [IsConsumeJade] DailyTreasureReadAdsArg IsConsumeJade
         */

        /**
         * Constructs a new DailyTreasureReadAdsArg.
         * @memberof pb
         * @classdesc Represents a DailyTreasureReadAdsArg.
         * @implements IDailyTreasureReadAdsArg
         * @constructor
         * @param {pb.IDailyTreasureReadAdsArg=} [properties] Properties to set
         */
        function DailyTreasureReadAdsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyTreasureReadAdsArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.DailyTreasureReadAdsArg
         * @instance
         */
        DailyTreasureReadAdsArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new DailyTreasureReadAdsArg instance using the specified properties.
         * @function create
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {pb.IDailyTreasureReadAdsArg=} [properties] Properties to set
         * @returns {pb.DailyTreasureReadAdsArg} DailyTreasureReadAdsArg instance
         */
        DailyTreasureReadAdsArg.create = function create(properties) {
            return new DailyTreasureReadAdsArg(properties);
        };

        /**
         * Encodes the specified DailyTreasureReadAdsArg message. Does not implicitly {@link pb.DailyTreasureReadAdsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {pb.IDailyTreasureReadAdsArg} message DailyTreasureReadAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyTreasureReadAdsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified DailyTreasureReadAdsArg message, length delimited. Does not implicitly {@link pb.DailyTreasureReadAdsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {pb.IDailyTreasureReadAdsArg} message DailyTreasureReadAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyTreasureReadAdsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyTreasureReadAdsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DailyTreasureReadAdsArg} DailyTreasureReadAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyTreasureReadAdsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DailyTreasureReadAdsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyTreasureReadAdsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DailyTreasureReadAdsArg} DailyTreasureReadAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyTreasureReadAdsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyTreasureReadAdsArg message.
         * @function verify
         * @memberof pb.DailyTreasureReadAdsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyTreasureReadAdsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return DailyTreasureReadAdsArg;
    })();

    pb.WatchUpTreasureRareAdsArg = (function() {

        /**
         * Properties of a WatchUpTreasureRareAdsArg.
         * @memberof pb
         * @interface IWatchUpTreasureRareAdsArg
         * @property {boolean|null} [IsConsumeJade] WatchUpTreasureRareAdsArg IsConsumeJade
         */

        /**
         * Constructs a new WatchUpTreasureRareAdsArg.
         * @memberof pb
         * @classdesc Represents a WatchUpTreasureRareAdsArg.
         * @implements IWatchUpTreasureRareAdsArg
         * @constructor
         * @param {pb.IWatchUpTreasureRareAdsArg=} [properties] Properties to set
         */
        function WatchUpTreasureRareAdsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchUpTreasureRareAdsArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @instance
         */
        WatchUpTreasureRareAdsArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new WatchUpTreasureRareAdsArg instance using the specified properties.
         * @function create
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {pb.IWatchUpTreasureRareAdsArg=} [properties] Properties to set
         * @returns {pb.WatchUpTreasureRareAdsArg} WatchUpTreasureRareAdsArg instance
         */
        WatchUpTreasureRareAdsArg.create = function create(properties) {
            return new WatchUpTreasureRareAdsArg(properties);
        };

        /**
         * Encodes the specified WatchUpTreasureRareAdsArg message. Does not implicitly {@link pb.WatchUpTreasureRareAdsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {pb.IWatchUpTreasureRareAdsArg} message WatchUpTreasureRareAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchUpTreasureRareAdsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified WatchUpTreasureRareAdsArg message, length delimited. Does not implicitly {@link pb.WatchUpTreasureRareAdsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {pb.IWatchUpTreasureRareAdsArg} message WatchUpTreasureRareAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchUpTreasureRareAdsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchUpTreasureRareAdsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchUpTreasureRareAdsArg} WatchUpTreasureRareAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchUpTreasureRareAdsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchUpTreasureRareAdsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchUpTreasureRareAdsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchUpTreasureRareAdsArg} WatchUpTreasureRareAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchUpTreasureRareAdsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchUpTreasureRareAdsArg message.
         * @function verify
         * @memberof pb.WatchUpTreasureRareAdsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchUpTreasureRareAdsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return WatchUpTreasureRareAdsArg;
    })();

    pb.WatchTreasureAddCardAdsArg = (function() {

        /**
         * Properties of a WatchTreasureAddCardAdsArg.
         * @memberof pb
         * @interface IWatchTreasureAddCardAdsArg
         * @property {number|null} [TreasureID] WatchTreasureAddCardAdsArg TreasureID
         * @property {boolean|null} [IsConsumeJade] WatchTreasureAddCardAdsArg IsConsumeJade
         */

        /**
         * Constructs a new WatchTreasureAddCardAdsArg.
         * @memberof pb
         * @classdesc Represents a WatchTreasureAddCardAdsArg.
         * @implements IWatchTreasureAddCardAdsArg
         * @constructor
         * @param {pb.IWatchTreasureAddCardAdsArg=} [properties] Properties to set
         */
        function WatchTreasureAddCardAdsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchTreasureAddCardAdsArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @instance
         */
        WatchTreasureAddCardAdsArg.prototype.TreasureID = 0;

        /**
         * WatchTreasureAddCardAdsArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @instance
         */
        WatchTreasureAddCardAdsArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new WatchTreasureAddCardAdsArg instance using the specified properties.
         * @function create
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {pb.IWatchTreasureAddCardAdsArg=} [properties] Properties to set
         * @returns {pb.WatchTreasureAddCardAdsArg} WatchTreasureAddCardAdsArg instance
         */
        WatchTreasureAddCardAdsArg.create = function create(properties) {
            return new WatchTreasureAddCardAdsArg(properties);
        };

        /**
         * Encodes the specified WatchTreasureAddCardAdsArg message. Does not implicitly {@link pb.WatchTreasureAddCardAdsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {pb.IWatchTreasureAddCardAdsArg} message WatchTreasureAddCardAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchTreasureAddCardAdsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified WatchTreasureAddCardAdsArg message, length delimited. Does not implicitly {@link pb.WatchTreasureAddCardAdsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {pb.IWatchTreasureAddCardAdsArg} message WatchTreasureAddCardAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchTreasureAddCardAdsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchTreasureAddCardAdsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchTreasureAddCardAdsArg} WatchTreasureAddCardAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchTreasureAddCardAdsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchTreasureAddCardAdsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                case 2:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchTreasureAddCardAdsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchTreasureAddCardAdsArg} WatchTreasureAddCardAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchTreasureAddCardAdsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchTreasureAddCardAdsArg message.
         * @function verify
         * @memberof pb.WatchTreasureAddCardAdsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchTreasureAddCardAdsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return WatchTreasureAddCardAdsArg;
    })();

    pb.BattleLoseReadAdsReply = (function() {

        /**
         * Properties of a BattleLoseReadAdsReply.
         * @memberof pb
         * @interface IBattleLoseReadAdsReply
         * @property {number|null} [AddStar] BattleLoseReadAdsReply AddStar
         */

        /**
         * Constructs a new BattleLoseReadAdsReply.
         * @memberof pb
         * @classdesc Represents a BattleLoseReadAdsReply.
         * @implements IBattleLoseReadAdsReply
         * @constructor
         * @param {pb.IBattleLoseReadAdsReply=} [properties] Properties to set
         */
        function BattleLoseReadAdsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleLoseReadAdsReply AddStar.
         * @member {number} AddStar
         * @memberof pb.BattleLoseReadAdsReply
         * @instance
         */
        BattleLoseReadAdsReply.prototype.AddStar = 0;

        /**
         * Creates a new BattleLoseReadAdsReply instance using the specified properties.
         * @function create
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {pb.IBattleLoseReadAdsReply=} [properties] Properties to set
         * @returns {pb.BattleLoseReadAdsReply} BattleLoseReadAdsReply instance
         */
        BattleLoseReadAdsReply.create = function create(properties) {
            return new BattleLoseReadAdsReply(properties);
        };

        /**
         * Encodes the specified BattleLoseReadAdsReply message. Does not implicitly {@link pb.BattleLoseReadAdsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {pb.IBattleLoseReadAdsReply} message BattleLoseReadAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleLoseReadAdsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddStar != null && message.hasOwnProperty("AddStar"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AddStar);
            return writer;
        };

        /**
         * Encodes the specified BattleLoseReadAdsReply message, length delimited. Does not implicitly {@link pb.BattleLoseReadAdsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {pb.IBattleLoseReadAdsReply} message BattleLoseReadAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleLoseReadAdsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleLoseReadAdsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BattleLoseReadAdsReply} BattleLoseReadAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleLoseReadAdsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BattleLoseReadAdsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AddStar = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleLoseReadAdsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BattleLoseReadAdsReply} BattleLoseReadAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleLoseReadAdsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleLoseReadAdsReply message.
         * @function verify
         * @memberof pb.BattleLoseReadAdsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleLoseReadAdsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddStar != null && message.hasOwnProperty("AddStar"))
                if (!$util.isInteger(message.AddStar))
                    return "AddStar: integer expected";
            return null;
        };

        return BattleLoseReadAdsReply;
    })();

    /**
     * ShopFreeAdsType enum.
     * @name pb.ShopFreeAdsType
     * @enum {string}
     * @property {number} GoldAds=0 GoldAds value
     * @property {number} TreasureAds=1 TreasureAds value
     * @property {number} JadeAds=2 JadeAds value
     */
    pb.ShopFreeAdsType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GoldAds"] = 0;
        values[valuesById[1] = "TreasureAds"] = 1;
        values[valuesById[2] = "JadeAds"] = 2;
        return values;
    })();

    pb.ShopFreeAds = (function() {

        /**
         * Properties of a ShopFreeAds.
         * @memberof pb
         * @interface IShopFreeAds
         * @property {pb.ShopFreeAdsType|null} [Type] ShopFreeAds Type
         * @property {number|null} [ID] ShopFreeAds ID
         * @property {number|null} [RemainTime] ShopFreeAds RemainTime
         * @property {boolean|null} [CanGet] ShopFreeAds CanGet
         */

        /**
         * Constructs a new ShopFreeAds.
         * @memberof pb
         * @classdesc Represents a ShopFreeAds.
         * @implements IShopFreeAds
         * @constructor
         * @param {pb.IShopFreeAds=} [properties] Properties to set
         */
        function ShopFreeAds(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopFreeAds Type.
         * @member {pb.ShopFreeAdsType} Type
         * @memberof pb.ShopFreeAds
         * @instance
         */
        ShopFreeAds.prototype.Type = 0;

        /**
         * ShopFreeAds ID.
         * @member {number} ID
         * @memberof pb.ShopFreeAds
         * @instance
         */
        ShopFreeAds.prototype.ID = 0;

        /**
         * ShopFreeAds RemainTime.
         * @member {number} RemainTime
         * @memberof pb.ShopFreeAds
         * @instance
         */
        ShopFreeAds.prototype.RemainTime = 0;

        /**
         * ShopFreeAds CanGet.
         * @member {boolean} CanGet
         * @memberof pb.ShopFreeAds
         * @instance
         */
        ShopFreeAds.prototype.CanGet = false;

        /**
         * Creates a new ShopFreeAds instance using the specified properties.
         * @function create
         * @memberof pb.ShopFreeAds
         * @static
         * @param {pb.IShopFreeAds=} [properties] Properties to set
         * @returns {pb.ShopFreeAds} ShopFreeAds instance
         */
        ShopFreeAds.create = function create(properties) {
            return new ShopFreeAds(properties);
        };

        /**
         * Encodes the specified ShopFreeAds message. Does not implicitly {@link pb.ShopFreeAds.verify|verify} messages.
         * @function encode
         * @memberof pb.ShopFreeAds
         * @static
         * @param {pb.IShopFreeAds} message ShopFreeAds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopFreeAds.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ID);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RemainTime);
            if (message.CanGet != null && message.hasOwnProperty("CanGet"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.CanGet);
            return writer;
        };

        /**
         * Encodes the specified ShopFreeAds message, length delimited. Does not implicitly {@link pb.ShopFreeAds.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ShopFreeAds
         * @static
         * @param {pb.IShopFreeAds} message ShopFreeAds message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopFreeAds.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopFreeAds message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ShopFreeAds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ShopFreeAds} ShopFreeAds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopFreeAds.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShopFreeAds();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.ID = reader.int32();
                    break;
                case 3:
                    message.RemainTime = reader.int32();
                    break;
                case 4:
                    message.CanGet = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopFreeAds message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ShopFreeAds
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ShopFreeAds} ShopFreeAds
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopFreeAds.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopFreeAds message.
         * @function verify
         * @memberof pb.ShopFreeAds
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopFreeAds.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.CanGet != null && message.hasOwnProperty("CanGet"))
                if (typeof message.CanGet !== "boolean")
                    return "CanGet: boolean expected";
            return null;
        };

        return ShopFreeAds;
    })();

    pb.WatchShopFreeAdsArg = (function() {

        /**
         * Properties of a WatchShopFreeAdsArg.
         * @memberof pb
         * @interface IWatchShopFreeAdsArg
         * @property {pb.ShopFreeAdsType|null} [Type] WatchShopFreeAdsArg Type
         * @property {number|null} [ID] WatchShopFreeAdsArg ID
         * @property {boolean|null} [IsConsumeJade] WatchShopFreeAdsArg IsConsumeJade
         */

        /**
         * Constructs a new WatchShopFreeAdsArg.
         * @memberof pb
         * @classdesc Represents a WatchShopFreeAdsArg.
         * @implements IWatchShopFreeAdsArg
         * @constructor
         * @param {pb.IWatchShopFreeAdsArg=} [properties] Properties to set
         */
        function WatchShopFreeAdsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchShopFreeAdsArg Type.
         * @member {pb.ShopFreeAdsType} Type
         * @memberof pb.WatchShopFreeAdsArg
         * @instance
         */
        WatchShopFreeAdsArg.prototype.Type = 0;

        /**
         * WatchShopFreeAdsArg ID.
         * @member {number} ID
         * @memberof pb.WatchShopFreeAdsArg
         * @instance
         */
        WatchShopFreeAdsArg.prototype.ID = 0;

        /**
         * WatchShopFreeAdsArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.WatchShopFreeAdsArg
         * @instance
         */
        WatchShopFreeAdsArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new WatchShopFreeAdsArg instance using the specified properties.
         * @function create
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {pb.IWatchShopFreeAdsArg=} [properties] Properties to set
         * @returns {pb.WatchShopFreeAdsArg} WatchShopFreeAdsArg instance
         */
        WatchShopFreeAdsArg.create = function create(properties) {
            return new WatchShopFreeAdsArg(properties);
        };

        /**
         * Encodes the specified WatchShopFreeAdsArg message. Does not implicitly {@link pb.WatchShopFreeAdsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {pb.IWatchShopFreeAdsArg} message WatchShopFreeAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchShopFreeAdsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ID);
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified WatchShopFreeAdsArg message, length delimited. Does not implicitly {@link pb.WatchShopFreeAdsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {pb.IWatchShopFreeAdsArg} message WatchShopFreeAdsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchShopFreeAdsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchShopFreeAdsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchShopFreeAdsArg} WatchShopFreeAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchShopFreeAdsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchShopFreeAdsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.ID = reader.int32();
                    break;
                case 3:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchShopFreeAdsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchShopFreeAdsArg} WatchShopFreeAdsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchShopFreeAdsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchShopFreeAdsArg message.
         * @function verify
         * @memberof pb.WatchShopFreeAdsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchShopFreeAdsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return WatchShopFreeAdsArg;
    })();

    pb.WatchShopFreeAdsReply = (function() {

        /**
         * Properties of a WatchShopFreeAdsReply.
         * @memberof pb
         * @interface IWatchShopFreeAdsReply
         * @property {pb.ShopFreeAdsType|null} [Type] WatchShopFreeAdsReply Type
         * @property {Uint8Array|null} [RewardPayload] WatchShopFreeAdsReply RewardPayload
         * @property {pb.IShopFreeAds|null} [NextAds] WatchShopFreeAdsReply NextAds
         */

        /**
         * Constructs a new WatchShopFreeAdsReply.
         * @memberof pb
         * @classdesc Represents a WatchShopFreeAdsReply.
         * @implements IWatchShopFreeAdsReply
         * @constructor
         * @param {pb.IWatchShopFreeAdsReply=} [properties] Properties to set
         */
        function WatchShopFreeAdsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchShopFreeAdsReply Type.
         * @member {pb.ShopFreeAdsType} Type
         * @memberof pb.WatchShopFreeAdsReply
         * @instance
         */
        WatchShopFreeAdsReply.prototype.Type = 0;

        /**
         * WatchShopFreeAdsReply RewardPayload.
         * @member {Uint8Array} RewardPayload
         * @memberof pb.WatchShopFreeAdsReply
         * @instance
         */
        WatchShopFreeAdsReply.prototype.RewardPayload = $util.newBuffer([]);

        /**
         * WatchShopFreeAdsReply NextAds.
         * @member {pb.IShopFreeAds|null|undefined} NextAds
         * @memberof pb.WatchShopFreeAdsReply
         * @instance
         */
        WatchShopFreeAdsReply.prototype.NextAds = null;

        /**
         * Creates a new WatchShopFreeAdsReply instance using the specified properties.
         * @function create
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {pb.IWatchShopFreeAdsReply=} [properties] Properties to set
         * @returns {pb.WatchShopFreeAdsReply} WatchShopFreeAdsReply instance
         */
        WatchShopFreeAdsReply.create = function create(properties) {
            return new WatchShopFreeAdsReply(properties);
        };

        /**
         * Encodes the specified WatchShopFreeAdsReply message. Does not implicitly {@link pb.WatchShopFreeAdsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {pb.IWatchShopFreeAdsReply} message WatchShopFreeAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchShopFreeAdsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.RewardPayload != null && message.hasOwnProperty("RewardPayload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.RewardPayload);
            if (message.NextAds != null && message.hasOwnProperty("NextAds"))
                $root.pb.ShopFreeAds.encode(message.NextAds, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WatchShopFreeAdsReply message, length delimited. Does not implicitly {@link pb.WatchShopFreeAdsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {pb.IWatchShopFreeAdsReply} message WatchShopFreeAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchShopFreeAdsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchShopFreeAdsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchShopFreeAdsReply} WatchShopFreeAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchShopFreeAdsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchShopFreeAdsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.RewardPayload = reader.bytes();
                    break;
                case 3:
                    message.NextAds = $root.pb.ShopFreeAds.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchShopFreeAdsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchShopFreeAdsReply} WatchShopFreeAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchShopFreeAdsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchShopFreeAdsReply message.
         * @function verify
         * @memberof pb.WatchShopFreeAdsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchShopFreeAdsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.RewardPayload != null && message.hasOwnProperty("RewardPayload"))
                if (!(message.RewardPayload && typeof message.RewardPayload.length === "number" || $util.isString(message.RewardPayload)))
                    return "RewardPayload: buffer expected";
            if (message.NextAds != null && message.hasOwnProperty("NextAds")) {
                var error = $root.pb.ShopFreeAds.verify(message.NextAds);
                if (error)
                    return "NextAds." + error;
            }
            return null;
        };

        WatchShopFreeAdsReply.GoldReward = (function() {

            /**
             * Properties of a GoldReward.
             * @memberof pb.WatchShopFreeAdsReply
             * @interface IGoldReward
             * @property {number|null} [GoldAmount] GoldReward GoldAmount
             */

            /**
             * Constructs a new GoldReward.
             * @memberof pb.WatchShopFreeAdsReply
             * @classdesc Represents a GoldReward.
             * @implements IGoldReward
             * @constructor
             * @param {pb.WatchShopFreeAdsReply.IGoldReward=} [properties] Properties to set
             */
            function GoldReward(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GoldReward GoldAmount.
             * @member {number} GoldAmount
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @instance
             */
            GoldReward.prototype.GoldAmount = 0;

            /**
             * Creates a new GoldReward instance using the specified properties.
             * @function create
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IGoldReward=} [properties] Properties to set
             * @returns {pb.WatchShopFreeAdsReply.GoldReward} GoldReward instance
             */
            GoldReward.create = function create(properties) {
                return new GoldReward(properties);
            };

            /**
             * Encodes the specified GoldReward message. Does not implicitly {@link pb.WatchShopFreeAdsReply.GoldReward.verify|verify} messages.
             * @function encode
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IGoldReward} message GoldReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoldReward.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.GoldAmount != null && message.hasOwnProperty("GoldAmount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.GoldAmount);
                return writer;
            };

            /**
             * Encodes the specified GoldReward message, length delimited. Does not implicitly {@link pb.WatchShopFreeAdsReply.GoldReward.verify|verify} messages.
             * @function encodeDelimited
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IGoldReward} message GoldReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GoldReward.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GoldReward message from the specified reader or buffer.
             * @function decode
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.WatchShopFreeAdsReply.GoldReward} GoldReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoldReward.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchShopFreeAdsReply.GoldReward();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.GoldAmount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GoldReward message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {pb.WatchShopFreeAdsReply.GoldReward} GoldReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GoldReward.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GoldReward message.
             * @function verify
             * @memberof pb.WatchShopFreeAdsReply.GoldReward
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GoldReward.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.GoldAmount != null && message.hasOwnProperty("GoldAmount"))
                    if (!$util.isInteger(message.GoldAmount))
                        return "GoldAmount: integer expected";
                return null;
            };

            return GoldReward;
        })();

        WatchShopFreeAdsReply.JadeReward = (function() {

            /**
             * Properties of a JadeReward.
             * @memberof pb.WatchShopFreeAdsReply
             * @interface IJadeReward
             * @property {number|null} [JadeAmount] JadeReward JadeAmount
             */

            /**
             * Constructs a new JadeReward.
             * @memberof pb.WatchShopFreeAdsReply
             * @classdesc Represents a JadeReward.
             * @implements IJadeReward
             * @constructor
             * @param {pb.WatchShopFreeAdsReply.IJadeReward=} [properties] Properties to set
             */
            function JadeReward(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * JadeReward JadeAmount.
             * @member {number} JadeAmount
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @instance
             */
            JadeReward.prototype.JadeAmount = 0;

            /**
             * Creates a new JadeReward instance using the specified properties.
             * @function create
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IJadeReward=} [properties] Properties to set
             * @returns {pb.WatchShopFreeAdsReply.JadeReward} JadeReward instance
             */
            JadeReward.create = function create(properties) {
                return new JadeReward(properties);
            };

            /**
             * Encodes the specified JadeReward message. Does not implicitly {@link pb.WatchShopFreeAdsReply.JadeReward.verify|verify} messages.
             * @function encode
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IJadeReward} message JadeReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JadeReward.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.JadeAmount != null && message.hasOwnProperty("JadeAmount"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.JadeAmount);
                return writer;
            };

            /**
             * Encodes the specified JadeReward message, length delimited. Does not implicitly {@link pb.WatchShopFreeAdsReply.JadeReward.verify|verify} messages.
             * @function encodeDelimited
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {pb.WatchShopFreeAdsReply.IJadeReward} message JadeReward message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            JadeReward.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a JadeReward message from the specified reader or buffer.
             * @function decode
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.WatchShopFreeAdsReply.JadeReward} JadeReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JadeReward.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchShopFreeAdsReply.JadeReward();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.JadeAmount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a JadeReward message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {pb.WatchShopFreeAdsReply.JadeReward} JadeReward
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            JadeReward.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a JadeReward message.
             * @function verify
             * @memberof pb.WatchShopFreeAdsReply.JadeReward
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            JadeReward.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.JadeAmount != null && message.hasOwnProperty("JadeAmount"))
                    if (!$util.isInteger(message.JadeAmount))
                        return "JadeAmount: integer expected";
                return null;
            };

            return JadeReward;
        })();

        return WatchShopFreeAdsReply;
    })();

    pb.WatchTreasureAddCardAdsReply = (function() {

        /**
         * Properties of a WatchTreasureAddCardAdsReply.
         * @memberof pb
         * @interface IWatchTreasureAddCardAdsReply
         * @property {number|null} [AddCardAmount] WatchTreasureAddCardAdsReply AddCardAmount
         */

        /**
         * Constructs a new WatchTreasureAddCardAdsReply.
         * @memberof pb
         * @classdesc Represents a WatchTreasureAddCardAdsReply.
         * @implements IWatchTreasureAddCardAdsReply
         * @constructor
         * @param {pb.IWatchTreasureAddCardAdsReply=} [properties] Properties to set
         */
        function WatchTreasureAddCardAdsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchTreasureAddCardAdsReply AddCardAmount.
         * @member {number} AddCardAmount
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @instance
         */
        WatchTreasureAddCardAdsReply.prototype.AddCardAmount = 0;

        /**
         * Creates a new WatchTreasureAddCardAdsReply instance using the specified properties.
         * @function create
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {pb.IWatchTreasureAddCardAdsReply=} [properties] Properties to set
         * @returns {pb.WatchTreasureAddCardAdsReply} WatchTreasureAddCardAdsReply instance
         */
        WatchTreasureAddCardAdsReply.create = function create(properties) {
            return new WatchTreasureAddCardAdsReply(properties);
        };

        /**
         * Encodes the specified WatchTreasureAddCardAdsReply message. Does not implicitly {@link pb.WatchTreasureAddCardAdsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {pb.IWatchTreasureAddCardAdsReply} message WatchTreasureAddCardAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchTreasureAddCardAdsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddCardAmount != null && message.hasOwnProperty("AddCardAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.AddCardAmount);
            return writer;
        };

        /**
         * Encodes the specified WatchTreasureAddCardAdsReply message, length delimited. Does not implicitly {@link pb.WatchTreasureAddCardAdsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {pb.IWatchTreasureAddCardAdsReply} message WatchTreasureAddCardAdsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchTreasureAddCardAdsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchTreasureAddCardAdsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchTreasureAddCardAdsReply} WatchTreasureAddCardAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchTreasureAddCardAdsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchTreasureAddCardAdsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.AddCardAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchTreasureAddCardAdsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchTreasureAddCardAdsReply} WatchTreasureAddCardAdsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchTreasureAddCardAdsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchTreasureAddCardAdsReply message.
         * @function verify
         * @memberof pb.WatchTreasureAddCardAdsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchTreasureAddCardAdsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddCardAmount != null && message.hasOwnProperty("AddCardAmount"))
                if (!$util.isInteger(message.AddCardAmount))
                    return "AddCardAmount: integer expected";
            return null;
        };

        return WatchTreasureAddCardAdsReply;
    })();

    pb.SendEmojiArg = (function() {

        /**
         * Properties of a SendEmojiArg.
         * @memberof pb
         * @interface ISendEmojiArg
         * @property {number|null} [EmojiID] SendEmojiArg EmojiID
         */

        /**
         * Constructs a new SendEmojiArg.
         * @memberof pb
         * @classdesc Represents a SendEmojiArg.
         * @implements ISendEmojiArg
         * @constructor
         * @param {pb.ISendEmojiArg=} [properties] Properties to set
         */
        function SendEmojiArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendEmojiArg EmojiID.
         * @member {number} EmojiID
         * @memberof pb.SendEmojiArg
         * @instance
         */
        SendEmojiArg.prototype.EmojiID = 0;

        /**
         * Creates a new SendEmojiArg instance using the specified properties.
         * @function create
         * @memberof pb.SendEmojiArg
         * @static
         * @param {pb.ISendEmojiArg=} [properties] Properties to set
         * @returns {pb.SendEmojiArg} SendEmojiArg instance
         */
        SendEmojiArg.create = function create(properties) {
            return new SendEmojiArg(properties);
        };

        /**
         * Encodes the specified SendEmojiArg message. Does not implicitly {@link pb.SendEmojiArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SendEmojiArg
         * @static
         * @param {pb.ISendEmojiArg} message SendEmojiArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendEmojiArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EmojiID != null && message.hasOwnProperty("EmojiID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.EmojiID);
            return writer;
        };

        /**
         * Encodes the specified SendEmojiArg message, length delimited. Does not implicitly {@link pb.SendEmojiArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SendEmojiArg
         * @static
         * @param {pb.ISendEmojiArg} message SendEmojiArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendEmojiArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendEmojiArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SendEmojiArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SendEmojiArg} SendEmojiArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendEmojiArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SendEmojiArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.EmojiID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendEmojiArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SendEmojiArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SendEmojiArg} SendEmojiArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendEmojiArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendEmojiArg message.
         * @function verify
         * @memberof pb.SendEmojiArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendEmojiArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EmojiID != null && message.hasOwnProperty("EmojiID"))
                if (!$util.isInteger(message.EmojiID))
                    return "EmojiID: integer expected";
            return null;
        };

        return SendEmojiArg;
    })();

    pb.MovieEffect = (function() {

        /**
         * Properties of a MovieEffect.
         * @memberof pb
         * @interface IMovieEffect
         * @property {string|null} [MovieID] MovieEffect MovieID
         * @property {number|null} [PlayType] MovieEffect PlayType
         * @property {number|null} [OwnerObjID] MovieEffect OwnerObjID
         */

        /**
         * Constructs a new MovieEffect.
         * @memberof pb
         * @classdesc Represents a MovieEffect.
         * @implements IMovieEffect
         * @constructor
         * @param {pb.IMovieEffect=} [properties] Properties to set
         */
        function MovieEffect(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MovieEffect MovieID.
         * @member {string} MovieID
         * @memberof pb.MovieEffect
         * @instance
         */
        MovieEffect.prototype.MovieID = "";

        /**
         * MovieEffect PlayType.
         * @member {number} PlayType
         * @memberof pb.MovieEffect
         * @instance
         */
        MovieEffect.prototype.PlayType = 0;

        /**
         * MovieEffect OwnerObjID.
         * @member {number} OwnerObjID
         * @memberof pb.MovieEffect
         * @instance
         */
        MovieEffect.prototype.OwnerObjID = 0;

        /**
         * Creates a new MovieEffect instance using the specified properties.
         * @function create
         * @memberof pb.MovieEffect
         * @static
         * @param {pb.IMovieEffect=} [properties] Properties to set
         * @returns {pb.MovieEffect} MovieEffect instance
         */
        MovieEffect.create = function create(properties) {
            return new MovieEffect(properties);
        };

        /**
         * Encodes the specified MovieEffect message. Does not implicitly {@link pb.MovieEffect.verify|verify} messages.
         * @function encode
         * @memberof pb.MovieEffect
         * @static
         * @param {pb.IMovieEffect} message MovieEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovieEffect.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.MovieID);
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PlayType);
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.OwnerObjID);
            return writer;
        };

        /**
         * Encodes the specified MovieEffect message, length delimited. Does not implicitly {@link pb.MovieEffect.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MovieEffect
         * @static
         * @param {pb.IMovieEffect} message MovieEffect message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovieEffect.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MovieEffect message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MovieEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MovieEffect} MovieEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovieEffect.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MovieEffect();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MovieID = reader.string();
                    break;
                case 2:
                    message.PlayType = reader.int32();
                    break;
                case 3:
                    message.OwnerObjID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MovieEffect message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MovieEffect
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MovieEffect} MovieEffect
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovieEffect.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MovieEffect message.
         * @function verify
         * @memberof pb.MovieEffect
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MovieEffect.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                if (!$util.isString(message.MovieID))
                    return "MovieID: string expected";
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                if (!$util.isInteger(message.PlayType))
                    return "PlayType: integer expected";
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                if (!$util.isInteger(message.OwnerObjID))
                    return "OwnerObjID: integer expected";
            return null;
        };

        return MovieEffect;
    })();

    pb.DiyFightCardInfo = (function() {

        /**
         * Properties of a DiyFightCardInfo.
         * @memberof pb
         * @interface IDiyFightCardInfo
         * @property {number|null} [CardId] DiyFightCardInfo CardId
         * @property {string|null} [Name] DiyFightCardInfo Name
         * @property {number|null} [DiySkillId1] DiyFightCardInfo DiySkillId1
         * @property {number|null} [DiySkillId2] DiyFightCardInfo DiySkillId2
         * @property {string|null} [Weapon] DiyFightCardInfo Weapon
         */

        /**
         * Constructs a new DiyFightCardInfo.
         * @memberof pb
         * @classdesc Represents a DiyFightCardInfo.
         * @implements IDiyFightCardInfo
         * @constructor
         * @param {pb.IDiyFightCardInfo=} [properties] Properties to set
         */
        function DiyFightCardInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiyFightCardInfo CardId.
         * @member {number} CardId
         * @memberof pb.DiyFightCardInfo
         * @instance
         */
        DiyFightCardInfo.prototype.CardId = 0;

        /**
         * DiyFightCardInfo Name.
         * @member {string} Name
         * @memberof pb.DiyFightCardInfo
         * @instance
         */
        DiyFightCardInfo.prototype.Name = "";

        /**
         * DiyFightCardInfo DiySkillId1.
         * @member {number} DiySkillId1
         * @memberof pb.DiyFightCardInfo
         * @instance
         */
        DiyFightCardInfo.prototype.DiySkillId1 = 0;

        /**
         * DiyFightCardInfo DiySkillId2.
         * @member {number} DiySkillId2
         * @memberof pb.DiyFightCardInfo
         * @instance
         */
        DiyFightCardInfo.prototype.DiySkillId2 = 0;

        /**
         * DiyFightCardInfo Weapon.
         * @member {string} Weapon
         * @memberof pb.DiyFightCardInfo
         * @instance
         */
        DiyFightCardInfo.prototype.Weapon = "";

        /**
         * Creates a new DiyFightCardInfo instance using the specified properties.
         * @function create
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {pb.IDiyFightCardInfo=} [properties] Properties to set
         * @returns {pb.DiyFightCardInfo} DiyFightCardInfo instance
         */
        DiyFightCardInfo.create = function create(properties) {
            return new DiyFightCardInfo(properties);
        };

        /**
         * Encodes the specified DiyFightCardInfo message. Does not implicitly {@link pb.DiyFightCardInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {pb.IDiyFightCardInfo} message DiyFightCardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyFightCardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.DiySkillId1);
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.DiySkillId2);
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Weapon);
            return writer;
        };

        /**
         * Encodes the specified DiyFightCardInfo message, length delimited. Does not implicitly {@link pb.DiyFightCardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {pb.IDiyFightCardInfo} message DiyFightCardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyFightCardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiyFightCardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DiyFightCardInfo} DiyFightCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyFightCardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiyFightCardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.DiySkillId1 = reader.int32();
                    break;
                case 4:
                    message.DiySkillId2 = reader.int32();
                    break;
                case 5:
                    message.Weapon = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DiyFightCardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DiyFightCardInfo} DiyFightCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyFightCardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiyFightCardInfo message.
         * @function verify
         * @memberof pb.DiyFightCardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiyFightCardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                if (!$util.isInteger(message.DiySkillId1))
                    return "DiySkillId1: integer expected";
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                if (!$util.isInteger(message.DiySkillId2))
                    return "DiySkillId2: integer expected";
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                if (!$util.isString(message.Weapon))
                    return "Weapon: string expected";
            return null;
        };

        return DiyFightCardInfo;
    })();

    pb.Card = (function() {

        /**
         * Properties of a Card.
         * @memberof pb
         * @interface ICard
         * @property {number|null} [Id] Card Id
         * @property {number|null} [ObjId] Card ObjId
         * @property {number|null} [Up] Card Up
         * @property {number|null} [Down] Card Down
         * @property {number|null} [Left] Card Left
         * @property {number|null} [Right] Card Right
         * @property {pb.IDiyFightCardInfo|null} [DiyInfo] Card DiyInfo
         * @property {Array.<pb.IMovieEffect>|null} [Effect] Card Effect
         * @property {Array.<number>|null} [Skills] Card Skills
         * @property {boolean|null} [IsInFog] Card IsInFog
         * @property {boolean|null} [IsPublicEnemy] Card IsPublicEnemy
         * @property {string|null} [Skin] Card Skin
         * @property {pb.IBattleEquip|null} [Equip] Card Equip
         */

        /**
         * Constructs a new Card.
         * @memberof pb
         * @classdesc Represents a Card.
         * @implements ICard
         * @constructor
         * @param {pb.ICard=} [properties] Properties to set
         */
        function Card(properties) {
            this.Effect = [];
            this.Skills = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Card Id.
         * @member {number} Id
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Id = 0;

        /**
         * Card ObjId.
         * @member {number} ObjId
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.ObjId = 0;

        /**
         * Card Up.
         * @member {number} Up
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Up = 0;

        /**
         * Card Down.
         * @member {number} Down
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Down = 0;

        /**
         * Card Left.
         * @member {number} Left
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Left = 0;

        /**
         * Card Right.
         * @member {number} Right
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Right = 0;

        /**
         * Card DiyInfo.
         * @member {pb.IDiyFightCardInfo|null|undefined} DiyInfo
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.DiyInfo = null;

        /**
         * Card Effect.
         * @member {Array.<pb.IMovieEffect>} Effect
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Effect = $util.emptyArray;

        /**
         * Card Skills.
         * @member {Array.<number>} Skills
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Skills = $util.emptyArray;

        /**
         * Card IsInFog.
         * @member {boolean} IsInFog
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.IsInFog = false;

        /**
         * Card IsPublicEnemy.
         * @member {boolean} IsPublicEnemy
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.IsPublicEnemy = false;

        /**
         * Card Skin.
         * @member {string} Skin
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Skin = "";

        /**
         * Card Equip.
         * @member {pb.IBattleEquip|null|undefined} Equip
         * @memberof pb.Card
         * @instance
         */
        Card.prototype.Equip = null;

        /**
         * Creates a new Card instance using the specified properties.
         * @function create
         * @memberof pb.Card
         * @static
         * @param {pb.ICard=} [properties] Properties to set
         * @returns {pb.Card} Card instance
         */
        Card.create = function create(properties) {
            return new Card(properties);
        };

        /**
         * Encodes the specified Card message. Does not implicitly {@link pb.Card.verify|verify} messages.
         * @function encode
         * @memberof pb.Card
         * @static
         * @param {pb.ICard} message Card message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Card.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Id != null && message.hasOwnProperty("Id"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.Id);
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ObjId);
            if (message.Up != null && message.hasOwnProperty("Up"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Up);
            if (message.Down != null && message.hasOwnProperty("Down"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Down);
            if (message.Left != null && message.hasOwnProperty("Left"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Left);
            if (message.Right != null && message.hasOwnProperty("Right"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Right);
            if (message.DiyInfo != null && message.hasOwnProperty("DiyInfo"))
                $root.pb.DiyFightCardInfo.encode(message.DiyInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.Effect != null && message.Effect.length)
                for (var i = 0; i < message.Effect.length; ++i)
                    $root.pb.MovieEffect.encode(message.Effect[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.Skills != null && message.Skills.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (var i = 0; i < message.Skills.length; ++i)
                    writer.int32(message.Skills[i]);
                writer.ldelim();
            }
            if (message.IsInFog != null && message.hasOwnProperty("IsInFog"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.IsInFog);
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.IsPublicEnemy);
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.Skin);
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                $root.pb.BattleEquip.encode(message.Equip, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Card message, length delimited. Does not implicitly {@link pb.Card.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Card
         * @static
         * @param {pb.ICard} message Card message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Card.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Card message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Card
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Card} Card
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Card.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Card();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Id = reader.uint32();
                    break;
                case 2:
                    message.ObjId = reader.int32();
                    break;
                case 3:
                    message.Up = reader.int32();
                    break;
                case 4:
                    message.Down = reader.int32();
                    break;
                case 5:
                    message.Left = reader.int32();
                    break;
                case 6:
                    message.Right = reader.int32();
                    break;
                case 7:
                    message.DiyInfo = $root.pb.DiyFightCardInfo.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.Effect && message.Effect.length))
                        message.Effect = [];
                    message.Effect.push($root.pb.MovieEffect.decode(reader, reader.uint32()));
                    break;
                case 9:
                    if (!(message.Skills && message.Skills.length))
                        message.Skills = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Skills.push(reader.int32());
                    } else
                        message.Skills.push(reader.int32());
                    break;
                case 10:
                    message.IsInFog = reader.bool();
                    break;
                case 11:
                    message.IsPublicEnemy = reader.bool();
                    break;
                case 12:
                    message.Skin = reader.string();
                    break;
                case 13:
                    message.Equip = $root.pb.BattleEquip.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Card message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Card
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Card} Card
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Card.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Card message.
         * @function verify
         * @memberof pb.Card
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Card.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Id != null && message.hasOwnProperty("Id"))
                if (!$util.isInteger(message.Id))
                    return "Id: integer expected";
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                if (!$util.isInteger(message.ObjId))
                    return "ObjId: integer expected";
            if (message.Up != null && message.hasOwnProperty("Up"))
                if (!$util.isInteger(message.Up))
                    return "Up: integer expected";
            if (message.Down != null && message.hasOwnProperty("Down"))
                if (!$util.isInteger(message.Down))
                    return "Down: integer expected";
            if (message.Left != null && message.hasOwnProperty("Left"))
                if (!$util.isInteger(message.Left))
                    return "Left: integer expected";
            if (message.Right != null && message.hasOwnProperty("Right"))
                if (!$util.isInteger(message.Right))
                    return "Right: integer expected";
            if (message.DiyInfo != null && message.hasOwnProperty("DiyInfo")) {
                var error = $root.pb.DiyFightCardInfo.verify(message.DiyInfo);
                if (error)
                    return "DiyInfo." + error;
            }
            if (message.Effect != null && message.hasOwnProperty("Effect")) {
                if (!Array.isArray(message.Effect))
                    return "Effect: array expected";
                for (var i = 0; i < message.Effect.length; ++i) {
                    var error = $root.pb.MovieEffect.verify(message.Effect[i]);
                    if (error)
                        return "Effect." + error;
                }
            }
            if (message.Skills != null && message.hasOwnProperty("Skills")) {
                if (!Array.isArray(message.Skills))
                    return "Skills: array expected";
                for (var i = 0; i < message.Skills.length; ++i)
                    if (!$util.isInteger(message.Skills[i]))
                        return "Skills: integer[] expected";
            }
            if (message.IsInFog != null && message.hasOwnProperty("IsInFog"))
                if (typeof message.IsInFog !== "boolean")
                    return "IsInFog: boolean expected";
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                if (typeof message.IsPublicEnemy !== "boolean")
                    return "IsPublicEnemy: boolean expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            if (message.Equip != null && message.hasOwnProperty("Equip")) {
                var error = $root.pb.BattleEquip.verify(message.Equip);
                if (error)
                    return "Equip." + error;
            }
            return null;
        };

        return Card;
    })();

    pb.BattleEquip = (function() {

        /**
         * Properties of a BattleEquip.
         * @memberof pb
         * @interface IBattleEquip
         * @property {string|null} [EquipID] BattleEquip EquipID
         * @property {Array.<number>|null} [Skills] BattleEquip Skills
         */

        /**
         * Constructs a new BattleEquip.
         * @memberof pb
         * @classdesc Represents a BattleEquip.
         * @implements IBattleEquip
         * @constructor
         * @param {pb.IBattleEquip=} [properties] Properties to set
         */
        function BattleEquip(properties) {
            this.Skills = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleEquip EquipID.
         * @member {string} EquipID
         * @memberof pb.BattleEquip
         * @instance
         */
        BattleEquip.prototype.EquipID = "";

        /**
         * BattleEquip Skills.
         * @member {Array.<number>} Skills
         * @memberof pb.BattleEquip
         * @instance
         */
        BattleEquip.prototype.Skills = $util.emptyArray;

        /**
         * Creates a new BattleEquip instance using the specified properties.
         * @function create
         * @memberof pb.BattleEquip
         * @static
         * @param {pb.IBattleEquip=} [properties] Properties to set
         * @returns {pb.BattleEquip} BattleEquip instance
         */
        BattleEquip.create = function create(properties) {
            return new BattleEquip(properties);
        };

        /**
         * Encodes the specified BattleEquip message. Does not implicitly {@link pb.BattleEquip.verify|verify} messages.
         * @function encode
         * @memberof pb.BattleEquip
         * @static
         * @param {pb.IBattleEquip} message BattleEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.EquipID);
            if (message.Skills != null && message.Skills.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Skills.length; ++i)
                    writer.int32(message.Skills[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified BattleEquip message, length delimited. Does not implicitly {@link pb.BattleEquip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BattleEquip
         * @static
         * @param {pb.IBattleEquip} message BattleEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleEquip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleEquip message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BattleEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BattleEquip} BattleEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BattleEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.EquipID = reader.string();
                    break;
                case 2:
                    if (!(message.Skills && message.Skills.length))
                        message.Skills = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Skills.push(reader.int32());
                    } else
                        message.Skills.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleEquip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BattleEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BattleEquip} BattleEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleEquip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleEquip message.
         * @function verify
         * @memberof pb.BattleEquip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleEquip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                if (!$util.isString(message.EquipID))
                    return "EquipID: string expected";
            if (message.Skills != null && message.hasOwnProperty("Skills")) {
                if (!Array.isArray(message.Skills))
                    return "Skills: array expected";
                for (var i = 0; i < message.Skills.length; ++i)
                    if (!$util.isInteger(message.Skills[i]))
                        return "Skills: integer[] expected";
            }
            return null;
        };

        return BattleEquip;
    })();

    pb.Fighter = (function() {

        /**
         * Properties of a Fighter.
         * @memberof pb
         * @interface IFighter
         * @property {number|Long|null} [Uid] Fighter Uid
         * @property {Array.<pb.ICard>|null} [Hand] Fighter Hand
         * @property {number|null} [ObjId] Fighter ObjId
         * @property {Array.<number>|null} [CasterSkills] Fighter CasterSkills
         * @property {string|null} [Name] Fighter Name
         * @property {number|null} [Camp] Fighter Camp
         * @property {number|null} [PvpScore] Fighter PvpScore
         * @property {number|null} [MaxHandAmount] Fighter MaxHandAmount
         * @property {string|null} [HeadImgUrl] Fighter HeadImgUrl
         * @property {string|null} [HeadFrame] Fighter HeadFrame
         * @property {number|null} [NameText] Fighter NameText
         */

        /**
         * Constructs a new Fighter.
         * @memberof pb
         * @classdesc Represents a Fighter.
         * @implements IFighter
         * @constructor
         * @param {pb.IFighter=} [properties] Properties to set
         */
        function Fighter(properties) {
            this.Hand = [];
            this.CasterSkills = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fighter Uid.
         * @member {number|Long} Uid
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Fighter Hand.
         * @member {Array.<pb.ICard>} Hand
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.Hand = $util.emptyArray;

        /**
         * Fighter ObjId.
         * @member {number} ObjId
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.ObjId = 0;

        /**
         * Fighter CasterSkills.
         * @member {Array.<number>} CasterSkills
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.CasterSkills = $util.emptyArray;

        /**
         * Fighter Name.
         * @member {string} Name
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.Name = "";

        /**
         * Fighter Camp.
         * @member {number} Camp
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.Camp = 0;

        /**
         * Fighter PvpScore.
         * @member {number} PvpScore
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.PvpScore = 0;

        /**
         * Fighter MaxHandAmount.
         * @member {number} MaxHandAmount
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.MaxHandAmount = 0;

        /**
         * Fighter HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.HeadImgUrl = "";

        /**
         * Fighter HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.HeadFrame = "";

        /**
         * Fighter NameText.
         * @member {number} NameText
         * @memberof pb.Fighter
         * @instance
         */
        Fighter.prototype.NameText = 0;

        /**
         * Creates a new Fighter instance using the specified properties.
         * @function create
         * @memberof pb.Fighter
         * @static
         * @param {pb.IFighter=} [properties] Properties to set
         * @returns {pb.Fighter} Fighter instance
         */
        Fighter.create = function create(properties) {
            return new Fighter(properties);
        };

        /**
         * Encodes the specified Fighter message. Does not implicitly {@link pb.Fighter.verify|verify} messages.
         * @function encode
         * @memberof pb.Fighter
         * @static
         * @param {pb.IFighter} message Fighter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fighter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Hand != null && message.Hand.length)
                for (var i = 0; i < message.Hand.length; ++i)
                    $root.pb.Card.encode(message.Hand[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ObjId);
            if (message.CasterSkills != null && message.CasterSkills.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.CasterSkills.length; ++i)
                    writer.int32(message.CasterSkills[i]);
                writer.ldelim();
            }
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Name);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Camp);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.PvpScore);
            if (message.MaxHandAmount != null && message.hasOwnProperty("MaxHandAmount"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.MaxHandAmount);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.HeadImgUrl);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.HeadFrame);
            if (message.NameText != null && message.hasOwnProperty("NameText"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.NameText);
            return writer;
        };

        /**
         * Encodes the specified Fighter message, length delimited. Does not implicitly {@link pb.Fighter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Fighter
         * @static
         * @param {pb.IFighter} message Fighter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Fighter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Fighter message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Fighter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Fighter} Fighter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fighter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Fighter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    if (!(message.Hand && message.Hand.length))
                        message.Hand = [];
                    message.Hand.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.ObjId = reader.int32();
                    break;
                case 4:
                    if (!(message.CasterSkills && message.CasterSkills.length))
                        message.CasterSkills = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CasterSkills.push(reader.int32());
                    } else
                        message.CasterSkills.push(reader.int32());
                    break;
                case 5:
                    message.Name = reader.string();
                    break;
                case 6:
                    message.Camp = reader.int32();
                    break;
                case 7:
                    message.PvpScore = reader.int32();
                    break;
                case 8:
                    message.MaxHandAmount = reader.int32();
                    break;
                case 9:
                    message.HeadImgUrl = reader.string();
                    break;
                case 10:
                    message.HeadFrame = reader.string();
                    break;
                case 11:
                    message.NameText = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Fighter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Fighter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Fighter} Fighter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Fighter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Fighter message.
         * @function verify
         * @memberof pb.Fighter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fighter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Hand != null && message.hasOwnProperty("Hand")) {
                if (!Array.isArray(message.Hand))
                    return "Hand: array expected";
                for (var i = 0; i < message.Hand.length; ++i) {
                    var error = $root.pb.Card.verify(message.Hand[i]);
                    if (error)
                        return "Hand." + error;
                }
            }
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                if (!$util.isInteger(message.ObjId))
                    return "ObjId: integer expected";
            if (message.CasterSkills != null && message.hasOwnProperty("CasterSkills")) {
                if (!Array.isArray(message.CasterSkills))
                    return "CasterSkills: array expected";
                for (var i = 0; i < message.CasterSkills.length; ++i)
                    if (!$util.isInteger(message.CasterSkills[i]))
                        return "CasterSkills: integer[] expected";
            }
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.MaxHandAmount != null && message.hasOwnProperty("MaxHandAmount"))
                if (!$util.isInteger(message.MaxHandAmount))
                    return "MaxHandAmount: integer expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.NameText != null && message.hasOwnProperty("NameText"))
                if (!$util.isInteger(message.NameText))
                    return "NameText: integer expected";
            return null;
        };

        return Fighter;
    })();

    pb.Grid = (function() {

        /**
         * Properties of a Grid.
         * @memberof pb
         * @interface IGrid
         * @property {number|null} [ObjId] Grid ObjId
         * @property {pb.ICard|null} [InGridCard] Grid InGridCard
         * @property {number|Long|null} [Owner] Grid Owner
         * @property {Array.<pb.IMovieEffect>|null} [Effect] Grid Effect
         */

        /**
         * Constructs a new Grid.
         * @memberof pb
         * @classdesc Represents a Grid.
         * @implements IGrid
         * @constructor
         * @param {pb.IGrid=} [properties] Properties to set
         */
        function Grid(properties) {
            this.Effect = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Grid ObjId.
         * @member {number} ObjId
         * @memberof pb.Grid
         * @instance
         */
        Grid.prototype.ObjId = 0;

        /**
         * Grid InGridCard.
         * @member {pb.ICard|null|undefined} InGridCard
         * @memberof pb.Grid
         * @instance
         */
        Grid.prototype.InGridCard = null;

        /**
         * Grid Owner.
         * @member {number|Long} Owner
         * @memberof pb.Grid
         * @instance
         */
        Grid.prototype.Owner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Grid Effect.
         * @member {Array.<pb.IMovieEffect>} Effect
         * @memberof pb.Grid
         * @instance
         */
        Grid.prototype.Effect = $util.emptyArray;

        /**
         * Creates a new Grid instance using the specified properties.
         * @function create
         * @memberof pb.Grid
         * @static
         * @param {pb.IGrid=} [properties] Properties to set
         * @returns {pb.Grid} Grid instance
         */
        Grid.create = function create(properties) {
            return new Grid(properties);
        };

        /**
         * Encodes the specified Grid message. Does not implicitly {@link pb.Grid.verify|verify} messages.
         * @function encode
         * @memberof pb.Grid
         * @static
         * @param {pb.IGrid} message Grid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Grid.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ObjId);
            if (message.InGridCard != null && message.hasOwnProperty("InGridCard"))
                $root.pb.Card.encode(message.InGridCard, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Owner != null && message.hasOwnProperty("Owner"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.Owner);
            if (message.Effect != null && message.Effect.length)
                for (var i = 0; i < message.Effect.length; ++i)
                    $root.pb.MovieEffect.encode(message.Effect[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Grid message, length delimited. Does not implicitly {@link pb.Grid.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Grid
         * @static
         * @param {pb.IGrid} message Grid message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Grid.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Grid message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Grid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Grid} Grid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Grid.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Grid();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ObjId = reader.int32();
                    break;
                case 2:
                    message.InGridCard = $root.pb.Card.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Owner = reader.uint64();
                    break;
                case 8:
                    if (!(message.Effect && message.Effect.length))
                        message.Effect = [];
                    message.Effect.push($root.pb.MovieEffect.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Grid message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Grid
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Grid} Grid
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Grid.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Grid message.
         * @function verify
         * @memberof pb.Grid
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Grid.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ObjId != null && message.hasOwnProperty("ObjId"))
                if (!$util.isInteger(message.ObjId))
                    return "ObjId: integer expected";
            if (message.InGridCard != null && message.hasOwnProperty("InGridCard")) {
                var error = $root.pb.Card.verify(message.InGridCard);
                if (error)
                    return "InGridCard." + error;
            }
            if (message.Owner != null && message.hasOwnProperty("Owner"))
                if (!$util.isInteger(message.Owner) && !(message.Owner && $util.isInteger(message.Owner.low) && $util.isInteger(message.Owner.high)))
                    return "Owner: integer|Long expected";
            if (message.Effect != null && message.hasOwnProperty("Effect")) {
                if (!Array.isArray(message.Effect))
                    return "Effect: array expected";
                for (var i = 0; i < message.Effect.length; ++i) {
                    var error = $root.pb.MovieEffect.verify(message.Effect[i]);
                    if (error)
                        return "Effect." + error;
                }
            }
            return null;
        };

        return Grid;
    })();

    pb.FightDesk = (function() {

        /**
         * Properties of a FightDesk.
         * @memberof pb
         * @interface IFightDesk
         * @property {number|Long|null} [DeskId] FightDesk DeskId
         * @property {number|null} [Type] FightDesk Type
         * @property {Array.<pb.IGrid>|null} [Grids] FightDesk Grids
         * @property {pb.IFighter|null} [Fighter1] FightDesk Fighter1
         * @property {pb.IFighter|null} [Fighter2] FightDesk Fighter2
         * @property {number|null} [Scale] FightDesk Scale
         * @property {number|null} [BattleRes] FightDesk BattleRes
         * @property {boolean|null} [IsFirstPvp] FightDesk IsFirstPvp
         */

        /**
         * Constructs a new FightDesk.
         * @memberof pb
         * @classdesc Represents a FightDesk.
         * @implements IFightDesk
         * @constructor
         * @param {pb.IFightDesk=} [properties] Properties to set
         */
        function FightDesk(properties) {
            this.Grids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightDesk DeskId.
         * @member {number|Long} DeskId
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.DeskId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FightDesk Type.
         * @member {number} Type
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.Type = 0;

        /**
         * FightDesk Grids.
         * @member {Array.<pb.IGrid>} Grids
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.Grids = $util.emptyArray;

        /**
         * FightDesk Fighter1.
         * @member {pb.IFighter|null|undefined} Fighter1
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.Fighter1 = null;

        /**
         * FightDesk Fighter2.
         * @member {pb.IFighter|null|undefined} Fighter2
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.Fighter2 = null;

        /**
         * FightDesk Scale.
         * @member {number} Scale
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.Scale = 0;

        /**
         * FightDesk BattleRes.
         * @member {number} BattleRes
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.BattleRes = 0;

        /**
         * FightDesk IsFirstPvp.
         * @member {boolean} IsFirstPvp
         * @memberof pb.FightDesk
         * @instance
         */
        FightDesk.prototype.IsFirstPvp = false;

        /**
         * Creates a new FightDesk instance using the specified properties.
         * @function create
         * @memberof pb.FightDesk
         * @static
         * @param {pb.IFightDesk=} [properties] Properties to set
         * @returns {pb.FightDesk} FightDesk instance
         */
        FightDesk.create = function create(properties) {
            return new FightDesk(properties);
        };

        /**
         * Encodes the specified FightDesk message. Does not implicitly {@link pb.FightDesk.verify|verify} messages.
         * @function encode
         * @memberof pb.FightDesk
         * @static
         * @param {pb.IFightDesk} message FightDesk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightDesk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.DeskId != null && message.hasOwnProperty("DeskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.DeskId);
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Type);
            if (message.Grids != null && message.Grids.length)
                for (var i = 0; i < message.Grids.length; ++i)
                    $root.pb.Grid.encode(message.Grids[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1"))
                $root.pb.Fighter.encode(message.Fighter1, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2"))
                $root.pb.Fighter.encode(message.Fighter2, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Scale != null && message.hasOwnProperty("Scale"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Scale);
            if (message.BattleRes != null && message.hasOwnProperty("BattleRes"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.BattleRes);
            if (message.IsFirstPvp != null && message.hasOwnProperty("IsFirstPvp"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsFirstPvp);
            return writer;
        };

        /**
         * Encodes the specified FightDesk message, length delimited. Does not implicitly {@link pb.FightDesk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FightDesk
         * @static
         * @param {pb.IFightDesk} message FightDesk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightDesk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightDesk message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FightDesk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FightDesk} FightDesk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightDesk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FightDesk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.DeskId = reader.uint64();
                    break;
                case 2:
                    message.Type = reader.int32();
                    break;
                case 3:
                    if (!(message.Grids && message.Grids.length))
                        message.Grids = [];
                    message.Grids.push($root.pb.Grid.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.Fighter1 = $root.pb.Fighter.decode(reader, reader.uint32());
                    break;
                case 5:
                    message.Fighter2 = $root.pb.Fighter.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.Scale = reader.int32();
                    break;
                case 7:
                    message.BattleRes = reader.int32();
                    break;
                case 8:
                    message.IsFirstPvp = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightDesk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FightDesk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FightDesk} FightDesk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightDesk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightDesk message.
         * @function verify
         * @memberof pb.FightDesk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightDesk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.DeskId != null && message.hasOwnProperty("DeskId"))
                if (!$util.isInteger(message.DeskId) && !(message.DeskId && $util.isInteger(message.DeskId.low) && $util.isInteger(message.DeskId.high)))
                    return "DeskId: integer|Long expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                if (!$util.isInteger(message.Type))
                    return "Type: integer expected";
            if (message.Grids != null && message.hasOwnProperty("Grids")) {
                if (!Array.isArray(message.Grids))
                    return "Grids: array expected";
                for (var i = 0; i < message.Grids.length; ++i) {
                    var error = $root.pb.Grid.verify(message.Grids[i]);
                    if (error)
                        return "Grids." + error;
                }
            }
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1")) {
                var error = $root.pb.Fighter.verify(message.Fighter1);
                if (error)
                    return "Fighter1." + error;
            }
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2")) {
                var error = $root.pb.Fighter.verify(message.Fighter2);
                if (error)
                    return "Fighter2." + error;
            }
            if (message.Scale != null && message.hasOwnProperty("Scale"))
                if (!$util.isInteger(message.Scale))
                    return "Scale: integer expected";
            if (message.BattleRes != null && message.hasOwnProperty("BattleRes"))
                if (!$util.isInteger(message.BattleRes))
                    return "BattleRes: integer expected";
            if (message.IsFirstPvp != null && message.hasOwnProperty("IsFirstPvp"))
                if (typeof message.IsFirstPvp !== "boolean")
                    return "IsFirstPvp: boolean expected";
            return null;
        };

        return FightDesk;
    })();

    /**
     * BattleHandType enum.
     * @name pb.BattleHandType
     * @enum {string}
     * @property {number} UnknowType=0 UnknowType value
     * @property {number} Default=1 Default value
     * @property {number} Random=2 Random value
     * @property {number} Ban=3 Ban value
     * @property {number} Switch=4 Switch value
     */
    pb.BattleHandType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UnknowType"] = 0;
        values[valuesById[1] = "Default"] = 1;
        values[valuesById[2] = "Random"] = 2;
        values[valuesById[3] = "Ban"] = 3;
        values[valuesById[4] = "Switch"] = 4;
        return values;
    })();

    pb.SeasonBattle = (function() {

        /**
         * Properties of a SeasonBattle.
         * @memberof pb
         * @interface ISeasonBattle
         * @property {pb.IFightDesk|null} [Battle] SeasonBattle Battle
         * @property {pb.BattleHandType|null} [HandType] SeasonBattle HandType
         * @property {Array.<pb.ISkinGCard>|null} [MyHandCards] SeasonBattle MyHandCards
         * @property {Uint8Array|null} [Arg] SeasonBattle Arg
         */

        /**
         * Constructs a new SeasonBattle.
         * @memberof pb
         * @classdesc Represents a SeasonBattle.
         * @implements ISeasonBattle
         * @constructor
         * @param {pb.ISeasonBattle=} [properties] Properties to set
         */
        function SeasonBattle(properties) {
            this.MyHandCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonBattle Battle.
         * @member {pb.IFightDesk|null|undefined} Battle
         * @memberof pb.SeasonBattle
         * @instance
         */
        SeasonBattle.prototype.Battle = null;

        /**
         * SeasonBattle HandType.
         * @member {pb.BattleHandType} HandType
         * @memberof pb.SeasonBattle
         * @instance
         */
        SeasonBattle.prototype.HandType = 0;

        /**
         * SeasonBattle MyHandCards.
         * @member {Array.<pb.ISkinGCard>} MyHandCards
         * @memberof pb.SeasonBattle
         * @instance
         */
        SeasonBattle.prototype.MyHandCards = $util.emptyArray;

        /**
         * SeasonBattle Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.SeasonBattle
         * @instance
         */
        SeasonBattle.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new SeasonBattle instance using the specified properties.
         * @function create
         * @memberof pb.SeasonBattle
         * @static
         * @param {pb.ISeasonBattle=} [properties] Properties to set
         * @returns {pb.SeasonBattle} SeasonBattle instance
         */
        SeasonBattle.create = function create(properties) {
            return new SeasonBattle(properties);
        };

        /**
         * Encodes the specified SeasonBattle message. Does not implicitly {@link pb.SeasonBattle.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonBattle
         * @static
         * @param {pb.ISeasonBattle} message SeasonBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Battle != null && message.hasOwnProperty("Battle"))
                $root.pb.FightDesk.encode(message.Battle, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.HandType != null && message.hasOwnProperty("HandType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.HandType);
            if (message.MyHandCards != null && message.MyHandCards.length)
                for (var i = 0; i < message.MyHandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.MyHandCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified SeasonBattle message, length delimited. Does not implicitly {@link pb.SeasonBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonBattle
         * @static
         * @param {pb.ISeasonBattle} message SeasonBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonBattle message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonBattle} SeasonBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Battle = $root.pb.FightDesk.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.HandType = reader.int32();
                    break;
                case 3:
                    if (!(message.MyHandCards && message.MyHandCards.length))
                        message.MyHandCards = [];
                    message.MyHandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonBattle} SeasonBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonBattle message.
         * @function verify
         * @memberof pb.SeasonBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Battle != null && message.hasOwnProperty("Battle")) {
                var error = $root.pb.FightDesk.verify(message.Battle);
                if (error)
                    return "Battle." + error;
            }
            if (message.HandType != null && message.hasOwnProperty("HandType"))
                switch (message.HandType) {
                default:
                    return "HandType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.MyHandCards != null && message.hasOwnProperty("MyHandCards")) {
                if (!Array.isArray(message.MyHandCards))
                    return "MyHandCards: array expected";
                for (var i = 0; i < message.MyHandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.MyHandCards[i]);
                    if (error)
                        return "MyHandCards." + error;
                }
            }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        return SeasonBattle;
    })();

    pb.SeasonRandomHand = (function() {

        /**
         * Properties of a SeasonRandomHand.
         * @memberof pb
         * @interface ISeasonRandomHand
         * @property {number|null} [ChooseAmount] SeasonRandomHand ChooseAmount
         * @property {number|null} [RemainTime] SeasonRandomHand RemainTime
         */

        /**
         * Constructs a new SeasonRandomHand.
         * @memberof pb
         * @classdesc Represents a SeasonRandomHand.
         * @implements ISeasonRandomHand
         * @constructor
         * @param {pb.ISeasonRandomHand=} [properties] Properties to set
         */
        function SeasonRandomHand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonRandomHand ChooseAmount.
         * @member {number} ChooseAmount
         * @memberof pb.SeasonRandomHand
         * @instance
         */
        SeasonRandomHand.prototype.ChooseAmount = 0;

        /**
         * SeasonRandomHand RemainTime.
         * @member {number} RemainTime
         * @memberof pb.SeasonRandomHand
         * @instance
         */
        SeasonRandomHand.prototype.RemainTime = 0;

        /**
         * Creates a new SeasonRandomHand instance using the specified properties.
         * @function create
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {pb.ISeasonRandomHand=} [properties] Properties to set
         * @returns {pb.SeasonRandomHand} SeasonRandomHand instance
         */
        SeasonRandomHand.create = function create(properties) {
            return new SeasonRandomHand(properties);
        };

        /**
         * Encodes the specified SeasonRandomHand message. Does not implicitly {@link pb.SeasonRandomHand.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {pb.ISeasonRandomHand} message SeasonRandomHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonRandomHand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChooseAmount != null && message.hasOwnProperty("ChooseAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ChooseAmount);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified SeasonRandomHand message, length delimited. Does not implicitly {@link pb.SeasonRandomHand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {pb.ISeasonRandomHand} message SeasonRandomHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonRandomHand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonRandomHand message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonRandomHand} SeasonRandomHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonRandomHand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonRandomHand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.ChooseAmount = reader.int32();
                    break;
                case 3:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonRandomHand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonRandomHand} SeasonRandomHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonRandomHand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonRandomHand message.
         * @function verify
         * @memberof pb.SeasonRandomHand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonRandomHand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChooseAmount != null && message.hasOwnProperty("ChooseAmount"))
                if (!$util.isInteger(message.ChooseAmount))
                    return "ChooseAmount: integer expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return SeasonRandomHand;
    })();

    pb.SeasonBanHand = (function() {

        /**
         * Properties of a SeasonBanHand.
         * @memberof pb
         * @interface ISeasonBanHand
         * @property {Array.<number>|null} [BanMyCardIdxs] SeasonBanHand BanMyCardIdxs
         * @property {Array.<pb.ISkinGCard>|null} [MyRandomCards] SeasonBanHand MyRandomCards
         * @property {Array.<number>|null} [BanEnemyCardIdxs] SeasonBanHand BanEnemyCardIdxs
         * @property {Array.<pb.ISkinGCard>|null} [EnemyBanCards] SeasonBanHand EnemyBanCards
         */

        /**
         * Constructs a new SeasonBanHand.
         * @memberof pb
         * @classdesc Represents a SeasonBanHand.
         * @implements ISeasonBanHand
         * @constructor
         * @param {pb.ISeasonBanHand=} [properties] Properties to set
         */
        function SeasonBanHand(properties) {
            this.BanMyCardIdxs = [];
            this.MyRandomCards = [];
            this.BanEnemyCardIdxs = [];
            this.EnemyBanCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonBanHand BanMyCardIdxs.
         * @member {Array.<number>} BanMyCardIdxs
         * @memberof pb.SeasonBanHand
         * @instance
         */
        SeasonBanHand.prototype.BanMyCardIdxs = $util.emptyArray;

        /**
         * SeasonBanHand MyRandomCards.
         * @member {Array.<pb.ISkinGCard>} MyRandomCards
         * @memberof pb.SeasonBanHand
         * @instance
         */
        SeasonBanHand.prototype.MyRandomCards = $util.emptyArray;

        /**
         * SeasonBanHand BanEnemyCardIdxs.
         * @member {Array.<number>} BanEnemyCardIdxs
         * @memberof pb.SeasonBanHand
         * @instance
         */
        SeasonBanHand.prototype.BanEnemyCardIdxs = $util.emptyArray;

        /**
         * SeasonBanHand EnemyBanCards.
         * @member {Array.<pb.ISkinGCard>} EnemyBanCards
         * @memberof pb.SeasonBanHand
         * @instance
         */
        SeasonBanHand.prototype.EnemyBanCards = $util.emptyArray;

        /**
         * Creates a new SeasonBanHand instance using the specified properties.
         * @function create
         * @memberof pb.SeasonBanHand
         * @static
         * @param {pb.ISeasonBanHand=} [properties] Properties to set
         * @returns {pb.SeasonBanHand} SeasonBanHand instance
         */
        SeasonBanHand.create = function create(properties) {
            return new SeasonBanHand(properties);
        };

        /**
         * Encodes the specified SeasonBanHand message. Does not implicitly {@link pb.SeasonBanHand.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonBanHand
         * @static
         * @param {pb.ISeasonBanHand} message SeasonBanHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBanHand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BanMyCardIdxs != null && message.BanMyCardIdxs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.BanMyCardIdxs.length; ++i)
                    writer.int32(message.BanMyCardIdxs[i]);
                writer.ldelim();
            }
            if (message.MyRandomCards != null && message.MyRandomCards.length)
                for (var i = 0; i < message.MyRandomCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.MyRandomCards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.BanEnemyCardIdxs != null && message.BanEnemyCardIdxs.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.BanEnemyCardIdxs.length; ++i)
                    writer.int32(message.BanEnemyCardIdxs[i]);
                writer.ldelim();
            }
            if (message.EnemyBanCards != null && message.EnemyBanCards.length)
                for (var i = 0; i < message.EnemyBanCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.EnemyBanCards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SeasonBanHand message, length delimited. Does not implicitly {@link pb.SeasonBanHand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonBanHand
         * @static
         * @param {pb.ISeasonBanHand} message SeasonBanHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBanHand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonBanHand message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonBanHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonBanHand} SeasonBanHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBanHand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonBanHand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.BanMyCardIdxs && message.BanMyCardIdxs.length))
                        message.BanMyCardIdxs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.BanMyCardIdxs.push(reader.int32());
                    } else
                        message.BanMyCardIdxs.push(reader.int32());
                    break;
                case 2:
                    if (!(message.MyRandomCards && message.MyRandomCards.length))
                        message.MyRandomCards = [];
                    message.MyRandomCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.BanEnemyCardIdxs && message.BanEnemyCardIdxs.length))
                        message.BanEnemyCardIdxs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.BanEnemyCardIdxs.push(reader.int32());
                    } else
                        message.BanEnemyCardIdxs.push(reader.int32());
                    break;
                case 4:
                    if (!(message.EnemyBanCards && message.EnemyBanCards.length))
                        message.EnemyBanCards = [];
                    message.EnemyBanCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonBanHand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonBanHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonBanHand} SeasonBanHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBanHand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonBanHand message.
         * @function verify
         * @memberof pb.SeasonBanHand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonBanHand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BanMyCardIdxs != null && message.hasOwnProperty("BanMyCardIdxs")) {
                if (!Array.isArray(message.BanMyCardIdxs))
                    return "BanMyCardIdxs: array expected";
                for (var i = 0; i < message.BanMyCardIdxs.length; ++i)
                    if (!$util.isInteger(message.BanMyCardIdxs[i]))
                        return "BanMyCardIdxs: integer[] expected";
            }
            if (message.MyRandomCards != null && message.hasOwnProperty("MyRandomCards")) {
                if (!Array.isArray(message.MyRandomCards))
                    return "MyRandomCards: array expected";
                for (var i = 0; i < message.MyRandomCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.MyRandomCards[i]);
                    if (error)
                        return "MyRandomCards." + error;
                }
            }
            if (message.BanEnemyCardIdxs != null && message.hasOwnProperty("BanEnemyCardIdxs")) {
                if (!Array.isArray(message.BanEnemyCardIdxs))
                    return "BanEnemyCardIdxs: array expected";
                for (var i = 0; i < message.BanEnemyCardIdxs.length; ++i)
                    if (!$util.isInteger(message.BanEnemyCardIdxs[i]))
                        return "BanEnemyCardIdxs: integer[] expected";
            }
            if (message.EnemyBanCards != null && message.hasOwnProperty("EnemyBanCards")) {
                if (!Array.isArray(message.EnemyBanCards))
                    return "EnemyBanCards: array expected";
                for (var i = 0; i < message.EnemyBanCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.EnemyBanCards[i]);
                    if (error)
                        return "EnemyBanCards." + error;
                }
            }
            return null;
        };

        return SeasonBanHand;
    })();

    pb.SeasonSwitchHand = (function() {

        /**
         * Properties of a SeasonSwitchHand.
         * @memberof pb
         * @interface ISeasonSwitchHand
         * @property {Array.<number>|null} [SwitchMyCardIdxs] SeasonSwitchHand SwitchMyCardIdxs
         * @property {Array.<number>|null} [SwitchEnemyCardIdxs] SeasonSwitchHand SwitchEnemyCardIdxs
         * @property {Array.<pb.ISkinGCard>|null} [EnemySwitchCards] SeasonSwitchHand EnemySwitchCards
         */

        /**
         * Constructs a new SeasonSwitchHand.
         * @memberof pb
         * @classdesc Represents a SeasonSwitchHand.
         * @implements ISeasonSwitchHand
         * @constructor
         * @param {pb.ISeasonSwitchHand=} [properties] Properties to set
         */
        function SeasonSwitchHand(properties) {
            this.SwitchMyCardIdxs = [];
            this.SwitchEnemyCardIdxs = [];
            this.EnemySwitchCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonSwitchHand SwitchMyCardIdxs.
         * @member {Array.<number>} SwitchMyCardIdxs
         * @memberof pb.SeasonSwitchHand
         * @instance
         */
        SeasonSwitchHand.prototype.SwitchMyCardIdxs = $util.emptyArray;

        /**
         * SeasonSwitchHand SwitchEnemyCardIdxs.
         * @member {Array.<number>} SwitchEnemyCardIdxs
         * @memberof pb.SeasonSwitchHand
         * @instance
         */
        SeasonSwitchHand.prototype.SwitchEnemyCardIdxs = $util.emptyArray;

        /**
         * SeasonSwitchHand EnemySwitchCards.
         * @member {Array.<pb.ISkinGCard>} EnemySwitchCards
         * @memberof pb.SeasonSwitchHand
         * @instance
         */
        SeasonSwitchHand.prototype.EnemySwitchCards = $util.emptyArray;

        /**
         * Creates a new SeasonSwitchHand instance using the specified properties.
         * @function create
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {pb.ISeasonSwitchHand=} [properties] Properties to set
         * @returns {pb.SeasonSwitchHand} SeasonSwitchHand instance
         */
        SeasonSwitchHand.create = function create(properties) {
            return new SeasonSwitchHand(properties);
        };

        /**
         * Encodes the specified SeasonSwitchHand message. Does not implicitly {@link pb.SeasonSwitchHand.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {pb.ISeasonSwitchHand} message SeasonSwitchHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonSwitchHand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.SwitchMyCardIdxs != null && message.SwitchMyCardIdxs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.SwitchMyCardIdxs.length; ++i)
                    writer.int32(message.SwitchMyCardIdxs[i]);
                writer.ldelim();
            }
            if (message.SwitchEnemyCardIdxs != null && message.SwitchEnemyCardIdxs.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.SwitchEnemyCardIdxs.length; ++i)
                    writer.int32(message.SwitchEnemyCardIdxs[i]);
                writer.ldelim();
            }
            if (message.EnemySwitchCards != null && message.EnemySwitchCards.length)
                for (var i = 0; i < message.EnemySwitchCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.EnemySwitchCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SeasonSwitchHand message, length delimited. Does not implicitly {@link pb.SeasonSwitchHand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {pb.ISeasonSwitchHand} message SeasonSwitchHand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonSwitchHand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonSwitchHand message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonSwitchHand} SeasonSwitchHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonSwitchHand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonSwitchHand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.SwitchMyCardIdxs && message.SwitchMyCardIdxs.length))
                        message.SwitchMyCardIdxs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.SwitchMyCardIdxs.push(reader.int32());
                    } else
                        message.SwitchMyCardIdxs.push(reader.int32());
                    break;
                case 2:
                    if (!(message.SwitchEnemyCardIdxs && message.SwitchEnemyCardIdxs.length))
                        message.SwitchEnemyCardIdxs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.SwitchEnemyCardIdxs.push(reader.int32());
                    } else
                        message.SwitchEnemyCardIdxs.push(reader.int32());
                    break;
                case 3:
                    if (!(message.EnemySwitchCards && message.EnemySwitchCards.length))
                        message.EnemySwitchCards = [];
                    message.EnemySwitchCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonSwitchHand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonSwitchHand} SeasonSwitchHand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonSwitchHand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonSwitchHand message.
         * @function verify
         * @memberof pb.SeasonSwitchHand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonSwitchHand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.SwitchMyCardIdxs != null && message.hasOwnProperty("SwitchMyCardIdxs")) {
                if (!Array.isArray(message.SwitchMyCardIdxs))
                    return "SwitchMyCardIdxs: array expected";
                for (var i = 0; i < message.SwitchMyCardIdxs.length; ++i)
                    if (!$util.isInteger(message.SwitchMyCardIdxs[i]))
                        return "SwitchMyCardIdxs: integer[] expected";
            }
            if (message.SwitchEnemyCardIdxs != null && message.hasOwnProperty("SwitchEnemyCardIdxs")) {
                if (!Array.isArray(message.SwitchEnemyCardIdxs))
                    return "SwitchEnemyCardIdxs: array expected";
                for (var i = 0; i < message.SwitchEnemyCardIdxs.length; ++i)
                    if (!$util.isInteger(message.SwitchEnemyCardIdxs[i]))
                        return "SwitchEnemyCardIdxs: integer[] expected";
            }
            if (message.EnemySwitchCards != null && message.hasOwnProperty("EnemySwitchCards")) {
                if (!Array.isArray(message.EnemySwitchCards))
                    return "EnemySwitchCards: array expected";
                for (var i = 0; i < message.EnemySwitchCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.EnemySwitchCards[i]);
                    if (error)
                        return "EnemySwitchCards." + error;
                }
            }
            return null;
        };

        return SeasonSwitchHand;
    })();

    pb.SeasonBattleReady = (function() {

        /**
         * Properties of a SeasonBattleReady.
         * @memberof pb
         * @interface ISeasonBattleReady
         * @property {Array.<number>|null} [ChooseCards] SeasonBattleReady ChooseCards
         */

        /**
         * Constructs a new SeasonBattleReady.
         * @memberof pb
         * @classdesc Represents a SeasonBattleReady.
         * @implements ISeasonBattleReady
         * @constructor
         * @param {pb.ISeasonBattleReady=} [properties] Properties to set
         */
        function SeasonBattleReady(properties) {
            this.ChooseCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonBattleReady ChooseCards.
         * @member {Array.<number>} ChooseCards
         * @memberof pb.SeasonBattleReady
         * @instance
         */
        SeasonBattleReady.prototype.ChooseCards = $util.emptyArray;

        /**
         * Creates a new SeasonBattleReady instance using the specified properties.
         * @function create
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {pb.ISeasonBattleReady=} [properties] Properties to set
         * @returns {pb.SeasonBattleReady} SeasonBattleReady instance
         */
        SeasonBattleReady.create = function create(properties) {
            return new SeasonBattleReady(properties);
        };

        /**
         * Encodes the specified SeasonBattleReady message. Does not implicitly {@link pb.SeasonBattleReady.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {pb.ISeasonBattleReady} message SeasonBattleReady message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattleReady.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChooseCards != null && message.ChooseCards.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.ChooseCards.length; ++i)
                    writer.uint32(message.ChooseCards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SeasonBattleReady message, length delimited. Does not implicitly {@link pb.SeasonBattleReady.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {pb.ISeasonBattleReady} message SeasonBattleReady message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattleReady.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonBattleReady message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonBattleReady} SeasonBattleReady
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattleReady.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonBattleReady();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    if (!(message.ChooseCards && message.ChooseCards.length))
                        message.ChooseCards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ChooseCards.push(reader.uint32());
                    } else
                        message.ChooseCards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonBattleReady message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonBattleReady} SeasonBattleReady
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattleReady.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonBattleReady message.
         * @function verify
         * @memberof pb.SeasonBattleReady
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonBattleReady.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChooseCards != null && message.hasOwnProperty("ChooseCards")) {
                if (!Array.isArray(message.ChooseCards))
                    return "ChooseCards: array expected";
                for (var i = 0; i < message.ChooseCards.length; ++i)
                    if (!$util.isInteger(message.ChooseCards[i]))
                        return "ChooseCards: integer[] expected";
            }
            return null;
        };

        return SeasonBattleReady;
    })();

    pb.SeasonBattleBegin = (function() {

        /**
         * Properties of a SeasonBattleBegin.
         * @memberof pb
         * @interface ISeasonBattleBegin
         * @property {Array.<pb.ICard>|null} [MyHand] SeasonBattleBegin MyHand
         * @property {Array.<pb.ICard>|null} [EnemyHand] SeasonBattleBegin EnemyHand
         */

        /**
         * Constructs a new SeasonBattleBegin.
         * @memberof pb
         * @classdesc Represents a SeasonBattleBegin.
         * @implements ISeasonBattleBegin
         * @constructor
         * @param {pb.ISeasonBattleBegin=} [properties] Properties to set
         */
        function SeasonBattleBegin(properties) {
            this.MyHand = [];
            this.EnemyHand = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonBattleBegin MyHand.
         * @member {Array.<pb.ICard>} MyHand
         * @memberof pb.SeasonBattleBegin
         * @instance
         */
        SeasonBattleBegin.prototype.MyHand = $util.emptyArray;

        /**
         * SeasonBattleBegin EnemyHand.
         * @member {Array.<pb.ICard>} EnemyHand
         * @memberof pb.SeasonBattleBegin
         * @instance
         */
        SeasonBattleBegin.prototype.EnemyHand = $util.emptyArray;

        /**
         * Creates a new SeasonBattleBegin instance using the specified properties.
         * @function create
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {pb.ISeasonBattleBegin=} [properties] Properties to set
         * @returns {pb.SeasonBattleBegin} SeasonBattleBegin instance
         */
        SeasonBattleBegin.create = function create(properties) {
            return new SeasonBattleBegin(properties);
        };

        /**
         * Encodes the specified SeasonBattleBegin message. Does not implicitly {@link pb.SeasonBattleBegin.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {pb.ISeasonBattleBegin} message SeasonBattleBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattleBegin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MyHand != null && message.MyHand.length)
                for (var i = 0; i < message.MyHand.length; ++i)
                    $root.pb.Card.encode(message.MyHand[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.EnemyHand != null && message.EnemyHand.length)
                for (var i = 0; i < message.EnemyHand.length; ++i)
                    $root.pb.Card.encode(message.EnemyHand[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SeasonBattleBegin message, length delimited. Does not implicitly {@link pb.SeasonBattleBegin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {pb.ISeasonBattleBegin} message SeasonBattleBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonBattleBegin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonBattleBegin message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonBattleBegin} SeasonBattleBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattleBegin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonBattleBegin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.MyHand && message.MyHand.length))
                        message.MyHand = [];
                    message.MyHand.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.EnemyHand && message.EnemyHand.length))
                        message.EnemyHand = [];
                    message.EnemyHand.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonBattleBegin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonBattleBegin} SeasonBattleBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonBattleBegin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonBattleBegin message.
         * @function verify
         * @memberof pb.SeasonBattleBegin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonBattleBegin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MyHand != null && message.hasOwnProperty("MyHand")) {
                if (!Array.isArray(message.MyHand))
                    return "MyHand: array expected";
                for (var i = 0; i < message.MyHand.length; ++i) {
                    var error = $root.pb.Card.verify(message.MyHand[i]);
                    if (error)
                        return "MyHand." + error;
                }
            }
            if (message.EnemyHand != null && message.hasOwnProperty("EnemyHand")) {
                if (!Array.isArray(message.EnemyHand))
                    return "EnemyHand: array expected";
                for (var i = 0; i < message.EnemyHand.length; ++i) {
                    var error = $root.pb.Card.verify(message.EnemyHand[i]);
                    if (error)
                        return "EnemyHand." + error;
                }
            }
            return null;
        };

        return SeasonBattleBegin;
    })();

    pb.FightBoutBegin = (function() {

        /**
         * Properties of a FightBoutBegin.
         * @memberof pb
         * @interface IFightBoutBegin
         * @property {number|Long|null} [BoutUid] FightBoutBegin BoutUid
         * @property {Array.<pb.IClientAction>|null} [Actions] FightBoutBegin Actions
         * @property {number|null} [BoutTimeout] FightBoutBegin BoutTimeout
         */

        /**
         * Constructs a new FightBoutBegin.
         * @memberof pb
         * @classdesc Represents a FightBoutBegin.
         * @implements IFightBoutBegin
         * @constructor
         * @param {pb.IFightBoutBegin=} [properties] Properties to set
         */
        function FightBoutBegin(properties) {
            this.Actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightBoutBegin BoutUid.
         * @member {number|Long} BoutUid
         * @memberof pb.FightBoutBegin
         * @instance
         */
        FightBoutBegin.prototype.BoutUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FightBoutBegin Actions.
         * @member {Array.<pb.IClientAction>} Actions
         * @memberof pb.FightBoutBegin
         * @instance
         */
        FightBoutBegin.prototype.Actions = $util.emptyArray;

        /**
         * FightBoutBegin BoutTimeout.
         * @member {number} BoutTimeout
         * @memberof pb.FightBoutBegin
         * @instance
         */
        FightBoutBegin.prototype.BoutTimeout = 0;

        /**
         * Creates a new FightBoutBegin instance using the specified properties.
         * @function create
         * @memberof pb.FightBoutBegin
         * @static
         * @param {pb.IFightBoutBegin=} [properties] Properties to set
         * @returns {pb.FightBoutBegin} FightBoutBegin instance
         */
        FightBoutBegin.create = function create(properties) {
            return new FightBoutBegin(properties);
        };

        /**
         * Encodes the specified FightBoutBegin message. Does not implicitly {@link pb.FightBoutBegin.verify|verify} messages.
         * @function encode
         * @memberof pb.FightBoutBegin
         * @static
         * @param {pb.IFightBoutBegin} message FightBoutBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutBegin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BoutUid != null && message.hasOwnProperty("BoutUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.BoutUid);
            if (message.Actions != null && message.Actions.length)
                for (var i = 0; i < message.Actions.length; ++i)
                    $root.pb.ClientAction.encode(message.Actions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.BoutTimeout != null && message.hasOwnProperty("BoutTimeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.BoutTimeout);
            return writer;
        };

        /**
         * Encodes the specified FightBoutBegin message, length delimited. Does not implicitly {@link pb.FightBoutBegin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FightBoutBegin
         * @static
         * @param {pb.IFightBoutBegin} message FightBoutBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutBegin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightBoutBegin message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FightBoutBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FightBoutBegin} FightBoutBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutBegin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FightBoutBegin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BoutUid = reader.uint64();
                    break;
                case 2:
                    if (!(message.Actions && message.Actions.length))
                        message.Actions = [];
                    message.Actions.push($root.pb.ClientAction.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.BoutTimeout = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightBoutBegin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FightBoutBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FightBoutBegin} FightBoutBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutBegin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightBoutBegin message.
         * @function verify
         * @memberof pb.FightBoutBegin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightBoutBegin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BoutUid != null && message.hasOwnProperty("BoutUid"))
                if (!$util.isInteger(message.BoutUid) && !(message.BoutUid && $util.isInteger(message.BoutUid.low) && $util.isInteger(message.BoutUid.high)))
                    return "BoutUid: integer|Long expected";
            if (message.Actions != null && message.hasOwnProperty("Actions")) {
                if (!Array.isArray(message.Actions))
                    return "Actions: array expected";
                for (var i = 0; i < message.Actions.length; ++i) {
                    var error = $root.pb.ClientAction.verify(message.Actions[i]);
                    if (error)
                        return "Actions." + error;
                }
            }
            if (message.BoutTimeout != null && message.hasOwnProperty("BoutTimeout"))
                if (!$util.isInteger(message.BoutTimeout))
                    return "BoutTimeout: integer expected";
            return null;
        };

        return FightBoutBegin;
    })();

    pb.FightBoutCmd = (function() {

        /**
         * Properties of a FightBoutCmd.
         * @memberof pb
         * @interface IFightBoutCmd
         * @property {number|null} [UseCardObjID] FightBoutCmd UseCardObjID
         * @property {number|null} [TargetGridId] FightBoutCmd TargetGridId
         */

        /**
         * Constructs a new FightBoutCmd.
         * @memberof pb
         * @classdesc Represents a FightBoutCmd.
         * @implements IFightBoutCmd
         * @constructor
         * @param {pb.IFightBoutCmd=} [properties] Properties to set
         */
        function FightBoutCmd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightBoutCmd UseCardObjID.
         * @member {number} UseCardObjID
         * @memberof pb.FightBoutCmd
         * @instance
         */
        FightBoutCmd.prototype.UseCardObjID = 0;

        /**
         * FightBoutCmd TargetGridId.
         * @member {number} TargetGridId
         * @memberof pb.FightBoutCmd
         * @instance
         */
        FightBoutCmd.prototype.TargetGridId = 0;

        /**
         * Creates a new FightBoutCmd instance using the specified properties.
         * @function create
         * @memberof pb.FightBoutCmd
         * @static
         * @param {pb.IFightBoutCmd=} [properties] Properties to set
         * @returns {pb.FightBoutCmd} FightBoutCmd instance
         */
        FightBoutCmd.create = function create(properties) {
            return new FightBoutCmd(properties);
        };

        /**
         * Encodes the specified FightBoutCmd message. Does not implicitly {@link pb.FightBoutCmd.verify|verify} messages.
         * @function encode
         * @memberof pb.FightBoutCmd
         * @static
         * @param {pb.IFightBoutCmd} message FightBoutCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutCmd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.UseCardObjID != null && message.hasOwnProperty("UseCardObjID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.UseCardObjID);
            if (message.TargetGridId != null && message.hasOwnProperty("TargetGridId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TargetGridId);
            return writer;
        };

        /**
         * Encodes the specified FightBoutCmd message, length delimited. Does not implicitly {@link pb.FightBoutCmd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FightBoutCmd
         * @static
         * @param {pb.IFightBoutCmd} message FightBoutCmd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutCmd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightBoutCmd message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FightBoutCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FightBoutCmd} FightBoutCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutCmd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FightBoutCmd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.UseCardObjID = reader.int32();
                    break;
                case 2:
                    message.TargetGridId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightBoutCmd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FightBoutCmd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FightBoutCmd} FightBoutCmd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutCmd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightBoutCmd message.
         * @function verify
         * @memberof pb.FightBoutCmd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightBoutCmd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.UseCardObjID != null && message.hasOwnProperty("UseCardObjID"))
                if (!$util.isInteger(message.UseCardObjID))
                    return "UseCardObjID: integer expected";
            if (message.TargetGridId != null && message.hasOwnProperty("TargetGridId"))
                if (!$util.isInteger(message.TargetGridId))
                    return "TargetGridId: integer expected";
            return null;
        };

        return FightBoutCmd;
    })();

    pb.FightBoutResult = (function() {

        /**
         * Properties of a FightBoutResult.
         * @memberof pb
         * @interface IFightBoutResult
         * @property {number|Long|null} [BoutUid] FightBoutResult BoutUid
         * @property {number|null} [UseCardObjID] FightBoutResult UseCardObjID
         * @property {number|null} [TargetGridId] FightBoutResult TargetGridId
         * @property {Array.<pb.IClientAction>|null} [Actions] FightBoutResult Actions
         * @property {number|Long|null} [WinUid] FightBoutResult WinUid
         * @property {boolean|null} [CardNeedTalk] FightBoutResult CardNeedTalk
         * @property {boolean|null} [IsUseCardPublicEnemy] FightBoutResult IsUseCardPublicEnemy
         * @property {boolean|null} [IsUseCardInFog] FightBoutResult IsUseCardInFog
         */

        /**
         * Constructs a new FightBoutResult.
         * @memberof pb
         * @classdesc Represents a FightBoutResult.
         * @implements IFightBoutResult
         * @constructor
         * @param {pb.IFightBoutResult=} [properties] Properties to set
         */
        function FightBoutResult(properties) {
            this.Actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightBoutResult BoutUid.
         * @member {number|Long} BoutUid
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.BoutUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FightBoutResult UseCardObjID.
         * @member {number} UseCardObjID
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.UseCardObjID = 0;

        /**
         * FightBoutResult TargetGridId.
         * @member {number} TargetGridId
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.TargetGridId = 0;

        /**
         * FightBoutResult Actions.
         * @member {Array.<pb.IClientAction>} Actions
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.Actions = $util.emptyArray;

        /**
         * FightBoutResult WinUid.
         * @member {number|Long} WinUid
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.WinUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FightBoutResult CardNeedTalk.
         * @member {boolean} CardNeedTalk
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.CardNeedTalk = false;

        /**
         * FightBoutResult IsUseCardPublicEnemy.
         * @member {boolean} IsUseCardPublicEnemy
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.IsUseCardPublicEnemy = false;

        /**
         * FightBoutResult IsUseCardInFog.
         * @member {boolean} IsUseCardInFog
         * @memberof pb.FightBoutResult
         * @instance
         */
        FightBoutResult.prototype.IsUseCardInFog = false;

        /**
         * Creates a new FightBoutResult instance using the specified properties.
         * @function create
         * @memberof pb.FightBoutResult
         * @static
         * @param {pb.IFightBoutResult=} [properties] Properties to set
         * @returns {pb.FightBoutResult} FightBoutResult instance
         */
        FightBoutResult.create = function create(properties) {
            return new FightBoutResult(properties);
        };

        /**
         * Encodes the specified FightBoutResult message. Does not implicitly {@link pb.FightBoutResult.verify|verify} messages.
         * @function encode
         * @memberof pb.FightBoutResult
         * @static
         * @param {pb.IFightBoutResult} message FightBoutResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BoutUid != null && message.hasOwnProperty("BoutUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.BoutUid);
            if (message.UseCardObjID != null && message.hasOwnProperty("UseCardObjID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.UseCardObjID);
            if (message.TargetGridId != null && message.hasOwnProperty("TargetGridId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.TargetGridId);
            if (message.Actions != null && message.Actions.length)
                for (var i = 0; i < message.Actions.length; ++i)
                    $root.pb.ClientAction.encode(message.Actions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.WinUid != null && message.hasOwnProperty("WinUid"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.WinUid);
            if (message.CardNeedTalk != null && message.hasOwnProperty("CardNeedTalk"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.CardNeedTalk);
            if (message.IsUseCardPublicEnemy != null && message.hasOwnProperty("IsUseCardPublicEnemy"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.IsUseCardPublicEnemy);
            if (message.IsUseCardInFog != null && message.hasOwnProperty("IsUseCardInFog"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsUseCardInFog);
            return writer;
        };

        /**
         * Encodes the specified FightBoutResult message, length delimited. Does not implicitly {@link pb.FightBoutResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FightBoutResult
         * @static
         * @param {pb.IFightBoutResult} message FightBoutResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightBoutResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightBoutResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FightBoutResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FightBoutResult} FightBoutResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FightBoutResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BoutUid = reader.uint64();
                    break;
                case 2:
                    message.UseCardObjID = reader.int32();
                    break;
                case 3:
                    message.TargetGridId = reader.int32();
                    break;
                case 4:
                    if (!(message.Actions && message.Actions.length))
                        message.Actions = [];
                    message.Actions.push($root.pb.ClientAction.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.WinUid = reader.uint64();
                    break;
                case 6:
                    message.CardNeedTalk = reader.bool();
                    break;
                case 7:
                    message.IsUseCardPublicEnemy = reader.bool();
                    break;
                case 8:
                    message.IsUseCardInFog = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightBoutResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FightBoutResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FightBoutResult} FightBoutResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightBoutResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightBoutResult message.
         * @function verify
         * @memberof pb.FightBoutResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightBoutResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BoutUid != null && message.hasOwnProperty("BoutUid"))
                if (!$util.isInteger(message.BoutUid) && !(message.BoutUid && $util.isInteger(message.BoutUid.low) && $util.isInteger(message.BoutUid.high)))
                    return "BoutUid: integer|Long expected";
            if (message.UseCardObjID != null && message.hasOwnProperty("UseCardObjID"))
                if (!$util.isInteger(message.UseCardObjID))
                    return "UseCardObjID: integer expected";
            if (message.TargetGridId != null && message.hasOwnProperty("TargetGridId"))
                if (!$util.isInteger(message.TargetGridId))
                    return "TargetGridId: integer expected";
            if (message.Actions != null && message.hasOwnProperty("Actions")) {
                if (!Array.isArray(message.Actions))
                    return "Actions: array expected";
                for (var i = 0; i < message.Actions.length; ++i) {
                    var error = $root.pb.ClientAction.verify(message.Actions[i]);
                    if (error)
                        return "Actions." + error;
                }
            }
            if (message.WinUid != null && message.hasOwnProperty("WinUid"))
                if (!$util.isInteger(message.WinUid) && !(message.WinUid && $util.isInteger(message.WinUid.low) && $util.isInteger(message.WinUid.high)))
                    return "WinUid: integer|Long expected";
            if (message.CardNeedTalk != null && message.hasOwnProperty("CardNeedTalk"))
                if (typeof message.CardNeedTalk !== "boolean")
                    return "CardNeedTalk: boolean expected";
            if (message.IsUseCardPublicEnemy != null && message.hasOwnProperty("IsUseCardPublicEnemy"))
                if (typeof message.IsUseCardPublicEnemy !== "boolean")
                    return "IsUseCardPublicEnemy: boolean expected";
            if (message.IsUseCardInFog != null && message.hasOwnProperty("IsUseCardInFog"))
                if (typeof message.IsUseCardInFog !== "boolean")
                    return "IsUseCardInFog: boolean expected";
            return null;
        };

        return FightBoutResult;
    })();

    pb.ChangeCardInfo = (function() {

        /**
         * Properties of a ChangeCardInfo.
         * @memberof pb
         * @interface IChangeCardInfo
         * @property {pb.ICardInfo|null} [Old] ChangeCardInfo Old
         * @property {pb.ICardInfo|null} [New] ChangeCardInfo New
         */

        /**
         * Constructs a new ChangeCardInfo.
         * @memberof pb
         * @classdesc Represents a ChangeCardInfo.
         * @implements IChangeCardInfo
         * @constructor
         * @param {pb.IChangeCardInfo=} [properties] Properties to set
         */
        function ChangeCardInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeCardInfo Old.
         * @member {pb.ICardInfo|null|undefined} Old
         * @memberof pb.ChangeCardInfo
         * @instance
         */
        ChangeCardInfo.prototype.Old = null;

        /**
         * ChangeCardInfo New.
         * @member {pb.ICardInfo|null|undefined} New
         * @memberof pb.ChangeCardInfo
         * @instance
         */
        ChangeCardInfo.prototype.New = null;

        /**
         * Creates a new ChangeCardInfo instance using the specified properties.
         * @function create
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {pb.IChangeCardInfo=} [properties] Properties to set
         * @returns {pb.ChangeCardInfo} ChangeCardInfo instance
         */
        ChangeCardInfo.create = function create(properties) {
            return new ChangeCardInfo(properties);
        };

        /**
         * Encodes the specified ChangeCardInfo message. Does not implicitly {@link pb.ChangeCardInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {pb.IChangeCardInfo} message ChangeCardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeCardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Old != null && message.hasOwnProperty("Old"))
                $root.pb.CardInfo.encode(message.Old, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.New != null && message.hasOwnProperty("New"))
                $root.pb.CardInfo.encode(message.New, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeCardInfo message, length delimited. Does not implicitly {@link pb.ChangeCardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {pb.IChangeCardInfo} message ChangeCardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeCardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeCardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChangeCardInfo} ChangeCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeCardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChangeCardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Old = $root.pb.CardInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.New = $root.pb.CardInfo.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeCardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChangeCardInfo} ChangeCardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeCardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeCardInfo message.
         * @function verify
         * @memberof pb.ChangeCardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeCardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Old != null && message.hasOwnProperty("Old")) {
                var error = $root.pb.CardInfo.verify(message.Old);
                if (error)
                    return "Old." + error;
            }
            if (message.New != null && message.hasOwnProperty("New")) {
                var error = $root.pb.CardInfo.verify(message.New);
                if (error)
                    return "New." + error;
            }
            return null;
        };

        return ChangeCardInfo;
    })();

    pb.ChangeResInfo = (function() {

        /**
         * Properties of a ChangeResInfo.
         * @memberof pb
         * @interface IChangeResInfo
         * @property {pb.IResource|null} [Old] ChangeResInfo Old
         * @property {pb.IResource|null} [New] ChangeResInfo New
         */

        /**
         * Constructs a new ChangeResInfo.
         * @memberof pb
         * @classdesc Represents a ChangeResInfo.
         * @implements IChangeResInfo
         * @constructor
         * @param {pb.IChangeResInfo=} [properties] Properties to set
         */
        function ChangeResInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeResInfo Old.
         * @member {pb.IResource|null|undefined} Old
         * @memberof pb.ChangeResInfo
         * @instance
         */
        ChangeResInfo.prototype.Old = null;

        /**
         * ChangeResInfo New.
         * @member {pb.IResource|null|undefined} New
         * @memberof pb.ChangeResInfo
         * @instance
         */
        ChangeResInfo.prototype.New = null;

        /**
         * Creates a new ChangeResInfo instance using the specified properties.
         * @function create
         * @memberof pb.ChangeResInfo
         * @static
         * @param {pb.IChangeResInfo=} [properties] Properties to set
         * @returns {pb.ChangeResInfo} ChangeResInfo instance
         */
        ChangeResInfo.create = function create(properties) {
            return new ChangeResInfo(properties);
        };

        /**
         * Encodes the specified ChangeResInfo message. Does not implicitly {@link pb.ChangeResInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.ChangeResInfo
         * @static
         * @param {pb.IChangeResInfo} message ChangeResInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeResInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Old != null && message.hasOwnProperty("Old"))
                $root.pb.Resource.encode(message.Old, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.New != null && message.hasOwnProperty("New"))
                $root.pb.Resource.encode(message.New, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChangeResInfo message, length delimited. Does not implicitly {@link pb.ChangeResInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChangeResInfo
         * @static
         * @param {pb.IChangeResInfo} message ChangeResInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeResInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeResInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChangeResInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChangeResInfo} ChangeResInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeResInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChangeResInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Old = $root.pb.Resource.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.New = $root.pb.Resource.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeResInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChangeResInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChangeResInfo} ChangeResInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeResInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeResInfo message.
         * @function verify
         * @memberof pb.ChangeResInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeResInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Old != null && message.hasOwnProperty("Old")) {
                var error = $root.pb.Resource.verify(message.Old);
                if (error)
                    return "Old." + error;
            }
            if (message.New != null && message.hasOwnProperty("New")) {
                var error = $root.pb.Resource.verify(message.New);
                if (error)
                    return "New." + error;
            }
            return null;
        };

        return ChangeResInfo;
    })();

    pb.BattleResult = (function() {

        /**
         * Properties of a BattleResult.
         * @memberof pb
         * @interface IBattleResult
         * @property {number|Long|null} [WinUid] BattleResult WinUid
         * @property {Array.<pb.IChangeCardInfo>|null} [ChangeCards] BattleResult ChangeCards
         * @property {Array.<pb.IChangeResInfo>|null} [ChangeRes] BattleResult ChangeRes
         * @property {string|null} [TreasureID] BattleResult TreasureID
         * @property {Array.<number>|null} [UpPvpLevelRewardCards] BattleResult UpPvpLevelRewardCards
         * @property {boolean|null} [CanShare] BattleResult CanShare
         * @property {pb.NoTreasureReasonEnum|null} [NoTreasureReason] BattleResult NoTreasureReason
         * @property {string|null} [UpRareTreasureModelID] BattleResult UpRareTreasureModelID
         * @property {pb.BattleResult.NoSubStarReasonEnum|null} [NoSubStarReason] BattleResult NoSubStarReason
         */

        /**
         * Constructs a new BattleResult.
         * @memberof pb
         * @classdesc Represents a BattleResult.
         * @implements IBattleResult
         * @constructor
         * @param {pb.IBattleResult=} [properties] Properties to set
         */
        function BattleResult(properties) {
            this.ChangeCards = [];
            this.ChangeRes = [];
            this.UpPvpLevelRewardCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleResult WinUid.
         * @member {number|Long} WinUid
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.WinUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BattleResult ChangeCards.
         * @member {Array.<pb.IChangeCardInfo>} ChangeCards
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.ChangeCards = $util.emptyArray;

        /**
         * BattleResult ChangeRes.
         * @member {Array.<pb.IChangeResInfo>} ChangeRes
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.ChangeRes = $util.emptyArray;

        /**
         * BattleResult TreasureID.
         * @member {string} TreasureID
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.TreasureID = "";

        /**
         * BattleResult UpPvpLevelRewardCards.
         * @member {Array.<number>} UpPvpLevelRewardCards
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.UpPvpLevelRewardCards = $util.emptyArray;

        /**
         * BattleResult CanShare.
         * @member {boolean} CanShare
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.CanShare = false;

        /**
         * BattleResult NoTreasureReason.
         * @member {pb.NoTreasureReasonEnum} NoTreasureReason
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.NoTreasureReason = 0;

        /**
         * BattleResult UpRareTreasureModelID.
         * @member {string} UpRareTreasureModelID
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.UpRareTreasureModelID = "";

        /**
         * BattleResult NoSubStarReason.
         * @member {pb.BattleResult.NoSubStarReasonEnum} NoSubStarReason
         * @memberof pb.BattleResult
         * @instance
         */
        BattleResult.prototype.NoSubStarReason = 0;

        /**
         * Creates a new BattleResult instance using the specified properties.
         * @function create
         * @memberof pb.BattleResult
         * @static
         * @param {pb.IBattleResult=} [properties] Properties to set
         * @returns {pb.BattleResult} BattleResult instance
         */
        BattleResult.create = function create(properties) {
            return new BattleResult(properties);
        };

        /**
         * Encodes the specified BattleResult message. Does not implicitly {@link pb.BattleResult.verify|verify} messages.
         * @function encode
         * @memberof pb.BattleResult
         * @static
         * @param {pb.IBattleResult} message BattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.WinUid != null && message.hasOwnProperty("WinUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.WinUid);
            if (message.ChangeCards != null && message.ChangeCards.length)
                for (var i = 0; i < message.ChangeCards.length; ++i)
                    $root.pb.ChangeCardInfo.encode(message.ChangeCards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.ChangeRes != null && message.ChangeRes.length)
                for (var i = 0; i < message.ChangeRes.length; ++i)
                    $root.pb.ChangeResInfo.encode(message.ChangeRes[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.TreasureID);
            if (message.UpPvpLevelRewardCards != null && message.UpPvpLevelRewardCards.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.UpPvpLevelRewardCards.length; ++i)
                    writer.uint32(message.UpPvpLevelRewardCards[i]);
                writer.ldelim();
            }
            if (message.CanShare != null && message.hasOwnProperty("CanShare"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.CanShare);
            if (message.NoTreasureReason != null && message.hasOwnProperty("NoTreasureReason"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.NoTreasureReason);
            if (message.UpRareTreasureModelID != null && message.hasOwnProperty("UpRareTreasureModelID"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.UpRareTreasureModelID);
            if (message.NoSubStarReason != null && message.hasOwnProperty("NoSubStarReason"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.NoSubStarReason);
            return writer;
        };

        /**
         * Encodes the specified BattleResult message, length delimited. Does not implicitly {@link pb.BattleResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BattleResult
         * @static
         * @param {pb.IBattleResult} message BattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BattleResult} BattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BattleResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.WinUid = reader.uint64();
                    break;
                case 2:
                    if (!(message.ChangeCards && message.ChangeCards.length))
                        message.ChangeCards = [];
                    message.ChangeCards.push($root.pb.ChangeCardInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.ChangeRes && message.ChangeRes.length))
                        message.ChangeRes = [];
                    message.ChangeRes.push($root.pb.ChangeResInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.TreasureID = reader.string();
                    break;
                case 5:
                    if (!(message.UpPvpLevelRewardCards && message.UpPvpLevelRewardCards.length))
                        message.UpPvpLevelRewardCards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.UpPvpLevelRewardCards.push(reader.uint32());
                    } else
                        message.UpPvpLevelRewardCards.push(reader.uint32());
                    break;
                case 6:
                    message.CanShare = reader.bool();
                    break;
                case 7:
                    message.NoTreasureReason = reader.int32();
                    break;
                case 8:
                    message.UpRareTreasureModelID = reader.string();
                    break;
                case 9:
                    message.NoSubStarReason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BattleResult} BattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleResult message.
         * @function verify
         * @memberof pb.BattleResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.WinUid != null && message.hasOwnProperty("WinUid"))
                if (!$util.isInteger(message.WinUid) && !(message.WinUid && $util.isInteger(message.WinUid.low) && $util.isInteger(message.WinUid.high)))
                    return "WinUid: integer|Long expected";
            if (message.ChangeCards != null && message.hasOwnProperty("ChangeCards")) {
                if (!Array.isArray(message.ChangeCards))
                    return "ChangeCards: array expected";
                for (var i = 0; i < message.ChangeCards.length; ++i) {
                    var error = $root.pb.ChangeCardInfo.verify(message.ChangeCards[i]);
                    if (error)
                        return "ChangeCards." + error;
                }
            }
            if (message.ChangeRes != null && message.hasOwnProperty("ChangeRes")) {
                if (!Array.isArray(message.ChangeRes))
                    return "ChangeRes: array expected";
                for (var i = 0; i < message.ChangeRes.length; ++i) {
                    var error = $root.pb.ChangeResInfo.verify(message.ChangeRes[i]);
                    if (error)
                        return "ChangeRes." + error;
                }
            }
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isString(message.TreasureID))
                    return "TreasureID: string expected";
            if (message.UpPvpLevelRewardCards != null && message.hasOwnProperty("UpPvpLevelRewardCards")) {
                if (!Array.isArray(message.UpPvpLevelRewardCards))
                    return "UpPvpLevelRewardCards: array expected";
                for (var i = 0; i < message.UpPvpLevelRewardCards.length; ++i)
                    if (!$util.isInteger(message.UpPvpLevelRewardCards[i]))
                        return "UpPvpLevelRewardCards: integer[] expected";
            }
            if (message.CanShare != null && message.hasOwnProperty("CanShare"))
                if (typeof message.CanShare !== "boolean")
                    return "CanShare: boolean expected";
            if (message.NoTreasureReason != null && message.hasOwnProperty("NoTreasureReason"))
                switch (message.NoTreasureReason) {
                default:
                    return "NoTreasureReason: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.UpRareTreasureModelID != null && message.hasOwnProperty("UpRareTreasureModelID"))
                if (!$util.isString(message.UpRareTreasureModelID))
                    return "UpRareTreasureModelID: string expected";
            if (message.NoSubStarReason != null && message.hasOwnProperty("NoSubStarReason"))
                switch (message.NoSubStarReason) {
                default:
                    return "NoSubStarReason: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * NoSubStarReasonEnum enum.
         * @name pb.BattleResult.NoSubStarReasonEnum
         * @enum {string}
         * @property {number} Normal=0 Normal value
         * @property {number} NoSubStarPriv=1 NoSubStarPriv value
         */
        BattleResult.NoSubStarReasonEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Normal"] = 0;
            values[valuesById[1] = "NoSubStarPriv"] = 1;
            return values;
        })();

        return BattleResult;
    })();

    pb.LoadFightReq = (function() {

        /**
         * Properties of a LoadFightReq.
         * @memberof pb
         * @interface ILoadFightReq
         * @property {number|Long|null} [DeskID] LoadFightReq DeskID
         */

        /**
         * Constructs a new LoadFightReq.
         * @memberof pb
         * @classdesc Represents a LoadFightReq.
         * @implements ILoadFightReq
         * @constructor
         * @param {pb.ILoadFightReq=} [properties] Properties to set
         */
        function LoadFightReq(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoadFightReq DeskID.
         * @member {number|Long} DeskID
         * @memberof pb.LoadFightReq
         * @instance
         */
        LoadFightReq.prototype.DeskID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new LoadFightReq instance using the specified properties.
         * @function create
         * @memberof pb.LoadFightReq
         * @static
         * @param {pb.ILoadFightReq=} [properties] Properties to set
         * @returns {pb.LoadFightReq} LoadFightReq instance
         */
        LoadFightReq.create = function create(properties) {
            return new LoadFightReq(properties);
        };

        /**
         * Encodes the specified LoadFightReq message. Does not implicitly {@link pb.LoadFightReq.verify|verify} messages.
         * @function encode
         * @memberof pb.LoadFightReq
         * @static
         * @param {pb.ILoadFightReq} message LoadFightReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadFightReq.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.DeskID != null && message.hasOwnProperty("DeskID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.DeskID);
            return writer;
        };

        /**
         * Encodes the specified LoadFightReq message, length delimited. Does not implicitly {@link pb.LoadFightReq.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LoadFightReq
         * @static
         * @param {pb.ILoadFightReq} message LoadFightReq message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadFightReq.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoadFightReq message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LoadFightReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LoadFightReq} LoadFightReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadFightReq.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadFightReq();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.DeskID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoadFightReq message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LoadFightReq
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LoadFightReq} LoadFightReq
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadFightReq.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoadFightReq message.
         * @function verify
         * @memberof pb.LoadFightReq
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoadFightReq.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.DeskID != null && message.hasOwnProperty("DeskID"))
                if (!$util.isInteger(message.DeskID) && !(message.DeskID && $util.isInteger(message.DeskID.low) && $util.isInteger(message.DeskID.high)))
                    return "DeskID: integer|Long expected";
            return null;
        };

        return LoadFightReq;
    })();

    pb.RestoredFightDesk = (function() {

        /**
         * Properties of a RestoredFightDesk.
         * @memberof pb
         * @interface IRestoredFightDesk
         * @property {pb.IFightDesk|null} [Desk] RestoredFightDesk Desk
         * @property {number|Long|null} [CurBoutUid] RestoredFightDesk CurBoutUid
         * @property {number|null} [CampaignType] RestoredFightDesk CampaignType
         * @property {number|null} [CampaignLevel] RestoredFightDesk CampaignLevel
         * @property {number|null} [LevelID] RestoredFightDesk LevelID
         * @property {number|null} [FieldCnt] RestoredFightDesk FieldCnt
         * @property {number|null} [CurBout] RestoredFightDesk CurBout
         */

        /**
         * Constructs a new RestoredFightDesk.
         * @memberof pb
         * @classdesc Represents a RestoredFightDesk.
         * @implements IRestoredFightDesk
         * @constructor
         * @param {pb.IRestoredFightDesk=} [properties] Properties to set
         */
        function RestoredFightDesk(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RestoredFightDesk Desk.
         * @member {pb.IFightDesk|null|undefined} Desk
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.Desk = null;

        /**
         * RestoredFightDesk CurBoutUid.
         * @member {number|Long} CurBoutUid
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.CurBoutUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RestoredFightDesk CampaignType.
         * @member {number} CampaignType
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.CampaignType = 0;

        /**
         * RestoredFightDesk CampaignLevel.
         * @member {number} CampaignLevel
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.CampaignLevel = 0;

        /**
         * RestoredFightDesk LevelID.
         * @member {number} LevelID
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.LevelID = 0;

        /**
         * RestoredFightDesk FieldCnt.
         * @member {number} FieldCnt
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.FieldCnt = 0;

        /**
         * RestoredFightDesk CurBout.
         * @member {number} CurBout
         * @memberof pb.RestoredFightDesk
         * @instance
         */
        RestoredFightDesk.prototype.CurBout = 0;

        /**
         * Creates a new RestoredFightDesk instance using the specified properties.
         * @function create
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {pb.IRestoredFightDesk=} [properties] Properties to set
         * @returns {pb.RestoredFightDesk} RestoredFightDesk instance
         */
        RestoredFightDesk.create = function create(properties) {
            return new RestoredFightDesk(properties);
        };

        /**
         * Encodes the specified RestoredFightDesk message. Does not implicitly {@link pb.RestoredFightDesk.verify|verify} messages.
         * @function encode
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {pb.IRestoredFightDesk} message RestoredFightDesk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoredFightDesk.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Desk != null && message.hasOwnProperty("Desk"))
                $root.pb.FightDesk.encode(message.Desk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.CurBoutUid != null && message.hasOwnProperty("CurBoutUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.CurBoutUid);
            if (message.CampaignType != null && message.hasOwnProperty("CampaignType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CampaignType);
            if (message.CampaignLevel != null && message.hasOwnProperty("CampaignLevel"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CampaignLevel);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.LevelID);
            if (message.FieldCnt != null && message.hasOwnProperty("FieldCnt"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.FieldCnt);
            if (message.CurBout != null && message.hasOwnProperty("CurBout"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.CurBout);
            return writer;
        };

        /**
         * Encodes the specified RestoredFightDesk message, length delimited. Does not implicitly {@link pb.RestoredFightDesk.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {pb.IRestoredFightDesk} message RestoredFightDesk message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RestoredFightDesk.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RestoredFightDesk message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RestoredFightDesk} RestoredFightDesk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoredFightDesk.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RestoredFightDesk();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Desk = $root.pb.FightDesk.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.CurBoutUid = reader.uint64();
                    break;
                case 3:
                    message.CampaignType = reader.int32();
                    break;
                case 4:
                    message.CampaignLevel = reader.int32();
                    break;
                case 5:
                    message.LevelID = reader.int32();
                    break;
                case 6:
                    message.FieldCnt = reader.int32();
                    break;
                case 7:
                    message.CurBout = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RestoredFightDesk message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RestoredFightDesk} RestoredFightDesk
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RestoredFightDesk.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RestoredFightDesk message.
         * @function verify
         * @memberof pb.RestoredFightDesk
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RestoredFightDesk.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Desk != null && message.hasOwnProperty("Desk")) {
                var error = $root.pb.FightDesk.verify(message.Desk);
                if (error)
                    return "Desk." + error;
            }
            if (message.CurBoutUid != null && message.hasOwnProperty("CurBoutUid"))
                if (!$util.isInteger(message.CurBoutUid) && !(message.CurBoutUid && $util.isInteger(message.CurBoutUid.low) && $util.isInteger(message.CurBoutUid.high)))
                    return "CurBoutUid: integer|Long expected";
            if (message.CampaignType != null && message.hasOwnProperty("CampaignType"))
                if (!$util.isInteger(message.CampaignType))
                    return "CampaignType: integer expected";
            if (message.CampaignLevel != null && message.hasOwnProperty("CampaignLevel"))
                if (!$util.isInteger(message.CampaignLevel))
                    return "CampaignLevel: integer expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            if (message.FieldCnt != null && message.hasOwnProperty("FieldCnt"))
                if (!$util.isInteger(message.FieldCnt))
                    return "FieldCnt: integer expected";
            if (message.CurBout != null && message.hasOwnProperty("CurBout"))
                if (!$util.isInteger(message.CurBout))
                    return "CurBout: integer expected";
            return null;
        };

        return RestoredFightDesk;
    })();

    pb.VideoBattleData = (function() {

        /**
         * Properties of a VideoBattleData.
         * @memberof pb
         * @interface IVideoBattleData
         * @property {Array.<pb.IVideoAction>|null} [Actions] VideoBattleData Actions
         * @property {number|Long|null} [ShareUid] VideoBattleData ShareUid
         */

        /**
         * Constructs a new VideoBattleData.
         * @memberof pb
         * @classdesc Represents a VideoBattleData.
         * @implements IVideoBattleData
         * @constructor
         * @param {pb.IVideoBattleData=} [properties] Properties to set
         */
        function VideoBattleData(properties) {
            this.Actions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoBattleData Actions.
         * @member {Array.<pb.IVideoAction>} Actions
         * @memberof pb.VideoBattleData
         * @instance
         */
        VideoBattleData.prototype.Actions = $util.emptyArray;

        /**
         * VideoBattleData ShareUid.
         * @member {number|Long} ShareUid
         * @memberof pb.VideoBattleData
         * @instance
         */
        VideoBattleData.prototype.ShareUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new VideoBattleData instance using the specified properties.
         * @function create
         * @memberof pb.VideoBattleData
         * @static
         * @param {pb.IVideoBattleData=} [properties] Properties to set
         * @returns {pb.VideoBattleData} VideoBattleData instance
         */
        VideoBattleData.create = function create(properties) {
            return new VideoBattleData(properties);
        };

        /**
         * Encodes the specified VideoBattleData message. Does not implicitly {@link pb.VideoBattleData.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoBattleData
         * @static
         * @param {pb.IVideoBattleData} message VideoBattleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoBattleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Actions != null && message.Actions.length)
                for (var i = 0; i < message.Actions.length; ++i)
                    $root.pb.VideoAction.encode(message.Actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ShareUid);
            return writer;
        };

        /**
         * Encodes the specified VideoBattleData message, length delimited. Does not implicitly {@link pb.VideoBattleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoBattleData
         * @static
         * @param {pb.IVideoBattleData} message VideoBattleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoBattleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoBattleData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoBattleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoBattleData} VideoBattleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoBattleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoBattleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Actions && message.Actions.length))
                        message.Actions = [];
                    message.Actions.push($root.pb.VideoAction.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.ShareUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoBattleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoBattleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoBattleData} VideoBattleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoBattleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoBattleData message.
         * @function verify
         * @memberof pb.VideoBattleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoBattleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Actions != null && message.hasOwnProperty("Actions")) {
                if (!Array.isArray(message.Actions))
                    return "Actions: array expected";
                for (var i = 0; i < message.Actions.length; ++i) {
                    var error = $root.pb.VideoAction.verify(message.Actions[i]);
                    if (error)
                        return "Actions." + error;
                }
            }
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                if (!$util.isInteger(message.ShareUid) && !(message.ShareUid && $util.isInteger(message.ShareUid.low) && $util.isInteger(message.ShareUid.high)))
                    return "ShareUid: integer|Long expected";
            return null;
        };

        return VideoBattleData;
    })();

    pb.VideoAction = (function() {

        /**
         * Properties of a VideoAction.
         * @memberof pb
         * @interface IVideoAction
         * @property {pb.VideoAction.ActionID|null} [ID] VideoAction ID
         * @property {Uint8Array|null} [Data] VideoAction Data
         */

        /**
         * Constructs a new VideoAction.
         * @memberof pb
         * @classdesc Represents a VideoAction.
         * @implements IVideoAction
         * @constructor
         * @param {pb.IVideoAction=} [properties] Properties to set
         */
        function VideoAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoAction ID.
         * @member {pb.VideoAction.ActionID} ID
         * @memberof pb.VideoAction
         * @instance
         */
        VideoAction.prototype.ID = 0;

        /**
         * VideoAction Data.
         * @member {Uint8Array} Data
         * @memberof pb.VideoAction
         * @instance
         */
        VideoAction.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new VideoAction instance using the specified properties.
         * @function create
         * @memberof pb.VideoAction
         * @static
         * @param {pb.IVideoAction=} [properties] Properties to set
         * @returns {pb.VideoAction} VideoAction instance
         */
        VideoAction.create = function create(properties) {
            return new VideoAction(properties);
        };

        /**
         * Encodes the specified VideoAction message. Does not implicitly {@link pb.VideoAction.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoAction
         * @static
         * @param {pb.IVideoAction} message VideoAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified VideoAction message, length delimited. Does not implicitly {@link pb.VideoAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoAction
         * @static
         * @param {pb.IVideoAction} message VideoAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoAction message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoAction} VideoAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoAction} VideoAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoAction message.
         * @function verify
         * @memberof pb.VideoAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                switch (message.ID) {
                default:
                    return "ID: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        /**
         * ActionID enum.
         * @name pb.VideoAction.ActionID
         * @enum {string}
         * @property {number} Unknow=0 Unknow value
         * @property {number} Begin=1 Begin value
         * @property {number} BoutBegin=2 BoutBegin value
         * @property {number} BoutAction=3 BoutAction value
         * @property {number} End=4 End value
         */
        VideoAction.ActionID = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknow"] = 0;
            values[valuesById[1] = "Begin"] = 1;
            values[valuesById[2] = "BoutBegin"] = 2;
            values[valuesById[3] = "BoutAction"] = 3;
            values[valuesById[4] = "End"] = 4;
            return values;
        })();

        return VideoAction;
    })();

    pb.InGridCard = (function() {

        /**
         * Properties of an InGridCard.
         * @memberof pb
         * @interface IInGridCard
         * @property {number|null} [GridID] InGridCard GridID
         * @property {number|null} [GCardID] InGridCard GCardID
         * @property {string|null} [Skin] InGridCard Skin
         * @property {string|null} [Equip] InGridCard Equip
         */

        /**
         * Constructs a new InGridCard.
         * @memberof pb
         * @classdesc Represents an InGridCard.
         * @implements IInGridCard
         * @constructor
         * @param {pb.IInGridCard=} [properties] Properties to set
         */
        function InGridCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InGridCard GridID.
         * @member {number} GridID
         * @memberof pb.InGridCard
         * @instance
         */
        InGridCard.prototype.GridID = 0;

        /**
         * InGridCard GCardID.
         * @member {number} GCardID
         * @memberof pb.InGridCard
         * @instance
         */
        InGridCard.prototype.GCardID = 0;

        /**
         * InGridCard Skin.
         * @member {string} Skin
         * @memberof pb.InGridCard
         * @instance
         */
        InGridCard.prototype.Skin = "";

        /**
         * InGridCard Equip.
         * @member {string} Equip
         * @memberof pb.InGridCard
         * @instance
         */
        InGridCard.prototype.Equip = "";

        /**
         * Creates a new InGridCard instance using the specified properties.
         * @function create
         * @memberof pb.InGridCard
         * @static
         * @param {pb.IInGridCard=} [properties] Properties to set
         * @returns {pb.InGridCard} InGridCard instance
         */
        InGridCard.create = function create(properties) {
            return new InGridCard(properties);
        };

        /**
         * Encodes the specified InGridCard message. Does not implicitly {@link pb.InGridCard.verify|verify} messages.
         * @function encode
         * @memberof pb.InGridCard
         * @static
         * @param {pb.IInGridCard} message InGridCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InGridCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GridID != null && message.hasOwnProperty("GridID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.GridID);
            if (message.GCardID != null && message.hasOwnProperty("GCardID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.GCardID);
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Skin);
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Equip);
            return writer;
        };

        /**
         * Encodes the specified InGridCard message, length delimited. Does not implicitly {@link pb.InGridCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.InGridCard
         * @static
         * @param {pb.IInGridCard} message InGridCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InGridCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InGridCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.InGridCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.InGridCard} InGridCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGridCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.InGridCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GridID = reader.int32();
                    break;
                case 2:
                    message.GCardID = reader.uint32();
                    break;
                case 3:
                    message.Skin = reader.string();
                    break;
                case 4:
                    message.Equip = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InGridCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.InGridCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.InGridCard} InGridCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InGridCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InGridCard message.
         * @function verify
         * @memberof pb.InGridCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InGridCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GridID != null && message.hasOwnProperty("GridID"))
                if (!$util.isInteger(message.GridID))
                    return "GridID: integer expected";
            if (message.GCardID != null && message.hasOwnProperty("GCardID"))
                if (!$util.isInteger(message.GCardID))
                    return "GCardID: integer expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                if (!$util.isString(message.Equip))
                    return "Equip: string expected";
            return null;
        };

        return InGridCard;
    })();

    pb.FighterData = (function() {

        /**
         * Properties of a FighterData.
         * @memberof pb
         * @interface IFighterData
         * @property {number|Long|null} [Uid] FighterData Uid
         * @property {number|Long|null} [ClientID] FighterData ClientID
         * @property {number|null} [GateID] FighterData GateID
         * @property {Array.<pb.ISkinGCard>|null} [HandCards] FighterData HandCards
         * @property {Array.<pb.ISkinGCard>|null} [DrawCardPool] FighterData DrawCardPool
         * @property {string|null} [Name] FighterData Name
         * @property {number|null} [Camp] FighterData Camp
         * @property {number|null} [PvpScore] FighterData PvpScore
         * @property {boolean|null} [IsRobot] FighterData IsRobot
         * @property {Array.<pb.IInGridCard>|null} [GridCards] FighterData GridCards
         * @property {Array.<number>|null} [CasterSkills] FighterData CasterSkills
         * @property {number|null} [Mmr] FighterData Mmr
         * @property {number|Long|null} [RobotID] FighterData RobotID
         * @property {string|null} [HeadImgUrl] FighterData HeadImgUrl
         * @property {string|null} [HeadFrame] FighterData HeadFrame
         * @property {number|null} [NameText] FighterData NameText
         */

        /**
         * Constructs a new FighterData.
         * @memberof pb
         * @classdesc Represents a FighterData.
         * @implements IFighterData
         * @constructor
         * @param {pb.IFighterData=} [properties] Properties to set
         */
        function FighterData(properties) {
            this.HandCards = [];
            this.DrawCardPool = [];
            this.GridCards = [];
            this.CasterSkills = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FighterData Uid.
         * @member {number|Long} Uid
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FighterData ClientID.
         * @member {number|Long} ClientID
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.ClientID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FighterData GateID.
         * @member {number} GateID
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.GateID = 0;

        /**
         * FighterData HandCards.
         * @member {Array.<pb.ISkinGCard>} HandCards
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.HandCards = $util.emptyArray;

        /**
         * FighterData DrawCardPool.
         * @member {Array.<pb.ISkinGCard>} DrawCardPool
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.DrawCardPool = $util.emptyArray;

        /**
         * FighterData Name.
         * @member {string} Name
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.Name = "";

        /**
         * FighterData Camp.
         * @member {number} Camp
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.Camp = 0;

        /**
         * FighterData PvpScore.
         * @member {number} PvpScore
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.PvpScore = 0;

        /**
         * FighterData IsRobot.
         * @member {boolean} IsRobot
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.IsRobot = false;

        /**
         * FighterData GridCards.
         * @member {Array.<pb.IInGridCard>} GridCards
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.GridCards = $util.emptyArray;

        /**
         * FighterData CasterSkills.
         * @member {Array.<number>} CasterSkills
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.CasterSkills = $util.emptyArray;

        /**
         * FighterData Mmr.
         * @member {number} Mmr
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.Mmr = 0;

        /**
         * FighterData RobotID.
         * @member {number|Long} RobotID
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.RobotID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FighterData HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.HeadImgUrl = "";

        /**
         * FighterData HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.HeadFrame = "";

        /**
         * FighterData NameText.
         * @member {number} NameText
         * @memberof pb.FighterData
         * @instance
         */
        FighterData.prototype.NameText = 0;

        /**
         * Creates a new FighterData instance using the specified properties.
         * @function create
         * @memberof pb.FighterData
         * @static
         * @param {pb.IFighterData=} [properties] Properties to set
         * @returns {pb.FighterData} FighterData instance
         */
        FighterData.create = function create(properties) {
            return new FighterData(properties);
        };

        /**
         * Encodes the specified FighterData message. Does not implicitly {@link pb.FighterData.verify|verify} messages.
         * @function encode
         * @memberof pb.FighterData
         * @static
         * @param {pb.IFighterData} message FighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FighterData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.ClientID != null && message.hasOwnProperty("ClientID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ClientID);
            if (message.GateID != null && message.hasOwnProperty("GateID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.GateID);
            if (message.HandCards != null && message.HandCards.length)
                for (var i = 0; i < message.HandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.HandCards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.DrawCardPool != null && message.DrawCardPool.length)
                for (var i = 0; i < message.DrawCardPool.length; ++i)
                    $root.pb.SkinGCard.encode(message.DrawCardPool[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Name);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Camp);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.PvpScore);
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.IsRobot);
            if (message.GridCards != null && message.GridCards.length)
                for (var i = 0; i < message.GridCards.length; ++i)
                    $root.pb.InGridCard.encode(message.GridCards[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.CasterSkills != null && message.CasterSkills.length) {
                writer.uint32(/* id 11, wireType 2 =*/90).fork();
                for (var i = 0; i < message.CasterSkills.length; ++i)
                    writer.int32(message.CasterSkills[i]);
                writer.ldelim();
            }
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.Mmr);
            if (message.RobotID != null && message.hasOwnProperty("RobotID"))
                writer.uint32(/* id 13, wireType 0 =*/104).uint64(message.RobotID);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.HeadImgUrl);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.HeadFrame);
            if (message.NameText != null && message.hasOwnProperty("NameText"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.NameText);
            return writer;
        };

        /**
         * Encodes the specified FighterData message, length delimited. Does not implicitly {@link pb.FighterData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FighterData
         * @static
         * @param {pb.IFighterData} message FighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FighterData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FighterData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FighterData} FighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FighterData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FighterData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.ClientID = reader.uint64();
                    break;
                case 3:
                    message.GateID = reader.uint32();
                    break;
                case 4:
                    if (!(message.HandCards && message.HandCards.length))
                        message.HandCards = [];
                    message.HandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.DrawCardPool && message.DrawCardPool.length))
                        message.DrawCardPool = [];
                    message.DrawCardPool.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.Name = reader.string();
                    break;
                case 7:
                    message.Camp = reader.int32();
                    break;
                case 8:
                    message.PvpScore = reader.int32();
                    break;
                case 9:
                    message.IsRobot = reader.bool();
                    break;
                case 10:
                    if (!(message.GridCards && message.GridCards.length))
                        message.GridCards = [];
                    message.GridCards.push($root.pb.InGridCard.decode(reader, reader.uint32()));
                    break;
                case 11:
                    if (!(message.CasterSkills && message.CasterSkills.length))
                        message.CasterSkills = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CasterSkills.push(reader.int32());
                    } else
                        message.CasterSkills.push(reader.int32());
                    break;
                case 12:
                    message.Mmr = reader.int32();
                    break;
                case 13:
                    message.RobotID = reader.uint64();
                    break;
                case 14:
                    message.HeadImgUrl = reader.string();
                    break;
                case 15:
                    message.HeadFrame = reader.string();
                    break;
                case 16:
                    message.NameText = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FighterData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FighterData} FighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FighterData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FighterData message.
         * @function verify
         * @memberof pb.FighterData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FighterData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.ClientID != null && message.hasOwnProperty("ClientID"))
                if (!$util.isInteger(message.ClientID) && !(message.ClientID && $util.isInteger(message.ClientID.low) && $util.isInteger(message.ClientID.high)))
                    return "ClientID: integer|Long expected";
            if (message.GateID != null && message.hasOwnProperty("GateID"))
                if (!$util.isInteger(message.GateID))
                    return "GateID: integer expected";
            if (message.HandCards != null && message.hasOwnProperty("HandCards")) {
                if (!Array.isArray(message.HandCards))
                    return "HandCards: array expected";
                for (var i = 0; i < message.HandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.HandCards[i]);
                    if (error)
                        return "HandCards." + error;
                }
            }
            if (message.DrawCardPool != null && message.hasOwnProperty("DrawCardPool")) {
                if (!Array.isArray(message.DrawCardPool))
                    return "DrawCardPool: array expected";
                for (var i = 0; i < message.DrawCardPool.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.DrawCardPool[i]);
                    if (error)
                        return "DrawCardPool." + error;
                }
            }
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                if (typeof message.IsRobot !== "boolean")
                    return "IsRobot: boolean expected";
            if (message.GridCards != null && message.hasOwnProperty("GridCards")) {
                if (!Array.isArray(message.GridCards))
                    return "GridCards: array expected";
                for (var i = 0; i < message.GridCards.length; ++i) {
                    var error = $root.pb.InGridCard.verify(message.GridCards[i]);
                    if (error)
                        return "GridCards." + error;
                }
            }
            if (message.CasterSkills != null && message.hasOwnProperty("CasterSkills")) {
                if (!Array.isArray(message.CasterSkills))
                    return "CasterSkills: array expected";
                for (var i = 0; i < message.CasterSkills.length; ++i)
                    if (!$util.isInteger(message.CasterSkills[i]))
                        return "CasterSkills: integer[] expected";
            }
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                if (!$util.isInteger(message.Mmr))
                    return "Mmr: integer expected";
            if (message.RobotID != null && message.hasOwnProperty("RobotID"))
                if (!$util.isInteger(message.RobotID) && !(message.RobotID && $util.isInteger(message.RobotID.low) && $util.isInteger(message.RobotID.high)))
                    return "RobotID: integer|Long expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.NameText != null && message.hasOwnProperty("NameText"))
                if (!$util.isInteger(message.NameText))
                    return "NameText: integer expected";
            return null;
        };

        return FighterData;
    })();

    pb.BeginBattleArg = (function() {

        /**
         * Properties of a BeginBattleArg.
         * @memberof pb
         * @interface IBeginBattleArg
         * @property {number|null} [BattleType] BeginBattleArg BattleType
         * @property {pb.IFighterData|null} [Fighter1] BeginBattleArg Fighter1
         * @property {pb.IFighterData|null} [Fighter2] BeginBattleArg Fighter2
         * @property {boolean|null} [NeedFortifications] BeginBattleArg NeedFortifications
         * @property {number|null} [BonusType] BeginBattleArg BonusType
         * @property {boolean|null} [NeedVideo] BeginBattleArg NeedVideo
         * @property {number|null} [UpperType] BeginBattleArg UpperType
         * @property {boolean|null} [IsFirstPvp] BeginBattleArg IsFirstPvp
         * @property {number|null} [SeasonPvpSession] BeginBattleArg SeasonPvpSession
         */

        /**
         * Constructs a new BeginBattleArg.
         * @memberof pb
         * @classdesc Represents a BeginBattleArg.
         * @implements IBeginBattleArg
         * @constructor
         * @param {pb.IBeginBattleArg=} [properties] Properties to set
         */
        function BeginBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginBattleArg BattleType.
         * @member {number} BattleType
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.BattleType = 0;

        /**
         * BeginBattleArg Fighter1.
         * @member {pb.IFighterData|null|undefined} Fighter1
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.Fighter1 = null;

        /**
         * BeginBattleArg Fighter2.
         * @member {pb.IFighterData|null|undefined} Fighter2
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.Fighter2 = null;

        /**
         * BeginBattleArg NeedFortifications.
         * @member {boolean} NeedFortifications
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.NeedFortifications = false;

        /**
         * BeginBattleArg BonusType.
         * @member {number} BonusType
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.BonusType = 0;

        /**
         * BeginBattleArg NeedVideo.
         * @member {boolean} NeedVideo
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.NeedVideo = false;

        /**
         * BeginBattleArg UpperType.
         * @member {number} UpperType
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.UpperType = 0;

        /**
         * BeginBattleArg IsFirstPvp.
         * @member {boolean} IsFirstPvp
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.IsFirstPvp = false;

        /**
         * BeginBattleArg SeasonPvpSession.
         * @member {number} SeasonPvpSession
         * @memberof pb.BeginBattleArg
         * @instance
         */
        BeginBattleArg.prototype.SeasonPvpSession = 0;

        /**
         * Creates a new BeginBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.BeginBattleArg
         * @static
         * @param {pb.IBeginBattleArg=} [properties] Properties to set
         * @returns {pb.BeginBattleArg} BeginBattleArg instance
         */
        BeginBattleArg.create = function create(properties) {
            return new BeginBattleArg(properties);
        };

        /**
         * Encodes the specified BeginBattleArg message. Does not implicitly {@link pb.BeginBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeginBattleArg
         * @static
         * @param {pb.IBeginBattleArg} message BeginBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.BattleType);
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1"))
                $root.pb.FighterData.encode(message.Fighter1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2"))
                $root.pb.FighterData.encode(message.Fighter2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.NeedFortifications != null && message.hasOwnProperty("NeedFortifications"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.NeedFortifications);
            if (message.BonusType != null && message.hasOwnProperty("BonusType"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.BonusType);
            if (message.NeedVideo != null && message.hasOwnProperty("NeedVideo"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.NeedVideo);
            if (message.UpperType != null && message.hasOwnProperty("UpperType"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.UpperType);
            if (message.IsFirstPvp != null && message.hasOwnProperty("IsFirstPvp"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsFirstPvp);
            if (message.SeasonPvpSession != null && message.hasOwnProperty("SeasonPvpSession"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.SeasonPvpSession);
            return writer;
        };

        /**
         * Encodes the specified BeginBattleArg message, length delimited. Does not implicitly {@link pb.BeginBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeginBattleArg
         * @static
         * @param {pb.IBeginBattleArg} message BeginBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeginBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeginBattleArg} BeginBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeginBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BattleType = reader.int32();
                    break;
                case 2:
                    message.Fighter1 = $root.pb.FighterData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Fighter2 = $root.pb.FighterData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.NeedFortifications = reader.bool();
                    break;
                case 5:
                    message.BonusType = reader.int32();
                    break;
                case 6:
                    message.NeedVideo = reader.bool();
                    break;
                case 7:
                    message.UpperType = reader.int32();
                    break;
                case 8:
                    message.IsFirstPvp = reader.bool();
                    break;
                case 9:
                    message.SeasonPvpSession = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeginBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeginBattleArg} BeginBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginBattleArg message.
         * @function verify
         * @memberof pb.BeginBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                if (!$util.isInteger(message.BattleType))
                    return "BattleType: integer expected";
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1")) {
                var error = $root.pb.FighterData.verify(message.Fighter1);
                if (error)
                    return "Fighter1." + error;
            }
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2")) {
                var error = $root.pb.FighterData.verify(message.Fighter2);
                if (error)
                    return "Fighter2." + error;
            }
            if (message.NeedFortifications != null && message.hasOwnProperty("NeedFortifications"))
                if (typeof message.NeedFortifications !== "boolean")
                    return "NeedFortifications: boolean expected";
            if (message.BonusType != null && message.hasOwnProperty("BonusType"))
                if (!$util.isInteger(message.BonusType))
                    return "BonusType: integer expected";
            if (message.NeedVideo != null && message.hasOwnProperty("NeedVideo"))
                if (typeof message.NeedVideo !== "boolean")
                    return "NeedVideo: boolean expected";
            if (message.UpperType != null && message.hasOwnProperty("UpperType"))
                if (!$util.isInteger(message.UpperType))
                    return "UpperType: integer expected";
            if (message.IsFirstPvp != null && message.hasOwnProperty("IsFirstPvp"))
                if (typeof message.IsFirstPvp !== "boolean")
                    return "IsFirstPvp: boolean expected";
            if (message.SeasonPvpSession != null && message.hasOwnProperty("SeasonPvpSession"))
                if (!$util.isInteger(message.SeasonPvpSession))
                    return "SeasonPvpSession: integer expected";
            return null;
        };

        return BeginBattleArg;
    })();

    pb.BeginLevelBattleArg = (function() {

        /**
         * Properties of a BeginLevelBattleArg.
         * @memberof pb
         * @interface IBeginLevelBattleArg
         * @property {pb.IFighterData|null} [Fighter1] BeginLevelBattleArg Fighter1
         * @property {number|null} [LevelID] BeginLevelBattleArg LevelID
         */

        /**
         * Constructs a new BeginLevelBattleArg.
         * @memberof pb
         * @classdesc Represents a BeginLevelBattleArg.
         * @implements IBeginLevelBattleArg
         * @constructor
         * @param {pb.IBeginLevelBattleArg=} [properties] Properties to set
         */
        function BeginLevelBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginLevelBattleArg Fighter1.
         * @member {pb.IFighterData|null|undefined} Fighter1
         * @memberof pb.BeginLevelBattleArg
         * @instance
         */
        BeginLevelBattleArg.prototype.Fighter1 = null;

        /**
         * BeginLevelBattleArg LevelID.
         * @member {number} LevelID
         * @memberof pb.BeginLevelBattleArg
         * @instance
         */
        BeginLevelBattleArg.prototype.LevelID = 0;

        /**
         * Creates a new BeginLevelBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {pb.IBeginLevelBattleArg=} [properties] Properties to set
         * @returns {pb.BeginLevelBattleArg} BeginLevelBattleArg instance
         */
        BeginLevelBattleArg.create = function create(properties) {
            return new BeginLevelBattleArg(properties);
        };

        /**
         * Encodes the specified BeginLevelBattleArg message. Does not implicitly {@link pb.BeginLevelBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {pb.IBeginLevelBattleArg} message BeginLevelBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLevelBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1"))
                $root.pb.FighterData.encode(message.Fighter1, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified BeginLevelBattleArg message, length delimited. Does not implicitly {@link pb.BeginLevelBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {pb.IBeginLevelBattleArg} message BeginLevelBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLevelBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginLevelBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeginLevelBattleArg} BeginLevelBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLevelBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeginLevelBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Fighter1 = $root.pb.FighterData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginLevelBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeginLevelBattleArg} BeginLevelBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLevelBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginLevelBattleArg message.
         * @function verify
         * @memberof pb.BeginLevelBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginLevelBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1")) {
                var error = $root.pb.FighterData.verify(message.Fighter1);
                if (error)
                    return "Fighter1." + error;
            }
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return BeginLevelBattleArg;
    })();

    pb.LoadBattleArg = (function() {

        /**
         * Properties of a LoadBattleArg.
         * @memberof pb
         * @interface ILoadBattleArg
         * @property {number|Long|null} [Uid] LoadBattleArg Uid
         * @property {number|Long|null} [ClientID] LoadBattleArg ClientID
         * @property {number|null} [GateID] LoadBattleArg GateID
         * @property {number|Long|null} [BattleID] LoadBattleArg BattleID
         */

        /**
         * Constructs a new LoadBattleArg.
         * @memberof pb
         * @classdesc Represents a LoadBattleArg.
         * @implements ILoadBattleArg
         * @constructor
         * @param {pb.ILoadBattleArg=} [properties] Properties to set
         */
        function LoadBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoadBattleArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.LoadBattleArg
         * @instance
         */
        LoadBattleArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoadBattleArg ClientID.
         * @member {number|Long} ClientID
         * @memberof pb.LoadBattleArg
         * @instance
         */
        LoadBattleArg.prototype.ClientID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoadBattleArg GateID.
         * @member {number} GateID
         * @memberof pb.LoadBattleArg
         * @instance
         */
        LoadBattleArg.prototype.GateID = 0;

        /**
         * LoadBattleArg BattleID.
         * @member {number|Long} BattleID
         * @memberof pb.LoadBattleArg
         * @instance
         */
        LoadBattleArg.prototype.BattleID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new LoadBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.LoadBattleArg
         * @static
         * @param {pb.ILoadBattleArg=} [properties] Properties to set
         * @returns {pb.LoadBattleArg} LoadBattleArg instance
         */
        LoadBattleArg.create = function create(properties) {
            return new LoadBattleArg(properties);
        };

        /**
         * Encodes the specified LoadBattleArg message. Does not implicitly {@link pb.LoadBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LoadBattleArg
         * @static
         * @param {pb.ILoadBattleArg} message LoadBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.ClientID != null && message.hasOwnProperty("ClientID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ClientID);
            if (message.GateID != null && message.hasOwnProperty("GateID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.GateID);
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.BattleID);
            return writer;
        };

        /**
         * Encodes the specified LoadBattleArg message, length delimited. Does not implicitly {@link pb.LoadBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LoadBattleArg
         * @static
         * @param {pb.ILoadBattleArg} message LoadBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoadBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LoadBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LoadBattleArg} LoadBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.ClientID = reader.uint64();
                    break;
                case 3:
                    message.GateID = reader.uint32();
                    break;
                case 4:
                    message.BattleID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoadBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LoadBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LoadBattleArg} LoadBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoadBattleArg message.
         * @function verify
         * @memberof pb.LoadBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoadBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.ClientID != null && message.hasOwnProperty("ClientID"))
                if (!$util.isInteger(message.ClientID) && !(message.ClientID && $util.isInteger(message.ClientID.low) && $util.isInteger(message.ClientID.high)))
                    return "ClientID: integer|Long expected";
            if (message.GateID != null && message.hasOwnProperty("GateID"))
                if (!$util.isInteger(message.GateID))
                    return "GateID: integer expected";
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                if (!$util.isInteger(message.BattleID) && !(message.BattleID && $util.isInteger(message.BattleID.low) && $util.isInteger(message.BattleID.high)))
                    return "BattleID: integer|Long expected";
            return null;
        };

        return LoadBattleArg;
    })();

    pb.C2SLoadFightArg = (function() {

        /**
         * Properties of a C2SLoadFightArg.
         * @memberof pb
         * @interface IC2SLoadFightArg
         * @property {boolean|null} [IsIgnorePve] C2SLoadFightArg IsIgnorePve
         */

        /**
         * Constructs a new C2SLoadFightArg.
         * @memberof pb
         * @classdesc Represents a C2SLoadFightArg.
         * @implements IC2SLoadFightArg
         * @constructor
         * @param {pb.IC2SLoadFightArg=} [properties] Properties to set
         */
        function C2SLoadFightArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * C2SLoadFightArg IsIgnorePve.
         * @member {boolean} IsIgnorePve
         * @memberof pb.C2SLoadFightArg
         * @instance
         */
        C2SLoadFightArg.prototype.IsIgnorePve = false;

        /**
         * Creates a new C2SLoadFightArg instance using the specified properties.
         * @function create
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {pb.IC2SLoadFightArg=} [properties] Properties to set
         * @returns {pb.C2SLoadFightArg} C2SLoadFightArg instance
         */
        C2SLoadFightArg.create = function create(properties) {
            return new C2SLoadFightArg(properties);
        };

        /**
         * Encodes the specified C2SLoadFightArg message. Does not implicitly {@link pb.C2SLoadFightArg.verify|verify} messages.
         * @function encode
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {pb.IC2SLoadFightArg} message C2SLoadFightArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2SLoadFightArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsIgnorePve != null && message.hasOwnProperty("IsIgnorePve"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsIgnorePve);
            return writer;
        };

        /**
         * Encodes the specified C2SLoadFightArg message, length delimited. Does not implicitly {@link pb.C2SLoadFightArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {pb.IC2SLoadFightArg} message C2SLoadFightArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        C2SLoadFightArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a C2SLoadFightArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.C2SLoadFightArg} C2SLoadFightArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2SLoadFightArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.C2SLoadFightArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsIgnorePve = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a C2SLoadFightArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.C2SLoadFightArg} C2SLoadFightArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        C2SLoadFightArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a C2SLoadFightArg message.
         * @function verify
         * @memberof pb.C2SLoadFightArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        C2SLoadFightArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsIgnorePve != null && message.hasOwnProperty("IsIgnorePve"))
                if (typeof message.IsIgnorePve !== "boolean")
                    return "IsIgnorePve: boolean expected";
            return null;
        };

        return C2SLoadFightArg;
    })();

    pb.ClientAction = (function() {

        /**
         * Properties of a ClientAction.
         * @memberof pb
         * @interface IClientAction
         * @property {pb.ClientAction.ActionID|null} [ID] ClientAction ID
         * @property {Uint8Array|null} [Data] ClientAction Data
         */

        /**
         * Constructs a new ClientAction.
         * @memberof pb
         * @classdesc Represents a ClientAction.
         * @implements IClientAction
         * @constructor
         * @param {pb.IClientAction=} [properties] Properties to set
         */
        function ClientAction(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientAction ID.
         * @member {pb.ClientAction.ActionID} ID
         * @memberof pb.ClientAction
         * @instance
         */
        ClientAction.prototype.ID = 0;

        /**
         * ClientAction Data.
         * @member {Uint8Array} Data
         * @memberof pb.ClientAction
         * @instance
         */
        ClientAction.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new ClientAction instance using the specified properties.
         * @function create
         * @memberof pb.ClientAction
         * @static
         * @param {pb.IClientAction=} [properties] Properties to set
         * @returns {pb.ClientAction} ClientAction instance
         */
        ClientAction.create = function create(properties) {
            return new ClientAction(properties);
        };

        /**
         * Encodes the specified ClientAction message. Does not implicitly {@link pb.ClientAction.verify|verify} messages.
         * @function encode
         * @memberof pb.ClientAction
         * @static
         * @param {pb.IClientAction} message ClientAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientAction.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified ClientAction message, length delimited. Does not implicitly {@link pb.ClientAction.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ClientAction
         * @static
         * @param {pb.IClientAction} message ClientAction message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientAction.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientAction message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ClientAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ClientAction} ClientAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientAction.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ClientAction();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientAction message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ClientAction
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ClientAction} ClientAction
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientAction.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientAction message.
         * @function verify
         * @memberof pb.ClientAction
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientAction.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                switch (message.ID) {
                default:
                    return "ID: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 6:
                case 7:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 1000:
                case 1001:
                case 1002:
                    break;
                }
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        /**
         * ActionID enum.
         * @name pb.ClientAction.ActionID
         * @enum {string}
         * @property {number} Unknow=0 Unknow value
         * @property {number} Attack=1 Attack value
         * @property {number} TurnOver=2 TurnOver value
         * @property {number} Skill=3 Skill value
         * @property {number} SkillStatusMovie=6 SkillStatusMovie value
         * @property {number} ModifyValue=7 ModifyValue value
         * @property {number} TextMovie=9 TextMovie value
         * @property {number} Movie=10 Movie value
         * @property {number} DrawCard=11 DrawCard value
         * @property {number} Bonus=12 Bonus value
         * @property {number} SwitchPos=13 SwitchPos value
         * @property {number} HandShow=14 HandShow value
         * @property {number} AddSkill=15 AddSkill value
         * @property {number} DelSkill=16 DelSkill value
         * @property {number} DisCard=17 DisCard value
         * @property {number} Destroy=18 Destroy value
         * @property {number} Summon=19 Summon value
         * @property {number} Return=20 Return value
         * @property {number} Guanxing=21 Guanxing value
         * @property {number} Copy=22 Copy value
         * @property {number} EnterFog=23 EnterFog value
         * @property {number} LeaveFog=24 LeaveFog value
         * @property {number} GoldGob=25 GoldGob value
         * @property {number} PlayCard=1000 PlayCard value
         * @property {number} Move=1001 Move value
         * @property {number} BattleEnd=1002 BattleEnd value
         */
        ClientAction.ActionID = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknow"] = 0;
            values[valuesById[1] = "Attack"] = 1;
            values[valuesById[2] = "TurnOver"] = 2;
            values[valuesById[3] = "Skill"] = 3;
            values[valuesById[6] = "SkillStatusMovie"] = 6;
            values[valuesById[7] = "ModifyValue"] = 7;
            values[valuesById[9] = "TextMovie"] = 9;
            values[valuesById[10] = "Movie"] = 10;
            values[valuesById[11] = "DrawCard"] = 11;
            values[valuesById[12] = "Bonus"] = 12;
            values[valuesById[13] = "SwitchPos"] = 13;
            values[valuesById[14] = "HandShow"] = 14;
            values[valuesById[15] = "AddSkill"] = 15;
            values[valuesById[16] = "DelSkill"] = 16;
            values[valuesById[17] = "DisCard"] = 17;
            values[valuesById[18] = "Destroy"] = 18;
            values[valuesById[19] = "Summon"] = 19;
            values[valuesById[20] = "Return"] = 20;
            values[valuesById[21] = "Guanxing"] = 21;
            values[valuesById[22] = "Copy"] = 22;
            values[valuesById[23] = "EnterFog"] = 23;
            values[valuesById[24] = "LeaveFog"] = 24;
            values[valuesById[25] = "GoldGob"] = 25;
            values[valuesById[1000] = "PlayCard"] = 1000;
            values[valuesById[1001] = "Move"] = 1001;
            values[valuesById[1002] = "BattleEnd"] = 1002;
            return values;
        })();

        return ClientAction;
    })();

    pb.AttackAct = (function() {

        /**
         * Properties of an AttackAct.
         * @memberof pb
         * @interface IAttackAct
         * @property {number|null} [Attacker] AttackAct Attacker
         * @property {Array.<pb.IAttackWinAct>|null} [WinActs] AttackAct WinActs
         * @property {Array.<pb.IMoveAct>|null} [MoveActs] AttackAct MoveActs
         * @property {Array.<pb.IClientAction>|null} [AfterMoveActs] AttackAct AfterMoveActs
         * @property {boolean|null} [IsArrow] AttackAct IsArrow
         */

        /**
         * Constructs a new AttackAct.
         * @memberof pb
         * @classdesc Represents an AttackAct.
         * @implements IAttackAct
         * @constructor
         * @param {pb.IAttackAct=} [properties] Properties to set
         */
        function AttackAct(properties) {
            this.WinActs = [];
            this.MoveActs = [];
            this.AfterMoveActs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttackAct Attacker.
         * @member {number} Attacker
         * @memberof pb.AttackAct
         * @instance
         */
        AttackAct.prototype.Attacker = 0;

        /**
         * AttackAct WinActs.
         * @member {Array.<pb.IAttackWinAct>} WinActs
         * @memberof pb.AttackAct
         * @instance
         */
        AttackAct.prototype.WinActs = $util.emptyArray;

        /**
         * AttackAct MoveActs.
         * @member {Array.<pb.IMoveAct>} MoveActs
         * @memberof pb.AttackAct
         * @instance
         */
        AttackAct.prototype.MoveActs = $util.emptyArray;

        /**
         * AttackAct AfterMoveActs.
         * @member {Array.<pb.IClientAction>} AfterMoveActs
         * @memberof pb.AttackAct
         * @instance
         */
        AttackAct.prototype.AfterMoveActs = $util.emptyArray;

        /**
         * AttackAct IsArrow.
         * @member {boolean} IsArrow
         * @memberof pb.AttackAct
         * @instance
         */
        AttackAct.prototype.IsArrow = false;

        /**
         * Creates a new AttackAct instance using the specified properties.
         * @function create
         * @memberof pb.AttackAct
         * @static
         * @param {pb.IAttackAct=} [properties] Properties to set
         * @returns {pb.AttackAct} AttackAct instance
         */
        AttackAct.create = function create(properties) {
            return new AttackAct(properties);
        };

        /**
         * Encodes the specified AttackAct message. Does not implicitly {@link pb.AttackAct.verify|verify} messages.
         * @function encode
         * @memberof pb.AttackAct
         * @static
         * @param {pb.IAttackAct} message AttackAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttackAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Attacker != null && message.hasOwnProperty("Attacker"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Attacker);
            if (message.WinActs != null && message.WinActs.length)
                for (var i = 0; i < message.WinActs.length; ++i)
                    $root.pb.AttackWinAct.encode(message.WinActs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.MoveActs != null && message.MoveActs.length)
                for (var i = 0; i < message.MoveActs.length; ++i)
                    $root.pb.MoveAct.encode(message.MoveActs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.AfterMoveActs != null && message.AfterMoveActs.length)
                for (var i = 0; i < message.AfterMoveActs.length; ++i)
                    $root.pb.ClientAction.encode(message.AfterMoveActs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.IsArrow != null && message.hasOwnProperty("IsArrow"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsArrow);
            return writer;
        };

        /**
         * Encodes the specified AttackAct message, length delimited. Does not implicitly {@link pb.AttackAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AttackAct
         * @static
         * @param {pb.IAttackAct} message AttackAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttackAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttackAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AttackAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AttackAct} AttackAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttackAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AttackAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Attacker = reader.int32();
                    break;
                case 2:
                    if (!(message.WinActs && message.WinActs.length))
                        message.WinActs = [];
                    message.WinActs.push($root.pb.AttackWinAct.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.MoveActs && message.MoveActs.length))
                        message.MoveActs = [];
                    message.MoveActs.push($root.pb.MoveAct.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.AfterMoveActs && message.AfterMoveActs.length))
                        message.AfterMoveActs = [];
                    message.AfterMoveActs.push($root.pb.ClientAction.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.IsArrow = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttackAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AttackAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AttackAct} AttackAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttackAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttackAct message.
         * @function verify
         * @memberof pb.AttackAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttackAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Attacker != null && message.hasOwnProperty("Attacker"))
                if (!$util.isInteger(message.Attacker))
                    return "Attacker: integer expected";
            if (message.WinActs != null && message.hasOwnProperty("WinActs")) {
                if (!Array.isArray(message.WinActs))
                    return "WinActs: array expected";
                for (var i = 0; i < message.WinActs.length; ++i) {
                    var error = $root.pb.AttackWinAct.verify(message.WinActs[i]);
                    if (error)
                        return "WinActs." + error;
                }
            }
            if (message.MoveActs != null && message.hasOwnProperty("MoveActs")) {
                if (!Array.isArray(message.MoveActs))
                    return "MoveActs: array expected";
                for (var i = 0; i < message.MoveActs.length; ++i) {
                    var error = $root.pb.MoveAct.verify(message.MoveActs[i]);
                    if (error)
                        return "MoveActs." + error;
                }
            }
            if (message.AfterMoveActs != null && message.hasOwnProperty("AfterMoveActs")) {
                if (!Array.isArray(message.AfterMoveActs))
                    return "AfterMoveActs: array expected";
                for (var i = 0; i < message.AfterMoveActs.length; ++i) {
                    var error = $root.pb.ClientAction.verify(message.AfterMoveActs[i]);
                    if (error)
                        return "AfterMoveActs." + error;
                }
            }
            if (message.IsArrow != null && message.hasOwnProperty("IsArrow"))
                if (typeof message.IsArrow !== "boolean")
                    return "IsArrow: boolean expected";
            return null;
        };

        return AttackAct;
    })();

    pb.AttackWinAct = (function() {

        /**
         * Properties of an AttackWinAct.
         * @memberof pb
         * @interface IAttackWinAct
         * @property {number|null} [BeAttacker] AttackWinAct BeAttacker
         * @property {number|null} [WinPos] AttackWinAct WinPos
         * @property {number|null} [LosePos] AttackWinAct LosePos
         */

        /**
         * Constructs a new AttackWinAct.
         * @memberof pb
         * @classdesc Represents an AttackWinAct.
         * @implements IAttackWinAct
         * @constructor
         * @param {pb.IAttackWinAct=} [properties] Properties to set
         */
        function AttackWinAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AttackWinAct BeAttacker.
         * @member {number} BeAttacker
         * @memberof pb.AttackWinAct
         * @instance
         */
        AttackWinAct.prototype.BeAttacker = 0;

        /**
         * AttackWinAct WinPos.
         * @member {number} WinPos
         * @memberof pb.AttackWinAct
         * @instance
         */
        AttackWinAct.prototype.WinPos = 0;

        /**
         * AttackWinAct LosePos.
         * @member {number} LosePos
         * @memberof pb.AttackWinAct
         * @instance
         */
        AttackWinAct.prototype.LosePos = 0;

        /**
         * Creates a new AttackWinAct instance using the specified properties.
         * @function create
         * @memberof pb.AttackWinAct
         * @static
         * @param {pb.IAttackWinAct=} [properties] Properties to set
         * @returns {pb.AttackWinAct} AttackWinAct instance
         */
        AttackWinAct.create = function create(properties) {
            return new AttackWinAct(properties);
        };

        /**
         * Encodes the specified AttackWinAct message. Does not implicitly {@link pb.AttackWinAct.verify|verify} messages.
         * @function encode
         * @memberof pb.AttackWinAct
         * @static
         * @param {pb.IAttackWinAct} message AttackWinAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttackWinAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BeAttacker != null && message.hasOwnProperty("BeAttacker"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.BeAttacker);
            if (message.WinPos != null && message.hasOwnProperty("WinPos"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.WinPos);
            if (message.LosePos != null && message.hasOwnProperty("LosePos"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.LosePos);
            return writer;
        };

        /**
         * Encodes the specified AttackWinAct message, length delimited. Does not implicitly {@link pb.AttackWinAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AttackWinAct
         * @static
         * @param {pb.IAttackWinAct} message AttackWinAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AttackWinAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AttackWinAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AttackWinAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AttackWinAct} AttackWinAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttackWinAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AttackWinAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BeAttacker = reader.int32();
                    break;
                case 2:
                    message.WinPos = reader.int32();
                    break;
                case 3:
                    message.LosePos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AttackWinAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AttackWinAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AttackWinAct} AttackWinAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AttackWinAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AttackWinAct message.
         * @function verify
         * @memberof pb.AttackWinAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AttackWinAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BeAttacker != null && message.hasOwnProperty("BeAttacker"))
                if (!$util.isInteger(message.BeAttacker))
                    return "BeAttacker: integer expected";
            if (message.WinPos != null && message.hasOwnProperty("WinPos"))
                if (!$util.isInteger(message.WinPos))
                    return "WinPos: integer expected";
            if (message.LosePos != null && message.hasOwnProperty("LosePos"))
                if (!$util.isInteger(message.LosePos))
                    return "LosePos: integer expected";
            return null;
        };

        return AttackWinAct;
    })();

    pb.MoveAct = (function() {

        /**
         * Properties of a MoveAct.
         * @memberof pb
         * @interface IMoveAct
         * @property {number|null} [Target] MoveAct Target
         * @property {number|null} [TargetGrid] MoveAct TargetGrid
         * @property {string|null} [MovieID] MoveAct MovieID
         * @property {number|null} [MovePos] MoveAct MovePos
         * @property {number|null} [OwnerObjID] MoveAct OwnerObjID
         */

        /**
         * Constructs a new MoveAct.
         * @memberof pb
         * @classdesc Represents a MoveAct.
         * @implements IMoveAct
         * @constructor
         * @param {pb.IMoveAct=} [properties] Properties to set
         */
        function MoveAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveAct Target.
         * @member {number} Target
         * @memberof pb.MoveAct
         * @instance
         */
        MoveAct.prototype.Target = 0;

        /**
         * MoveAct TargetGrid.
         * @member {number} TargetGrid
         * @memberof pb.MoveAct
         * @instance
         */
        MoveAct.prototype.TargetGrid = 0;

        /**
         * MoveAct MovieID.
         * @member {string} MovieID
         * @memberof pb.MoveAct
         * @instance
         */
        MoveAct.prototype.MovieID = "";

        /**
         * MoveAct MovePos.
         * @member {number} MovePos
         * @memberof pb.MoveAct
         * @instance
         */
        MoveAct.prototype.MovePos = 0;

        /**
         * MoveAct OwnerObjID.
         * @member {number} OwnerObjID
         * @memberof pb.MoveAct
         * @instance
         */
        MoveAct.prototype.OwnerObjID = 0;

        /**
         * Creates a new MoveAct instance using the specified properties.
         * @function create
         * @memberof pb.MoveAct
         * @static
         * @param {pb.IMoveAct=} [properties] Properties to set
         * @returns {pb.MoveAct} MoveAct instance
         */
        MoveAct.create = function create(properties) {
            return new MoveAct(properties);
        };

        /**
         * Encodes the specified MoveAct message. Does not implicitly {@link pb.MoveAct.verify|verify} messages.
         * @function encode
         * @memberof pb.MoveAct
         * @static
         * @param {pb.IMoveAct} message MoveAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Target != null && message.hasOwnProperty("Target"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Target);
            if (message.TargetGrid != null && message.hasOwnProperty("TargetGrid"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TargetGrid);
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.MovieID);
            if (message.MovePos != null && message.hasOwnProperty("MovePos"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MovePos);
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.OwnerObjID);
            return writer;
        };

        /**
         * Encodes the specified MoveAct message, length delimited. Does not implicitly {@link pb.MoveAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MoveAct
         * @static
         * @param {pb.IMoveAct} message MoveAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MoveAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MoveAct} MoveAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Target = reader.int32();
                    break;
                case 2:
                    message.TargetGrid = reader.int32();
                    break;
                case 3:
                    message.MovieID = reader.string();
                    break;
                case 4:
                    message.MovePos = reader.int32();
                    break;
                case 5:
                    message.OwnerObjID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MoveAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MoveAct} MoveAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveAct message.
         * @function verify
         * @memberof pb.MoveAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Target != null && message.hasOwnProperty("Target"))
                if (!$util.isInteger(message.Target))
                    return "Target: integer expected";
            if (message.TargetGrid != null && message.hasOwnProperty("TargetGrid"))
                if (!$util.isInteger(message.TargetGrid))
                    return "TargetGrid: integer expected";
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                if (!$util.isString(message.MovieID))
                    return "MovieID: string expected";
            if (message.MovePos != null && message.hasOwnProperty("MovePos"))
                if (!$util.isInteger(message.MovePos))
                    return "MovePos: integer expected";
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                if (!$util.isInteger(message.OwnerObjID))
                    return "OwnerObjID: integer expected";
            return null;
        };

        return MoveAct;
    })();

    pb.TurnOverAct = (function() {

        /**
         * Properties of a TurnOverAct.
         * @memberof pb
         * @interface ITurnOverAct
         * @property {Array.<number>|null} [BeTurners] TurnOverAct BeTurners
         */

        /**
         * Constructs a new TurnOverAct.
         * @memberof pb
         * @classdesc Represents a TurnOverAct.
         * @implements ITurnOverAct
         * @constructor
         * @param {pb.ITurnOverAct=} [properties] Properties to set
         */
        function TurnOverAct(properties) {
            this.BeTurners = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TurnOverAct BeTurners.
         * @member {Array.<number>} BeTurners
         * @memberof pb.TurnOverAct
         * @instance
         */
        TurnOverAct.prototype.BeTurners = $util.emptyArray;

        /**
         * Creates a new TurnOverAct instance using the specified properties.
         * @function create
         * @memberof pb.TurnOverAct
         * @static
         * @param {pb.ITurnOverAct=} [properties] Properties to set
         * @returns {pb.TurnOverAct} TurnOverAct instance
         */
        TurnOverAct.create = function create(properties) {
            return new TurnOverAct(properties);
        };

        /**
         * Encodes the specified TurnOverAct message. Does not implicitly {@link pb.TurnOverAct.verify|verify} messages.
         * @function encode
         * @memberof pb.TurnOverAct
         * @static
         * @param {pb.ITurnOverAct} message TurnOverAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnOverAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BeTurners != null && message.BeTurners.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.BeTurners.length; ++i)
                    writer.int32(message.BeTurners[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified TurnOverAct message, length delimited. Does not implicitly {@link pb.TurnOverAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TurnOverAct
         * @static
         * @param {pb.ITurnOverAct} message TurnOverAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TurnOverAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TurnOverAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TurnOverAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TurnOverAct} TurnOverAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnOverAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TurnOverAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.BeTurners && message.BeTurners.length))
                        message.BeTurners = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.BeTurners.push(reader.int32());
                    } else
                        message.BeTurners.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TurnOverAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TurnOverAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TurnOverAct} TurnOverAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TurnOverAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TurnOverAct message.
         * @function verify
         * @memberof pb.TurnOverAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TurnOverAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BeTurners != null && message.hasOwnProperty("BeTurners")) {
                if (!Array.isArray(message.BeTurners))
                    return "BeTurners: array expected";
                for (var i = 0; i < message.BeTurners.length; ++i)
                    if (!$util.isInteger(message.BeTurners[i]))
                        return "BeTurners: integer[] expected";
            }
            return null;
        };

        return TurnOverAct;
    })();

    pb.SkillAct = (function() {

        /**
         * Properties of a SkillAct.
         * @memberof pb
         * @interface ISkillAct
         * @property {number|null} [Owner] SkillAct Owner
         * @property {number|null} [SkillID] SkillAct SkillID
         * @property {Array.<pb.IClientAction>|null} [Actions] SkillAct Actions
         * @property {Array.<pb.IMoveAct>|null} [MoveActs] SkillAct MoveActs
         * @property {Array.<pb.IClientAction>|null} [AfterMoveActs] SkillAct AfterMoveActs
         * @property {boolean|null} [IsEquip] SkillAct IsEquip
         */

        /**
         * Constructs a new SkillAct.
         * @memberof pb
         * @classdesc Represents a SkillAct.
         * @implements ISkillAct
         * @constructor
         * @param {pb.ISkillAct=} [properties] Properties to set
         */
        function SkillAct(properties) {
            this.Actions = [];
            this.MoveActs = [];
            this.AfterMoveActs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillAct Owner.
         * @member {number} Owner
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.Owner = 0;

        /**
         * SkillAct SkillID.
         * @member {number} SkillID
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.SkillID = 0;

        /**
         * SkillAct Actions.
         * @member {Array.<pb.IClientAction>} Actions
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.Actions = $util.emptyArray;

        /**
         * SkillAct MoveActs.
         * @member {Array.<pb.IMoveAct>} MoveActs
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.MoveActs = $util.emptyArray;

        /**
         * SkillAct AfterMoveActs.
         * @member {Array.<pb.IClientAction>} AfterMoveActs
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.AfterMoveActs = $util.emptyArray;

        /**
         * SkillAct IsEquip.
         * @member {boolean} IsEquip
         * @memberof pb.SkillAct
         * @instance
         */
        SkillAct.prototype.IsEquip = false;

        /**
         * Creates a new SkillAct instance using the specified properties.
         * @function create
         * @memberof pb.SkillAct
         * @static
         * @param {pb.ISkillAct=} [properties] Properties to set
         * @returns {pb.SkillAct} SkillAct instance
         */
        SkillAct.create = function create(properties) {
            return new SkillAct(properties);
        };

        /**
         * Encodes the specified SkillAct message. Does not implicitly {@link pb.SkillAct.verify|verify} messages.
         * @function encode
         * @memberof pb.SkillAct
         * @static
         * @param {pb.ISkillAct} message SkillAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Owner != null && message.hasOwnProperty("Owner"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Owner);
            if (message.SkillID != null && message.hasOwnProperty("SkillID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.SkillID);
            if (message.Actions != null && message.Actions.length)
                for (var i = 0; i < message.Actions.length; ++i)
                    $root.pb.ClientAction.encode(message.Actions[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.MoveActs != null && message.MoveActs.length)
                for (var i = 0; i < message.MoveActs.length; ++i)
                    $root.pb.MoveAct.encode(message.MoveActs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.AfterMoveActs != null && message.AfterMoveActs.length)
                for (var i = 0; i < message.AfterMoveActs.length; ++i)
                    $root.pb.ClientAction.encode(message.AfterMoveActs[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.IsEquip != null && message.hasOwnProperty("IsEquip"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsEquip);
            return writer;
        };

        /**
         * Encodes the specified SkillAct message, length delimited. Does not implicitly {@link pb.SkillAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SkillAct
         * @static
         * @param {pb.ISkillAct} message SkillAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkillAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SkillAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SkillAct} SkillAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkillAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Owner = reader.int32();
                    break;
                case 2:
                    message.SkillID = reader.int32();
                    break;
                case 3:
                    if (!(message.Actions && message.Actions.length))
                        message.Actions = [];
                    message.Actions.push($root.pb.ClientAction.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.MoveActs && message.MoveActs.length))
                        message.MoveActs = [];
                    message.MoveActs.push($root.pb.MoveAct.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.AfterMoveActs && message.AfterMoveActs.length))
                        message.AfterMoveActs = [];
                    message.AfterMoveActs.push($root.pb.ClientAction.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.IsEquip = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SkillAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SkillAct} SkillAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkillAct message.
         * @function verify
         * @memberof pb.SkillAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkillAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Owner != null && message.hasOwnProperty("Owner"))
                if (!$util.isInteger(message.Owner))
                    return "Owner: integer expected";
            if (message.SkillID != null && message.hasOwnProperty("SkillID"))
                if (!$util.isInteger(message.SkillID))
                    return "SkillID: integer expected";
            if (message.Actions != null && message.hasOwnProperty("Actions")) {
                if (!Array.isArray(message.Actions))
                    return "Actions: array expected";
                for (var i = 0; i < message.Actions.length; ++i) {
                    var error = $root.pb.ClientAction.verify(message.Actions[i]);
                    if (error)
                        return "Actions." + error;
                }
            }
            if (message.MoveActs != null && message.hasOwnProperty("MoveActs")) {
                if (!Array.isArray(message.MoveActs))
                    return "MoveActs: array expected";
                for (var i = 0; i < message.MoveActs.length; ++i) {
                    var error = $root.pb.MoveAct.verify(message.MoveActs[i]);
                    if (error)
                        return "MoveActs." + error;
                }
            }
            if (message.AfterMoveActs != null && message.hasOwnProperty("AfterMoveActs")) {
                if (!Array.isArray(message.AfterMoveActs))
                    return "AfterMoveActs: array expected";
                for (var i = 0; i < message.AfterMoveActs.length; ++i) {
                    var error = $root.pb.ClientAction.verify(message.AfterMoveActs[i]);
                    if (error)
                        return "AfterMoveActs." + error;
                }
            }
            if (message.IsEquip != null && message.hasOwnProperty("IsEquip"))
                if (typeof message.IsEquip !== "boolean")
                    return "IsEquip: boolean expected";
            return null;
        };

        return SkillAct;
    })();

    pb.ModifyValueAct = (function() {

        /**
         * Properties of a ModifyValueAct.
         * @memberof pb
         * @interface IModifyValueAct
         * @property {number|null} [Value] ModifyValueAct Value
         * @property {Array.<number>|null} [Targets] ModifyValueAct Targets
         * @property {number|null} [ModifyType] ModifyValueAct ModifyType
         */

        /**
         * Constructs a new ModifyValueAct.
         * @memberof pb
         * @classdesc Represents a ModifyValueAct.
         * @implements IModifyValueAct
         * @constructor
         * @param {pb.IModifyValueAct=} [properties] Properties to set
         */
        function ModifyValueAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyValueAct Value.
         * @member {number} Value
         * @memberof pb.ModifyValueAct
         * @instance
         */
        ModifyValueAct.prototype.Value = 0;

        /**
         * ModifyValueAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.ModifyValueAct
         * @instance
         */
        ModifyValueAct.prototype.Targets = $util.emptyArray;

        /**
         * ModifyValueAct ModifyType.
         * @member {number} ModifyType
         * @memberof pb.ModifyValueAct
         * @instance
         */
        ModifyValueAct.prototype.ModifyType = 0;

        /**
         * Creates a new ModifyValueAct instance using the specified properties.
         * @function create
         * @memberof pb.ModifyValueAct
         * @static
         * @param {pb.IModifyValueAct=} [properties] Properties to set
         * @returns {pb.ModifyValueAct} ModifyValueAct instance
         */
        ModifyValueAct.create = function create(properties) {
            return new ModifyValueAct(properties);
        };

        /**
         * Encodes the specified ModifyValueAct message. Does not implicitly {@link pb.ModifyValueAct.verify|verify} messages.
         * @function encode
         * @memberof pb.ModifyValueAct
         * @static
         * @param {pb.IModifyValueAct} message ModifyValueAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyValueAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Value);
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            if (message.ModifyType != null && message.hasOwnProperty("ModifyType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ModifyType);
            return writer;
        };

        /**
         * Encodes the specified ModifyValueAct message, length delimited. Does not implicitly {@link pb.ModifyValueAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ModifyValueAct
         * @static
         * @param {pb.IModifyValueAct} message ModifyValueAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyValueAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyValueAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ModifyValueAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ModifyValueAct} ModifyValueAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyValueAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ModifyValueAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Value = reader.int32();
                    break;
                case 2:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                case 3:
                    message.ModifyType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyValueAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ModifyValueAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ModifyValueAct} ModifyValueAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyValueAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyValueAct message.
         * @function verify
         * @memberof pb.ModifyValueAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyValueAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (!$util.isInteger(message.Value))
                    return "Value: integer expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            if (message.ModifyType != null && message.hasOwnProperty("ModifyType"))
                if (!$util.isInteger(message.ModifyType))
                    return "ModifyType: integer expected";
            return null;
        };

        return ModifyValueAct;
    })();

    pb.SkillStatusMovieAct = (function() {

        /**
         * Properties of a SkillStatusMovieAct.
         * @memberof pb
         * @interface ISkillStatusMovieAct
         * @property {number|null} [Type] SkillStatusMovieAct Type
         * @property {string|null} [MovieId] SkillStatusMovieAct MovieId
         * @property {Array.<number>|null} [Targets] SkillStatusMovieAct Targets
         * @property {number|null} [PlayType] SkillStatusMovieAct PlayType
         */

        /**
         * Constructs a new SkillStatusMovieAct.
         * @memberof pb
         * @classdesc Represents a SkillStatusMovieAct.
         * @implements ISkillStatusMovieAct
         * @constructor
         * @param {pb.ISkillStatusMovieAct=} [properties] Properties to set
         */
        function SkillStatusMovieAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillStatusMovieAct Type.
         * @member {number} Type
         * @memberof pb.SkillStatusMovieAct
         * @instance
         */
        SkillStatusMovieAct.prototype.Type = 0;

        /**
         * SkillStatusMovieAct MovieId.
         * @member {string} MovieId
         * @memberof pb.SkillStatusMovieAct
         * @instance
         */
        SkillStatusMovieAct.prototype.MovieId = "";

        /**
         * SkillStatusMovieAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.SkillStatusMovieAct
         * @instance
         */
        SkillStatusMovieAct.prototype.Targets = $util.emptyArray;

        /**
         * SkillStatusMovieAct PlayType.
         * @member {number} PlayType
         * @memberof pb.SkillStatusMovieAct
         * @instance
         */
        SkillStatusMovieAct.prototype.PlayType = 0;

        /**
         * Creates a new SkillStatusMovieAct instance using the specified properties.
         * @function create
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {pb.ISkillStatusMovieAct=} [properties] Properties to set
         * @returns {pb.SkillStatusMovieAct} SkillStatusMovieAct instance
         */
        SkillStatusMovieAct.create = function create(properties) {
            return new SkillStatusMovieAct(properties);
        };

        /**
         * Encodes the specified SkillStatusMovieAct message. Does not implicitly {@link pb.SkillStatusMovieAct.verify|verify} messages.
         * @function encode
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {pb.ISkillStatusMovieAct} message SkillStatusMovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillStatusMovieAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.MovieId != null && message.hasOwnProperty("MovieId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.MovieId);
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.PlayType);
            return writer;
        };

        /**
         * Encodes the specified SkillStatusMovieAct message, length delimited. Does not implicitly {@link pb.SkillStatusMovieAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {pb.ISkillStatusMovieAct} message SkillStatusMovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillStatusMovieAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkillStatusMovieAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SkillStatusMovieAct} SkillStatusMovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillStatusMovieAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkillStatusMovieAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.MovieId = reader.string();
                    break;
                case 3:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                case 4:
                    message.PlayType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillStatusMovieAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SkillStatusMovieAct} SkillStatusMovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillStatusMovieAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkillStatusMovieAct message.
         * @function verify
         * @memberof pb.SkillStatusMovieAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkillStatusMovieAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                if (!$util.isInteger(message.Type))
                    return "Type: integer expected";
            if (message.MovieId != null && message.hasOwnProperty("MovieId"))
                if (!$util.isString(message.MovieId))
                    return "MovieId: string expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                if (!$util.isInteger(message.PlayType))
                    return "PlayType: integer expected";
            return null;
        };

        return SkillStatusMovieAct;
    })();

    pb.MovieAct = (function() {

        /**
         * Properties of a MovieAct.
         * @memberof pb
         * @interface IMovieAct
         * @property {string|null} [MovieID] MovieAct MovieID
         * @property {Array.<number>|null} [Targets] MovieAct Targets
         * @property {number|null} [PlayType] MovieAct PlayType
         * @property {number|null} [OwnerObjID] MovieAct OwnerObjID
         */

        /**
         * Constructs a new MovieAct.
         * @memberof pb
         * @classdesc Represents a MovieAct.
         * @implements IMovieAct
         * @constructor
         * @param {pb.IMovieAct=} [properties] Properties to set
         */
        function MovieAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MovieAct MovieID.
         * @member {string} MovieID
         * @memberof pb.MovieAct
         * @instance
         */
        MovieAct.prototype.MovieID = "";

        /**
         * MovieAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.MovieAct
         * @instance
         */
        MovieAct.prototype.Targets = $util.emptyArray;

        /**
         * MovieAct PlayType.
         * @member {number} PlayType
         * @memberof pb.MovieAct
         * @instance
         */
        MovieAct.prototype.PlayType = 0;

        /**
         * MovieAct OwnerObjID.
         * @member {number} OwnerObjID
         * @memberof pb.MovieAct
         * @instance
         */
        MovieAct.prototype.OwnerObjID = 0;

        /**
         * Creates a new MovieAct instance using the specified properties.
         * @function create
         * @memberof pb.MovieAct
         * @static
         * @param {pb.IMovieAct=} [properties] Properties to set
         * @returns {pb.MovieAct} MovieAct instance
         */
        MovieAct.create = function create(properties) {
            return new MovieAct(properties);
        };

        /**
         * Encodes the specified MovieAct message. Does not implicitly {@link pb.MovieAct.verify|verify} messages.
         * @function encode
         * @memberof pb.MovieAct
         * @static
         * @param {pb.IMovieAct} message MovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovieAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.MovieID);
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PlayType);
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.OwnerObjID);
            return writer;
        };

        /**
         * Encodes the specified MovieAct message, length delimited. Does not implicitly {@link pb.MovieAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MovieAct
         * @static
         * @param {pb.IMovieAct} message MovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MovieAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MovieAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MovieAct} MovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovieAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MovieAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MovieID = reader.string();
                    break;
                case 2:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                case 3:
                    message.PlayType = reader.int32();
                    break;
                case 4:
                    message.OwnerObjID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MovieAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MovieAct} MovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MovieAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MovieAct message.
         * @function verify
         * @memberof pb.MovieAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MovieAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                if (!$util.isString(message.MovieID))
                    return "MovieID: string expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                if (!$util.isInteger(message.PlayType))
                    return "PlayType: integer expected";
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                if (!$util.isInteger(message.OwnerObjID))
                    return "OwnerObjID: integer expected";
            return null;
        };

        return MovieAct;
    })();

    pb.TextMovieAct = (function() {

        /**
         * Properties of a TextMovieAct.
         * @memberof pb
         * @interface ITextMovieAct
         * @property {number|null} [MovieID] TextMovieAct MovieID
         * @property {Array.<number>|null} [Targets] TextMovieAct Targets
         * @property {number|null} [PlayType] TextMovieAct PlayType
         * @property {number|null} [TargetCount] TextMovieAct TargetCount
         * @property {number|null} [Value] TextMovieAct Value
         * @property {number|null} [OwnerObjID] TextMovieAct OwnerObjID
         */

        /**
         * Constructs a new TextMovieAct.
         * @memberof pb
         * @classdesc Represents a TextMovieAct.
         * @implements ITextMovieAct
         * @constructor
         * @param {pb.ITextMovieAct=} [properties] Properties to set
         */
        function TextMovieAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextMovieAct MovieID.
         * @member {number} MovieID
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.MovieID = 0;

        /**
         * TextMovieAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.Targets = $util.emptyArray;

        /**
         * TextMovieAct PlayType.
         * @member {number} PlayType
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.PlayType = 0;

        /**
         * TextMovieAct TargetCount.
         * @member {number} TargetCount
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.TargetCount = 0;

        /**
         * TextMovieAct Value.
         * @member {number} Value
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.Value = 0;

        /**
         * TextMovieAct OwnerObjID.
         * @member {number} OwnerObjID
         * @memberof pb.TextMovieAct
         * @instance
         */
        TextMovieAct.prototype.OwnerObjID = 0;

        /**
         * Creates a new TextMovieAct instance using the specified properties.
         * @function create
         * @memberof pb.TextMovieAct
         * @static
         * @param {pb.ITextMovieAct=} [properties] Properties to set
         * @returns {pb.TextMovieAct} TextMovieAct instance
         */
        TextMovieAct.create = function create(properties) {
            return new TextMovieAct(properties);
        };

        /**
         * Encodes the specified TextMovieAct message. Does not implicitly {@link pb.TextMovieAct.verify|verify} messages.
         * @function encode
         * @memberof pb.TextMovieAct
         * @static
         * @param {pb.ITextMovieAct} message TextMovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextMovieAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MovieID);
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PlayType);
            if (message.TargetCount != null && message.hasOwnProperty("TargetCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.TargetCount);
            if (message.Value != null && message.hasOwnProperty("Value"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Value);
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.OwnerObjID);
            return writer;
        };

        /**
         * Encodes the specified TextMovieAct message, length delimited. Does not implicitly {@link pb.TextMovieAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TextMovieAct
         * @static
         * @param {pb.ITextMovieAct} message TextMovieAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextMovieAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextMovieAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TextMovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TextMovieAct} TextMovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextMovieAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TextMovieAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MovieID = reader.int32();
                    break;
                case 2:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                case 3:
                    message.PlayType = reader.int32();
                    break;
                case 4:
                    message.TargetCount = reader.int32();
                    break;
                case 5:
                    message.Value = reader.int32();
                    break;
                case 6:
                    message.OwnerObjID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextMovieAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TextMovieAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TextMovieAct} TextMovieAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextMovieAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextMovieAct message.
         * @function verify
         * @memberof pb.TextMovieAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextMovieAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                if (!$util.isInteger(message.MovieID))
                    return "MovieID: integer expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            if (message.PlayType != null && message.hasOwnProperty("PlayType"))
                if (!$util.isInteger(message.PlayType))
                    return "PlayType: integer expected";
            if (message.TargetCount != null && message.hasOwnProperty("TargetCount"))
                if (!$util.isInteger(message.TargetCount))
                    return "TargetCount: integer expected";
            if (message.Value != null && message.hasOwnProperty("Value"))
                if (!$util.isInteger(message.Value))
                    return "Value: integer expected";
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                if (!$util.isInteger(message.OwnerObjID))
                    return "OwnerObjID: integer expected";
            return null;
        };

        return TextMovieAct;
    })();

    pb.DrawCardAct = (function() {

        /**
         * Properties of a DrawCardAct.
         * @memberof pb
         * @interface IDrawCardAct
         * @property {number|Long|null} [Uid] DrawCardAct Uid
         * @property {Array.<pb.ICard>|null} [Cards] DrawCardAct Cards
         * @property {number|null} [MovieID] DrawCardAct MovieID
         * @property {number|null} [OwnerObjID] DrawCardAct OwnerObjID
         */

        /**
         * Constructs a new DrawCardAct.
         * @memberof pb
         * @classdesc Represents a DrawCardAct.
         * @implements IDrawCardAct
         * @constructor
         * @param {pb.IDrawCardAct=} [properties] Properties to set
         */
        function DrawCardAct(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DrawCardAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.DrawCardAct
         * @instance
         */
        DrawCardAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DrawCardAct Cards.
         * @member {Array.<pb.ICard>} Cards
         * @memberof pb.DrawCardAct
         * @instance
         */
        DrawCardAct.prototype.Cards = $util.emptyArray;

        /**
         * DrawCardAct MovieID.
         * @member {number} MovieID
         * @memberof pb.DrawCardAct
         * @instance
         */
        DrawCardAct.prototype.MovieID = 0;

        /**
         * DrawCardAct OwnerObjID.
         * @member {number} OwnerObjID
         * @memberof pb.DrawCardAct
         * @instance
         */
        DrawCardAct.prototype.OwnerObjID = 0;

        /**
         * Creates a new DrawCardAct instance using the specified properties.
         * @function create
         * @memberof pb.DrawCardAct
         * @static
         * @param {pb.IDrawCardAct=} [properties] Properties to set
         * @returns {pb.DrawCardAct} DrawCardAct instance
         */
        DrawCardAct.create = function create(properties) {
            return new DrawCardAct(properties);
        };

        /**
         * Encodes the specified DrawCardAct message. Does not implicitly {@link pb.DrawCardAct.verify|verify} messages.
         * @function encode
         * @memberof pb.DrawCardAct
         * @static
         * @param {pb.IDrawCardAct} message DrawCardAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DrawCardAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Cards != null && message.Cards.length)
                for (var i = 0; i < message.Cards.length; ++i)
                    $root.pb.Card.encode(message.Cards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MovieID);
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.OwnerObjID);
            return writer;
        };

        /**
         * Encodes the specified DrawCardAct message, length delimited. Does not implicitly {@link pb.DrawCardAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DrawCardAct
         * @static
         * @param {pb.IDrawCardAct} message DrawCardAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DrawCardAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DrawCardAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DrawCardAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DrawCardAct} DrawCardAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawCardAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DrawCardAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    message.Cards.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.MovieID = reader.int32();
                    break;
                case 4:
                    message.OwnerObjID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DrawCardAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DrawCardAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DrawCardAct} DrawCardAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DrawCardAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DrawCardAct message.
         * @function verify
         * @memberof pb.DrawCardAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DrawCardAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i) {
                    var error = $root.pb.Card.verify(message.Cards[i]);
                    if (error)
                        return "Cards." + error;
                }
            }
            if (message.MovieID != null && message.hasOwnProperty("MovieID"))
                if (!$util.isInteger(message.MovieID))
                    return "MovieID: integer expected";
            if (message.OwnerObjID != null && message.hasOwnProperty("OwnerObjID"))
                if (!$util.isInteger(message.OwnerObjID))
                    return "OwnerObjID: integer expected";
            return null;
        };

        return DrawCardAct;
    })();

    pb.HandShowAct = (function() {

        /**
         * Properties of a HandShowAct.
         * @memberof pb
         * @interface IHandShowAct
         * @property {number|Long|null} [Uid] HandShowAct Uid
         */

        /**
         * Constructs a new HandShowAct.
         * @memberof pb
         * @classdesc Represents a HandShowAct.
         * @implements IHandShowAct
         * @constructor
         * @param {pb.IHandShowAct=} [properties] Properties to set
         */
        function HandShowAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HandShowAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.HandShowAct
         * @instance
         */
        HandShowAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HandShowAct instance using the specified properties.
         * @function create
         * @memberof pb.HandShowAct
         * @static
         * @param {pb.IHandShowAct=} [properties] Properties to set
         * @returns {pb.HandShowAct} HandShowAct instance
         */
        HandShowAct.create = function create(properties) {
            return new HandShowAct(properties);
        };

        /**
         * Encodes the specified HandShowAct message. Does not implicitly {@link pb.HandShowAct.verify|verify} messages.
         * @function encode
         * @memberof pb.HandShowAct
         * @static
         * @param {pb.IHandShowAct} message HandShowAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandShowAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified HandShowAct message, length delimited. Does not implicitly {@link pb.HandShowAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HandShowAct
         * @static
         * @param {pb.IHandShowAct} message HandShowAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HandShowAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HandShowAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HandShowAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HandShowAct} HandShowAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandShowAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HandShowAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HandShowAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HandShowAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HandShowAct} HandShowAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HandShowAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HandShowAct message.
         * @function verify
         * @memberof pb.HandShowAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HandShowAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return HandShowAct;
    })();

    pb.GuanxingAct = (function() {

        /**
         * Properties of a GuanxingAct.
         * @memberof pb
         * @interface IGuanxingAct
         * @property {Array.<number|Long>|null} [Uids] GuanxingAct Uids
         * @property {Array.<pb.ICard>|null} [SitOneDrawCards] GuanxingAct SitOneDrawCards
         * @property {Array.<pb.ICard>|null} [SitTwoDrawCards] GuanxingAct SitTwoDrawCards
         */

        /**
         * Constructs a new GuanxingAct.
         * @memberof pb
         * @classdesc Represents a GuanxingAct.
         * @implements IGuanxingAct
         * @constructor
         * @param {pb.IGuanxingAct=} [properties] Properties to set
         */
        function GuanxingAct(properties) {
            this.Uids = [];
            this.SitOneDrawCards = [];
            this.SitTwoDrawCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuanxingAct Uids.
         * @member {Array.<number|Long>} Uids
         * @memberof pb.GuanxingAct
         * @instance
         */
        GuanxingAct.prototype.Uids = $util.emptyArray;

        /**
         * GuanxingAct SitOneDrawCards.
         * @member {Array.<pb.ICard>} SitOneDrawCards
         * @memberof pb.GuanxingAct
         * @instance
         */
        GuanxingAct.prototype.SitOneDrawCards = $util.emptyArray;

        /**
         * GuanxingAct SitTwoDrawCards.
         * @member {Array.<pb.ICard>} SitTwoDrawCards
         * @memberof pb.GuanxingAct
         * @instance
         */
        GuanxingAct.prototype.SitTwoDrawCards = $util.emptyArray;

        /**
         * Creates a new GuanxingAct instance using the specified properties.
         * @function create
         * @memberof pb.GuanxingAct
         * @static
         * @param {pb.IGuanxingAct=} [properties] Properties to set
         * @returns {pb.GuanxingAct} GuanxingAct instance
         */
        GuanxingAct.create = function create(properties) {
            return new GuanxingAct(properties);
        };

        /**
         * Encodes the specified GuanxingAct message. Does not implicitly {@link pb.GuanxingAct.verify|verify} messages.
         * @function encode
         * @memberof pb.GuanxingAct
         * @static
         * @param {pb.IGuanxingAct} message GuanxingAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuanxingAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uids != null && message.Uids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Uids.length; ++i)
                    writer.uint64(message.Uids[i]);
                writer.ldelim();
            }
            if (message.SitOneDrawCards != null && message.SitOneDrawCards.length)
                for (var i = 0; i < message.SitOneDrawCards.length; ++i)
                    $root.pb.Card.encode(message.SitOneDrawCards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.SitTwoDrawCards != null && message.SitTwoDrawCards.length)
                for (var i = 0; i < message.SitTwoDrawCards.length; ++i)
                    $root.pb.Card.encode(message.SitTwoDrawCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GuanxingAct message, length delimited. Does not implicitly {@link pb.GuanxingAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GuanxingAct
         * @static
         * @param {pb.IGuanxingAct} message GuanxingAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuanxingAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuanxingAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GuanxingAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GuanxingAct} GuanxingAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuanxingAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GuanxingAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Uids && message.Uids.length))
                        message.Uids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Uids.push(reader.uint64());
                    } else
                        message.Uids.push(reader.uint64());
                    break;
                case 2:
                    if (!(message.SitOneDrawCards && message.SitOneDrawCards.length))
                        message.SitOneDrawCards = [];
                    message.SitOneDrawCards.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.SitTwoDrawCards && message.SitTwoDrawCards.length))
                        message.SitTwoDrawCards = [];
                    message.SitTwoDrawCards.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuanxingAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GuanxingAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GuanxingAct} GuanxingAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuanxingAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuanxingAct message.
         * @function verify
         * @memberof pb.GuanxingAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuanxingAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uids != null && message.hasOwnProperty("Uids")) {
                if (!Array.isArray(message.Uids))
                    return "Uids: array expected";
                for (var i = 0; i < message.Uids.length; ++i)
                    if (!$util.isInteger(message.Uids[i]) && !(message.Uids[i] && $util.isInteger(message.Uids[i].low) && $util.isInteger(message.Uids[i].high)))
                        return "Uids: integer|Long[] expected";
            }
            if (message.SitOneDrawCards != null && message.hasOwnProperty("SitOneDrawCards")) {
                if (!Array.isArray(message.SitOneDrawCards))
                    return "SitOneDrawCards: array expected";
                for (var i = 0; i < message.SitOneDrawCards.length; ++i) {
                    var error = $root.pb.Card.verify(message.SitOneDrawCards[i]);
                    if (error)
                        return "SitOneDrawCards." + error;
                }
            }
            if (message.SitTwoDrawCards != null && message.hasOwnProperty("SitTwoDrawCards")) {
                if (!Array.isArray(message.SitTwoDrawCards))
                    return "SitTwoDrawCards: array expected";
                for (var i = 0; i < message.SitTwoDrawCards.length; ++i) {
                    var error = $root.pb.Card.verify(message.SitTwoDrawCards[i]);
                    if (error)
                        return "SitTwoDrawCards." + error;
                }
            }
            return null;
        };

        return GuanxingAct;
    })();

    pb.ModifySkillAct = (function() {

        /**
         * Properties of a ModifySkillAct.
         * @memberof pb
         * @interface IModifySkillAct
         * @property {number|null} [CardObjID] ModifySkillAct CardObjID
         * @property {number|null} [SkillID] ModifySkillAct SkillID
         * @property {boolean|null} [IsEquip] ModifySkillAct IsEquip
         */

        /**
         * Constructs a new ModifySkillAct.
         * @memberof pb
         * @classdesc Represents a ModifySkillAct.
         * @implements IModifySkillAct
         * @constructor
         * @param {pb.IModifySkillAct=} [properties] Properties to set
         */
        function ModifySkillAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifySkillAct CardObjID.
         * @member {number} CardObjID
         * @memberof pb.ModifySkillAct
         * @instance
         */
        ModifySkillAct.prototype.CardObjID = 0;

        /**
         * ModifySkillAct SkillID.
         * @member {number} SkillID
         * @memberof pb.ModifySkillAct
         * @instance
         */
        ModifySkillAct.prototype.SkillID = 0;

        /**
         * ModifySkillAct IsEquip.
         * @member {boolean} IsEquip
         * @memberof pb.ModifySkillAct
         * @instance
         */
        ModifySkillAct.prototype.IsEquip = false;

        /**
         * Creates a new ModifySkillAct instance using the specified properties.
         * @function create
         * @memberof pb.ModifySkillAct
         * @static
         * @param {pb.IModifySkillAct=} [properties] Properties to set
         * @returns {pb.ModifySkillAct} ModifySkillAct instance
         */
        ModifySkillAct.create = function create(properties) {
            return new ModifySkillAct(properties);
        };

        /**
         * Encodes the specified ModifySkillAct message. Does not implicitly {@link pb.ModifySkillAct.verify|verify} messages.
         * @function encode
         * @memberof pb.ModifySkillAct
         * @static
         * @param {pb.IModifySkillAct} message ModifySkillAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifySkillAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardObjID != null && message.hasOwnProperty("CardObjID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CardObjID);
            if (message.SkillID != null && message.hasOwnProperty("SkillID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.SkillID);
            if (message.IsEquip != null && message.hasOwnProperty("IsEquip"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsEquip);
            return writer;
        };

        /**
         * Encodes the specified ModifySkillAct message, length delimited. Does not implicitly {@link pb.ModifySkillAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ModifySkillAct
         * @static
         * @param {pb.IModifySkillAct} message ModifySkillAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifySkillAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifySkillAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ModifySkillAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ModifySkillAct} ModifySkillAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifySkillAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ModifySkillAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardObjID = reader.int32();
                    break;
                case 2:
                    message.SkillID = reader.int32();
                    break;
                case 3:
                    message.IsEquip = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifySkillAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ModifySkillAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ModifySkillAct} ModifySkillAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifySkillAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifySkillAct message.
         * @function verify
         * @memberof pb.ModifySkillAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifySkillAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardObjID != null && message.hasOwnProperty("CardObjID"))
                if (!$util.isInteger(message.CardObjID))
                    return "CardObjID: integer expected";
            if (message.SkillID != null && message.hasOwnProperty("SkillID"))
                if (!$util.isInteger(message.SkillID))
                    return "SkillID: integer expected";
            if (message.IsEquip != null && message.hasOwnProperty("IsEquip"))
                if (typeof message.IsEquip !== "boolean")
                    return "IsEquip: boolean expected";
            return null;
        };

        return ModifySkillAct;
    })();

    pb.DisCardAct = (function() {

        /**
         * Properties of a DisCardAct.
         * @memberof pb
         * @interface IDisCardAct
         * @property {number|Long|null} [Uid] DisCardAct Uid
         * @property {Array.<number>|null} [CardObjIDs] DisCardAct CardObjIDs
         */

        /**
         * Constructs a new DisCardAct.
         * @memberof pb
         * @classdesc Represents a DisCardAct.
         * @implements IDisCardAct
         * @constructor
         * @param {pb.IDisCardAct=} [properties] Properties to set
         */
        function DisCardAct(properties) {
            this.CardObjIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DisCardAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.DisCardAct
         * @instance
         */
        DisCardAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * DisCardAct CardObjIDs.
         * @member {Array.<number>} CardObjIDs
         * @memberof pb.DisCardAct
         * @instance
         */
        DisCardAct.prototype.CardObjIDs = $util.emptyArray;

        /**
         * Creates a new DisCardAct instance using the specified properties.
         * @function create
         * @memberof pb.DisCardAct
         * @static
         * @param {pb.IDisCardAct=} [properties] Properties to set
         * @returns {pb.DisCardAct} DisCardAct instance
         */
        DisCardAct.create = function create(properties) {
            return new DisCardAct(properties);
        };

        /**
         * Encodes the specified DisCardAct message. Does not implicitly {@link pb.DisCardAct.verify|verify} messages.
         * @function encode
         * @memberof pb.DisCardAct
         * @static
         * @param {pb.IDisCardAct} message DisCardAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisCardAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.CardObjIDs != null && message.CardObjIDs.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.CardObjIDs.length; ++i)
                    writer.int32(message.CardObjIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified DisCardAct message, length delimited. Does not implicitly {@link pb.DisCardAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DisCardAct
         * @static
         * @param {pb.IDisCardAct} message DisCardAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DisCardAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DisCardAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DisCardAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DisCardAct} DisCardAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisCardAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DisCardAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    if (!(message.CardObjIDs && message.CardObjIDs.length))
                        message.CardObjIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardObjIDs.push(reader.int32());
                    } else
                        message.CardObjIDs.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DisCardAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DisCardAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DisCardAct} DisCardAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DisCardAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DisCardAct message.
         * @function verify
         * @memberof pb.DisCardAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DisCardAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.CardObjIDs != null && message.hasOwnProperty("CardObjIDs")) {
                if (!Array.isArray(message.CardObjIDs))
                    return "CardObjIDs: array expected";
                for (var i = 0; i < message.CardObjIDs.length; ++i)
                    if (!$util.isInteger(message.CardObjIDs[i]))
                        return "CardObjIDs: integer[] expected";
            }
            return null;
        };

        return DisCardAct;
    })();

    pb.DestroyAct = (function() {

        /**
         * Properties of a DestroyAct.
         * @memberof pb
         * @interface IDestroyAct
         * @property {Array.<number>|null} [Targets] DestroyAct Targets
         */

        /**
         * Constructs a new DestroyAct.
         * @memberof pb
         * @classdesc Represents a DestroyAct.
         * @implements IDestroyAct
         * @constructor
         * @param {pb.IDestroyAct=} [properties] Properties to set
         */
        function DestroyAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DestroyAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.DestroyAct
         * @instance
         */
        DestroyAct.prototype.Targets = $util.emptyArray;

        /**
         * Creates a new DestroyAct instance using the specified properties.
         * @function create
         * @memberof pb.DestroyAct
         * @static
         * @param {pb.IDestroyAct=} [properties] Properties to set
         * @returns {pb.DestroyAct} DestroyAct instance
         */
        DestroyAct.create = function create(properties) {
            return new DestroyAct(properties);
        };

        /**
         * Encodes the specified DestroyAct message. Does not implicitly {@link pb.DestroyAct.verify|verify} messages.
         * @function encode
         * @memberof pb.DestroyAct
         * @static
         * @param {pb.IDestroyAct} message DestroyAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DestroyAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified DestroyAct message, length delimited. Does not implicitly {@link pb.DestroyAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DestroyAct
         * @static
         * @param {pb.IDestroyAct} message DestroyAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DestroyAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DestroyAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DestroyAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DestroyAct} DestroyAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DestroyAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DestroyAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DestroyAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DestroyAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DestroyAct} DestroyAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DestroyAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DestroyAct message.
         * @function verify
         * @memberof pb.DestroyAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DestroyAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            return null;
        };

        return DestroyAct;
    })();

    pb.SummonAct = (function() {

        /**
         * Properties of a SummonAct.
         * @memberof pb
         * @interface ISummonAct
         * @property {number|Long|null} [Uid] SummonAct Uid
         * @property {number|null} [GridObjID] SummonAct GridObjID
         * @property {pb.ICard|null} [Card] SummonAct Card
         * @property {boolean|null} [IsInFog] SummonAct IsInFog
         * @property {boolean|null} [IsPublicEnemy] SummonAct IsPublicEnemy
         */

        /**
         * Constructs a new SummonAct.
         * @memberof pb
         * @classdesc Represents a SummonAct.
         * @implements ISummonAct
         * @constructor
         * @param {pb.ISummonAct=} [properties] Properties to set
         */
        function SummonAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SummonAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.SummonAct
         * @instance
         */
        SummonAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SummonAct GridObjID.
         * @member {number} GridObjID
         * @memberof pb.SummonAct
         * @instance
         */
        SummonAct.prototype.GridObjID = 0;

        /**
         * SummonAct Card.
         * @member {pb.ICard|null|undefined} Card
         * @memberof pb.SummonAct
         * @instance
         */
        SummonAct.prototype.Card = null;

        /**
         * SummonAct IsInFog.
         * @member {boolean} IsInFog
         * @memberof pb.SummonAct
         * @instance
         */
        SummonAct.prototype.IsInFog = false;

        /**
         * SummonAct IsPublicEnemy.
         * @member {boolean} IsPublicEnemy
         * @memberof pb.SummonAct
         * @instance
         */
        SummonAct.prototype.IsPublicEnemy = false;

        /**
         * Creates a new SummonAct instance using the specified properties.
         * @function create
         * @memberof pb.SummonAct
         * @static
         * @param {pb.ISummonAct=} [properties] Properties to set
         * @returns {pb.SummonAct} SummonAct instance
         */
        SummonAct.create = function create(properties) {
            return new SummonAct(properties);
        };

        /**
         * Encodes the specified SummonAct message. Does not implicitly {@link pb.SummonAct.verify|verify} messages.
         * @function encode
         * @memberof pb.SummonAct
         * @static
         * @param {pb.ISummonAct} message SummonAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummonAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.GridObjID != null && message.hasOwnProperty("GridObjID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GridObjID);
            if (message.Card != null && message.hasOwnProperty("Card"))
                $root.pb.Card.encode(message.Card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.IsInFog != null && message.hasOwnProperty("IsInFog"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsInFog);
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsPublicEnemy);
            return writer;
        };

        /**
         * Encodes the specified SummonAct message, length delimited. Does not implicitly {@link pb.SummonAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SummonAct
         * @static
         * @param {pb.ISummonAct} message SummonAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SummonAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SummonAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SummonAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SummonAct} SummonAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummonAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SummonAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.GridObjID = reader.int32();
                    break;
                case 3:
                    message.Card = $root.pb.Card.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.IsInFog = reader.bool();
                    break;
                case 5:
                    message.IsPublicEnemy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SummonAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SummonAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SummonAct} SummonAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SummonAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SummonAct message.
         * @function verify
         * @memberof pb.SummonAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SummonAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.GridObjID != null && message.hasOwnProperty("GridObjID"))
                if (!$util.isInteger(message.GridObjID))
                    return "GridObjID: integer expected";
            if (message.Card != null && message.hasOwnProperty("Card")) {
                var error = $root.pb.Card.verify(message.Card);
                if (error)
                    return "Card." + error;
            }
            if (message.IsInFog != null && message.hasOwnProperty("IsInFog"))
                if (typeof message.IsInFog !== "boolean")
                    return "IsInFog: boolean expected";
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                if (typeof message.IsPublicEnemy !== "boolean")
                    return "IsPublicEnemy: boolean expected";
            return null;
        };

        return SummonAct;
    })();

    pb.ReturnAct = (function() {

        /**
         * Properties of a ReturnAct.
         * @memberof pb
         * @interface IReturnAct
         * @property {number|Long|null} [Uid] ReturnAct Uid
         * @property {number|null} [CardObjID] ReturnAct CardObjID
         * @property {pb.ICard|null} [Card] ReturnAct Card
         */

        /**
         * Constructs a new ReturnAct.
         * @memberof pb
         * @classdesc Represents a ReturnAct.
         * @implements IReturnAct
         * @constructor
         * @param {pb.IReturnAct=} [properties] Properties to set
         */
        function ReturnAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReturnAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.ReturnAct
         * @instance
         */
        ReturnAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReturnAct CardObjID.
         * @member {number} CardObjID
         * @memberof pb.ReturnAct
         * @instance
         */
        ReturnAct.prototype.CardObjID = 0;

        /**
         * ReturnAct Card.
         * @member {pb.ICard|null|undefined} Card
         * @memberof pb.ReturnAct
         * @instance
         */
        ReturnAct.prototype.Card = null;

        /**
         * Creates a new ReturnAct instance using the specified properties.
         * @function create
         * @memberof pb.ReturnAct
         * @static
         * @param {pb.IReturnAct=} [properties] Properties to set
         * @returns {pb.ReturnAct} ReturnAct instance
         */
        ReturnAct.create = function create(properties) {
            return new ReturnAct(properties);
        };

        /**
         * Encodes the specified ReturnAct message. Does not implicitly {@link pb.ReturnAct.verify|verify} messages.
         * @function encode
         * @memberof pb.ReturnAct
         * @static
         * @param {pb.IReturnAct} message ReturnAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.CardObjID != null && message.hasOwnProperty("CardObjID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CardObjID);
            if (message.Card != null && message.hasOwnProperty("Card"))
                $root.pb.Card.encode(message.Card, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ReturnAct message, length delimited. Does not implicitly {@link pb.ReturnAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ReturnAct
         * @static
         * @param {pb.IReturnAct} message ReturnAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReturnAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReturnAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ReturnAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ReturnAct} ReturnAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReturnAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.CardObjID = reader.int32();
                    break;
                case 3:
                    message.Card = $root.pb.Card.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReturnAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ReturnAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ReturnAct} ReturnAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReturnAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReturnAct message.
         * @function verify
         * @memberof pb.ReturnAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReturnAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.CardObjID != null && message.hasOwnProperty("CardObjID"))
                if (!$util.isInteger(message.CardObjID))
                    return "CardObjID: integer expected";
            if (message.Card != null && message.hasOwnProperty("Card")) {
                var error = $root.pb.Card.verify(message.Card);
                if (error)
                    return "Card." + error;
            }
            return null;
        };

        return ReturnAct;
    })();

    pb.SwitchPosAct = (function() {

        /**
         * Properties of a SwitchPosAct.
         * @memberof pb
         * @interface ISwitchPosAct
         * @property {number|null} [Target] SwitchPosAct Target
         * @property {number|null} [SwitchTarget] SwitchPosAct SwitchTarget
         */

        /**
         * Constructs a new SwitchPosAct.
         * @memberof pb
         * @classdesc Represents a SwitchPosAct.
         * @implements ISwitchPosAct
         * @constructor
         * @param {pb.ISwitchPosAct=} [properties] Properties to set
         */
        function SwitchPosAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SwitchPosAct Target.
         * @member {number} Target
         * @memberof pb.SwitchPosAct
         * @instance
         */
        SwitchPosAct.prototype.Target = 0;

        /**
         * SwitchPosAct SwitchTarget.
         * @member {number} SwitchTarget
         * @memberof pb.SwitchPosAct
         * @instance
         */
        SwitchPosAct.prototype.SwitchTarget = 0;

        /**
         * Creates a new SwitchPosAct instance using the specified properties.
         * @function create
         * @memberof pb.SwitchPosAct
         * @static
         * @param {pb.ISwitchPosAct=} [properties] Properties to set
         * @returns {pb.SwitchPosAct} SwitchPosAct instance
         */
        SwitchPosAct.create = function create(properties) {
            return new SwitchPosAct(properties);
        };

        /**
         * Encodes the specified SwitchPosAct message. Does not implicitly {@link pb.SwitchPosAct.verify|verify} messages.
         * @function encode
         * @memberof pb.SwitchPosAct
         * @static
         * @param {pb.ISwitchPosAct} message SwitchPosAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwitchPosAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Target != null && message.hasOwnProperty("Target"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Target);
            if (message.SwitchTarget != null && message.hasOwnProperty("SwitchTarget"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.SwitchTarget);
            return writer;
        };

        /**
         * Encodes the specified SwitchPosAct message, length delimited. Does not implicitly {@link pb.SwitchPosAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SwitchPosAct
         * @static
         * @param {pb.ISwitchPosAct} message SwitchPosAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SwitchPosAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SwitchPosAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SwitchPosAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SwitchPosAct} SwitchPosAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwitchPosAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SwitchPosAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Target = reader.int32();
                    break;
                case 2:
                    message.SwitchTarget = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SwitchPosAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SwitchPosAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SwitchPosAct} SwitchPosAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SwitchPosAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SwitchPosAct message.
         * @function verify
         * @memberof pb.SwitchPosAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SwitchPosAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Target != null && message.hasOwnProperty("Target"))
                if (!$util.isInteger(message.Target))
                    return "Target: integer expected";
            if (message.SwitchTarget != null && message.hasOwnProperty("SwitchTarget"))
                if (!$util.isInteger(message.SwitchTarget))
                    return "SwitchTarget: integer expected";
            return null;
        };

        return SwitchPosAct;
    })();

    pb.BonusReward = (function() {

        /**
         * Properties of a BonusReward.
         * @memberof pb
         * @interface IBonusReward
         * @property {number|Long|null} [Uid] BonusReward Uid
         * @property {number|null} [BonusID] BonusReward BonusID
         * @property {Array.<pb.IResource>|null} [Res] BonusReward Res
         */

        /**
         * Constructs a new BonusReward.
         * @memberof pb
         * @classdesc Represents a BonusReward.
         * @implements IBonusReward
         * @constructor
         * @param {pb.IBonusReward=} [properties] Properties to set
         */
        function BonusReward(properties) {
            this.Res = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusReward Uid.
         * @member {number|Long} Uid
         * @memberof pb.BonusReward
         * @instance
         */
        BonusReward.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BonusReward BonusID.
         * @member {number} BonusID
         * @memberof pb.BonusReward
         * @instance
         */
        BonusReward.prototype.BonusID = 0;

        /**
         * BonusReward Res.
         * @member {Array.<pb.IResource>} Res
         * @memberof pb.BonusReward
         * @instance
         */
        BonusReward.prototype.Res = $util.emptyArray;

        /**
         * Creates a new BonusReward instance using the specified properties.
         * @function create
         * @memberof pb.BonusReward
         * @static
         * @param {pb.IBonusReward=} [properties] Properties to set
         * @returns {pb.BonusReward} BonusReward instance
         */
        BonusReward.create = function create(properties) {
            return new BonusReward(properties);
        };

        /**
         * Encodes the specified BonusReward message. Does not implicitly {@link pb.BonusReward.verify|verify} messages.
         * @function encode
         * @memberof pb.BonusReward
         * @static
         * @param {pb.IBonusReward} message BonusReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.BonusID != null && message.hasOwnProperty("BonusID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.BonusID);
            if (message.Res != null && message.Res.length)
                for (var i = 0; i < message.Res.length; ++i)
                    $root.pb.Resource.encode(message.Res[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BonusReward message, length delimited. Does not implicitly {@link pb.BonusReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BonusReward
         * @static
         * @param {pb.IBonusReward} message BonusReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BonusReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BonusReward} BonusReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BonusReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.BonusID = reader.int32();
                    break;
                case 3:
                    if (!(message.Res && message.Res.length))
                        message.Res = [];
                    message.Res.push($root.pb.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BonusReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BonusReward} BonusReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusReward message.
         * @function verify
         * @memberof pb.BonusReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.BonusID != null && message.hasOwnProperty("BonusID"))
                if (!$util.isInteger(message.BonusID))
                    return "BonusID: integer expected";
            if (message.Res != null && message.hasOwnProperty("Res")) {
                if (!Array.isArray(message.Res))
                    return "Res: array expected";
                for (var i = 0; i < message.Res.length; ++i) {
                    var error = $root.pb.Resource.verify(message.Res[i]);
                    if (error)
                        return "Res." + error;
                }
            }
            return null;
        };

        return BonusReward;
    })();

    pb.BonusAct = (function() {

        /**
         * Properties of a BonusAct.
         * @memberof pb
         * @interface IBonusAct
         * @property {Array.<pb.IBonusReward>|null} [Rewards] BonusAct Rewards
         */

        /**
         * Constructs a new BonusAct.
         * @memberof pb
         * @classdesc Represents a BonusAct.
         * @implements IBonusAct
         * @constructor
         * @param {pb.IBonusAct=} [properties] Properties to set
         */
        function BonusAct(properties) {
            this.Rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BonusAct Rewards.
         * @member {Array.<pb.IBonusReward>} Rewards
         * @memberof pb.BonusAct
         * @instance
         */
        BonusAct.prototype.Rewards = $util.emptyArray;

        /**
         * Creates a new BonusAct instance using the specified properties.
         * @function create
         * @memberof pb.BonusAct
         * @static
         * @param {pb.IBonusAct=} [properties] Properties to set
         * @returns {pb.BonusAct} BonusAct instance
         */
        BonusAct.create = function create(properties) {
            return new BonusAct(properties);
        };

        /**
         * Encodes the specified BonusAct message. Does not implicitly {@link pb.BonusAct.verify|verify} messages.
         * @function encode
         * @memberof pb.BonusAct
         * @static
         * @param {pb.IBonusAct} message BonusAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Rewards != null && message.Rewards.length)
                for (var i = 0; i < message.Rewards.length; ++i)
                    $root.pb.BonusReward.encode(message.Rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BonusAct message, length delimited. Does not implicitly {@link pb.BonusAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BonusAct
         * @static
         * @param {pb.IBonusAct} message BonusAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BonusAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BonusAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BonusAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BonusAct} BonusAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BonusAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Rewards && message.Rewards.length))
                        message.Rewards = [];
                    message.Rewards.push($root.pb.BonusReward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BonusAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BonusAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BonusAct} BonusAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BonusAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BonusAct message.
         * @function verify
         * @memberof pb.BonusAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BonusAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Rewards != null && message.hasOwnProperty("Rewards")) {
                if (!Array.isArray(message.Rewards))
                    return "Rewards: array expected";
                for (var i = 0; i < message.Rewards.length; ++i) {
                    var error = $root.pb.BonusReward.verify(message.Rewards[i]);
                    if (error)
                        return "Rewards." + error;
                }
            }
            return null;
        };

        return BonusAct;
    })();

    pb.CopyAct = (function() {

        /**
         * Properties of a CopyAct.
         * @memberof pb
         * @interface ICopyAct
         * @property {number|null} [Target] CopyAct Target
         * @property {pb.ICard|null} [CopyCard] CopyAct CopyCard
         * @property {number|Long|null} [OwnerUid] CopyAct OwnerUid
         */

        /**
         * Constructs a new CopyAct.
         * @memberof pb
         * @classdesc Represents a CopyAct.
         * @implements ICopyAct
         * @constructor
         * @param {pb.ICopyAct=} [properties] Properties to set
         */
        function CopyAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CopyAct Target.
         * @member {number} Target
         * @memberof pb.CopyAct
         * @instance
         */
        CopyAct.prototype.Target = 0;

        /**
         * CopyAct CopyCard.
         * @member {pb.ICard|null|undefined} CopyCard
         * @memberof pb.CopyAct
         * @instance
         */
        CopyAct.prototype.CopyCard = null;

        /**
         * CopyAct OwnerUid.
         * @member {number|Long} OwnerUid
         * @memberof pb.CopyAct
         * @instance
         */
        CopyAct.prototype.OwnerUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new CopyAct instance using the specified properties.
         * @function create
         * @memberof pb.CopyAct
         * @static
         * @param {pb.ICopyAct=} [properties] Properties to set
         * @returns {pb.CopyAct} CopyAct instance
         */
        CopyAct.create = function create(properties) {
            return new CopyAct(properties);
        };

        /**
         * Encodes the specified CopyAct message. Does not implicitly {@link pb.CopyAct.verify|verify} messages.
         * @function encode
         * @memberof pb.CopyAct
         * @static
         * @param {pb.ICopyAct} message CopyAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Target != null && message.hasOwnProperty("Target"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Target);
            if (message.CopyCard != null && message.hasOwnProperty("CopyCard"))
                $root.pb.Card.encode(message.CopyCard, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.OwnerUid != null && message.hasOwnProperty("OwnerUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.OwnerUid);
            return writer;
        };

        /**
         * Encodes the specified CopyAct message, length delimited. Does not implicitly {@link pb.CopyAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CopyAct
         * @static
         * @param {pb.ICopyAct} message CopyAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CopyAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CopyAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CopyAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CopyAct} CopyAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CopyAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Target = reader.int32();
                    break;
                case 2:
                    message.CopyCard = $root.pb.Card.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.OwnerUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CopyAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CopyAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CopyAct} CopyAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CopyAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CopyAct message.
         * @function verify
         * @memberof pb.CopyAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CopyAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Target != null && message.hasOwnProperty("Target"))
                if (!$util.isInteger(message.Target))
                    return "Target: integer expected";
            if (message.CopyCard != null && message.hasOwnProperty("CopyCard")) {
                var error = $root.pb.Card.verify(message.CopyCard);
                if (error)
                    return "CopyCard." + error;
            }
            if (message.OwnerUid != null && message.hasOwnProperty("OwnerUid"))
                if (!$util.isInteger(message.OwnerUid) && !(message.OwnerUid && $util.isInteger(message.OwnerUid.low) && $util.isInteger(message.OwnerUid.high)))
                    return "OwnerUid: integer|Long expected";
            return null;
        };

        return CopyAct;
    })();

    pb.EnterFogAct = (function() {

        /**
         * Properties of an EnterFogAct.
         * @memberof pb
         * @interface IEnterFogAct
         * @property {number|null} [Target] EnterFogAct Target
         * @property {boolean|null} [IsPublicEnemy] EnterFogAct IsPublicEnemy
         */

        /**
         * Constructs a new EnterFogAct.
         * @memberof pb
         * @classdesc Represents an EnterFogAct.
         * @implements IEnterFogAct
         * @constructor
         * @param {pb.IEnterFogAct=} [properties] Properties to set
         */
        function EnterFogAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnterFogAct Target.
         * @member {number} Target
         * @memberof pb.EnterFogAct
         * @instance
         */
        EnterFogAct.prototype.Target = 0;

        /**
         * EnterFogAct IsPublicEnemy.
         * @member {boolean} IsPublicEnemy
         * @memberof pb.EnterFogAct
         * @instance
         */
        EnterFogAct.prototype.IsPublicEnemy = false;

        /**
         * Creates a new EnterFogAct instance using the specified properties.
         * @function create
         * @memberof pb.EnterFogAct
         * @static
         * @param {pb.IEnterFogAct=} [properties] Properties to set
         * @returns {pb.EnterFogAct} EnterFogAct instance
         */
        EnterFogAct.create = function create(properties) {
            return new EnterFogAct(properties);
        };

        /**
         * Encodes the specified EnterFogAct message. Does not implicitly {@link pb.EnterFogAct.verify|verify} messages.
         * @function encode
         * @memberof pb.EnterFogAct
         * @static
         * @param {pb.IEnterFogAct} message EnterFogAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterFogAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Target != null && message.hasOwnProperty("Target"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Target);
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsPublicEnemy);
            return writer;
        };

        /**
         * Encodes the specified EnterFogAct message, length delimited. Does not implicitly {@link pb.EnterFogAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EnterFogAct
         * @static
         * @param {pb.IEnterFogAct} message EnterFogAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EnterFogAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EnterFogAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EnterFogAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EnterFogAct} EnterFogAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterFogAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EnterFogAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Target = reader.int32();
                    break;
                case 3:
                    message.IsPublicEnemy = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EnterFogAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EnterFogAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EnterFogAct} EnterFogAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EnterFogAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EnterFogAct message.
         * @function verify
         * @memberof pb.EnterFogAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnterFogAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Target != null && message.hasOwnProperty("Target"))
                if (!$util.isInteger(message.Target))
                    return "Target: integer expected";
            if (message.IsPublicEnemy != null && message.hasOwnProperty("IsPublicEnemy"))
                if (typeof message.IsPublicEnemy !== "boolean")
                    return "IsPublicEnemy: boolean expected";
            return null;
        };

        return EnterFogAct;
    })();

    pb.LeaveFogAct = (function() {

        /**
         * Properties of a LeaveFogAct.
         * @memberof pb
         * @interface ILeaveFogAct
         * @property {Array.<number>|null} [Targets] LeaveFogAct Targets
         */

        /**
         * Constructs a new LeaveFogAct.
         * @memberof pb
         * @classdesc Represents a LeaveFogAct.
         * @implements ILeaveFogAct
         * @constructor
         * @param {pb.ILeaveFogAct=} [properties] Properties to set
         */
        function LeaveFogAct(properties) {
            this.Targets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaveFogAct Targets.
         * @member {Array.<number>} Targets
         * @memberof pb.LeaveFogAct
         * @instance
         */
        LeaveFogAct.prototype.Targets = $util.emptyArray;

        /**
         * Creates a new LeaveFogAct instance using the specified properties.
         * @function create
         * @memberof pb.LeaveFogAct
         * @static
         * @param {pb.ILeaveFogAct=} [properties] Properties to set
         * @returns {pb.LeaveFogAct} LeaveFogAct instance
         */
        LeaveFogAct.create = function create(properties) {
            return new LeaveFogAct(properties);
        };

        /**
         * Encodes the specified LeaveFogAct message. Does not implicitly {@link pb.LeaveFogAct.verify|verify} messages.
         * @function encode
         * @memberof pb.LeaveFogAct
         * @static
         * @param {pb.ILeaveFogAct} message LeaveFogAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveFogAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Targets != null && message.Targets.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Targets.length; ++i)
                    writer.int32(message.Targets[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LeaveFogAct message, length delimited. Does not implicitly {@link pb.LeaveFogAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LeaveFogAct
         * @static
         * @param {pb.ILeaveFogAct} message LeaveFogAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveFogAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LeaveFogAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LeaveFogAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LeaveFogAct} LeaveFogAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveFogAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LeaveFogAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Targets && message.Targets.length))
                        message.Targets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Targets.push(reader.int32());
                    } else
                        message.Targets.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LeaveFogAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LeaveFogAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LeaveFogAct} LeaveFogAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveFogAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LeaveFogAct message.
         * @function verify
         * @memberof pb.LeaveFogAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LeaveFogAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Targets != null && message.hasOwnProperty("Targets")) {
                if (!Array.isArray(message.Targets))
                    return "Targets: array expected";
                for (var i = 0; i < message.Targets.length; ++i)
                    if (!$util.isInteger(message.Targets[i]))
                        return "Targets: integer[] expected";
            }
            return null;
        };

        return LeaveFogAct;
    })();

    pb.GoldGobAct = (function() {

        /**
         * Properties of a GoldGobAct.
         * @memberof pb
         * @interface IGoldGobAct
         * @property {number|Long|null} [Uid] GoldGobAct Uid
         * @property {number|null} [Gold] GoldGobAct Gold
         * @property {boolean|null} [IsLadder] GoldGobAct IsLadder
         */

        /**
         * Constructs a new GoldGobAct.
         * @memberof pb
         * @classdesc Represents a GoldGobAct.
         * @implements IGoldGobAct
         * @constructor
         * @param {pb.IGoldGobAct=} [properties] Properties to set
         */
        function GoldGobAct(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GoldGobAct Uid.
         * @member {number|Long} Uid
         * @memberof pb.GoldGobAct
         * @instance
         */
        GoldGobAct.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GoldGobAct Gold.
         * @member {number} Gold
         * @memberof pb.GoldGobAct
         * @instance
         */
        GoldGobAct.prototype.Gold = 0;

        /**
         * GoldGobAct IsLadder.
         * @member {boolean} IsLadder
         * @memberof pb.GoldGobAct
         * @instance
         */
        GoldGobAct.prototype.IsLadder = false;

        /**
         * Creates a new GoldGobAct instance using the specified properties.
         * @function create
         * @memberof pb.GoldGobAct
         * @static
         * @param {pb.IGoldGobAct=} [properties] Properties to set
         * @returns {pb.GoldGobAct} GoldGobAct instance
         */
        GoldGobAct.create = function create(properties) {
            return new GoldGobAct(properties);
        };

        /**
         * Encodes the specified GoldGobAct message. Does not implicitly {@link pb.GoldGobAct.verify|verify} messages.
         * @function encode
         * @memberof pb.GoldGobAct
         * @static
         * @param {pb.IGoldGobAct} message GoldGobAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GoldGobAct.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            if (message.IsLadder != null && message.hasOwnProperty("IsLadder"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsLadder);
            return writer;
        };

        /**
         * Encodes the specified GoldGobAct message, length delimited. Does not implicitly {@link pb.GoldGobAct.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GoldGobAct
         * @static
         * @param {pb.IGoldGobAct} message GoldGobAct message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GoldGobAct.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GoldGobAct message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GoldGobAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GoldGobAct} GoldGobAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoldGobAct.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GoldGobAct();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                case 3:
                    message.IsLadder = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GoldGobAct message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GoldGobAct
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GoldGobAct} GoldGobAct
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoldGobAct.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GoldGobAct message.
         * @function verify
         * @memberof pb.GoldGobAct
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GoldGobAct.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.IsLadder != null && message.hasOwnProperty("IsLadder"))
                if (typeof message.IsLadder !== "boolean")
                    return "IsLadder: boolean expected";
            return null;
        };

        return GoldGobAct;
    })();

    pb.CardPool = (function() {

        /**
         * Properties of a CardPool.
         * @memberof pb
         * @interface ICardPool
         * @property {number|null} [PoolId] CardPool PoolId
         * @property {Array.<number>|null} [Cards] CardPool Cards
         * @property {number|null} [Camp] CardPool Camp
         * @property {boolean|null} [IsFight] CardPool IsFight
         */

        /**
         * Constructs a new CardPool.
         * @memberof pb
         * @classdesc Represents a CardPool.
         * @implements ICardPool
         * @constructor
         * @param {pb.ICardPool=} [properties] Properties to set
         */
        function CardPool(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardPool PoolId.
         * @member {number} PoolId
         * @memberof pb.CardPool
         * @instance
         */
        CardPool.prototype.PoolId = 0;

        /**
         * CardPool Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.CardPool
         * @instance
         */
        CardPool.prototype.Cards = $util.emptyArray;

        /**
         * CardPool Camp.
         * @member {number} Camp
         * @memberof pb.CardPool
         * @instance
         */
        CardPool.prototype.Camp = 0;

        /**
         * CardPool IsFight.
         * @member {boolean} IsFight
         * @memberof pb.CardPool
         * @instance
         */
        CardPool.prototype.IsFight = false;

        /**
         * Creates a new CardPool instance using the specified properties.
         * @function create
         * @memberof pb.CardPool
         * @static
         * @param {pb.ICardPool=} [properties] Properties to set
         * @returns {pb.CardPool} CardPool instance
         */
        CardPool.create = function create(properties) {
            return new CardPool(properties);
        };

        /**
         * Encodes the specified CardPool message. Does not implicitly {@link pb.CardPool.verify|verify} messages.
         * @function encode
         * @memberof pb.CardPool
         * @static
         * @param {pb.ICardPool} message CardPool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPool.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PoolId);
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Camp);
            if (message.IsFight != null && message.hasOwnProperty("IsFight"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsFight);
            return writer;
        };

        /**
         * Encodes the specified CardPool message, length delimited. Does not implicitly {@link pb.CardPool.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardPool
         * @static
         * @param {pb.ICardPool} message CardPool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPool.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardPool message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardPool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardPool} CardPool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPool.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardPool();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PoolId = reader.int32();
                    break;
                case 2:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                case 3:
                    message.Camp = reader.int32();
                    break;
                case 4:
                    message.IsFight = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardPool message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardPool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardPool} CardPool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPool.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardPool message.
         * @function verify
         * @memberof pb.CardPool
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardPool.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                if (!$util.isInteger(message.PoolId))
                    return "PoolId: integer expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.IsFight != null && message.hasOwnProperty("IsFight"))
                if (typeof message.IsFight !== "boolean")
                    return "IsFight: boolean expected";
            return null;
        };

        return CardPool;
    })();

    /**
     * CardState enum.
     * @name pb.CardState
     * @enum {string}
     * @property {number} NormalCState=0 NormalCState value
     * @property {number} InCampaignMs=1 InCampaignMs value
     * @property {number} InSeasonPvp=2 InSeasonPvp value
     */
    pb.CardState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NormalCState"] = 0;
        values[valuesById[1] = "InCampaignMs"] = 1;
        values[valuesById[2] = "InSeasonPvp"] = 2;
        return values;
    })();

    pb.CardInfo = (function() {

        /**
         * Properties of a CardInfo.
         * @memberof pb
         * @interface ICardInfo
         * @property {number|null} [CardId] CardInfo CardId
         * @property {number|null} [Level] CardInfo Level
         * @property {number|null} [Amount] CardInfo Amount
         * @property {number|null} [Energy] CardInfo Energy
         * @property {string|null} [Skin] CardInfo Skin
         * @property {string|null} [Equip] CardInfo Equip
         * @property {pb.CardState|null} [State] CardInfo State
         */

        /**
         * Constructs a new CardInfo.
         * @memberof pb
         * @classdesc Represents a CardInfo.
         * @implements ICardInfo
         * @constructor
         * @param {pb.ICardInfo=} [properties] Properties to set
         */
        function CardInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardInfo CardId.
         * @member {number} CardId
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.CardId = 0;

        /**
         * CardInfo Level.
         * @member {number} Level
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.Level = 0;

        /**
         * CardInfo Amount.
         * @member {number} Amount
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.Amount = 0;

        /**
         * CardInfo Energy.
         * @member {number} Energy
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.Energy = 0;

        /**
         * CardInfo Skin.
         * @member {string} Skin
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.Skin = "";

        /**
         * CardInfo Equip.
         * @member {string} Equip
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.Equip = "";

        /**
         * CardInfo State.
         * @member {pb.CardState} State
         * @memberof pb.CardInfo
         * @instance
         */
        CardInfo.prototype.State = 0;

        /**
         * Creates a new CardInfo instance using the specified properties.
         * @function create
         * @memberof pb.CardInfo
         * @static
         * @param {pb.ICardInfo=} [properties] Properties to set
         * @returns {pb.CardInfo} CardInfo instance
         */
        CardInfo.create = function create(properties) {
            return new CardInfo(properties);
        };

        /**
         * Encodes the specified CardInfo message. Does not implicitly {@link pb.CardInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.CardInfo
         * @static
         * @param {pb.ICardInfo} message CardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            if (message.Level != null && message.hasOwnProperty("Level"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Level);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Amount);
            if (message.Energy != null && message.hasOwnProperty("Energy"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.Energy);
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Skin);
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Equip);
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.State);
            return writer;
        };

        /**
         * Encodes the specified CardInfo message, length delimited. Does not implicitly {@link pb.CardInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardInfo
         * @static
         * @param {pb.ICardInfo} message CardInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardInfo} CardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                case 2:
                    message.Level = reader.int32();
                    break;
                case 3:
                    message.Amount = reader.int32();
                    break;
                case 4:
                    message.Energy = reader.float();
                    break;
                case 5:
                    message.Skin = reader.string();
                    break;
                case 6:
                    message.Equip = reader.string();
                    break;
                case 7:
                    message.State = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardInfo} CardInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardInfo message.
         * @function verify
         * @memberof pb.CardInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            if (message.Level != null && message.hasOwnProperty("Level"))
                if (!$util.isInteger(message.Level))
                    return "Level: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.Energy != null && message.hasOwnProperty("Energy"))
                if (typeof message.Energy !== "number")
                    return "Energy: number expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                if (!$util.isString(message.Equip))
                    return "Equip: string expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        return CardInfo;
    })();

    pb.CardPools = (function() {

        /**
         * Properties of a CardPools.
         * @memberof pb
         * @interface ICardPools
         * @property {Array.<pb.ICardPool>|null} [Pools] CardPools Pools
         * @property {number|null} [FightCamp] CardPools FightCamp
         */

        /**
         * Constructs a new CardPools.
         * @memberof pb
         * @classdesc Represents a CardPools.
         * @implements ICardPools
         * @constructor
         * @param {pb.ICardPools=} [properties] Properties to set
         */
        function CardPools(properties) {
            this.Pools = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardPools Pools.
         * @member {Array.<pb.ICardPool>} Pools
         * @memberof pb.CardPools
         * @instance
         */
        CardPools.prototype.Pools = $util.emptyArray;

        /**
         * CardPools FightCamp.
         * @member {number} FightCamp
         * @memberof pb.CardPools
         * @instance
         */
        CardPools.prototype.FightCamp = 0;

        /**
         * Creates a new CardPools instance using the specified properties.
         * @function create
         * @memberof pb.CardPools
         * @static
         * @param {pb.ICardPools=} [properties] Properties to set
         * @returns {pb.CardPools} CardPools instance
         */
        CardPools.create = function create(properties) {
            return new CardPools(properties);
        };

        /**
         * Encodes the specified CardPools message. Does not implicitly {@link pb.CardPools.verify|verify} messages.
         * @function encode
         * @memberof pb.CardPools
         * @static
         * @param {pb.ICardPools} message CardPools message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPools.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Pools != null && message.Pools.length)
                for (var i = 0; i < message.Pools.length; ++i)
                    $root.pb.CardPool.encode(message.Pools[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.FightCamp != null && message.hasOwnProperty("FightCamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.FightCamp);
            return writer;
        };

        /**
         * Encodes the specified CardPools message, length delimited. Does not implicitly {@link pb.CardPools.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardPools
         * @static
         * @param {pb.ICardPools} message CardPools message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPools.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardPools message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardPools
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardPools} CardPools
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPools.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardPools();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Pools && message.Pools.length))
                        message.Pools = [];
                    message.Pools.push($root.pb.CardPool.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.FightCamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardPools message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardPools
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardPools} CardPools
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPools.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardPools message.
         * @function verify
         * @memberof pb.CardPools
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardPools.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Pools != null && message.hasOwnProperty("Pools")) {
                if (!Array.isArray(message.Pools))
                    return "Pools: array expected";
                for (var i = 0; i < message.Pools.length; ++i) {
                    var error = $root.pb.CardPool.verify(message.Pools[i]);
                    if (error)
                        return "Pools." + error;
                }
            }
            if (message.FightCamp != null && message.hasOwnProperty("FightCamp"))
                if (!$util.isInteger(message.FightCamp))
                    return "FightCamp: integer expected";
            return null;
        };

        return CardPools;
    })();

    pb.CardDatas = (function() {

        /**
         * Properties of a CardDatas.
         * @memberof pb
         * @interface ICardDatas
         * @property {Array.<pb.ICardInfo>|null} [Cards] CardDatas Cards
         * @property {Array.<pb.IDiyCardData>|null} [DiyCards] CardDatas DiyCards
         */

        /**
         * Constructs a new CardDatas.
         * @memberof pb
         * @classdesc Represents a CardDatas.
         * @implements ICardDatas
         * @constructor
         * @param {pb.ICardDatas=} [properties] Properties to set
         */
        function CardDatas(properties) {
            this.Cards = [];
            this.DiyCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardDatas Cards.
         * @member {Array.<pb.ICardInfo>} Cards
         * @memberof pb.CardDatas
         * @instance
         */
        CardDatas.prototype.Cards = $util.emptyArray;

        /**
         * CardDatas DiyCards.
         * @member {Array.<pb.IDiyCardData>} DiyCards
         * @memberof pb.CardDatas
         * @instance
         */
        CardDatas.prototype.DiyCards = $util.emptyArray;

        /**
         * Creates a new CardDatas instance using the specified properties.
         * @function create
         * @memberof pb.CardDatas
         * @static
         * @param {pb.ICardDatas=} [properties] Properties to set
         * @returns {pb.CardDatas} CardDatas instance
         */
        CardDatas.create = function create(properties) {
            return new CardDatas(properties);
        };

        /**
         * Encodes the specified CardDatas message. Does not implicitly {@link pb.CardDatas.verify|verify} messages.
         * @function encode
         * @memberof pb.CardDatas
         * @static
         * @param {pb.ICardDatas} message CardDatas message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardDatas.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Cards != null && message.Cards.length)
                for (var i = 0; i < message.Cards.length; ++i)
                    $root.pb.CardInfo.encode(message.Cards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.DiyCards != null && message.DiyCards.length)
                for (var i = 0; i < message.DiyCards.length; ++i)
                    $root.pb.DiyCardData.encode(message.DiyCards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CardDatas message, length delimited. Does not implicitly {@link pb.CardDatas.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardDatas
         * @static
         * @param {pb.ICardDatas} message CardDatas message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardDatas.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardDatas message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardDatas} CardDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardDatas.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardDatas();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    message.Cards.push($root.pb.CardInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.DiyCards && message.DiyCards.length))
                        message.DiyCards = [];
                    message.DiyCards.push($root.pb.DiyCardData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardDatas message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardDatas
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardDatas} CardDatas
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardDatas.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardDatas message.
         * @function verify
         * @memberof pb.CardDatas
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardDatas.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i) {
                    var error = $root.pb.CardInfo.verify(message.Cards[i]);
                    if (error)
                        return "Cards." + error;
                }
            }
            if (message.DiyCards != null && message.hasOwnProperty("DiyCards")) {
                if (!Array.isArray(message.DiyCards))
                    return "DiyCards: array expected";
                for (var i = 0; i < message.DiyCards.length; ++i) {
                    var error = $root.pb.DiyCardData.verify(message.DiyCards[i]);
                    if (error)
                        return "DiyCards." + error;
                }
            }
            return null;
        };

        return CardDatas;
    })();

    pb.PoolAddCard = (function() {

        /**
         * Properties of a PoolAddCard.
         * @memberof pb
         * @interface IPoolAddCard
         * @property {number|null} [Card] PoolAddCard Card
         * @property {number|null} [Idx] PoolAddCard Idx
         * @property {number|null} [PoolId] PoolAddCard PoolId
         */

        /**
         * Constructs a new PoolAddCard.
         * @memberof pb
         * @classdesc Represents a PoolAddCard.
         * @implements IPoolAddCard
         * @constructor
         * @param {pb.IPoolAddCard=} [properties] Properties to set
         */
        function PoolAddCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PoolAddCard Card.
         * @member {number} Card
         * @memberof pb.PoolAddCard
         * @instance
         */
        PoolAddCard.prototype.Card = 0;

        /**
         * PoolAddCard Idx.
         * @member {number} Idx
         * @memberof pb.PoolAddCard
         * @instance
         */
        PoolAddCard.prototype.Idx = 0;

        /**
         * PoolAddCard PoolId.
         * @member {number} PoolId
         * @memberof pb.PoolAddCard
         * @instance
         */
        PoolAddCard.prototype.PoolId = 0;

        /**
         * Creates a new PoolAddCard instance using the specified properties.
         * @function create
         * @memberof pb.PoolAddCard
         * @static
         * @param {pb.IPoolAddCard=} [properties] Properties to set
         * @returns {pb.PoolAddCard} PoolAddCard instance
         */
        PoolAddCard.create = function create(properties) {
            return new PoolAddCard(properties);
        };

        /**
         * Encodes the specified PoolAddCard message. Does not implicitly {@link pb.PoolAddCard.verify|verify} messages.
         * @function encode
         * @memberof pb.PoolAddCard
         * @static
         * @param {pb.IPoolAddCard} message PoolAddCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoolAddCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Card != null && message.hasOwnProperty("Card"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.Card);
            if (message.Idx != null && message.hasOwnProperty("Idx"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Idx);
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PoolId);
            return writer;
        };

        /**
         * Encodes the specified PoolAddCard message, length delimited. Does not implicitly {@link pb.PoolAddCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PoolAddCard
         * @static
         * @param {pb.IPoolAddCard} message PoolAddCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoolAddCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PoolAddCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PoolAddCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PoolAddCard} PoolAddCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoolAddCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PoolAddCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Card = reader.uint32();
                    break;
                case 2:
                    message.Idx = reader.int32();
                    break;
                case 3:
                    message.PoolId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PoolAddCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PoolAddCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PoolAddCard} PoolAddCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoolAddCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PoolAddCard message.
         * @function verify
         * @memberof pb.PoolAddCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PoolAddCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Card != null && message.hasOwnProperty("Card"))
                if (!$util.isInteger(message.Card))
                    return "Card: integer expected";
            if (message.Idx != null && message.hasOwnProperty("Idx"))
                if (!$util.isInteger(message.Idx))
                    return "Idx: integer expected";
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                if (!$util.isInteger(message.PoolId))
                    return "PoolId: integer expected";
            return null;
        };

        return PoolAddCard;
    })();

    pb.PoolUpdateCard = (function() {

        /**
         * Properties of a PoolUpdateCard.
         * @memberof pb
         * @interface IPoolUpdateCard
         * @property {number|null} [PoolId] PoolUpdateCard PoolId
         * @property {Array.<number>|null} [Cards] PoolUpdateCard Cards
         */

        /**
         * Constructs a new PoolUpdateCard.
         * @memberof pb
         * @classdesc Represents a PoolUpdateCard.
         * @implements IPoolUpdateCard
         * @constructor
         * @param {pb.IPoolUpdateCard=} [properties] Properties to set
         */
        function PoolUpdateCard(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PoolUpdateCard PoolId.
         * @member {number} PoolId
         * @memberof pb.PoolUpdateCard
         * @instance
         */
        PoolUpdateCard.prototype.PoolId = 0;

        /**
         * PoolUpdateCard Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.PoolUpdateCard
         * @instance
         */
        PoolUpdateCard.prototype.Cards = $util.emptyArray;

        /**
         * Creates a new PoolUpdateCard instance using the specified properties.
         * @function create
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {pb.IPoolUpdateCard=} [properties] Properties to set
         * @returns {pb.PoolUpdateCard} PoolUpdateCard instance
         */
        PoolUpdateCard.create = function create(properties) {
            return new PoolUpdateCard(properties);
        };

        /**
         * Encodes the specified PoolUpdateCard message. Does not implicitly {@link pb.PoolUpdateCard.verify|verify} messages.
         * @function encode
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {pb.IPoolUpdateCard} message PoolUpdateCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoolUpdateCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PoolId);
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified PoolUpdateCard message, length delimited. Does not implicitly {@link pb.PoolUpdateCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {pb.IPoolUpdateCard} message PoolUpdateCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PoolUpdateCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PoolUpdateCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PoolUpdateCard} PoolUpdateCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoolUpdateCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PoolUpdateCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PoolId = reader.int32();
                    break;
                case 2:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PoolUpdateCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PoolUpdateCard} PoolUpdateCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PoolUpdateCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PoolUpdateCard message.
         * @function verify
         * @memberof pb.PoolUpdateCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PoolUpdateCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                if (!$util.isInteger(message.PoolId))
                    return "PoolId: integer expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            return null;
        };

        return PoolUpdateCard;
    })();

    pb.FightPool = (function() {

        /**
         * Properties of a FightPool.
         * @memberof pb
         * @interface IFightPool
         * @property {number|null} [PoolId] FightPool PoolId
         * @property {number|null} [Camp] FightPool Camp
         */

        /**
         * Constructs a new FightPool.
         * @memberof pb
         * @classdesc Represents a FightPool.
         * @implements IFightPool
         * @constructor
         * @param {pb.IFightPool=} [properties] Properties to set
         */
        function FightPool(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightPool PoolId.
         * @member {number} PoolId
         * @memberof pb.FightPool
         * @instance
         */
        FightPool.prototype.PoolId = 0;

        /**
         * FightPool Camp.
         * @member {number} Camp
         * @memberof pb.FightPool
         * @instance
         */
        FightPool.prototype.Camp = 0;

        /**
         * Creates a new FightPool instance using the specified properties.
         * @function create
         * @memberof pb.FightPool
         * @static
         * @param {pb.IFightPool=} [properties] Properties to set
         * @returns {pb.FightPool} FightPool instance
         */
        FightPool.create = function create(properties) {
            return new FightPool(properties);
        };

        /**
         * Encodes the specified FightPool message. Does not implicitly {@link pb.FightPool.verify|verify} messages.
         * @function encode
         * @memberof pb.FightPool
         * @static
         * @param {pb.IFightPool} message FightPool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightPool.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PoolId);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Camp);
            return writer;
        };

        /**
         * Encodes the specified FightPool message, length delimited. Does not implicitly {@link pb.FightPool.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FightPool
         * @static
         * @param {pb.IFightPool} message FightPool message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightPool.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightPool message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FightPool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FightPool} FightPool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightPool.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FightPool();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PoolId = reader.int32();
                    break;
                case 2:
                    message.Camp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightPool message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FightPool
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FightPool} FightPool
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightPool.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightPool message.
         * @function verify
         * @memberof pb.FightPool
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightPool.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PoolId != null && message.hasOwnProperty("PoolId"))
                if (!$util.isInteger(message.PoolId))
                    return "PoolId: integer expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            return null;
        };

        return FightPool;
    })();

    pb.UpdateCardPools = (function() {

        /**
         * Properties of an UpdateCardPools.
         * @memberof pb
         * @interface IUpdateCardPools
         * @property {Array.<pb.IFightPool>|null} [Pools] UpdateCardPools Pools
         * @property {number|null} [FightCamp] UpdateCardPools FightCamp
         */

        /**
         * Constructs a new UpdateCardPools.
         * @memberof pb
         * @classdesc Represents an UpdateCardPools.
         * @implements IUpdateCardPools
         * @constructor
         * @param {pb.IUpdateCardPools=} [properties] Properties to set
         */
        function UpdateCardPools(properties) {
            this.Pools = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateCardPools Pools.
         * @member {Array.<pb.IFightPool>} Pools
         * @memberof pb.UpdateCardPools
         * @instance
         */
        UpdateCardPools.prototype.Pools = $util.emptyArray;

        /**
         * UpdateCardPools FightCamp.
         * @member {number} FightCamp
         * @memberof pb.UpdateCardPools
         * @instance
         */
        UpdateCardPools.prototype.FightCamp = 0;

        /**
         * Creates a new UpdateCardPools instance using the specified properties.
         * @function create
         * @memberof pb.UpdateCardPools
         * @static
         * @param {pb.IUpdateCardPools=} [properties] Properties to set
         * @returns {pb.UpdateCardPools} UpdateCardPools instance
         */
        UpdateCardPools.create = function create(properties) {
            return new UpdateCardPools(properties);
        };

        /**
         * Encodes the specified UpdateCardPools message. Does not implicitly {@link pb.UpdateCardPools.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateCardPools
         * @static
         * @param {pb.IUpdateCardPools} message UpdateCardPools message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCardPools.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Pools != null && message.Pools.length)
                for (var i = 0; i < message.Pools.length; ++i)
                    $root.pb.FightPool.encode(message.Pools[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.FightCamp != null && message.hasOwnProperty("FightCamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.FightCamp);
            return writer;
        };

        /**
         * Encodes the specified UpdateCardPools message, length delimited. Does not implicitly {@link pb.UpdateCardPools.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateCardPools
         * @static
         * @param {pb.IUpdateCardPools} message UpdateCardPools message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCardPools.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateCardPools message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateCardPools
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateCardPools} UpdateCardPools
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCardPools.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateCardPools();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Pools && message.Pools.length))
                        message.Pools = [];
                    message.Pools.push($root.pb.FightPool.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.FightCamp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateCardPools message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateCardPools
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateCardPools} UpdateCardPools
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCardPools.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateCardPools message.
         * @function verify
         * @memberof pb.UpdateCardPools
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateCardPools.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Pools != null && message.hasOwnProperty("Pools")) {
                if (!Array.isArray(message.Pools))
                    return "Pools: array expected";
                for (var i = 0; i < message.Pools.length; ++i) {
                    var error = $root.pb.FightPool.verify(message.Pools[i]);
                    if (error)
                        return "Pools." + error;
                }
            }
            if (message.FightCamp != null && message.hasOwnProperty("FightCamp"))
                if (!$util.isInteger(message.FightCamp))
                    return "FightCamp: integer expected";
            return null;
        };

        return UpdateCardPools;
    })();

    pb.TargetCard = (function() {

        /**
         * Properties of a TargetCard.
         * @memberof pb
         * @interface ITargetCard
         * @property {number|null} [CardId] TargetCard CardId
         */

        /**
         * Constructs a new TargetCard.
         * @memberof pb
         * @classdesc Represents a TargetCard.
         * @implements ITargetCard
         * @constructor
         * @param {pb.ITargetCard=} [properties] Properties to set
         */
        function TargetCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetCard CardId.
         * @member {number} CardId
         * @memberof pb.TargetCard
         * @instance
         */
        TargetCard.prototype.CardId = 0;

        /**
         * Creates a new TargetCard instance using the specified properties.
         * @function create
         * @memberof pb.TargetCard
         * @static
         * @param {pb.ITargetCard=} [properties] Properties to set
         * @returns {pb.TargetCard} TargetCard instance
         */
        TargetCard.create = function create(properties) {
            return new TargetCard(properties);
        };

        /**
         * Encodes the specified TargetCard message. Does not implicitly {@link pb.TargetCard.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetCard
         * @static
         * @param {pb.ITargetCard} message TargetCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            return writer;
        };

        /**
         * Encodes the specified TargetCard message, length delimited. Does not implicitly {@link pb.TargetCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetCard
         * @static
         * @param {pb.ITargetCard} message TargetCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetCard} TargetCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetCard} TargetCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetCard message.
         * @function verify
         * @memberof pb.TargetCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            return null;
        };

        return TargetCard;
    })();

    pb.DiyCardArg = (function() {

        /**
         * Properties of a DiyCardArg.
         * @memberof pb
         * @interface IDiyCardArg
         * @property {string|null} [Name] DiyCardArg Name
         * @property {number|null} [DiySkillId1] DiyCardArg DiySkillId1
         * @property {number|null} [DiySkillId2] DiyCardArg DiySkillId2
         * @property {string|null} [Weapon] DiyCardArg Weapon
         * @property {string|null} [Img] DiyCardArg Img
         */

        /**
         * Constructs a new DiyCardArg.
         * @memberof pb
         * @classdesc Represents a DiyCardArg.
         * @implements IDiyCardArg
         * @constructor
         * @param {pb.IDiyCardArg=} [properties] Properties to set
         */
        function DiyCardArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiyCardArg Name.
         * @member {string} Name
         * @memberof pb.DiyCardArg
         * @instance
         */
        DiyCardArg.prototype.Name = "";

        /**
         * DiyCardArg DiySkillId1.
         * @member {number} DiySkillId1
         * @memberof pb.DiyCardArg
         * @instance
         */
        DiyCardArg.prototype.DiySkillId1 = 0;

        /**
         * DiyCardArg DiySkillId2.
         * @member {number} DiySkillId2
         * @memberof pb.DiyCardArg
         * @instance
         */
        DiyCardArg.prototype.DiySkillId2 = 0;

        /**
         * DiyCardArg Weapon.
         * @member {string} Weapon
         * @memberof pb.DiyCardArg
         * @instance
         */
        DiyCardArg.prototype.Weapon = "";

        /**
         * DiyCardArg Img.
         * @member {string} Img
         * @memberof pb.DiyCardArg
         * @instance
         */
        DiyCardArg.prototype.Img = "";

        /**
         * Creates a new DiyCardArg instance using the specified properties.
         * @function create
         * @memberof pb.DiyCardArg
         * @static
         * @param {pb.IDiyCardArg=} [properties] Properties to set
         * @returns {pb.DiyCardArg} DiyCardArg instance
         */
        DiyCardArg.create = function create(properties) {
            return new DiyCardArg(properties);
        };

        /**
         * Encodes the specified DiyCardArg message. Does not implicitly {@link pb.DiyCardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.DiyCardArg
         * @static
         * @param {pb.IDiyCardArg} message DiyCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.DiySkillId1);
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.DiySkillId2);
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Weapon);
            if (message.Img != null && message.hasOwnProperty("Img"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Img);
            return writer;
        };

        /**
         * Encodes the specified DiyCardArg message, length delimited. Does not implicitly {@link pb.DiyCardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DiyCardArg
         * @static
         * @param {pb.IDiyCardArg} message DiyCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiyCardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DiyCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DiyCardArg} DiyCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiyCardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.DiySkillId1 = reader.int32();
                    break;
                case 3:
                    message.DiySkillId2 = reader.int32();
                    break;
                case 4:
                    message.Weapon = reader.string();
                    break;
                case 5:
                    message.Img = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DiyCardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DiyCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DiyCardArg} DiyCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiyCardArg message.
         * @function verify
         * @memberof pb.DiyCardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiyCardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                if (!$util.isInteger(message.DiySkillId1))
                    return "DiySkillId1: integer expected";
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                if (!$util.isInteger(message.DiySkillId2))
                    return "DiySkillId2: integer expected";
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                if (!$util.isString(message.Weapon))
                    return "Weapon: string expected";
            if (message.Img != null && message.hasOwnProperty("Img"))
                if (!$util.isString(message.Img))
                    return "Img: string expected";
            return null;
        };

        return DiyCardArg;
    })();

    pb.DiyCardReply = (function() {

        /**
         * Properties of a DiyCardReply.
         * @memberof pb
         * @interface IDiyCardReply
         * @property {number|null} [CardId] DiyCardReply CardId
         * @property {number|null} [MinUp] DiyCardReply MinUp
         * @property {number|null} [MaxUp] DiyCardReply MaxUp
         * @property {number|null} [MinDown] DiyCardReply MinDown
         * @property {number|null} [MaxDown] DiyCardReply MaxDown
         * @property {number|null} [MinLeft] DiyCardReply MinLeft
         * @property {number|null} [MaxLeft] DiyCardReply MaxLeft
         * @property {number|null} [MinRight] DiyCardReply MinRight
         * @property {number|null} [MaxRight] DiyCardReply MaxRight
         */

        /**
         * Constructs a new DiyCardReply.
         * @memberof pb
         * @classdesc Represents a DiyCardReply.
         * @implements IDiyCardReply
         * @constructor
         * @param {pb.IDiyCardReply=} [properties] Properties to set
         */
        function DiyCardReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiyCardReply CardId.
         * @member {number} CardId
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.CardId = 0;

        /**
         * DiyCardReply MinUp.
         * @member {number} MinUp
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MinUp = 0;

        /**
         * DiyCardReply MaxUp.
         * @member {number} MaxUp
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MaxUp = 0;

        /**
         * DiyCardReply MinDown.
         * @member {number} MinDown
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MinDown = 0;

        /**
         * DiyCardReply MaxDown.
         * @member {number} MaxDown
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MaxDown = 0;

        /**
         * DiyCardReply MinLeft.
         * @member {number} MinLeft
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MinLeft = 0;

        /**
         * DiyCardReply MaxLeft.
         * @member {number} MaxLeft
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MaxLeft = 0;

        /**
         * DiyCardReply MinRight.
         * @member {number} MinRight
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MinRight = 0;

        /**
         * DiyCardReply MaxRight.
         * @member {number} MaxRight
         * @memberof pb.DiyCardReply
         * @instance
         */
        DiyCardReply.prototype.MaxRight = 0;

        /**
         * Creates a new DiyCardReply instance using the specified properties.
         * @function create
         * @memberof pb.DiyCardReply
         * @static
         * @param {pb.IDiyCardReply=} [properties] Properties to set
         * @returns {pb.DiyCardReply} DiyCardReply instance
         */
        DiyCardReply.create = function create(properties) {
            return new DiyCardReply(properties);
        };

        /**
         * Encodes the specified DiyCardReply message. Does not implicitly {@link pb.DiyCardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.DiyCardReply
         * @static
         * @param {pb.IDiyCardReply} message DiyCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            if (message.MinUp != null && message.hasOwnProperty("MinUp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MinUp);
            if (message.MaxUp != null && message.hasOwnProperty("MaxUp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MaxUp);
            if (message.MinDown != null && message.hasOwnProperty("MinDown"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MinDown);
            if (message.MaxDown != null && message.hasOwnProperty("MaxDown"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MaxDown);
            if (message.MinLeft != null && message.hasOwnProperty("MinLeft"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.MinLeft);
            if (message.MaxLeft != null && message.hasOwnProperty("MaxLeft"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.MaxLeft);
            if (message.MinRight != null && message.hasOwnProperty("MinRight"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.MinRight);
            if (message.MaxRight != null && message.hasOwnProperty("MaxRight"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.MaxRight);
            return writer;
        };

        /**
         * Encodes the specified DiyCardReply message, length delimited. Does not implicitly {@link pb.DiyCardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DiyCardReply
         * @static
         * @param {pb.IDiyCardReply} message DiyCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiyCardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DiyCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DiyCardReply} DiyCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiyCardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                case 2:
                    message.MinUp = reader.int32();
                    break;
                case 3:
                    message.MaxUp = reader.int32();
                    break;
                case 4:
                    message.MinDown = reader.int32();
                    break;
                case 5:
                    message.MaxDown = reader.int32();
                    break;
                case 6:
                    message.MinLeft = reader.int32();
                    break;
                case 7:
                    message.MaxLeft = reader.int32();
                    break;
                case 8:
                    message.MinRight = reader.int32();
                    break;
                case 9:
                    message.MaxRight = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DiyCardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DiyCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DiyCardReply} DiyCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiyCardReply message.
         * @function verify
         * @memberof pb.DiyCardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiyCardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            if (message.MinUp != null && message.hasOwnProperty("MinUp"))
                if (!$util.isInteger(message.MinUp))
                    return "MinUp: integer expected";
            if (message.MaxUp != null && message.hasOwnProperty("MaxUp"))
                if (!$util.isInteger(message.MaxUp))
                    return "MaxUp: integer expected";
            if (message.MinDown != null && message.hasOwnProperty("MinDown"))
                if (!$util.isInteger(message.MinDown))
                    return "MinDown: integer expected";
            if (message.MaxDown != null && message.hasOwnProperty("MaxDown"))
                if (!$util.isInteger(message.MaxDown))
                    return "MaxDown: integer expected";
            if (message.MinLeft != null && message.hasOwnProperty("MinLeft"))
                if (!$util.isInteger(message.MinLeft))
                    return "MinLeft: integer expected";
            if (message.MaxLeft != null && message.hasOwnProperty("MaxLeft"))
                if (!$util.isInteger(message.MaxLeft))
                    return "MaxLeft: integer expected";
            if (message.MinRight != null && message.hasOwnProperty("MinRight"))
                if (!$util.isInteger(message.MinRight))
                    return "MinRight: integer expected";
            if (message.MaxRight != null && message.hasOwnProperty("MaxRight"))
                if (!$util.isInteger(message.MaxRight))
                    return "MaxRight: integer expected";
            return null;
        };

        return DiyCardReply;
    })();

    pb.DiyCardData = (function() {

        /**
         * Properties of a DiyCardData.
         * @memberof pb
         * @interface IDiyCardData
         * @property {number|null} [CardId] DiyCardData CardId
         * @property {string|null} [Name] DiyCardData Name
         * @property {number|null} [DiySkillId1] DiyCardData DiySkillId1
         * @property {number|null} [DiySkillId2] DiyCardData DiySkillId2
         * @property {number|null} [MinUp] DiyCardData MinUp
         * @property {number|null} [MaxUp] DiyCardData MaxUp
         * @property {number|null} [MinDown] DiyCardData MinDown
         * @property {number|null} [MaxDown] DiyCardData MaxDown
         * @property {number|null} [MinLeft] DiyCardData MinLeft
         * @property {number|null} [MaxLeft] DiyCardData MaxLeft
         * @property {number|null} [MinRight] DiyCardData MinRight
         * @property {number|null} [MaxRight] DiyCardData MaxRight
         * @property {string|null} [Weapon] DiyCardData Weapon
         */

        /**
         * Constructs a new DiyCardData.
         * @memberof pb
         * @classdesc Represents a DiyCardData.
         * @implements IDiyCardData
         * @constructor
         * @param {pb.IDiyCardData=} [properties] Properties to set
         */
        function DiyCardData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiyCardData CardId.
         * @member {number} CardId
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.CardId = 0;

        /**
         * DiyCardData Name.
         * @member {string} Name
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.Name = "";

        /**
         * DiyCardData DiySkillId1.
         * @member {number} DiySkillId1
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.DiySkillId1 = 0;

        /**
         * DiyCardData DiySkillId2.
         * @member {number} DiySkillId2
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.DiySkillId2 = 0;

        /**
         * DiyCardData MinUp.
         * @member {number} MinUp
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MinUp = 0;

        /**
         * DiyCardData MaxUp.
         * @member {number} MaxUp
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MaxUp = 0;

        /**
         * DiyCardData MinDown.
         * @member {number} MinDown
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MinDown = 0;

        /**
         * DiyCardData MaxDown.
         * @member {number} MaxDown
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MaxDown = 0;

        /**
         * DiyCardData MinLeft.
         * @member {number} MinLeft
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MinLeft = 0;

        /**
         * DiyCardData MaxLeft.
         * @member {number} MaxLeft
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MaxLeft = 0;

        /**
         * DiyCardData MinRight.
         * @member {number} MinRight
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MinRight = 0;

        /**
         * DiyCardData MaxRight.
         * @member {number} MaxRight
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.MaxRight = 0;

        /**
         * DiyCardData Weapon.
         * @member {string} Weapon
         * @memberof pb.DiyCardData
         * @instance
         */
        DiyCardData.prototype.Weapon = "";

        /**
         * Creates a new DiyCardData instance using the specified properties.
         * @function create
         * @memberof pb.DiyCardData
         * @static
         * @param {pb.IDiyCardData=} [properties] Properties to set
         * @returns {pb.DiyCardData} DiyCardData instance
         */
        DiyCardData.create = function create(properties) {
            return new DiyCardData(properties);
        };

        /**
         * Encodes the specified DiyCardData message. Does not implicitly {@link pb.DiyCardData.verify|verify} messages.
         * @function encode
         * @memberof pb.DiyCardData
         * @static
         * @param {pb.IDiyCardData} message DiyCardData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.DiySkillId1);
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.DiySkillId2);
            if (message.MinUp != null && message.hasOwnProperty("MinUp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MinUp);
            if (message.MaxUp != null && message.hasOwnProperty("MaxUp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.MaxUp);
            if (message.MinDown != null && message.hasOwnProperty("MinDown"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.MinDown);
            if (message.MaxDown != null && message.hasOwnProperty("MaxDown"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.MaxDown);
            if (message.MinLeft != null && message.hasOwnProperty("MinLeft"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.MinLeft);
            if (message.MaxLeft != null && message.hasOwnProperty("MaxLeft"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.MaxLeft);
            if (message.MinRight != null && message.hasOwnProperty("MinRight"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.MinRight);
            if (message.MaxRight != null && message.hasOwnProperty("MaxRight"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.MaxRight);
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                writer.uint32(/* id 13, wireType 2 =*/106).string(message.Weapon);
            return writer;
        };

        /**
         * Encodes the specified DiyCardData message, length delimited. Does not implicitly {@link pb.DiyCardData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DiyCardData
         * @static
         * @param {pb.IDiyCardData} message DiyCardData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiyCardData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DiyCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DiyCardData} DiyCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiyCardData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.DiySkillId1 = reader.int32();
                    break;
                case 4:
                    message.DiySkillId2 = reader.int32();
                    break;
                case 5:
                    message.MinUp = reader.int32();
                    break;
                case 6:
                    message.MaxUp = reader.int32();
                    break;
                case 7:
                    message.MinDown = reader.int32();
                    break;
                case 8:
                    message.MaxDown = reader.int32();
                    break;
                case 9:
                    message.MinLeft = reader.int32();
                    break;
                case 10:
                    message.MaxLeft = reader.int32();
                    break;
                case 11:
                    message.MinRight = reader.int32();
                    break;
                case 12:
                    message.MaxRight = reader.int32();
                    break;
                case 13:
                    message.Weapon = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DiyCardData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DiyCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DiyCardData} DiyCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiyCardData message.
         * @function verify
         * @memberof pb.DiyCardData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiyCardData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.DiySkillId1 != null && message.hasOwnProperty("DiySkillId1"))
                if (!$util.isInteger(message.DiySkillId1))
                    return "DiySkillId1: integer expected";
            if (message.DiySkillId2 != null && message.hasOwnProperty("DiySkillId2"))
                if (!$util.isInteger(message.DiySkillId2))
                    return "DiySkillId2: integer expected";
            if (message.MinUp != null && message.hasOwnProperty("MinUp"))
                if (!$util.isInteger(message.MinUp))
                    return "MinUp: integer expected";
            if (message.MaxUp != null && message.hasOwnProperty("MaxUp"))
                if (!$util.isInteger(message.MaxUp))
                    return "MaxUp: integer expected";
            if (message.MinDown != null && message.hasOwnProperty("MinDown"))
                if (!$util.isInteger(message.MinDown))
                    return "MinDown: integer expected";
            if (message.MaxDown != null && message.hasOwnProperty("MaxDown"))
                if (!$util.isInteger(message.MaxDown))
                    return "MaxDown: integer expected";
            if (message.MinLeft != null && message.hasOwnProperty("MinLeft"))
                if (!$util.isInteger(message.MinLeft))
                    return "MinLeft: integer expected";
            if (message.MaxLeft != null && message.hasOwnProperty("MaxLeft"))
                if (!$util.isInteger(message.MaxLeft))
                    return "MaxLeft: integer expected";
            if (message.MinRight != null && message.hasOwnProperty("MinRight"))
                if (!$util.isInteger(message.MinRight))
                    return "MinRight: integer expected";
            if (message.MaxRight != null && message.hasOwnProperty("MaxRight"))
                if (!$util.isInteger(message.MaxRight))
                    return "MaxRight: integer expected";
            if (message.Weapon != null && message.hasOwnProperty("Weapon"))
                if (!$util.isString(message.Weapon))
                    return "Weapon: string expected";
            return null;
        };

        return DiyCardData;
    })();

    pb.DiyCardImg = (function() {

        /**
         * Properties of a DiyCardImg.
         * @memberof pb
         * @interface IDiyCardImg
         * @property {string|null} [Img] DiyCardImg Img
         */

        /**
         * Constructs a new DiyCardImg.
         * @memberof pb
         * @classdesc Represents a DiyCardImg.
         * @implements IDiyCardImg
         * @constructor
         * @param {pb.IDiyCardImg=} [properties] Properties to set
         */
        function DiyCardImg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DiyCardImg Img.
         * @member {string} Img
         * @memberof pb.DiyCardImg
         * @instance
         */
        DiyCardImg.prototype.Img = "";

        /**
         * Creates a new DiyCardImg instance using the specified properties.
         * @function create
         * @memberof pb.DiyCardImg
         * @static
         * @param {pb.IDiyCardImg=} [properties] Properties to set
         * @returns {pb.DiyCardImg} DiyCardImg instance
         */
        DiyCardImg.create = function create(properties) {
            return new DiyCardImg(properties);
        };

        /**
         * Encodes the specified DiyCardImg message. Does not implicitly {@link pb.DiyCardImg.verify|verify} messages.
         * @function encode
         * @memberof pb.DiyCardImg
         * @static
         * @param {pb.IDiyCardImg} message DiyCardImg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardImg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Img != null && message.hasOwnProperty("Img"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Img);
            return writer;
        };

        /**
         * Encodes the specified DiyCardImg message, length delimited. Does not implicitly {@link pb.DiyCardImg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DiyCardImg
         * @static
         * @param {pb.IDiyCardImg} message DiyCardImg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DiyCardImg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DiyCardImg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DiyCardImg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DiyCardImg} DiyCardImg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardImg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DiyCardImg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Img = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DiyCardImg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DiyCardImg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DiyCardImg} DiyCardImg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DiyCardImg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DiyCardImg message.
         * @function verify
         * @memberof pb.DiyCardImg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DiyCardImg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Img != null && message.hasOwnProperty("Img"))
                if (!$util.isString(message.Img))
                    return "Img: string expected";
            return null;
        };

        return DiyCardImg;
    })();

    pb.AddCardSkinArg = (function() {

        /**
         * Properties of an AddCardSkinArg.
         * @memberof pb
         * @interface IAddCardSkinArg
         * @property {string|null} [Skin] AddCardSkinArg Skin
         */

        /**
         * Constructs a new AddCardSkinArg.
         * @memberof pb
         * @classdesc Represents an AddCardSkinArg.
         * @implements IAddCardSkinArg
         * @constructor
         * @param {pb.IAddCardSkinArg=} [properties] Properties to set
         */
        function AddCardSkinArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddCardSkinArg Skin.
         * @member {string} Skin
         * @memberof pb.AddCardSkinArg
         * @instance
         */
        AddCardSkinArg.prototype.Skin = "";

        /**
         * Creates a new AddCardSkinArg instance using the specified properties.
         * @function create
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {pb.IAddCardSkinArg=} [properties] Properties to set
         * @returns {pb.AddCardSkinArg} AddCardSkinArg instance
         */
        AddCardSkinArg.create = function create(properties) {
            return new AddCardSkinArg(properties);
        };

        /**
         * Encodes the specified AddCardSkinArg message. Does not implicitly {@link pb.AddCardSkinArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {pb.IAddCardSkinArg} message AddCardSkinArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddCardSkinArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Skin);
            return writer;
        };

        /**
         * Encodes the specified AddCardSkinArg message, length delimited. Does not implicitly {@link pb.AddCardSkinArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {pb.IAddCardSkinArg} message AddCardSkinArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddCardSkinArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddCardSkinArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AddCardSkinArg} AddCardSkinArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddCardSkinArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AddCardSkinArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Skin = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddCardSkinArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AddCardSkinArg} AddCardSkinArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddCardSkinArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddCardSkinArg message.
         * @function verify
         * @memberof pb.AddCardSkinArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddCardSkinArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            return null;
        };

        return AddCardSkinArg;
    })();

    pb.SkinGCard = (function() {

        /**
         * Properties of a SkinGCard.
         * @memberof pb
         * @interface ISkinGCard
         * @property {number|null} [GCardID] SkinGCard GCardID
         * @property {string|null} [Skin] SkinGCard Skin
         * @property {string|null} [Equip] SkinGCard Equip
         */

        /**
         * Constructs a new SkinGCard.
         * @memberof pb
         * @classdesc Represents a SkinGCard.
         * @implements ISkinGCard
         * @constructor
         * @param {pb.ISkinGCard=} [properties] Properties to set
         */
        function SkinGCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkinGCard GCardID.
         * @member {number} GCardID
         * @memberof pb.SkinGCard
         * @instance
         */
        SkinGCard.prototype.GCardID = 0;

        /**
         * SkinGCard Skin.
         * @member {string} Skin
         * @memberof pb.SkinGCard
         * @instance
         */
        SkinGCard.prototype.Skin = "";

        /**
         * SkinGCard Equip.
         * @member {string} Equip
         * @memberof pb.SkinGCard
         * @instance
         */
        SkinGCard.prototype.Equip = "";

        /**
         * Creates a new SkinGCard instance using the specified properties.
         * @function create
         * @memberof pb.SkinGCard
         * @static
         * @param {pb.ISkinGCard=} [properties] Properties to set
         * @returns {pb.SkinGCard} SkinGCard instance
         */
        SkinGCard.create = function create(properties) {
            return new SkinGCard(properties);
        };

        /**
         * Encodes the specified SkinGCard message. Does not implicitly {@link pb.SkinGCard.verify|verify} messages.
         * @function encode
         * @memberof pb.SkinGCard
         * @static
         * @param {pb.ISkinGCard} message SkinGCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkinGCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GCardID != null && message.hasOwnProperty("GCardID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.GCardID);
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Skin);
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Equip);
            return writer;
        };

        /**
         * Encodes the specified SkinGCard message, length delimited. Does not implicitly {@link pb.SkinGCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SkinGCard
         * @static
         * @param {pb.ISkinGCard} message SkinGCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkinGCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkinGCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SkinGCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SkinGCard} SkinGCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkinGCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkinGCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GCardID = reader.uint32();
                    break;
                case 2:
                    message.Skin = reader.string();
                    break;
                case 3:
                    message.Equip = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkinGCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SkinGCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SkinGCard} SkinGCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkinGCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkinGCard message.
         * @function verify
         * @memberof pb.SkinGCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkinGCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GCardID != null && message.hasOwnProperty("GCardID"))
                if (!$util.isInteger(message.GCardID))
                    return "GCardID: integer expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                if (!$util.isString(message.Equip))
                    return "Equip: string expected";
            return null;
        };

        return SkinGCard;
    })();

    pb.SkinCard = (function() {

        /**
         * Properties of a SkinCard.
         * @memberof pb
         * @interface ISkinCard
         * @property {number|null} [CardID] SkinCard CardID
         * @property {string|null} [Skin] SkinCard Skin
         * @property {string|null} [Equip] SkinCard Equip
         */

        /**
         * Constructs a new SkinCard.
         * @memberof pb
         * @classdesc Represents a SkinCard.
         * @implements ISkinCard
         * @constructor
         * @param {pb.ISkinCard=} [properties] Properties to set
         */
        function SkinCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkinCard CardID.
         * @member {number} CardID
         * @memberof pb.SkinCard
         * @instance
         */
        SkinCard.prototype.CardID = 0;

        /**
         * SkinCard Skin.
         * @member {string} Skin
         * @memberof pb.SkinCard
         * @instance
         */
        SkinCard.prototype.Skin = "";

        /**
         * SkinCard Equip.
         * @member {string} Equip
         * @memberof pb.SkinCard
         * @instance
         */
        SkinCard.prototype.Equip = "";

        /**
         * Creates a new SkinCard instance using the specified properties.
         * @function create
         * @memberof pb.SkinCard
         * @static
         * @param {pb.ISkinCard=} [properties] Properties to set
         * @returns {pb.SkinCard} SkinCard instance
         */
        SkinCard.create = function create(properties) {
            return new SkinCard(properties);
        };

        /**
         * Encodes the specified SkinCard message. Does not implicitly {@link pb.SkinCard.verify|verify} messages.
         * @function encode
         * @memberof pb.SkinCard
         * @static
         * @param {pb.ISkinCard} message SkinCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkinCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardID);
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Skin);
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Equip);
            return writer;
        };

        /**
         * Encodes the specified SkinCard message, length delimited. Does not implicitly {@link pb.SkinCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SkinCard
         * @static
         * @param {pb.ISkinCard} message SkinCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkinCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkinCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SkinCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SkinCard} SkinCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkinCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SkinCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardID = reader.uint32();
                    break;
                case 2:
                    message.Skin = reader.string();
                    break;
                case 3:
                    message.Equip = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkinCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SkinCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SkinCard} SkinCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkinCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkinCard message.
         * @function verify
         * @memberof pb.SkinCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkinCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            if (message.Skin != null && message.hasOwnProperty("Skin"))
                if (!$util.isString(message.Skin))
                    return "Skin: string expected";
            if (message.Equip != null && message.hasOwnProperty("Equip"))
                if (!$util.isString(message.Equip))
                    return "Equip: string expected";
            return null;
        };

        return SkinCard;
    })();

    pb.UpLevelCardArg = (function() {

        /**
         * Properties of an UpLevelCardArg.
         * @memberof pb
         * @interface IUpLevelCardArg
         * @property {number|null} [CardId] UpLevelCardArg CardId
         * @property {boolean|null} [IsConsumeJade] UpLevelCardArg IsConsumeJade
         */

        /**
         * Constructs a new UpLevelCardArg.
         * @memberof pb
         * @classdesc Represents an UpLevelCardArg.
         * @implements IUpLevelCardArg
         * @constructor
         * @param {pb.IUpLevelCardArg=} [properties] Properties to set
         */
        function UpLevelCardArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpLevelCardArg CardId.
         * @member {number} CardId
         * @memberof pb.UpLevelCardArg
         * @instance
         */
        UpLevelCardArg.prototype.CardId = 0;

        /**
         * UpLevelCardArg IsConsumeJade.
         * @member {boolean} IsConsumeJade
         * @memberof pb.UpLevelCardArg
         * @instance
         */
        UpLevelCardArg.prototype.IsConsumeJade = false;

        /**
         * Creates a new UpLevelCardArg instance using the specified properties.
         * @function create
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {pb.IUpLevelCardArg=} [properties] Properties to set
         * @returns {pb.UpLevelCardArg} UpLevelCardArg instance
         */
        UpLevelCardArg.create = function create(properties) {
            return new UpLevelCardArg(properties);
        };

        /**
         * Encodes the specified UpLevelCardArg message. Does not implicitly {@link pb.UpLevelCardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {pb.IUpLevelCardArg} message UpLevelCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpLevelCardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardId);
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsConsumeJade);
            return writer;
        };

        /**
         * Encodes the specified UpLevelCardArg message, length delimited. Does not implicitly {@link pb.UpLevelCardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {pb.IUpLevelCardArg} message UpLevelCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpLevelCardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpLevelCardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpLevelCardArg} UpLevelCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpLevelCardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpLevelCardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardId = reader.uint32();
                    break;
                case 2:
                    message.IsConsumeJade = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpLevelCardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpLevelCardArg} UpLevelCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpLevelCardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpLevelCardArg message.
         * @function verify
         * @memberof pb.UpLevelCardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpLevelCardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardId != null && message.hasOwnProperty("CardId"))
                if (!$util.isInteger(message.CardId))
                    return "CardId: integer expected";
            if (message.IsConsumeJade != null && message.hasOwnProperty("IsConsumeJade"))
                if (typeof message.IsConsumeJade !== "boolean")
                    return "IsConsumeJade: boolean expected";
            return null;
        };

        return UpLevelCardArg;
    })();

    pb.Resource = (function() {

        /**
         * Properties of a Resource.
         * @memberof pb
         * @interface IResource
         * @property {number|null} [Type] Resource Type
         * @property {number|null} [Amount] Resource Amount
         */

        /**
         * Constructs a new Resource.
         * @memberof pb
         * @classdesc Represents a Resource.
         * @implements IResource
         * @constructor
         * @param {pb.IResource=} [properties] Properties to set
         */
        function Resource(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Resource Type.
         * @member {number} Type
         * @memberof pb.Resource
         * @instance
         */
        Resource.prototype.Type = 0;

        /**
         * Resource Amount.
         * @member {number} Amount
         * @memberof pb.Resource
         * @instance
         */
        Resource.prototype.Amount = 0;

        /**
         * Creates a new Resource instance using the specified properties.
         * @function create
         * @memberof pb.Resource
         * @static
         * @param {pb.IResource=} [properties] Properties to set
         * @returns {pb.Resource} Resource instance
         */
        Resource.create = function create(properties) {
            return new Resource(properties);
        };

        /**
         * Encodes the specified Resource message. Does not implicitly {@link pb.Resource.verify|verify} messages.
         * @function encode
         * @memberof pb.Resource
         * @static
         * @param {pb.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified Resource message, length delimited. Does not implicitly {@link pb.Resource.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Resource
         * @static
         * @param {pb.IResource} message Resource message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Resource.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Resource message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Resource();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Resource message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Resource
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Resource} Resource
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Resource.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Resource message.
         * @function verify
         * @memberof pb.Resource
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Resource.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                if (!$util.isInteger(message.Type))
                    return "Type: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return Resource;
    })();

    pb.Treasure = (function() {

        /**
         * Properties of a Treasure.
         * @memberof pb
         * @interface ITreasure
         * @property {number|null} [ID] Treasure ID
         * @property {string|null} [ModelID] Treasure ModelID
         * @property {number|null} [OpenTimeout] Treasure OpenTimeout
         * @property {number|null} [OpenStarCount] Treasure OpenStarCount
         * @property {number|null} [Pos] Treasure Pos
         */

        /**
         * Constructs a new Treasure.
         * @memberof pb
         * @classdesc Represents a Treasure.
         * @implements ITreasure
         * @constructor
         * @param {pb.ITreasure=} [properties] Properties to set
         */
        function Treasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Treasure ID.
         * @member {number} ID
         * @memberof pb.Treasure
         * @instance
         */
        Treasure.prototype.ID = 0;

        /**
         * Treasure ModelID.
         * @member {string} ModelID
         * @memberof pb.Treasure
         * @instance
         */
        Treasure.prototype.ModelID = "";

        /**
         * Treasure OpenTimeout.
         * @member {number} OpenTimeout
         * @memberof pb.Treasure
         * @instance
         */
        Treasure.prototype.OpenTimeout = 0;

        /**
         * Treasure OpenStarCount.
         * @member {number} OpenStarCount
         * @memberof pb.Treasure
         * @instance
         */
        Treasure.prototype.OpenStarCount = 0;

        /**
         * Treasure Pos.
         * @member {number} Pos
         * @memberof pb.Treasure
         * @instance
         */
        Treasure.prototype.Pos = 0;

        /**
         * Creates a new Treasure instance using the specified properties.
         * @function create
         * @memberof pb.Treasure
         * @static
         * @param {pb.ITreasure=} [properties] Properties to set
         * @returns {pb.Treasure} Treasure instance
         */
        Treasure.create = function create(properties) {
            return new Treasure(properties);
        };

        /**
         * Encodes the specified Treasure message. Does not implicitly {@link pb.Treasure.verify|verify} messages.
         * @function encode
         * @memberof pb.Treasure
         * @static
         * @param {pb.ITreasure} message Treasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Treasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ID);
            if (message.ModelID != null && message.hasOwnProperty("ModelID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ModelID);
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.OpenTimeout);
            if (message.OpenStarCount != null && message.hasOwnProperty("OpenStarCount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.OpenStarCount);
            if (message.Pos != null && message.hasOwnProperty("Pos"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Pos);
            return writer;
        };

        /**
         * Encodes the specified Treasure message, length delimited. Does not implicitly {@link pb.Treasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Treasure
         * @static
         * @param {pb.ITreasure} message Treasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Treasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Treasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Treasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Treasure} Treasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Treasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Treasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.uint32();
                    break;
                case 2:
                    message.ModelID = reader.string();
                    break;
                case 3:
                    message.OpenTimeout = reader.int32();
                    break;
                case 4:
                    message.OpenStarCount = reader.int32();
                    break;
                case 5:
                    message.Pos = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Treasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Treasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Treasure} Treasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Treasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Treasure message.
         * @function verify
         * @memberof pb.Treasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Treasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.ModelID != null && message.hasOwnProperty("ModelID"))
                if (!$util.isString(message.ModelID))
                    return "ModelID: string expected";
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                if (!$util.isInteger(message.OpenTimeout))
                    return "OpenTimeout: integer expected";
            if (message.OpenStarCount != null && message.hasOwnProperty("OpenStarCount"))
                if (!$util.isInteger(message.OpenStarCount))
                    return "OpenStarCount: integer expected";
            if (message.Pos != null && message.hasOwnProperty("Pos"))
                if (!$util.isInteger(message.Pos))
                    return "Pos: integer expected";
            return null;
        };

        return Treasure;
    })();

    pb.DailyTreasure = (function() {

        /**
         * Properties of a DailyTreasure.
         * @memberof pb
         * @interface IDailyTreasure
         * @property {number|null} [ID] DailyTreasure ID
         * @property {string|null} [ModelID] DailyTreasure ModelID
         * @property {number|null} [OpenStarCount] DailyTreasure OpenStarCount
         * @property {boolean|null} [IsOpen] DailyTreasure IsOpen
         * @property {number|null} [NextTime] DailyTreasure NextTime
         * @property {boolean|null} [IsDouble] DailyTreasure IsDouble
         */

        /**
         * Constructs a new DailyTreasure.
         * @memberof pb
         * @classdesc Represents a DailyTreasure.
         * @implements IDailyTreasure
         * @constructor
         * @param {pb.IDailyTreasure=} [properties] Properties to set
         */
        function DailyTreasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DailyTreasure ID.
         * @member {number} ID
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.ID = 0;

        /**
         * DailyTreasure ModelID.
         * @member {string} ModelID
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.ModelID = "";

        /**
         * DailyTreasure OpenStarCount.
         * @member {number} OpenStarCount
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.OpenStarCount = 0;

        /**
         * DailyTreasure IsOpen.
         * @member {boolean} IsOpen
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.IsOpen = false;

        /**
         * DailyTreasure NextTime.
         * @member {number} NextTime
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.NextTime = 0;

        /**
         * DailyTreasure IsDouble.
         * @member {boolean} IsDouble
         * @memberof pb.DailyTreasure
         * @instance
         */
        DailyTreasure.prototype.IsDouble = false;

        /**
         * Creates a new DailyTreasure instance using the specified properties.
         * @function create
         * @memberof pb.DailyTreasure
         * @static
         * @param {pb.IDailyTreasure=} [properties] Properties to set
         * @returns {pb.DailyTreasure} DailyTreasure instance
         */
        DailyTreasure.create = function create(properties) {
            return new DailyTreasure(properties);
        };

        /**
         * Encodes the specified DailyTreasure message. Does not implicitly {@link pb.DailyTreasure.verify|verify} messages.
         * @function encode
         * @memberof pb.DailyTreasure
         * @static
         * @param {pb.IDailyTreasure} message DailyTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyTreasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ID);
            if (message.ModelID != null && message.hasOwnProperty("ModelID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ModelID);
            if (message.OpenStarCount != null && message.hasOwnProperty("OpenStarCount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.OpenStarCount);
            if (message.IsOpen != null && message.hasOwnProperty("IsOpen"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsOpen);
            if (message.NextTime != null && message.hasOwnProperty("NextTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.NextTime);
            if (message.IsDouble != null && message.hasOwnProperty("IsDouble"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsDouble);
            return writer;
        };

        /**
         * Encodes the specified DailyTreasure message, length delimited. Does not implicitly {@link pb.DailyTreasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DailyTreasure
         * @static
         * @param {pb.IDailyTreasure} message DailyTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DailyTreasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DailyTreasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DailyTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DailyTreasure} DailyTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyTreasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DailyTreasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.uint32();
                    break;
                case 2:
                    message.ModelID = reader.string();
                    break;
                case 3:
                    message.OpenStarCount = reader.int32();
                    break;
                case 4:
                    message.IsOpen = reader.bool();
                    break;
                case 5:
                    message.NextTime = reader.int32();
                    break;
                case 6:
                    message.IsDouble = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DailyTreasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DailyTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DailyTreasure} DailyTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DailyTreasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DailyTreasure message.
         * @function verify
         * @memberof pb.DailyTreasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DailyTreasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.ModelID != null && message.hasOwnProperty("ModelID"))
                if (!$util.isString(message.ModelID))
                    return "ModelID: string expected";
            if (message.OpenStarCount != null && message.hasOwnProperty("OpenStarCount"))
                if (!$util.isInteger(message.OpenStarCount))
                    return "OpenStarCount: integer expected";
            if (message.IsOpen != null && message.hasOwnProperty("IsOpen"))
                if (typeof message.IsOpen !== "boolean")
                    return "IsOpen: boolean expected";
            if (message.NextTime != null && message.hasOwnProperty("NextTime"))
                if (!$util.isInteger(message.NextTime))
                    return "NextTime: integer expected";
            if (message.IsDouble != null && message.hasOwnProperty("IsDouble"))
                if (typeof message.IsDouble !== "boolean")
                    return "IsDouble: boolean expected";
            return null;
        };

        return DailyTreasure;
    })();

    pb.GetTreasuresArg = (function() {

        /**
         * Properties of a GetTreasuresArg.
         * @memberof pb
         * @interface IGetTreasuresArg
         * @property {pb.GetTreasuresArg.TreasureType|null} [TreasureType1] GetTreasuresArg TreasureType1
         */

        /**
         * Constructs a new GetTreasuresArg.
         * @memberof pb
         * @classdesc Represents a GetTreasuresArg.
         * @implements IGetTreasuresArg
         * @constructor
         * @param {pb.IGetTreasuresArg=} [properties] Properties to set
         */
        function GetTreasuresArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTreasuresArg TreasureType1.
         * @member {pb.GetTreasuresArg.TreasureType} TreasureType1
         * @memberof pb.GetTreasuresArg
         * @instance
         */
        GetTreasuresArg.prototype.TreasureType1 = 0;

        /**
         * Creates a new GetTreasuresArg instance using the specified properties.
         * @function create
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {pb.IGetTreasuresArg=} [properties] Properties to set
         * @returns {pb.GetTreasuresArg} GetTreasuresArg instance
         */
        GetTreasuresArg.create = function create(properties) {
            return new GetTreasuresArg(properties);
        };

        /**
         * Encodes the specified GetTreasuresArg message. Does not implicitly {@link pb.GetTreasuresArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {pb.IGetTreasuresArg} message GetTreasuresArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTreasuresArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureType1 != null && message.hasOwnProperty("TreasureType1"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.TreasureType1);
            return writer;
        };

        /**
         * Encodes the specified GetTreasuresArg message, length delimited. Does not implicitly {@link pb.GetTreasuresArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {pb.IGetTreasuresArg} message GetTreasuresArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTreasuresArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTreasuresArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetTreasuresArg} GetTreasuresArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTreasuresArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetTreasuresArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureType1 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTreasuresArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetTreasuresArg} GetTreasuresArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTreasuresArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTreasuresArg message.
         * @function verify
         * @memberof pb.GetTreasuresArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTreasuresArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureType1 != null && message.hasOwnProperty("TreasureType1"))
                switch (message.TreasureType1) {
                default:
                    return "TreasureType1: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * TreasureType enum.
         * @name pb.GetTreasuresArg.TreasureType
         * @enum {string}
         * @property {number} Reward=0 Reward value
         * @property {number} Daily=1 Daily value
         */
        GetTreasuresArg.TreasureType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Reward"] = 0;
            values[valuesById[1] = "Daily"] = 1;
            return values;
        })();

        return GetTreasuresArg;
    })();

    pb.GetTreasuresReply = (function() {

        /**
         * Properties of a GetTreasuresReply.
         * @memberof pb
         * @interface IGetTreasuresReply
         * @property {Array.<pb.ITreasure>|null} [Treasures] GetTreasuresReply Treasures
         * @property {pb.IDailyTreasure|null} [DailyTreasure1] GetTreasuresReply DailyTreasure1
         */

        /**
         * Constructs a new GetTreasuresReply.
         * @memberof pb
         * @classdesc Represents a GetTreasuresReply.
         * @implements IGetTreasuresReply
         * @constructor
         * @param {pb.IGetTreasuresReply=} [properties] Properties to set
         */
        function GetTreasuresReply(properties) {
            this.Treasures = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTreasuresReply Treasures.
         * @member {Array.<pb.ITreasure>} Treasures
         * @memberof pb.GetTreasuresReply
         * @instance
         */
        GetTreasuresReply.prototype.Treasures = $util.emptyArray;

        /**
         * GetTreasuresReply DailyTreasure1.
         * @member {pb.IDailyTreasure|null|undefined} DailyTreasure1
         * @memberof pb.GetTreasuresReply
         * @instance
         */
        GetTreasuresReply.prototype.DailyTreasure1 = null;

        /**
         * Creates a new GetTreasuresReply instance using the specified properties.
         * @function create
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {pb.IGetTreasuresReply=} [properties] Properties to set
         * @returns {pb.GetTreasuresReply} GetTreasuresReply instance
         */
        GetTreasuresReply.create = function create(properties) {
            return new GetTreasuresReply(properties);
        };

        /**
         * Encodes the specified GetTreasuresReply message. Does not implicitly {@link pb.GetTreasuresReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {pb.IGetTreasuresReply} message GetTreasuresReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTreasuresReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Treasures != null && message.Treasures.length)
                for (var i = 0; i < message.Treasures.length; ++i)
                    $root.pb.Treasure.encode(message.Treasures[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.DailyTreasure1 != null && message.hasOwnProperty("DailyTreasure1"))
                $root.pb.DailyTreasure.encode(message.DailyTreasure1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetTreasuresReply message, length delimited. Does not implicitly {@link pb.GetTreasuresReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {pb.IGetTreasuresReply} message GetTreasuresReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTreasuresReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTreasuresReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetTreasuresReply} GetTreasuresReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTreasuresReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetTreasuresReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Treasures && message.Treasures.length))
                        message.Treasures = [];
                    message.Treasures.push($root.pb.Treasure.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.DailyTreasure1 = $root.pb.DailyTreasure.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTreasuresReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetTreasuresReply} GetTreasuresReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTreasuresReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTreasuresReply message.
         * @function verify
         * @memberof pb.GetTreasuresReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTreasuresReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Treasures != null && message.hasOwnProperty("Treasures")) {
                if (!Array.isArray(message.Treasures))
                    return "Treasures: array expected";
                for (var i = 0; i < message.Treasures.length; ++i) {
                    var error = $root.pb.Treasure.verify(message.Treasures[i]);
                    if (error)
                        return "Treasures." + error;
                }
            }
            if (message.DailyTreasure1 != null && message.hasOwnProperty("DailyTreasure1")) {
                var error = $root.pb.DailyTreasure.verify(message.DailyTreasure1);
                if (error)
                    return "DailyTreasure1." + error;
            }
            return null;
        };

        return GetTreasuresReply;
    })();

    pb.OpenTreasureArg = (function() {

        /**
         * Properties of an OpenTreasureArg.
         * @memberof pb
         * @interface IOpenTreasureArg
         * @property {number|null} [TreasureID] OpenTreasureArg TreasureID
         */

        /**
         * Constructs a new OpenTreasureArg.
         * @memberof pb
         * @classdesc Represents an OpenTreasureArg.
         * @implements IOpenTreasureArg
         * @constructor
         * @param {pb.IOpenTreasureArg=} [properties] Properties to set
         */
        function OpenTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenTreasureArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.OpenTreasureArg
         * @instance
         */
        OpenTreasureArg.prototype.TreasureID = 0;

        /**
         * Creates a new OpenTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {pb.IOpenTreasureArg=} [properties] Properties to set
         * @returns {pb.OpenTreasureArg} OpenTreasureArg instance
         */
        OpenTreasureArg.create = function create(properties) {
            return new OpenTreasureArg(properties);
        };

        /**
         * Encodes the specified OpenTreasureArg message. Does not implicitly {@link pb.OpenTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {pb.IOpenTreasureArg} message OpenTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            return writer;
        };

        /**
         * Encodes the specified OpenTreasureArg message, length delimited. Does not implicitly {@link pb.OpenTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {pb.IOpenTreasureArg} message OpenTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OpenTreasureArg} OpenTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OpenTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OpenTreasureArg} OpenTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenTreasureArg message.
         * @function verify
         * @memberof pb.OpenTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            return null;
        };

        return OpenTreasureArg;
    })();

    pb.OpenTreasureReply = (function() {

        /**
         * Properties of an OpenTreasureReply.
         * @memberof pb
         * @interface IOpenTreasureReply
         * @property {boolean|null} [OK] OpenTreasureReply OK
         * @property {Array.<number>|null} [CardIDs] OpenTreasureReply CardIDs
         * @property {number|null} [ShareHid] OpenTreasureReply ShareHid
         * @property {boolean|null} [CanWatchAddCardAds] OpenTreasureReply CanWatchAddCardAds
         * @property {Array.<string>|null} [CardSkins] OpenTreasureReply CardSkins
         * @property {Array.<number>|null} [EmojiTeams] OpenTreasureReply EmojiTeams
         * @property {Array.<string>|null} [Headframes] OpenTreasureReply Headframes
         * @property {Array.<pb.IResource>|null} [Resources] OpenTreasureReply Resources
         */

        /**
         * Constructs a new OpenTreasureReply.
         * @memberof pb
         * @classdesc Represents an OpenTreasureReply.
         * @implements IOpenTreasureReply
         * @constructor
         * @param {pb.IOpenTreasureReply=} [properties] Properties to set
         */
        function OpenTreasureReply(properties) {
            this.CardIDs = [];
            this.CardSkins = [];
            this.EmojiTeams = [];
            this.Headframes = [];
            this.Resources = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenTreasureReply OK.
         * @member {boolean} OK
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.OK = false;

        /**
         * OpenTreasureReply CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.CardIDs = $util.emptyArray;

        /**
         * OpenTreasureReply ShareHid.
         * @member {number} ShareHid
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.ShareHid = 0;

        /**
         * OpenTreasureReply CanWatchAddCardAds.
         * @member {boolean} CanWatchAddCardAds
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.CanWatchAddCardAds = false;

        /**
         * OpenTreasureReply CardSkins.
         * @member {Array.<string>} CardSkins
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.CardSkins = $util.emptyArray;

        /**
         * OpenTreasureReply EmojiTeams.
         * @member {Array.<number>} EmojiTeams
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.EmojiTeams = $util.emptyArray;

        /**
         * OpenTreasureReply Headframes.
         * @member {Array.<string>} Headframes
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.Headframes = $util.emptyArray;

        /**
         * OpenTreasureReply Resources.
         * @member {Array.<pb.IResource>} Resources
         * @memberof pb.OpenTreasureReply
         * @instance
         */
        OpenTreasureReply.prototype.Resources = $util.emptyArray;

        /**
         * Creates a new OpenTreasureReply instance using the specified properties.
         * @function create
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {pb.IOpenTreasureReply=} [properties] Properties to set
         * @returns {pb.OpenTreasureReply} OpenTreasureReply instance
         */
        OpenTreasureReply.create = function create(properties) {
            return new OpenTreasureReply(properties);
        };

        /**
         * Encodes the specified OpenTreasureReply message. Does not implicitly {@link pb.OpenTreasureReply.verify|verify} messages.
         * @function encode
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {pb.IOpenTreasureReply} message OpenTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OK != null && message.hasOwnProperty("OK"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.OK);
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            if (message.ShareHid != null && message.hasOwnProperty("ShareHid"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ShareHid);
            if (message.CanWatchAddCardAds != null && message.hasOwnProperty("CanWatchAddCardAds"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.CanWatchAddCardAds);
            if (message.CardSkins != null && message.CardSkins.length)
                for (var i = 0; i < message.CardSkins.length; ++i)
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.CardSkins[i]);
            if (message.EmojiTeams != null && message.EmojiTeams.length) {
                writer.uint32(/* id 6, wireType 2 =*/50).fork();
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    writer.int32(message.EmojiTeams[i]);
                writer.ldelim();
            }
            if (message.Headframes != null && message.Headframes.length)
                for (var i = 0; i < message.Headframes.length; ++i)
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.Headframes[i]);
            if (message.Resources != null && message.Resources.length)
                for (var i = 0; i < message.Resources.length; ++i)
                    $root.pb.Resource.encode(message.Resources[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenTreasureReply message, length delimited. Does not implicitly {@link pb.OpenTreasureReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {pb.IOpenTreasureReply} message OpenTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenTreasureReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenTreasureReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OpenTreasureReply} OpenTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OpenTreasureReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.OK = reader.bool();
                    break;
                case 2:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                case 3:
                    message.ShareHid = reader.int32();
                    break;
                case 4:
                    message.CanWatchAddCardAds = reader.bool();
                    break;
                case 5:
                    if (!(message.CardSkins && message.CardSkins.length))
                        message.CardSkins = [];
                    message.CardSkins.push(reader.string());
                    break;
                case 6:
                    if (!(message.EmojiTeams && message.EmojiTeams.length))
                        message.EmojiTeams = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.EmojiTeams.push(reader.int32());
                    } else
                        message.EmojiTeams.push(reader.int32());
                    break;
                case 7:
                    if (!(message.Headframes && message.Headframes.length))
                        message.Headframes = [];
                    message.Headframes.push(reader.string());
                    break;
                case 8:
                    if (!(message.Resources && message.Resources.length))
                        message.Resources = [];
                    message.Resources.push($root.pb.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenTreasureReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OpenTreasureReply} OpenTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenTreasureReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenTreasureReply message.
         * @function verify
         * @memberof pb.OpenTreasureReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenTreasureReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OK != null && message.hasOwnProperty("OK"))
                if (typeof message.OK !== "boolean")
                    return "OK: boolean expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            if (message.ShareHid != null && message.hasOwnProperty("ShareHid"))
                if (!$util.isInteger(message.ShareHid))
                    return "ShareHid: integer expected";
            if (message.CanWatchAddCardAds != null && message.hasOwnProperty("CanWatchAddCardAds"))
                if (typeof message.CanWatchAddCardAds !== "boolean")
                    return "CanWatchAddCardAds: boolean expected";
            if (message.CardSkins != null && message.hasOwnProperty("CardSkins")) {
                if (!Array.isArray(message.CardSkins))
                    return "CardSkins: array expected";
                for (var i = 0; i < message.CardSkins.length; ++i)
                    if (!$util.isString(message.CardSkins[i]))
                        return "CardSkins: string[] expected";
            }
            if (message.EmojiTeams != null && message.hasOwnProperty("EmojiTeams")) {
                if (!Array.isArray(message.EmojiTeams))
                    return "EmojiTeams: array expected";
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    if (!$util.isInteger(message.EmojiTeams[i]))
                        return "EmojiTeams: integer[] expected";
            }
            if (message.Headframes != null && message.hasOwnProperty("Headframes")) {
                if (!Array.isArray(message.Headframes))
                    return "Headframes: array expected";
                for (var i = 0; i < message.Headframes.length; ++i)
                    if (!$util.isString(message.Headframes[i]))
                        return "Headframes: string[] expected";
            }
            if (message.Resources != null && message.hasOwnProperty("Resources")) {
                if (!Array.isArray(message.Resources))
                    return "Resources: array expected";
                for (var i = 0; i < message.Resources.length; ++i) {
                    var error = $root.pb.Resource.verify(message.Resources[i]);
                    if (error)
                        return "Resources." + error;
                }
            }
            return null;
        };

        return OpenTreasureReply;
    })();

    pb.GainTreasure = (function() {

        /**
         * Properties of a GainTreasure.
         * @memberof pb
         * @interface IGainTreasure
         * @property {pb.ITreasure|null} [Treasure] GainTreasure Treasure
         */

        /**
         * Constructs a new GainTreasure.
         * @memberof pb
         * @classdesc Represents a GainTreasure.
         * @implements IGainTreasure
         * @constructor
         * @param {pb.IGainTreasure=} [properties] Properties to set
         */
        function GainTreasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GainTreasure Treasure.
         * @member {pb.ITreasure|null|undefined} Treasure
         * @memberof pb.GainTreasure
         * @instance
         */
        GainTreasure.prototype.Treasure = null;

        /**
         * Creates a new GainTreasure instance using the specified properties.
         * @function create
         * @memberof pb.GainTreasure
         * @static
         * @param {pb.IGainTreasure=} [properties] Properties to set
         * @returns {pb.GainTreasure} GainTreasure instance
         */
        GainTreasure.create = function create(properties) {
            return new GainTreasure(properties);
        };

        /**
         * Encodes the specified GainTreasure message. Does not implicitly {@link pb.GainTreasure.verify|verify} messages.
         * @function encode
         * @memberof pb.GainTreasure
         * @static
         * @param {pb.IGainTreasure} message GainTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GainTreasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Treasure != null && message.hasOwnProperty("Treasure"))
                $root.pb.Treasure.encode(message.Treasure, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GainTreasure message, length delimited. Does not implicitly {@link pb.GainTreasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GainTreasure
         * @static
         * @param {pb.IGainTreasure} message GainTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GainTreasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GainTreasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GainTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GainTreasure} GainTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GainTreasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GainTreasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Treasure = $root.pb.Treasure.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GainTreasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GainTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GainTreasure} GainTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GainTreasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GainTreasure message.
         * @function verify
         * @memberof pb.GainTreasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GainTreasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Treasure != null && message.hasOwnProperty("Treasure")) {
                var error = $root.pb.Treasure.verify(message.Treasure);
                if (error)
                    return "Treasure." + error;
            }
            return null;
        };

        return GainTreasure;
    })();

    pb.ActivateRewardTreasureArg = (function() {

        /**
         * Properties of an ActivateRewardTreasureArg.
         * @memberof pb
         * @interface IActivateRewardTreasureArg
         * @property {number|null} [TreasureID] ActivateRewardTreasureArg TreasureID
         */

        /**
         * Constructs a new ActivateRewardTreasureArg.
         * @memberof pb
         * @classdesc Represents an ActivateRewardTreasureArg.
         * @implements IActivateRewardTreasureArg
         * @constructor
         * @param {pb.IActivateRewardTreasureArg=} [properties] Properties to set
         */
        function ActivateRewardTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivateRewardTreasureArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.ActivateRewardTreasureArg
         * @instance
         */
        ActivateRewardTreasureArg.prototype.TreasureID = 0;

        /**
         * Creates a new ActivateRewardTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {pb.IActivateRewardTreasureArg=} [properties] Properties to set
         * @returns {pb.ActivateRewardTreasureArg} ActivateRewardTreasureArg instance
         */
        ActivateRewardTreasureArg.create = function create(properties) {
            return new ActivateRewardTreasureArg(properties);
        };

        /**
         * Encodes the specified ActivateRewardTreasureArg message. Does not implicitly {@link pb.ActivateRewardTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {pb.IActivateRewardTreasureArg} message ActivateRewardTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivateRewardTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            return writer;
        };

        /**
         * Encodes the specified ActivateRewardTreasureArg message, length delimited. Does not implicitly {@link pb.ActivateRewardTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {pb.IActivateRewardTreasureArg} message ActivateRewardTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivateRewardTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivateRewardTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ActivateRewardTreasureArg} ActivateRewardTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivateRewardTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ActivateRewardTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivateRewardTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ActivateRewardTreasureArg} ActivateRewardTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivateRewardTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivateRewardTreasureArg message.
         * @function verify
         * @memberof pb.ActivateRewardTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivateRewardTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            return null;
        };

        return ActivateRewardTreasureArg;
    })();

    pb.ActivateRewardTreasureReply = (function() {

        /**
         * Properties of an ActivateRewardTreasureReply.
         * @memberof pb
         * @interface IActivateRewardTreasureReply
         * @property {boolean|null} [OK] ActivateRewardTreasureReply OK
         * @property {number|null} [OpenTimeout] ActivateRewardTreasureReply OpenTimeout
         */

        /**
         * Constructs a new ActivateRewardTreasureReply.
         * @memberof pb
         * @classdesc Represents an ActivateRewardTreasureReply.
         * @implements IActivateRewardTreasureReply
         * @constructor
         * @param {pb.IActivateRewardTreasureReply=} [properties] Properties to set
         */
        function ActivateRewardTreasureReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ActivateRewardTreasureReply OK.
         * @member {boolean} OK
         * @memberof pb.ActivateRewardTreasureReply
         * @instance
         */
        ActivateRewardTreasureReply.prototype.OK = false;

        /**
         * ActivateRewardTreasureReply OpenTimeout.
         * @member {number} OpenTimeout
         * @memberof pb.ActivateRewardTreasureReply
         * @instance
         */
        ActivateRewardTreasureReply.prototype.OpenTimeout = 0;

        /**
         * Creates a new ActivateRewardTreasureReply instance using the specified properties.
         * @function create
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {pb.IActivateRewardTreasureReply=} [properties] Properties to set
         * @returns {pb.ActivateRewardTreasureReply} ActivateRewardTreasureReply instance
         */
        ActivateRewardTreasureReply.create = function create(properties) {
            return new ActivateRewardTreasureReply(properties);
        };

        /**
         * Encodes the specified ActivateRewardTreasureReply message. Does not implicitly {@link pb.ActivateRewardTreasureReply.verify|verify} messages.
         * @function encode
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {pb.IActivateRewardTreasureReply} message ActivateRewardTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivateRewardTreasureReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OK != null && message.hasOwnProperty("OK"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.OK);
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.OpenTimeout);
            return writer;
        };

        /**
         * Encodes the specified ActivateRewardTreasureReply message, length delimited. Does not implicitly {@link pb.ActivateRewardTreasureReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {pb.IActivateRewardTreasureReply} message ActivateRewardTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ActivateRewardTreasureReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ActivateRewardTreasureReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ActivateRewardTreasureReply} ActivateRewardTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivateRewardTreasureReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ActivateRewardTreasureReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.OK = reader.bool();
                    break;
                case 2:
                    message.OpenTimeout = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ActivateRewardTreasureReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ActivateRewardTreasureReply} ActivateRewardTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ActivateRewardTreasureReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ActivateRewardTreasureReply message.
         * @function verify
         * @memberof pb.ActivateRewardTreasureReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ActivateRewardTreasureReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OK != null && message.hasOwnProperty("OK"))
                if (typeof message.OK !== "boolean")
                    return "OK: boolean expected";
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                if (!$util.isInteger(message.OpenTimeout))
                    return "OpenTimeout: integer expected";
            return null;
        };

        return ActivateRewardTreasureReply;
    })();

    pb.TargetTreasure = (function() {

        /**
         * Properties of a TargetTreasure.
         * @memberof pb
         * @interface ITargetTreasure
         * @property {number|null} [TreasureID] TargetTreasure TreasureID
         */

        /**
         * Constructs a new TargetTreasure.
         * @memberof pb
         * @classdesc Represents a TargetTreasure.
         * @implements ITargetTreasure
         * @constructor
         * @param {pb.ITargetTreasure=} [properties] Properties to set
         */
        function TargetTreasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetTreasure TreasureID.
         * @member {number} TreasureID
         * @memberof pb.TargetTreasure
         * @instance
         */
        TargetTreasure.prototype.TreasureID = 0;

        /**
         * Creates a new TargetTreasure instance using the specified properties.
         * @function create
         * @memberof pb.TargetTreasure
         * @static
         * @param {pb.ITargetTreasure=} [properties] Properties to set
         * @returns {pb.TargetTreasure} TargetTreasure instance
         */
        TargetTreasure.create = function create(properties) {
            return new TargetTreasure(properties);
        };

        /**
         * Encodes the specified TargetTreasure message. Does not implicitly {@link pb.TargetTreasure.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetTreasure
         * @static
         * @param {pb.ITargetTreasure} message TargetTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetTreasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            return writer;
        };

        /**
         * Encodes the specified TargetTreasure message, length delimited. Does not implicitly {@link pb.TargetTreasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetTreasure
         * @static
         * @param {pb.ITargetTreasure} message TargetTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetTreasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetTreasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetTreasure} TargetTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetTreasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetTreasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetTreasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetTreasure} TargetTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetTreasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetTreasure message.
         * @function verify
         * @memberof pb.TargetTreasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetTreasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            return null;
        };

        return TargetTreasure;
    })();

    /**
     * NoTreasureReasonEnum enum.
     * @name pb.NoTreasureReasonEnum
     * @enum {string}
     * @property {number} Unknow=0 Unknow value
     * @property {number} NoPos=1 NoPos value
     * @property {number} AmountLimit=2 AmountLimit value
     */
    pb.NoTreasureReasonEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unknow"] = 0;
        values[valuesById[1] = "NoPos"] = 1;
        values[valuesById[2] = "AmountLimit"] = 2;
        return values;
    })();

    pb.CampaignState = (function() {

        /**
         * Properties of a CampaignState.
         * @memberof pb
         * @interface ICampaignState
         * @property {pb.CampaignState.StateEnum|null} [State] CampaignState State
         * @property {Uint8Array|null} [Arg] CampaignState Arg
         */

        /**
         * Constructs a new CampaignState.
         * @memberof pb
         * @classdesc Represents a CampaignState.
         * @implements ICampaignState
         * @constructor
         * @param {pb.ICampaignState=} [properties] Properties to set
         */
        function CampaignState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignState State.
         * @member {pb.CampaignState.StateEnum} State
         * @memberof pb.CampaignState
         * @instance
         */
        CampaignState.prototype.State = 0;

        /**
         * CampaignState Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.CampaignState
         * @instance
         */
        CampaignState.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new CampaignState instance using the specified properties.
         * @function create
         * @memberof pb.CampaignState
         * @static
         * @param {pb.ICampaignState=} [properties] Properties to set
         * @returns {pb.CampaignState} CampaignState instance
         */
        CampaignState.create = function create(properties) {
            return new CampaignState(properties);
        };

        /**
         * Encodes the specified CampaignState message. Does not implicitly {@link pb.CampaignState.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignState
         * @static
         * @param {pb.ICampaignState} message CampaignState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.State);
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified CampaignState message, length delimited. Does not implicitly {@link pb.CampaignState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignState
         * @static
         * @param {pb.ICampaignState} message CampaignState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignState message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignState} CampaignState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.State = reader.int32();
                    break;
                case 2:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignState} CampaignState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignState message.
         * @function verify
         * @memberof pb.CampaignState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        /**
         * StateEnum enum.
         * @name pb.CampaignState.StateEnum
         * @enum {string}
         * @property {number} Normal=0 Normal value
         * @property {number} ReadyWar=1 ReadyWar value
         * @property {number} InWar=2 InWar value
         * @property {number} WarEnd=3 WarEnd value
         * @property {number} Unified=4 Unified value
         */
        CampaignState.StateEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Normal"] = 0;
            values[valuesById[1] = "ReadyWar"] = 1;
            values[valuesById[2] = "InWar"] = 2;
            values[valuesById[3] = "WarEnd"] = 3;
            values[valuesById[4] = "Unified"] = 4;
            return values;
        })();

        return CampaignState;
    })();

    pb.CaStateWarArg = (function() {

        /**
         * Properties of a CaStateWarArg.
         * @memberof pb
         * @interface ICaStateWarArg
         * @property {number|null} [RemainTime] CaStateWarArg RemainTime
         */

        /**
         * Constructs a new CaStateWarArg.
         * @memberof pb
         * @classdesc Represents a CaStateWarArg.
         * @implements ICaStateWarArg
         * @constructor
         * @param {pb.ICaStateWarArg=} [properties] Properties to set
         */
        function CaStateWarArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CaStateWarArg RemainTime.
         * @member {number} RemainTime
         * @memberof pb.CaStateWarArg
         * @instance
         */
        CaStateWarArg.prototype.RemainTime = 0;

        /**
         * Creates a new CaStateWarArg instance using the specified properties.
         * @function create
         * @memberof pb.CaStateWarArg
         * @static
         * @param {pb.ICaStateWarArg=} [properties] Properties to set
         * @returns {pb.CaStateWarArg} CaStateWarArg instance
         */
        CaStateWarArg.create = function create(properties) {
            return new CaStateWarArg(properties);
        };

        /**
         * Encodes the specified CaStateWarArg message. Does not implicitly {@link pb.CaStateWarArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CaStateWarArg
         * @static
         * @param {pb.ICaStateWarArg} message CaStateWarArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateWarArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified CaStateWarArg message, length delimited. Does not implicitly {@link pb.CaStateWarArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CaStateWarArg
         * @static
         * @param {pb.ICaStateWarArg} message CaStateWarArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateWarArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CaStateWarArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CaStateWarArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CaStateWarArg} CaStateWarArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateWarArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CaStateWarArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CaStateWarArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CaStateWarArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CaStateWarArg} CaStateWarArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateWarArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CaStateWarArg message.
         * @function verify
         * @memberof pb.CaStateWarArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CaStateWarArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return CaStateWarArg;
    })();

    pb.CaStateUnifiedArg = (function() {

        /**
         * Properties of a CaStateUnifiedArg.
         * @memberof pb
         * @interface ICaStateUnifiedArg
         * @property {number|null} [CountryID] CaStateUnifiedArg CountryID
         * @property {string|null} [YourMajestyName] CaStateUnifiedArg YourMajestyName
         * @property {number|null} [CountryPlayerAmount] CaStateUnifiedArg CountryPlayerAmount
         */

        /**
         * Constructs a new CaStateUnifiedArg.
         * @memberof pb
         * @classdesc Represents a CaStateUnifiedArg.
         * @implements ICaStateUnifiedArg
         * @constructor
         * @param {pb.ICaStateUnifiedArg=} [properties] Properties to set
         */
        function CaStateUnifiedArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CaStateUnifiedArg CountryID.
         * @member {number} CountryID
         * @memberof pb.CaStateUnifiedArg
         * @instance
         */
        CaStateUnifiedArg.prototype.CountryID = 0;

        /**
         * CaStateUnifiedArg YourMajestyName.
         * @member {string} YourMajestyName
         * @memberof pb.CaStateUnifiedArg
         * @instance
         */
        CaStateUnifiedArg.prototype.YourMajestyName = "";

        /**
         * CaStateUnifiedArg CountryPlayerAmount.
         * @member {number} CountryPlayerAmount
         * @memberof pb.CaStateUnifiedArg
         * @instance
         */
        CaStateUnifiedArg.prototype.CountryPlayerAmount = 0;

        /**
         * Creates a new CaStateUnifiedArg instance using the specified properties.
         * @function create
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {pb.ICaStateUnifiedArg=} [properties] Properties to set
         * @returns {pb.CaStateUnifiedArg} CaStateUnifiedArg instance
         */
        CaStateUnifiedArg.create = function create(properties) {
            return new CaStateUnifiedArg(properties);
        };

        /**
         * Encodes the specified CaStateUnifiedArg message. Does not implicitly {@link pb.CaStateUnifiedArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {pb.ICaStateUnifiedArg} message CaStateUnifiedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateUnifiedArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.YourMajestyName);
            if (message.CountryPlayerAmount != null && message.hasOwnProperty("CountryPlayerAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CountryPlayerAmount);
            return writer;
        };

        /**
         * Encodes the specified CaStateUnifiedArg message, length delimited. Does not implicitly {@link pb.CaStateUnifiedArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {pb.ICaStateUnifiedArg} message CaStateUnifiedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateUnifiedArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CaStateUnifiedArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CaStateUnifiedArg} CaStateUnifiedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateUnifiedArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CaStateUnifiedArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.YourMajestyName = reader.string();
                    break;
                case 3:
                    message.CountryPlayerAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CaStateUnifiedArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CaStateUnifiedArg} CaStateUnifiedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateUnifiedArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CaStateUnifiedArg message.
         * @function verify
         * @memberof pb.CaStateUnifiedArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CaStateUnifiedArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                if (!$util.isString(message.YourMajestyName))
                    return "YourMajestyName: string expected";
            if (message.CountryPlayerAmount != null && message.hasOwnProperty("CountryPlayerAmount"))
                if (!$util.isInteger(message.CountryPlayerAmount))
                    return "CountryPlayerAmount: integer expected";
            return null;
        };

        return CaStateUnifiedArg;
    })();

    pb.CaStateWarEndArg = (function() {

        /**
         * Properties of a CaStateWarEndArg.
         * @memberof pb
         * @interface ICaStateWarEndArg
         * @property {number|null} [Contribution] CaStateWarEndArg Contribution
         * @property {Array.<number>|null} [LostCitys] CaStateWarEndArg LostCitys
         * @property {Array.<number>|null} [OccupyCitys] CaStateWarEndArg OccupyCitys
         * @property {number|null} [NextWarRemainTime] CaStateWarEndArg NextWarRemainTime
         */

        /**
         * Constructs a new CaStateWarEndArg.
         * @memberof pb
         * @classdesc Represents a CaStateWarEndArg.
         * @implements ICaStateWarEndArg
         * @constructor
         * @param {pb.ICaStateWarEndArg=} [properties] Properties to set
         */
        function CaStateWarEndArg(properties) {
            this.LostCitys = [];
            this.OccupyCitys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CaStateWarEndArg Contribution.
         * @member {number} Contribution
         * @memberof pb.CaStateWarEndArg
         * @instance
         */
        CaStateWarEndArg.prototype.Contribution = 0;

        /**
         * CaStateWarEndArg LostCitys.
         * @member {Array.<number>} LostCitys
         * @memberof pb.CaStateWarEndArg
         * @instance
         */
        CaStateWarEndArg.prototype.LostCitys = $util.emptyArray;

        /**
         * CaStateWarEndArg OccupyCitys.
         * @member {Array.<number>} OccupyCitys
         * @memberof pb.CaStateWarEndArg
         * @instance
         */
        CaStateWarEndArg.prototype.OccupyCitys = $util.emptyArray;

        /**
         * CaStateWarEndArg NextWarRemainTime.
         * @member {number} NextWarRemainTime
         * @memberof pb.CaStateWarEndArg
         * @instance
         */
        CaStateWarEndArg.prototype.NextWarRemainTime = 0;

        /**
         * Creates a new CaStateWarEndArg instance using the specified properties.
         * @function create
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {pb.ICaStateWarEndArg=} [properties] Properties to set
         * @returns {pb.CaStateWarEndArg} CaStateWarEndArg instance
         */
        CaStateWarEndArg.create = function create(properties) {
            return new CaStateWarEndArg(properties);
        };

        /**
         * Encodes the specified CaStateWarEndArg message. Does not implicitly {@link pb.CaStateWarEndArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {pb.ICaStateWarEndArg} message CaStateWarEndArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateWarEndArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Contribution);
            if (message.LostCitys != null && message.LostCitys.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.LostCitys.length; ++i)
                    writer.int32(message.LostCitys[i]);
                writer.ldelim();
            }
            if (message.OccupyCitys != null && message.OccupyCitys.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.OccupyCitys.length; ++i)
                    writer.int32(message.OccupyCitys[i]);
                writer.ldelim();
            }
            if (message.NextWarRemainTime != null && message.hasOwnProperty("NextWarRemainTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.NextWarRemainTime);
            return writer;
        };

        /**
         * Encodes the specified CaStateWarEndArg message, length delimited. Does not implicitly {@link pb.CaStateWarEndArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {pb.ICaStateWarEndArg} message CaStateWarEndArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CaStateWarEndArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CaStateWarEndArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CaStateWarEndArg} CaStateWarEndArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateWarEndArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CaStateWarEndArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Contribution = reader.int32();
                    break;
                case 2:
                    if (!(message.LostCitys && message.LostCitys.length))
                        message.LostCitys = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.LostCitys.push(reader.int32());
                    } else
                        message.LostCitys.push(reader.int32());
                    break;
                case 3:
                    if (!(message.OccupyCitys && message.OccupyCitys.length))
                        message.OccupyCitys = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.OccupyCitys.push(reader.int32());
                    } else
                        message.OccupyCitys.push(reader.int32());
                    break;
                case 4:
                    message.NextWarRemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CaStateWarEndArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CaStateWarEndArg} CaStateWarEndArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CaStateWarEndArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CaStateWarEndArg message.
         * @function verify
         * @memberof pb.CaStateWarEndArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CaStateWarEndArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.LostCitys != null && message.hasOwnProperty("LostCitys")) {
                if (!Array.isArray(message.LostCitys))
                    return "LostCitys: array expected";
                for (var i = 0; i < message.LostCitys.length; ++i)
                    if (!$util.isInteger(message.LostCitys[i]))
                        return "LostCitys: integer[] expected";
            }
            if (message.OccupyCitys != null && message.hasOwnProperty("OccupyCitys")) {
                if (!Array.isArray(message.OccupyCitys))
                    return "OccupyCitys: array expected";
                for (var i = 0; i < message.OccupyCitys.length; ++i)
                    if (!$util.isInteger(message.OccupyCitys[i]))
                        return "OccupyCitys: integer[] expected";
            }
            if (message.NextWarRemainTime != null && message.hasOwnProperty("NextWarRemainTime"))
                if (!$util.isInteger(message.NextWarRemainTime))
                    return "NextWarRemainTime: integer expected";
            return null;
        };

        return CaStateWarEndArg;
    })();

    /**
     * CityState enum.
     * @name pb.CityState
     * @enum {string}
     * @property {number} NormalCS=0 NormalCS value
     * @property {number} BeAttackCS=1 BeAttackCS value
     * @property {number} BeOccupyCS=2 BeOccupyCS value
     */
    pb.CityState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NormalCS"] = 0;
        values[valuesById[1] = "BeAttackCS"] = 1;
        values[valuesById[2] = "BeOccupyCS"] = 2;
        return values;
    })();

    pb.UpdateCityStateArg = (function() {

        /**
         * Properties of an UpdateCityStateArg.
         * @memberof pb
         * @interface IUpdateCityStateArg
         * @property {pb.CityState|null} [State] UpdateCityStateArg State
         * @property {number|null} [CityID] UpdateCityStateArg CityID
         * @property {number|null} [OccupyCountryID] UpdateCityStateArg OccupyCountryID
         */

        /**
         * Constructs a new UpdateCityStateArg.
         * @memberof pb
         * @classdesc Represents an UpdateCityStateArg.
         * @implements IUpdateCityStateArg
         * @constructor
         * @param {pb.IUpdateCityStateArg=} [properties] Properties to set
         */
        function UpdateCityStateArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateCityStateArg State.
         * @member {pb.CityState} State
         * @memberof pb.UpdateCityStateArg
         * @instance
         */
        UpdateCityStateArg.prototype.State = 0;

        /**
         * UpdateCityStateArg CityID.
         * @member {number} CityID
         * @memberof pb.UpdateCityStateArg
         * @instance
         */
        UpdateCityStateArg.prototype.CityID = 0;

        /**
         * UpdateCityStateArg OccupyCountryID.
         * @member {number} OccupyCountryID
         * @memberof pb.UpdateCityStateArg
         * @instance
         */
        UpdateCityStateArg.prototype.OccupyCountryID = 0;

        /**
         * Creates a new UpdateCityStateArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {pb.IUpdateCityStateArg=} [properties] Properties to set
         * @returns {pb.UpdateCityStateArg} UpdateCityStateArg instance
         */
        UpdateCityStateArg.create = function create(properties) {
            return new UpdateCityStateArg(properties);
        };

        /**
         * Encodes the specified UpdateCityStateArg message. Does not implicitly {@link pb.UpdateCityStateArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {pb.IUpdateCityStateArg} message UpdateCityStateArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCityStateArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.State);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            if (message.OccupyCountryID != null && message.hasOwnProperty("OccupyCountryID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.OccupyCountryID);
            return writer;
        };

        /**
         * Encodes the specified UpdateCityStateArg message, length delimited. Does not implicitly {@link pb.UpdateCityStateArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {pb.IUpdateCityStateArg} message UpdateCityStateArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCityStateArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateCityStateArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateCityStateArg} UpdateCityStateArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCityStateArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateCityStateArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.State = reader.int32();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                case 3:
                    message.OccupyCountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateCityStateArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateCityStateArg} UpdateCityStateArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCityStateArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateCityStateArg message.
         * @function verify
         * @memberof pb.UpdateCityStateArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateCityStateArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.OccupyCountryID != null && message.hasOwnProperty("OccupyCountryID"))
                if (!$util.isInteger(message.OccupyCountryID))
                    return "OccupyCountryID: integer expected";
            return null;
        };

        return UpdateCityStateArg;
    })();

    pb.CampaignPlayerState = (function() {

        /**
         * Properties of a CampaignPlayerState.
         * @memberof pb
         * @interface ICampaignPlayerState
         * @property {pb.CampaignPlayerState.StateEnum|null} [State] CampaignPlayerState State
         * @property {Uint8Array|null} [Arg] CampaignPlayerState Arg
         */

        /**
         * Constructs a new CampaignPlayerState.
         * @memberof pb
         * @classdesc Represents a CampaignPlayerState.
         * @implements ICampaignPlayerState
         * @constructor
         * @param {pb.ICampaignPlayerState=} [properties] Properties to set
         */
        function CampaignPlayerState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignPlayerState State.
         * @member {pb.CampaignPlayerState.StateEnum} State
         * @memberof pb.CampaignPlayerState
         * @instance
         */
        CampaignPlayerState.prototype.State = 0;

        /**
         * CampaignPlayerState Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.CampaignPlayerState
         * @instance
         */
        CampaignPlayerState.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new CampaignPlayerState instance using the specified properties.
         * @function create
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {pb.ICampaignPlayerState=} [properties] Properties to set
         * @returns {pb.CampaignPlayerState} CampaignPlayerState instance
         */
        CampaignPlayerState.create = function create(properties) {
            return new CampaignPlayerState(properties);
        };

        /**
         * Encodes the specified CampaignPlayerState message. Does not implicitly {@link pb.CampaignPlayerState.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {pb.ICampaignPlayerState} message CampaignPlayerState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayerState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.State);
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified CampaignPlayerState message, length delimited. Does not implicitly {@link pb.CampaignPlayerState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {pb.ICampaignPlayerState} message CampaignPlayerState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayerState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignPlayerState message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignPlayerState} CampaignPlayerState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayerState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignPlayerState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.State = reader.int32();
                    break;
                case 2:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignPlayerState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignPlayerState} CampaignPlayerState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayerState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignPlayerState message.
         * @function verify
         * @memberof pb.CampaignPlayerState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignPlayerState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        /**
         * StateEnum enum.
         * @name pb.CampaignPlayerState.StateEnum
         * @enum {string}
         * @property {number} Normal=0 Normal value
         * @property {number} BeCaptive=1 BeCaptive value
         * @property {number} KickOut=2 KickOut value
         * @property {number} Support=3 Support value
         * @property {number} Expedition=4 Expedition value
         * @property {number} DefCity=5 DefCity value
         * @property {number} Rectify=6 Rectify value
         * @property {number} Rest=7 Rest value
         */
        CampaignPlayerState.StateEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Normal"] = 0;
            values[valuesById[1] = "BeCaptive"] = 1;
            values[valuesById[2] = "KickOut"] = 2;
            values[valuesById[3] = "Support"] = 3;
            values[valuesById[4] = "Expedition"] = 4;
            values[valuesById[5] = "DefCity"] = 5;
            values[valuesById[6] = "Rectify"] = 6;
            values[valuesById[7] = "Rest"] = 7;
            return values;
        })();

        return CampaignPlayerState;
    })();

    pb.CpStateKickOutArg = (function() {

        /**
         * Properties of a CpStateKickOutArg.
         * @memberof pb
         * @interface ICpStateKickOutArg
         * @property {number|null} [RemainTime] CpStateKickOutArg RemainTime
         */

        /**
         * Constructs a new CpStateKickOutArg.
         * @memberof pb
         * @classdesc Represents a CpStateKickOutArg.
         * @implements ICpStateKickOutArg
         * @constructor
         * @param {pb.ICpStateKickOutArg=} [properties] Properties to set
         */
        function CpStateKickOutArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CpStateKickOutArg RemainTime.
         * @member {number} RemainTime
         * @memberof pb.CpStateKickOutArg
         * @instance
         */
        CpStateKickOutArg.prototype.RemainTime = 0;

        /**
         * Creates a new CpStateKickOutArg instance using the specified properties.
         * @function create
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {pb.ICpStateKickOutArg=} [properties] Properties to set
         * @returns {pb.CpStateKickOutArg} CpStateKickOutArg instance
         */
        CpStateKickOutArg.create = function create(properties) {
            return new CpStateKickOutArg(properties);
        };

        /**
         * Encodes the specified CpStateKickOutArg message. Does not implicitly {@link pb.CpStateKickOutArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {pb.ICpStateKickOutArg} message CpStateKickOutArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateKickOutArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified CpStateKickOutArg message, length delimited. Does not implicitly {@link pb.CpStateKickOutArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {pb.ICpStateKickOutArg} message CpStateKickOutArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateKickOutArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CpStateKickOutArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CpStateKickOutArg} CpStateKickOutArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateKickOutArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CpStateKickOutArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CpStateKickOutArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CpStateKickOutArg} CpStateKickOutArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateKickOutArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CpStateKickOutArg message.
         * @function verify
         * @memberof pb.CpStateKickOutArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CpStateKickOutArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return CpStateKickOutArg;
    })();

    pb.CpStateLoadingArg = (function() {

        /**
         * Properties of a CpStateLoadingArg.
         * @memberof pb
         * @interface ICpStateLoadingArg
         * @property {number|null} [MaxTime] CpStateLoadingArg MaxTime
         * @property {number|null} [RemainTime] CpStateLoadingArg RemainTime
         */

        /**
         * Constructs a new CpStateLoadingArg.
         * @memberof pb
         * @classdesc Represents a CpStateLoadingArg.
         * @implements ICpStateLoadingArg
         * @constructor
         * @param {pb.ICpStateLoadingArg=} [properties] Properties to set
         */
        function CpStateLoadingArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CpStateLoadingArg MaxTime.
         * @member {number} MaxTime
         * @memberof pb.CpStateLoadingArg
         * @instance
         */
        CpStateLoadingArg.prototype.MaxTime = 0;

        /**
         * CpStateLoadingArg RemainTime.
         * @member {number} RemainTime
         * @memberof pb.CpStateLoadingArg
         * @instance
         */
        CpStateLoadingArg.prototype.RemainTime = 0;

        /**
         * Creates a new CpStateLoadingArg instance using the specified properties.
         * @function create
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {pb.ICpStateLoadingArg=} [properties] Properties to set
         * @returns {pb.CpStateLoadingArg} CpStateLoadingArg instance
         */
        CpStateLoadingArg.create = function create(properties) {
            return new CpStateLoadingArg(properties);
        };

        /**
         * Encodes the specified CpStateLoadingArg message. Does not implicitly {@link pb.CpStateLoadingArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {pb.ICpStateLoadingArg} message CpStateLoadingArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateLoadingArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MaxTime != null && message.hasOwnProperty("MaxTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MaxTime);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified CpStateLoadingArg message, length delimited. Does not implicitly {@link pb.CpStateLoadingArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {pb.ICpStateLoadingArg} message CpStateLoadingArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateLoadingArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CpStateLoadingArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CpStateLoadingArg} CpStateLoadingArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateLoadingArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CpStateLoadingArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MaxTime = reader.int32();
                    break;
                case 2:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CpStateLoadingArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CpStateLoadingArg} CpStateLoadingArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateLoadingArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CpStateLoadingArg message.
         * @function verify
         * @memberof pb.CpStateLoadingArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CpStateLoadingArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MaxTime != null && message.hasOwnProperty("MaxTime"))
                if (!$util.isInteger(message.MaxTime))
                    return "MaxTime: integer expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return CpStateLoadingArg;
    })();

    pb.CpStateBeCaptiveArg = (function() {

        /**
         * Properties of a CpStateBeCaptiveArg.
         * @memberof pb
         * @interface ICpStateBeCaptiveArg
         * @property {number|null} [RemainTime] CpStateBeCaptiveArg RemainTime
         */

        /**
         * Constructs a new CpStateBeCaptiveArg.
         * @memberof pb
         * @classdesc Represents a CpStateBeCaptiveArg.
         * @implements ICpStateBeCaptiveArg
         * @constructor
         * @param {pb.ICpStateBeCaptiveArg=} [properties] Properties to set
         */
        function CpStateBeCaptiveArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CpStateBeCaptiveArg RemainTime.
         * @member {number} RemainTime
         * @memberof pb.CpStateBeCaptiveArg
         * @instance
         */
        CpStateBeCaptiveArg.prototype.RemainTime = 0;

        /**
         * Creates a new CpStateBeCaptiveArg instance using the specified properties.
         * @function create
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {pb.ICpStateBeCaptiveArg=} [properties] Properties to set
         * @returns {pb.CpStateBeCaptiveArg} CpStateBeCaptiveArg instance
         */
        CpStateBeCaptiveArg.create = function create(properties) {
            return new CpStateBeCaptiveArg(properties);
        };

        /**
         * Encodes the specified CpStateBeCaptiveArg message. Does not implicitly {@link pb.CpStateBeCaptiveArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {pb.ICpStateBeCaptiveArg} message CpStateBeCaptiveArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateBeCaptiveArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified CpStateBeCaptiveArg message, length delimited. Does not implicitly {@link pb.CpStateBeCaptiveArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {pb.ICpStateBeCaptiveArg} message CpStateBeCaptiveArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CpStateBeCaptiveArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CpStateBeCaptiveArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CpStateBeCaptiveArg} CpStateBeCaptiveArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateBeCaptiveArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CpStateBeCaptiveArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CpStateBeCaptiveArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CpStateBeCaptiveArg} CpStateBeCaptiveArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CpStateBeCaptiveArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CpStateBeCaptiveArg message.
         * @function verify
         * @memberof pb.CpStateBeCaptiveArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CpStateBeCaptiveArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return CpStateBeCaptiveArg;
    })();

    pb.CitySimpleData = (function() {

        /**
         * Properties of a CitySimpleData.
         * @memberof pb
         * @interface ICitySimpleData
         * @property {number|null} [CityID] CitySimpleData CityID
         * @property {number|null} [CountryID] CitySimpleData CountryID
         * @property {pb.CityState|null} [State] CitySimpleData State
         * @property {number|null} [Defense] CitySimpleData Defense
         */

        /**
         * Constructs a new CitySimpleData.
         * @memberof pb
         * @classdesc Represents a CitySimpleData.
         * @implements ICitySimpleData
         * @constructor
         * @param {pb.ICitySimpleData=} [properties] Properties to set
         */
        function CitySimpleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CitySimpleData CityID.
         * @member {number} CityID
         * @memberof pb.CitySimpleData
         * @instance
         */
        CitySimpleData.prototype.CityID = 0;

        /**
         * CitySimpleData CountryID.
         * @member {number} CountryID
         * @memberof pb.CitySimpleData
         * @instance
         */
        CitySimpleData.prototype.CountryID = 0;

        /**
         * CitySimpleData State.
         * @member {pb.CityState} State
         * @memberof pb.CitySimpleData
         * @instance
         */
        CitySimpleData.prototype.State = 0;

        /**
         * CitySimpleData Defense.
         * @member {number} Defense
         * @memberof pb.CitySimpleData
         * @instance
         */
        CitySimpleData.prototype.Defense = 0;

        /**
         * Creates a new CitySimpleData instance using the specified properties.
         * @function create
         * @memberof pb.CitySimpleData
         * @static
         * @param {pb.ICitySimpleData=} [properties] Properties to set
         * @returns {pb.CitySimpleData} CitySimpleData instance
         */
        CitySimpleData.create = function create(properties) {
            return new CitySimpleData(properties);
        };

        /**
         * Encodes the specified CitySimpleData message. Does not implicitly {@link pb.CitySimpleData.verify|verify} messages.
         * @function encode
         * @memberof pb.CitySimpleData
         * @static
         * @param {pb.ICitySimpleData} message CitySimpleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CitySimpleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.CountryID);
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.State);
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Defense);
            return writer;
        };

        /**
         * Encodes the specified CitySimpleData message, length delimited. Does not implicitly {@link pb.CitySimpleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CitySimpleData
         * @static
         * @param {pb.ICitySimpleData} message CitySimpleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CitySimpleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CitySimpleData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CitySimpleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CitySimpleData} CitySimpleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CitySimpleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CitySimpleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.CountryID = reader.uint32();
                    break;
                case 3:
                    message.State = reader.int32();
                    break;
                case 4:
                    message.Defense = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CitySimpleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CitySimpleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CitySimpleData} CitySimpleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CitySimpleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CitySimpleData message.
         * @function verify
         * @memberof pb.CitySimpleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CitySimpleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                if (!$util.isInteger(message.Defense))
                    return "Defense: integer expected";
            return null;
        };

        return CitySimpleData;
    })();

    /**
     * TeamState enum.
     * @name pb.TeamState
     * @enum {string}
     * @property {number} NormalTS=0 NormalTS value
     * @property {number} FieldBattleTS=1 FieldBattleTS value
     * @property {number} CanAttackCityTS=2 CanAttackCityTS value
     * @property {number} AttackingCityTS=3 AttackingCityTS value
     * @property {number} DisappearTS=4 DisappearTS value
     * @property {number} FieldBattleEndTS=5 FieldBattleEndTS value
     * @property {number} AtkCityBattleTS=6 AtkCityBattleTS value
     * @property {number} DefCityBattleTS=7 DefCityBattleTS value
     * @property {number} DefCityBattleEndTS=8 DefCityBattleEndTS value
     */
    pb.TeamState = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NormalTS"] = 0;
        values[valuesById[1] = "FieldBattleTS"] = 1;
        values[valuesById[2] = "CanAttackCityTS"] = 2;
        values[valuesById[3] = "AttackingCityTS"] = 3;
        values[valuesById[4] = "DisappearTS"] = 4;
        values[valuesById[5] = "FieldBattleEndTS"] = 5;
        values[valuesById[6] = "AtkCityBattleTS"] = 6;
        values[valuesById[7] = "DefCityBattleTS"] = 7;
        values[valuesById[8] = "DefCityBattleEndTS"] = 8;
        return values;
    })();

    pb.TeamData = (function() {

        /**
         * Properties of a TeamData.
         * @memberof pb
         * @interface ITeamData
         * @property {number|null} [ID] TeamData ID
         * @property {number|null} [CountryID] TeamData CountryID
         * @property {Array.<number>|null} [CityPath] TeamData CityPath
         * @property {number|null} [Trip] TeamData Trip
         * @property {pb.TeamState|null} [State] TeamData State
         * @property {number|null} [TeamAmount] TeamData TeamAmount
         */

        /**
         * Constructs a new TeamData.
         * @memberof pb
         * @classdesc Represents a TeamData.
         * @implements ITeamData
         * @constructor
         * @param {pb.ITeamData=} [properties] Properties to set
         */
        function TeamData(properties) {
            this.CityPath = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TeamData ID.
         * @member {number} ID
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.ID = 0;

        /**
         * TeamData CountryID.
         * @member {number} CountryID
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.CountryID = 0;

        /**
         * TeamData CityPath.
         * @member {Array.<number>} CityPath
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.CityPath = $util.emptyArray;

        /**
         * TeamData Trip.
         * @member {number} Trip
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.Trip = 0;

        /**
         * TeamData State.
         * @member {pb.TeamState} State
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.State = 0;

        /**
         * TeamData TeamAmount.
         * @member {number} TeamAmount
         * @memberof pb.TeamData
         * @instance
         */
        TeamData.prototype.TeamAmount = 0;

        /**
         * Creates a new TeamData instance using the specified properties.
         * @function create
         * @memberof pb.TeamData
         * @static
         * @param {pb.ITeamData=} [properties] Properties to set
         * @returns {pb.TeamData} TeamData instance
         */
        TeamData.create = function create(properties) {
            return new TeamData(properties);
        };

        /**
         * Encodes the specified TeamData message. Does not implicitly {@link pb.TeamData.verify|verify} messages.
         * @function encode
         * @memberof pb.TeamData
         * @static
         * @param {pb.ITeamData} message TeamData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.CountryID);
            if (message.CityPath != null && message.CityPath.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.CityPath.length; ++i)
                    writer.int32(message.CityPath[i]);
                writer.ldelim();
            }
            if (message.Trip != null && message.hasOwnProperty("Trip"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Trip);
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.State);
            if (message.TeamAmount != null && message.hasOwnProperty("TeamAmount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.TeamAmount);
            return writer;
        };

        /**
         * Encodes the specified TeamData message, length delimited. Does not implicitly {@link pb.TeamData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TeamData
         * @static
         * @param {pb.ITeamData} message TeamData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TeamData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TeamData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TeamData} TeamData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TeamData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.CountryID = reader.uint32();
                    break;
                case 3:
                    if (!(message.CityPath && message.CityPath.length))
                        message.CityPath = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CityPath.push(reader.int32());
                    } else
                        message.CityPath.push(reader.int32());
                    break;
                case 4:
                    message.Trip = reader.int32();
                    break;
                case 5:
                    message.State = reader.int32();
                    break;
                case 6:
                    message.TeamAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TeamData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TeamData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TeamData} TeamData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TeamData message.
         * @function verify
         * @memberof pb.TeamData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TeamData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.CityPath != null && message.hasOwnProperty("CityPath")) {
                if (!Array.isArray(message.CityPath))
                    return "CityPath: array expected";
                for (var i = 0; i < message.CityPath.length; ++i)
                    if (!$util.isInteger(message.CityPath[i]))
                        return "CityPath: integer[] expected";
            }
            if (message.Trip != null && message.hasOwnProperty("Trip"))
                if (!$util.isInteger(message.Trip))
                    return "Trip: integer expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.TeamAmount != null && message.hasOwnProperty("TeamAmount"))
                if (!$util.isInteger(message.TeamAmount))
                    return "TeamAmount: integer expected";
            return null;
        };

        return TeamData;
    })();

    pb.UpdateMyTeamStateArg = (function() {

        /**
         * Properties of an UpdateMyTeamStateArg.
         * @memberof pb
         * @interface IUpdateMyTeamStateArg
         * @property {pb.TeamState|null} [State] UpdateMyTeamStateArg State
         * @property {Uint8Array|null} [Arg] UpdateMyTeamStateArg Arg
         */

        /**
         * Constructs a new UpdateMyTeamStateArg.
         * @memberof pb
         * @classdesc Represents an UpdateMyTeamStateArg.
         * @implements IUpdateMyTeamStateArg
         * @constructor
         * @param {pb.IUpdateMyTeamStateArg=} [properties] Properties to set
         */
        function UpdateMyTeamStateArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMyTeamStateArg State.
         * @member {pb.TeamState} State
         * @memberof pb.UpdateMyTeamStateArg
         * @instance
         */
        UpdateMyTeamStateArg.prototype.State = 0;

        /**
         * UpdateMyTeamStateArg Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.UpdateMyTeamStateArg
         * @instance
         */
        UpdateMyTeamStateArg.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new UpdateMyTeamStateArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {pb.IUpdateMyTeamStateArg=} [properties] Properties to set
         * @returns {pb.UpdateMyTeamStateArg} UpdateMyTeamStateArg instance
         */
        UpdateMyTeamStateArg.create = function create(properties) {
            return new UpdateMyTeamStateArg(properties);
        };

        /**
         * Encodes the specified UpdateMyTeamStateArg message. Does not implicitly {@link pb.UpdateMyTeamStateArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {pb.IUpdateMyTeamStateArg} message UpdateMyTeamStateArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyTeamStateArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.State != null && message.hasOwnProperty("State"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.State);
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified UpdateMyTeamStateArg message, length delimited. Does not implicitly {@link pb.UpdateMyTeamStateArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {pb.IUpdateMyTeamStateArg} message UpdateMyTeamStateArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyTeamStateArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMyTeamStateArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateMyTeamStateArg} UpdateMyTeamStateArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyTeamStateArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateMyTeamStateArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.State = reader.int32();
                    break;
                case 2:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMyTeamStateArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateMyTeamStateArg} UpdateMyTeamStateArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyTeamStateArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMyTeamStateArg message.
         * @function verify
         * @memberof pb.UpdateMyTeamStateArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMyTeamStateArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.State != null && message.hasOwnProperty("State"))
                switch (message.State) {
                default:
                    return "State: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                    break;
                }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        return UpdateMyTeamStateArg;
    })();

    pb.MyTeamDisappear = (function() {

        /**
         * Properties of a MyTeamDisappear.
         * @memberof pb
         * @interface IMyTeamDisappear
         * @property {pb.MyTeamDisappear.ReasonEnum|null} [Reason] MyTeamDisappear Reason
         * @property {Uint8Array|null} [Arg] MyTeamDisappear Arg
         */

        /**
         * Constructs a new MyTeamDisappear.
         * @memberof pb
         * @classdesc Represents a MyTeamDisappear.
         * @implements IMyTeamDisappear
         * @constructor
         * @param {pb.IMyTeamDisappear=} [properties] Properties to set
         */
        function MyTeamDisappear(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MyTeamDisappear Reason.
         * @member {pb.MyTeamDisappear.ReasonEnum} Reason
         * @memberof pb.MyTeamDisappear
         * @instance
         */
        MyTeamDisappear.prototype.Reason = 0;

        /**
         * MyTeamDisappear Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.MyTeamDisappear
         * @instance
         */
        MyTeamDisappear.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new MyTeamDisappear instance using the specified properties.
         * @function create
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {pb.IMyTeamDisappear=} [properties] Properties to set
         * @returns {pb.MyTeamDisappear} MyTeamDisappear instance
         */
        MyTeamDisappear.create = function create(properties) {
            return new MyTeamDisappear(properties);
        };

        /**
         * Encodes the specified MyTeamDisappear message. Does not implicitly {@link pb.MyTeamDisappear.verify|verify} messages.
         * @function encode
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {pb.IMyTeamDisappear} message MyTeamDisappear message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MyTeamDisappear.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Reason);
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified MyTeamDisappear message, length delimited. Does not implicitly {@link pb.MyTeamDisappear.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {pb.IMyTeamDisappear} message MyTeamDisappear message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MyTeamDisappear.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MyTeamDisappear message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MyTeamDisappear} MyTeamDisappear
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyTeamDisappear.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MyTeamDisappear();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Reason = reader.int32();
                    break;
                case 2:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MyTeamDisappear message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MyTeamDisappear} MyTeamDisappear
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MyTeamDisappear.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MyTeamDisappear message.
         * @function verify
         * @memberof pb.MyTeamDisappear
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MyTeamDisappear.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                switch (message.Reason) {
                default:
                    return "Reason: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        /**
         * ReasonEnum enum.
         * @name pb.MyTeamDisappear.ReasonEnum
         * @enum {string}
         * @property {number} Retreat=0 Retreat value
         * @property {number} CityBeOccupy=1 CityBeOccupy value
         * @property {number} OccupyCity=2 OccupyCity value
         * @property {number} EnterCity=3 EnterCity value
         * @property {number} NoForage=4 NoForage value
         * @property {number} CountryDestory=5 CountryDestory value
         */
        MyTeamDisappear.ReasonEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Retreat"] = 0;
            values[valuesById[1] = "CityBeOccupy"] = 1;
            values[valuesById[2] = "OccupyCity"] = 2;
            values[valuesById[3] = "EnterCity"] = 3;
            values[valuesById[4] = "NoForage"] = 4;
            values[valuesById[5] = "CountryDestory"] = 5;
            return values;
        })();

        return MyTeamDisappear;
    })();

    pb.TeamRetreat = (function() {

        /**
         * Properties of a TeamRetreat.
         * @memberof pb
         * @interface ITeamRetreat
         * @property {number|null} [OldCity] TeamRetreat OldCity
         * @property {number|null} [NewCity] TeamRetreat NewCity
         */

        /**
         * Constructs a new TeamRetreat.
         * @memberof pb
         * @classdesc Represents a TeamRetreat.
         * @implements ITeamRetreat
         * @constructor
         * @param {pb.ITeamRetreat=} [properties] Properties to set
         */
        function TeamRetreat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TeamRetreat OldCity.
         * @member {number} OldCity
         * @memberof pb.TeamRetreat
         * @instance
         */
        TeamRetreat.prototype.OldCity = 0;

        /**
         * TeamRetreat NewCity.
         * @member {number} NewCity
         * @memberof pb.TeamRetreat
         * @instance
         */
        TeamRetreat.prototype.NewCity = 0;

        /**
         * Creates a new TeamRetreat instance using the specified properties.
         * @function create
         * @memberof pb.TeamRetreat
         * @static
         * @param {pb.ITeamRetreat=} [properties] Properties to set
         * @returns {pb.TeamRetreat} TeamRetreat instance
         */
        TeamRetreat.create = function create(properties) {
            return new TeamRetreat(properties);
        };

        /**
         * Encodes the specified TeamRetreat message. Does not implicitly {@link pb.TeamRetreat.verify|verify} messages.
         * @function encode
         * @memberof pb.TeamRetreat
         * @static
         * @param {pb.ITeamRetreat} message TeamRetreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamRetreat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OldCity != null && message.hasOwnProperty("OldCity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.OldCity);
            if (message.NewCity != null && message.hasOwnProperty("NewCity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NewCity);
            return writer;
        };

        /**
         * Encodes the specified TeamRetreat message, length delimited. Does not implicitly {@link pb.TeamRetreat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TeamRetreat
         * @static
         * @param {pb.ITeamRetreat} message TeamRetreat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TeamRetreat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TeamRetreat message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TeamRetreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TeamRetreat} TeamRetreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamRetreat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TeamRetreat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.OldCity = reader.int32();
                    break;
                case 2:
                    message.NewCity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TeamRetreat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TeamRetreat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TeamRetreat} TeamRetreat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TeamRetreat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TeamRetreat message.
         * @function verify
         * @memberof pb.TeamRetreat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TeamRetreat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OldCity != null && message.hasOwnProperty("OldCity"))
                if (!$util.isInteger(message.OldCity))
                    return "OldCity: integer expected";
            if (message.NewCity != null && message.hasOwnProperty("NewCity"))
                if (!$util.isInteger(message.NewCity))
                    return "NewCity: integer expected";
            return null;
        };

        return TeamRetreat;
    })();

    /**
     * MilitaryOrderType enum.
     * @name pb.MilitaryOrderType
     * @enum {string}
     * @property {number} SupportMT=0 SupportMT value
     * @property {number} ExpeditionMT=1 ExpeditionMT value
     * @property {number} DefCityMT=2 DefCityMT value
     */
    pb.MilitaryOrderType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SupportMT"] = 0;
        values[valuesById[1] = "ExpeditionMT"] = 1;
        values[valuesById[2] = "DefCityMT"] = 2;
        return values;
    })();

    pb.MilitaryOrder = (function() {

        /**
         * Properties of a MilitaryOrder.
         * @memberof pb
         * @interface IMilitaryOrder
         * @property {pb.MilitaryOrderType|null} [Type] MilitaryOrder Type
         * @property {number|null} [Forage] MilitaryOrder Forage
         * @property {number|null} [Amount] MilitaryOrder Amount
         * @property {number|null} [MaxAmount] MilitaryOrder MaxAmount
         * @property {number|null} [TargetCity] MilitaryOrder TargetCity
         */

        /**
         * Constructs a new MilitaryOrder.
         * @memberof pb
         * @classdesc Represents a MilitaryOrder.
         * @implements IMilitaryOrder
         * @constructor
         * @param {pb.IMilitaryOrder=} [properties] Properties to set
         */
        function MilitaryOrder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MilitaryOrder Type.
         * @member {pb.MilitaryOrderType} Type
         * @memberof pb.MilitaryOrder
         * @instance
         */
        MilitaryOrder.prototype.Type = 0;

        /**
         * MilitaryOrder Forage.
         * @member {number} Forage
         * @memberof pb.MilitaryOrder
         * @instance
         */
        MilitaryOrder.prototype.Forage = 0;

        /**
         * MilitaryOrder Amount.
         * @member {number} Amount
         * @memberof pb.MilitaryOrder
         * @instance
         */
        MilitaryOrder.prototype.Amount = 0;

        /**
         * MilitaryOrder MaxAmount.
         * @member {number} MaxAmount
         * @memberof pb.MilitaryOrder
         * @instance
         */
        MilitaryOrder.prototype.MaxAmount = 0;

        /**
         * MilitaryOrder TargetCity.
         * @member {number} TargetCity
         * @memberof pb.MilitaryOrder
         * @instance
         */
        MilitaryOrder.prototype.TargetCity = 0;

        /**
         * Creates a new MilitaryOrder instance using the specified properties.
         * @function create
         * @memberof pb.MilitaryOrder
         * @static
         * @param {pb.IMilitaryOrder=} [properties] Properties to set
         * @returns {pb.MilitaryOrder} MilitaryOrder instance
         */
        MilitaryOrder.create = function create(properties) {
            return new MilitaryOrder(properties);
        };

        /**
         * Encodes the specified MilitaryOrder message. Does not implicitly {@link pb.MilitaryOrder.verify|verify} messages.
         * @function encode
         * @memberof pb.MilitaryOrder
         * @static
         * @param {pb.IMilitaryOrder} message MilitaryOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MilitaryOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Forage);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Amount);
            if (message.MaxAmount != null && message.hasOwnProperty("MaxAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MaxAmount);
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.TargetCity);
            return writer;
        };

        /**
         * Encodes the specified MilitaryOrder message, length delimited. Does not implicitly {@link pb.MilitaryOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MilitaryOrder
         * @static
         * @param {pb.IMilitaryOrder} message MilitaryOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MilitaryOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MilitaryOrder message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MilitaryOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MilitaryOrder} MilitaryOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MilitaryOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MilitaryOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Forage = reader.int32();
                    break;
                case 3:
                    message.Amount = reader.int32();
                    break;
                case 4:
                    message.MaxAmount = reader.int32();
                    break;
                case 5:
                    message.TargetCity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MilitaryOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MilitaryOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MilitaryOrder} MilitaryOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MilitaryOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MilitaryOrder message.
         * @function verify
         * @memberof pb.MilitaryOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MilitaryOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.MaxAmount != null && message.hasOwnProperty("MaxAmount"))
                if (!$util.isInteger(message.MaxAmount))
                    return "MaxAmount: integer expected";
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                if (!$util.isInteger(message.TargetCity))
                    return "TargetCity: integer expected";
            return null;
        };

        return MilitaryOrder;
    })();

    pb.PublishMilitaryOrderArg = (function() {

        /**
         * Properties of a PublishMilitaryOrderArg.
         * @memberof pb
         * @interface IPublishMilitaryOrderArg
         * @property {pb.MilitaryOrderType|null} [Type] PublishMilitaryOrderArg Type
         * @property {number|null} [Forage] PublishMilitaryOrderArg Forage
         * @property {number|null} [Amount] PublishMilitaryOrderArg Amount
         * @property {Array.<number>|null} [CityPath] PublishMilitaryOrderArg CityPath
         */

        /**
         * Constructs a new PublishMilitaryOrderArg.
         * @memberof pb
         * @classdesc Represents a PublishMilitaryOrderArg.
         * @implements IPublishMilitaryOrderArg
         * @constructor
         * @param {pb.IPublishMilitaryOrderArg=} [properties] Properties to set
         */
        function PublishMilitaryOrderArg(properties) {
            this.CityPath = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishMilitaryOrderArg Type.
         * @member {pb.MilitaryOrderType} Type
         * @memberof pb.PublishMilitaryOrderArg
         * @instance
         */
        PublishMilitaryOrderArg.prototype.Type = 0;

        /**
         * PublishMilitaryOrderArg Forage.
         * @member {number} Forage
         * @memberof pb.PublishMilitaryOrderArg
         * @instance
         */
        PublishMilitaryOrderArg.prototype.Forage = 0;

        /**
         * PublishMilitaryOrderArg Amount.
         * @member {number} Amount
         * @memberof pb.PublishMilitaryOrderArg
         * @instance
         */
        PublishMilitaryOrderArg.prototype.Amount = 0;

        /**
         * PublishMilitaryOrderArg CityPath.
         * @member {Array.<number>} CityPath
         * @memberof pb.PublishMilitaryOrderArg
         * @instance
         */
        PublishMilitaryOrderArg.prototype.CityPath = $util.emptyArray;

        /**
         * Creates a new PublishMilitaryOrderArg instance using the specified properties.
         * @function create
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {pb.IPublishMilitaryOrderArg=} [properties] Properties to set
         * @returns {pb.PublishMilitaryOrderArg} PublishMilitaryOrderArg instance
         */
        PublishMilitaryOrderArg.create = function create(properties) {
            return new PublishMilitaryOrderArg(properties);
        };

        /**
         * Encodes the specified PublishMilitaryOrderArg message. Does not implicitly {@link pb.PublishMilitaryOrderArg.verify|verify} messages.
         * @function encode
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {pb.IPublishMilitaryOrderArg} message PublishMilitaryOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishMilitaryOrderArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Forage);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Amount);
            if (message.CityPath != null && message.CityPath.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.CityPath.length; ++i)
                    writer.int32(message.CityPath[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified PublishMilitaryOrderArg message, length delimited. Does not implicitly {@link pb.PublishMilitaryOrderArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {pb.IPublishMilitaryOrderArg} message PublishMilitaryOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishMilitaryOrderArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishMilitaryOrderArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PublishMilitaryOrderArg} PublishMilitaryOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishMilitaryOrderArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PublishMilitaryOrderArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Forage = reader.int32();
                    break;
                case 3:
                    message.Amount = reader.int32();
                    break;
                case 4:
                    if (!(message.CityPath && message.CityPath.length))
                        message.CityPath = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CityPath.push(reader.int32());
                    } else
                        message.CityPath.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishMilitaryOrderArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PublishMilitaryOrderArg} PublishMilitaryOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishMilitaryOrderArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishMilitaryOrderArg message.
         * @function verify
         * @memberof pb.PublishMilitaryOrderArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishMilitaryOrderArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.CityPath != null && message.hasOwnProperty("CityPath")) {
                if (!Array.isArray(message.CityPath))
                    return "CityPath: array expected";
                for (var i = 0; i < message.CityPath.length; ++i)
                    if (!$util.isInteger(message.CityPath[i]))
                        return "CityPath: integer[] expected";
            }
            return null;
        };

        return PublishMilitaryOrderArg;
    })();

    pb.PublishMilitaryOrderReply = (function() {

        /**
         * Properties of a PublishMilitaryOrderReply.
         * @memberof pb
         * @interface IPublishMilitaryOrderReply
         * @property {Array.<pb.IMilitaryOrder>|null} [Orders] PublishMilitaryOrderReply Orders
         * @property {number|null} [Forage] PublishMilitaryOrderReply Forage
         */

        /**
         * Constructs a new PublishMilitaryOrderReply.
         * @memberof pb
         * @classdesc Represents a PublishMilitaryOrderReply.
         * @implements IPublishMilitaryOrderReply
         * @constructor
         * @param {pb.IPublishMilitaryOrderReply=} [properties] Properties to set
         */
        function PublishMilitaryOrderReply(properties) {
            this.Orders = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PublishMilitaryOrderReply Orders.
         * @member {Array.<pb.IMilitaryOrder>} Orders
         * @memberof pb.PublishMilitaryOrderReply
         * @instance
         */
        PublishMilitaryOrderReply.prototype.Orders = $util.emptyArray;

        /**
         * PublishMilitaryOrderReply Forage.
         * @member {number} Forage
         * @memberof pb.PublishMilitaryOrderReply
         * @instance
         */
        PublishMilitaryOrderReply.prototype.Forage = 0;

        /**
         * Creates a new PublishMilitaryOrderReply instance using the specified properties.
         * @function create
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {pb.IPublishMilitaryOrderReply=} [properties] Properties to set
         * @returns {pb.PublishMilitaryOrderReply} PublishMilitaryOrderReply instance
         */
        PublishMilitaryOrderReply.create = function create(properties) {
            return new PublishMilitaryOrderReply(properties);
        };

        /**
         * Encodes the specified PublishMilitaryOrderReply message. Does not implicitly {@link pb.PublishMilitaryOrderReply.verify|verify} messages.
         * @function encode
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {pb.IPublishMilitaryOrderReply} message PublishMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishMilitaryOrderReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Orders != null && message.Orders.length)
                for (var i = 0; i < message.Orders.length; ++i)
                    $root.pb.MilitaryOrder.encode(message.Orders[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Forage);
            return writer;
        };

        /**
         * Encodes the specified PublishMilitaryOrderReply message, length delimited. Does not implicitly {@link pb.PublishMilitaryOrderReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {pb.IPublishMilitaryOrderReply} message PublishMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PublishMilitaryOrderReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PublishMilitaryOrderReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PublishMilitaryOrderReply} PublishMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishMilitaryOrderReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PublishMilitaryOrderReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Orders && message.Orders.length))
                        message.Orders = [];
                    message.Orders.push($root.pb.MilitaryOrder.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.Forage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PublishMilitaryOrderReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PublishMilitaryOrderReply} PublishMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PublishMilitaryOrderReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PublishMilitaryOrderReply message.
         * @function verify
         * @memberof pb.PublishMilitaryOrderReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PublishMilitaryOrderReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Orders != null && message.hasOwnProperty("Orders")) {
                if (!Array.isArray(message.Orders))
                    return "Orders: array expected";
                for (var i = 0; i < message.Orders.length; ++i) {
                    var error = $root.pb.MilitaryOrder.verify(message.Orders[i]);
                    if (error)
                        return "Orders." + error;
                }
            }
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            return null;
        };

        return PublishMilitaryOrderReply;
    })();

    pb.CancelMilitaryOrderReply = (function() {

        /**
         * Properties of a CancelMilitaryOrderReply.
         * @memberof pb
         * @interface ICancelMilitaryOrderReply
         * @property {number|null} [Forage] CancelMilitaryOrderReply Forage
         */

        /**
         * Constructs a new CancelMilitaryOrderReply.
         * @memberof pb
         * @classdesc Represents a CancelMilitaryOrderReply.
         * @implements ICancelMilitaryOrderReply
         * @constructor
         * @param {pb.ICancelMilitaryOrderReply=} [properties] Properties to set
         */
        function CancelMilitaryOrderReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelMilitaryOrderReply Forage.
         * @member {number} Forage
         * @memberof pb.CancelMilitaryOrderReply
         * @instance
         */
        CancelMilitaryOrderReply.prototype.Forage = 0;

        /**
         * Creates a new CancelMilitaryOrderReply instance using the specified properties.
         * @function create
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {pb.ICancelMilitaryOrderReply=} [properties] Properties to set
         * @returns {pb.CancelMilitaryOrderReply} CancelMilitaryOrderReply instance
         */
        CancelMilitaryOrderReply.create = function create(properties) {
            return new CancelMilitaryOrderReply(properties);
        };

        /**
         * Encodes the specified CancelMilitaryOrderReply message. Does not implicitly {@link pb.CancelMilitaryOrderReply.verify|verify} messages.
         * @function encode
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {pb.ICancelMilitaryOrderReply} message CancelMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelMilitaryOrderReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Forage);
            return writer;
        };

        /**
         * Encodes the specified CancelMilitaryOrderReply message, length delimited. Does not implicitly {@link pb.CancelMilitaryOrderReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {pb.ICancelMilitaryOrderReply} message CancelMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelMilitaryOrderReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelMilitaryOrderReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CancelMilitaryOrderReply} CancelMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelMilitaryOrderReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelMilitaryOrderReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Forage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelMilitaryOrderReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CancelMilitaryOrderReply} CancelMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelMilitaryOrderReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelMilitaryOrderReply message.
         * @function verify
         * @memberof pb.CancelMilitaryOrderReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelMilitaryOrderReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            return null;
        };

        return CancelMilitaryOrderReply;
    })();

    pb.MilitaryOrderInfo = (function() {

        /**
         * Properties of a MilitaryOrderInfo.
         * @memberof pb
         * @interface IMilitaryOrderInfo
         * @property {Array.<pb.IMilitaryOrder>|null} [Orders] MilitaryOrderInfo Orders
         */

        /**
         * Constructs a new MilitaryOrderInfo.
         * @memberof pb
         * @classdesc Represents a MilitaryOrderInfo.
         * @implements IMilitaryOrderInfo
         * @constructor
         * @param {pb.IMilitaryOrderInfo=} [properties] Properties to set
         */
        function MilitaryOrderInfo(properties) {
            this.Orders = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MilitaryOrderInfo Orders.
         * @member {Array.<pb.IMilitaryOrder>} Orders
         * @memberof pb.MilitaryOrderInfo
         * @instance
         */
        MilitaryOrderInfo.prototype.Orders = $util.emptyArray;

        /**
         * Creates a new MilitaryOrderInfo instance using the specified properties.
         * @function create
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {pb.IMilitaryOrderInfo=} [properties] Properties to set
         * @returns {pb.MilitaryOrderInfo} MilitaryOrderInfo instance
         */
        MilitaryOrderInfo.create = function create(properties) {
            return new MilitaryOrderInfo(properties);
        };

        /**
         * Encodes the specified MilitaryOrderInfo message. Does not implicitly {@link pb.MilitaryOrderInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {pb.IMilitaryOrderInfo} message MilitaryOrderInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MilitaryOrderInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Orders != null && message.Orders.length)
                for (var i = 0; i < message.Orders.length; ++i)
                    $root.pb.MilitaryOrder.encode(message.Orders[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MilitaryOrderInfo message, length delimited. Does not implicitly {@link pb.MilitaryOrderInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {pb.IMilitaryOrderInfo} message MilitaryOrderInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MilitaryOrderInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MilitaryOrderInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MilitaryOrderInfo} MilitaryOrderInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MilitaryOrderInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MilitaryOrderInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Orders && message.Orders.length))
                        message.Orders = [];
                    message.Orders.push($root.pb.MilitaryOrder.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MilitaryOrderInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MilitaryOrderInfo} MilitaryOrderInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MilitaryOrderInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MilitaryOrderInfo message.
         * @function verify
         * @memberof pb.MilitaryOrderInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MilitaryOrderInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Orders != null && message.hasOwnProperty("Orders")) {
                if (!Array.isArray(message.Orders))
                    return "Orders: array expected";
                for (var i = 0; i < message.Orders.length; ++i) {
                    var error = $root.pb.MilitaryOrder.verify(message.Orders[i]);
                    if (error)
                        return "Orders." + error;
                }
            }
            return null;
        };

        return MilitaryOrderInfo;
    })();

    pb.TargetMilitaryOrder = (function() {

        /**
         * Properties of a TargetMilitaryOrder.
         * @memberof pb
         * @interface ITargetMilitaryOrder
         * @property {pb.MilitaryOrderType|null} [Type] TargetMilitaryOrder Type
         * @property {number|null} [TargetCity] TargetMilitaryOrder TargetCity
         */

        /**
         * Constructs a new TargetMilitaryOrder.
         * @memberof pb
         * @classdesc Represents a TargetMilitaryOrder.
         * @implements ITargetMilitaryOrder
         * @constructor
         * @param {pb.ITargetMilitaryOrder=} [properties] Properties to set
         */
        function TargetMilitaryOrder(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetMilitaryOrder Type.
         * @member {pb.MilitaryOrderType} Type
         * @memberof pb.TargetMilitaryOrder
         * @instance
         */
        TargetMilitaryOrder.prototype.Type = 0;

        /**
         * TargetMilitaryOrder TargetCity.
         * @member {number} TargetCity
         * @memberof pb.TargetMilitaryOrder
         * @instance
         */
        TargetMilitaryOrder.prototype.TargetCity = 0;

        /**
         * Creates a new TargetMilitaryOrder instance using the specified properties.
         * @function create
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {pb.ITargetMilitaryOrder=} [properties] Properties to set
         * @returns {pb.TargetMilitaryOrder} TargetMilitaryOrder instance
         */
        TargetMilitaryOrder.create = function create(properties) {
            return new TargetMilitaryOrder(properties);
        };

        /**
         * Encodes the specified TargetMilitaryOrder message. Does not implicitly {@link pb.TargetMilitaryOrder.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {pb.ITargetMilitaryOrder} message TargetMilitaryOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetMilitaryOrder.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TargetCity);
            return writer;
        };

        /**
         * Encodes the specified TargetMilitaryOrder message, length delimited. Does not implicitly {@link pb.TargetMilitaryOrder.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {pb.ITargetMilitaryOrder} message TargetMilitaryOrder message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetMilitaryOrder.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetMilitaryOrder message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetMilitaryOrder} TargetMilitaryOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetMilitaryOrder.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetMilitaryOrder();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.TargetCity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetMilitaryOrder message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetMilitaryOrder} TargetMilitaryOrder
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetMilitaryOrder.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetMilitaryOrder message.
         * @function verify
         * @memberof pb.TargetMilitaryOrder
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetMilitaryOrder.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                if (!$util.isInteger(message.TargetCity))
                    return "TargetCity: integer expected";
            return null;
        };

        return TargetMilitaryOrder;
    })();

    pb.AcceptMilitaryOrderArg = (function() {

        /**
         * Properties of an AcceptMilitaryOrderArg.
         * @memberof pb
         * @interface IAcceptMilitaryOrderArg
         * @property {pb.MilitaryOrderType|null} [Type] AcceptMilitaryOrderArg Type
         * @property {number|null} [TargetCity] AcceptMilitaryOrderArg TargetCity
         * @property {Array.<number>|null} [CardIDs] AcceptMilitaryOrderArg CardIDs
         */

        /**
         * Constructs a new AcceptMilitaryOrderArg.
         * @memberof pb
         * @classdesc Represents an AcceptMilitaryOrderArg.
         * @implements IAcceptMilitaryOrderArg
         * @constructor
         * @param {pb.IAcceptMilitaryOrderArg=} [properties] Properties to set
         */
        function AcceptMilitaryOrderArg(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptMilitaryOrderArg Type.
         * @member {pb.MilitaryOrderType} Type
         * @memberof pb.AcceptMilitaryOrderArg
         * @instance
         */
        AcceptMilitaryOrderArg.prototype.Type = 0;

        /**
         * AcceptMilitaryOrderArg TargetCity.
         * @member {number} TargetCity
         * @memberof pb.AcceptMilitaryOrderArg
         * @instance
         */
        AcceptMilitaryOrderArg.prototype.TargetCity = 0;

        /**
         * AcceptMilitaryOrderArg CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.AcceptMilitaryOrderArg
         * @instance
         */
        AcceptMilitaryOrderArg.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new AcceptMilitaryOrderArg instance using the specified properties.
         * @function create
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {pb.IAcceptMilitaryOrderArg=} [properties] Properties to set
         * @returns {pb.AcceptMilitaryOrderArg} AcceptMilitaryOrderArg instance
         */
        AcceptMilitaryOrderArg.create = function create(properties) {
            return new AcceptMilitaryOrderArg(properties);
        };

        /**
         * Encodes the specified AcceptMilitaryOrderArg message. Does not implicitly {@link pb.AcceptMilitaryOrderArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {pb.IAcceptMilitaryOrderArg} message AcceptMilitaryOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptMilitaryOrderArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TargetCity);
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified AcceptMilitaryOrderArg message, length delimited. Does not implicitly {@link pb.AcceptMilitaryOrderArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {pb.IAcceptMilitaryOrderArg} message AcceptMilitaryOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptMilitaryOrderArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptMilitaryOrderArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AcceptMilitaryOrderArg} AcceptMilitaryOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptMilitaryOrderArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AcceptMilitaryOrderArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.TargetCity = reader.int32();
                    break;
                case 3:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptMilitaryOrderArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AcceptMilitaryOrderArg} AcceptMilitaryOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptMilitaryOrderArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptMilitaryOrderArg message.
         * @function verify
         * @memberof pb.AcceptMilitaryOrderArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptMilitaryOrderArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                if (!$util.isInteger(message.TargetCity))
                    return "TargetCity: integer expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return AcceptMilitaryOrderArg;
    })();

    pb.AcceptMilitaryOrderReply = (function() {

        /**
         * Properties of an AcceptMilitaryOrderReply.
         * @memberof pb
         * @interface IAcceptMilitaryOrderReply
         * @property {pb.ICampaignPlayerState|null} [State] AcceptMilitaryOrderReply State
         * @property {pb.ITeamData|null} [Team] AcceptMilitaryOrderReply Team
         */

        /**
         * Constructs a new AcceptMilitaryOrderReply.
         * @memberof pb
         * @classdesc Represents an AcceptMilitaryOrderReply.
         * @implements IAcceptMilitaryOrderReply
         * @constructor
         * @param {pb.IAcceptMilitaryOrderReply=} [properties] Properties to set
         */
        function AcceptMilitaryOrderReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptMilitaryOrderReply State.
         * @member {pb.ICampaignPlayerState|null|undefined} State
         * @memberof pb.AcceptMilitaryOrderReply
         * @instance
         */
        AcceptMilitaryOrderReply.prototype.State = null;

        /**
         * AcceptMilitaryOrderReply Team.
         * @member {pb.ITeamData|null|undefined} Team
         * @memberof pb.AcceptMilitaryOrderReply
         * @instance
         */
        AcceptMilitaryOrderReply.prototype.Team = null;

        /**
         * Creates a new AcceptMilitaryOrderReply instance using the specified properties.
         * @function create
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {pb.IAcceptMilitaryOrderReply=} [properties] Properties to set
         * @returns {pb.AcceptMilitaryOrderReply} AcceptMilitaryOrderReply instance
         */
        AcceptMilitaryOrderReply.create = function create(properties) {
            return new AcceptMilitaryOrderReply(properties);
        };

        /**
         * Encodes the specified AcceptMilitaryOrderReply message. Does not implicitly {@link pb.AcceptMilitaryOrderReply.verify|verify} messages.
         * @function encode
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {pb.IAcceptMilitaryOrderReply} message AcceptMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptMilitaryOrderReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.State != null && message.hasOwnProperty("State"))
                $root.pb.CampaignPlayerState.encode(message.State, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Team != null && message.hasOwnProperty("Team"))
                $root.pb.TeamData.encode(message.Team, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AcceptMilitaryOrderReply message, length delimited. Does not implicitly {@link pb.AcceptMilitaryOrderReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {pb.IAcceptMilitaryOrderReply} message AcceptMilitaryOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptMilitaryOrderReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptMilitaryOrderReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AcceptMilitaryOrderReply} AcceptMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptMilitaryOrderReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AcceptMilitaryOrderReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.State = $root.pb.CampaignPlayerState.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Team = $root.pb.TeamData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptMilitaryOrderReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AcceptMilitaryOrderReply} AcceptMilitaryOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptMilitaryOrderReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptMilitaryOrderReply message.
         * @function verify
         * @memberof pb.AcceptMilitaryOrderReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptMilitaryOrderReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.State != null && message.hasOwnProperty("State")) {
                var error = $root.pb.CampaignPlayerState.verify(message.State);
                if (error)
                    return "State." + error;
            }
            if (message.Team != null && message.hasOwnProperty("Team")) {
                var error = $root.pb.TeamData.verify(message.Team);
                if (error)
                    return "Team." + error;
            }
            return null;
        };

        return AcceptMilitaryOrderReply;
    })();

    pb.CountrySimpleData = (function() {

        /**
         * Properties of a CountrySimpleData.
         * @memberof pb
         * @interface ICountrySimpleData
         * @property {number|null} [CountryID] CountrySimpleData CountryID
         * @property {string|null} [Name] CountrySimpleData Name
         * @property {string|null} [Flag] CountrySimpleData Flag
         */

        /**
         * Constructs a new CountrySimpleData.
         * @memberof pb
         * @classdesc Represents a CountrySimpleData.
         * @implements ICountrySimpleData
         * @constructor
         * @param {pb.ICountrySimpleData=} [properties] Properties to set
         */
        function CountrySimpleData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CountrySimpleData CountryID.
         * @member {number} CountryID
         * @memberof pb.CountrySimpleData
         * @instance
         */
        CountrySimpleData.prototype.CountryID = 0;

        /**
         * CountrySimpleData Name.
         * @member {string} Name
         * @memberof pb.CountrySimpleData
         * @instance
         */
        CountrySimpleData.prototype.Name = "";

        /**
         * CountrySimpleData Flag.
         * @member {string} Flag
         * @memberof pb.CountrySimpleData
         * @instance
         */
        CountrySimpleData.prototype.Flag = "";

        /**
         * Creates a new CountrySimpleData instance using the specified properties.
         * @function create
         * @memberof pb.CountrySimpleData
         * @static
         * @param {pb.ICountrySimpleData=} [properties] Properties to set
         * @returns {pb.CountrySimpleData} CountrySimpleData instance
         */
        CountrySimpleData.create = function create(properties) {
            return new CountrySimpleData(properties);
        };

        /**
         * Encodes the specified CountrySimpleData message. Does not implicitly {@link pb.CountrySimpleData.verify|verify} messages.
         * @function encode
         * @memberof pb.CountrySimpleData
         * @static
         * @param {pb.ICountrySimpleData} message CountrySimpleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountrySimpleData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Flag);
            return writer;
        };

        /**
         * Encodes the specified CountrySimpleData message, length delimited. Does not implicitly {@link pb.CountrySimpleData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CountrySimpleData
         * @static
         * @param {pb.ICountrySimpleData} message CountrySimpleData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountrySimpleData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CountrySimpleData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CountrySimpleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CountrySimpleData} CountrySimpleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountrySimpleData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CountrySimpleData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Flag = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CountrySimpleData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CountrySimpleData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CountrySimpleData} CountrySimpleData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountrySimpleData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CountrySimpleData message.
         * @function verify
         * @memberof pb.CountrySimpleData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CountrySimpleData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                if (!$util.isString(message.Flag))
                    return "Flag: string expected";
            return null;
        };

        return CountrySimpleData;
    })();

    pb.CampaignInfo = (function() {

        /**
         * Properties of a CampaignInfo.
         * @memberof pb
         * @interface ICampaignInfo
         * @property {Array.<pb.ICitySimpleData>|null} [Citys] CampaignInfo Citys
         * @property {Array.<pb.ICountrySimpleData>|null} [Countrys] CampaignInfo Countrys
         * @property {number|null} [MyCityID] CampaignInfo MyCityID
         * @property {number|null} [MyLocationCityID] CampaignInfo MyLocationCityID
         * @property {pb.CampaignJob|null} [MyCityJob] CampaignInfo MyCityJob
         * @property {pb.CampaignJob|null} [MyCountryJob] CampaignInfo MyCountryJob
         * @property {pb.ITeamData|null} [MyTeam] CampaignInfo MyTeam
         * @property {Array.<pb.ITeamData>|null} [Teams] CampaignInfo Teams
         * @property {number|null} [Forage] CampaignInfo Forage
         * @property {boolean|null} [HasCompleteMission] CampaignInfo HasCompleteMission
         * @property {boolean|null} [HasNewNotice] CampaignInfo HasNewNotice
         * @property {pb.ICampaignState|null} [State] CampaignInfo State
         * @property {pb.ICampaignPlayerState|null} [MyState] CampaignInfo MyState
         * @property {number|null} [MyCountryID] CampaignInfo MyCountryID
         * @property {number|null} [Contribution] CampaignInfo Contribution
         * @property {number|null} [LastCountryID] CampaignInfo LastCountryID
         * @property {pb.IMyTeamDisappear|null} [TeamDisappear] CampaignInfo TeamDisappear
         * @property {Array.<number>|null} [SupportCards] CampaignInfo SupportCards
         * @property {number|null} [MaxContribution] CampaignInfo MaxContribution
         * @property {pb.ICitysDefPlayerAmount|null} [DefPlayerAmounts] CampaignInfo DefPlayerAmounts
         */

        /**
         * Constructs a new CampaignInfo.
         * @memberof pb
         * @classdesc Represents a CampaignInfo.
         * @implements ICampaignInfo
         * @constructor
         * @param {pb.ICampaignInfo=} [properties] Properties to set
         */
        function CampaignInfo(properties) {
            this.Citys = [];
            this.Countrys = [];
            this.Teams = [];
            this.SupportCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignInfo Citys.
         * @member {Array.<pb.ICitySimpleData>} Citys
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.Citys = $util.emptyArray;

        /**
         * CampaignInfo Countrys.
         * @member {Array.<pb.ICountrySimpleData>} Countrys
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.Countrys = $util.emptyArray;

        /**
         * CampaignInfo MyCityID.
         * @member {number} MyCityID
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyCityID = 0;

        /**
         * CampaignInfo MyLocationCityID.
         * @member {number} MyLocationCityID
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyLocationCityID = 0;

        /**
         * CampaignInfo MyCityJob.
         * @member {pb.CampaignJob} MyCityJob
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyCityJob = 0;

        /**
         * CampaignInfo MyCountryJob.
         * @member {pb.CampaignJob} MyCountryJob
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyCountryJob = 0;

        /**
         * CampaignInfo MyTeam.
         * @member {pb.ITeamData|null|undefined} MyTeam
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyTeam = null;

        /**
         * CampaignInfo Teams.
         * @member {Array.<pb.ITeamData>} Teams
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.Teams = $util.emptyArray;

        /**
         * CampaignInfo Forage.
         * @member {number} Forage
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.Forage = 0;

        /**
         * CampaignInfo HasCompleteMission.
         * @member {boolean} HasCompleteMission
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.HasCompleteMission = false;

        /**
         * CampaignInfo HasNewNotice.
         * @member {boolean} HasNewNotice
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.HasNewNotice = false;

        /**
         * CampaignInfo State.
         * @member {pb.ICampaignState|null|undefined} State
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.State = null;

        /**
         * CampaignInfo MyState.
         * @member {pb.ICampaignPlayerState|null|undefined} MyState
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyState = null;

        /**
         * CampaignInfo MyCountryID.
         * @member {number} MyCountryID
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MyCountryID = 0;

        /**
         * CampaignInfo Contribution.
         * @member {number} Contribution
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.Contribution = 0;

        /**
         * CampaignInfo LastCountryID.
         * @member {number} LastCountryID
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.LastCountryID = 0;

        /**
         * CampaignInfo TeamDisappear.
         * @member {pb.IMyTeamDisappear|null|undefined} TeamDisappear
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.TeamDisappear = null;

        /**
         * CampaignInfo SupportCards.
         * @member {Array.<number>} SupportCards
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.SupportCards = $util.emptyArray;

        /**
         * CampaignInfo MaxContribution.
         * @member {number} MaxContribution
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.MaxContribution = 0;

        /**
         * CampaignInfo DefPlayerAmounts.
         * @member {pb.ICitysDefPlayerAmount|null|undefined} DefPlayerAmounts
         * @memberof pb.CampaignInfo
         * @instance
         */
        CampaignInfo.prototype.DefPlayerAmounts = null;

        /**
         * Creates a new CampaignInfo instance using the specified properties.
         * @function create
         * @memberof pb.CampaignInfo
         * @static
         * @param {pb.ICampaignInfo=} [properties] Properties to set
         * @returns {pb.CampaignInfo} CampaignInfo instance
         */
        CampaignInfo.create = function create(properties) {
            return new CampaignInfo(properties);
        };

        /**
         * Encodes the specified CampaignInfo message. Does not implicitly {@link pb.CampaignInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignInfo
         * @static
         * @param {pb.ICampaignInfo} message CampaignInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Citys != null && message.Citys.length)
                for (var i = 0; i < message.Citys.length; ++i)
                    $root.pb.CitySimpleData.encode(message.Citys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Countrys != null && message.Countrys.length)
                for (var i = 0; i < message.Countrys.length; ++i)
                    $root.pb.CountrySimpleData.encode(message.Countrys[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.MyCityID != null && message.hasOwnProperty("MyCityID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MyCityID);
            if (message.MyLocationCityID != null && message.hasOwnProperty("MyLocationCityID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MyLocationCityID);
            if (message.MyCityJob != null && message.hasOwnProperty("MyCityJob"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MyCityJob);
            if (message.MyCountryJob != null && message.hasOwnProperty("MyCountryJob"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.MyCountryJob);
            if (message.MyTeam != null && message.hasOwnProperty("MyTeam"))
                $root.pb.TeamData.encode(message.MyTeam, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.Teams != null && message.Teams.length)
                for (var i = 0; i < message.Teams.length; ++i)
                    $root.pb.TeamData.encode(message.Teams[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.Forage);
            if (message.HasCompleteMission != null && message.hasOwnProperty("HasCompleteMission"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.HasCompleteMission);
            if (message.HasNewNotice != null && message.hasOwnProperty("HasNewNotice"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.HasNewNotice);
            if (message.State != null && message.hasOwnProperty("State"))
                $root.pb.CampaignState.encode(message.State, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
            if (message.MyState != null && message.hasOwnProperty("MyState"))
                $root.pb.CampaignPlayerState.encode(message.MyState, writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.MyCountryID != null && message.hasOwnProperty("MyCountryID"))
                writer.uint32(/* id 14, wireType 0 =*/112).uint32(message.MyCountryID);
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.Contribution);
            if (message.LastCountryID != null && message.hasOwnProperty("LastCountryID"))
                writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.LastCountryID);
            if (message.TeamDisappear != null && message.hasOwnProperty("TeamDisappear"))
                $root.pb.MyTeamDisappear.encode(message.TeamDisappear, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.SupportCards != null && message.SupportCards.length) {
                writer.uint32(/* id 18, wireType 2 =*/146).fork();
                for (var i = 0; i < message.SupportCards.length; ++i)
                    writer.uint32(message.SupportCards[i]);
                writer.ldelim();
            }
            if (message.MaxContribution != null && message.hasOwnProperty("MaxContribution"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.MaxContribution);
            if (message.DefPlayerAmounts != null && message.hasOwnProperty("DefPlayerAmounts"))
                $root.pb.CitysDefPlayerAmount.encode(message.DefPlayerAmounts, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignInfo message, length delimited. Does not implicitly {@link pb.CampaignInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignInfo
         * @static
         * @param {pb.ICampaignInfo} message CampaignInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignInfo} CampaignInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Citys && message.Citys.length))
                        message.Citys = [];
                    message.Citys.push($root.pb.CitySimpleData.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.Countrys && message.Countrys.length))
                        message.Countrys = [];
                    message.Countrys.push($root.pb.CountrySimpleData.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.MyCityID = reader.int32();
                    break;
                case 4:
                    message.MyLocationCityID = reader.int32();
                    break;
                case 5:
                    message.MyCityJob = reader.int32();
                    break;
                case 6:
                    message.MyCountryJob = reader.int32();
                    break;
                case 7:
                    message.MyTeam = $root.pb.TeamData.decode(reader, reader.uint32());
                    break;
                case 8:
                    if (!(message.Teams && message.Teams.length))
                        message.Teams = [];
                    message.Teams.push($root.pb.TeamData.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.Forage = reader.int32();
                    break;
                case 10:
                    message.HasCompleteMission = reader.bool();
                    break;
                case 11:
                    message.HasNewNotice = reader.bool();
                    break;
                case 12:
                    message.State = $root.pb.CampaignState.decode(reader, reader.uint32());
                    break;
                case 13:
                    message.MyState = $root.pb.CampaignPlayerState.decode(reader, reader.uint32());
                    break;
                case 14:
                    message.MyCountryID = reader.uint32();
                    break;
                case 15:
                    message.Contribution = reader.int32();
                    break;
                case 16:
                    message.LastCountryID = reader.uint32();
                    break;
                case 17:
                    message.TeamDisappear = $root.pb.MyTeamDisappear.decode(reader, reader.uint32());
                    break;
                case 18:
                    if (!(message.SupportCards && message.SupportCards.length))
                        message.SupportCards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.SupportCards.push(reader.uint32());
                    } else
                        message.SupportCards.push(reader.uint32());
                    break;
                case 19:
                    message.MaxContribution = reader.int32();
                    break;
                case 20:
                    message.DefPlayerAmounts = $root.pb.CitysDefPlayerAmount.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignInfo} CampaignInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignInfo message.
         * @function verify
         * @memberof pb.CampaignInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Citys != null && message.hasOwnProperty("Citys")) {
                if (!Array.isArray(message.Citys))
                    return "Citys: array expected";
                for (var i = 0; i < message.Citys.length; ++i) {
                    var error = $root.pb.CitySimpleData.verify(message.Citys[i]);
                    if (error)
                        return "Citys." + error;
                }
            }
            if (message.Countrys != null && message.hasOwnProperty("Countrys")) {
                if (!Array.isArray(message.Countrys))
                    return "Countrys: array expected";
                for (var i = 0; i < message.Countrys.length; ++i) {
                    var error = $root.pb.CountrySimpleData.verify(message.Countrys[i]);
                    if (error)
                        return "Countrys." + error;
                }
            }
            if (message.MyCityID != null && message.hasOwnProperty("MyCityID"))
                if (!$util.isInteger(message.MyCityID))
                    return "MyCityID: integer expected";
            if (message.MyLocationCityID != null && message.hasOwnProperty("MyLocationCityID"))
                if (!$util.isInteger(message.MyLocationCityID))
                    return "MyLocationCityID: integer expected";
            if (message.MyCityJob != null && message.hasOwnProperty("MyCityJob"))
                switch (message.MyCityJob) {
                default:
                    return "MyCityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.MyCountryJob != null && message.hasOwnProperty("MyCountryJob"))
                switch (message.MyCountryJob) {
                default:
                    return "MyCountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.MyTeam != null && message.hasOwnProperty("MyTeam")) {
                var error = $root.pb.TeamData.verify(message.MyTeam);
                if (error)
                    return "MyTeam." + error;
            }
            if (message.Teams != null && message.hasOwnProperty("Teams")) {
                if (!Array.isArray(message.Teams))
                    return "Teams: array expected";
                for (var i = 0; i < message.Teams.length; ++i) {
                    var error = $root.pb.TeamData.verify(message.Teams[i]);
                    if (error)
                        return "Teams." + error;
                }
            }
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            if (message.HasCompleteMission != null && message.hasOwnProperty("HasCompleteMission"))
                if (typeof message.HasCompleteMission !== "boolean")
                    return "HasCompleteMission: boolean expected";
            if (message.HasNewNotice != null && message.hasOwnProperty("HasNewNotice"))
                if (typeof message.HasNewNotice !== "boolean")
                    return "HasNewNotice: boolean expected";
            if (message.State != null && message.hasOwnProperty("State")) {
                var error = $root.pb.CampaignState.verify(message.State);
                if (error)
                    return "State." + error;
            }
            if (message.MyState != null && message.hasOwnProperty("MyState")) {
                var error = $root.pb.CampaignPlayerState.verify(message.MyState);
                if (error)
                    return "MyState." + error;
            }
            if (message.MyCountryID != null && message.hasOwnProperty("MyCountryID"))
                if (!$util.isInteger(message.MyCountryID))
                    return "MyCountryID: integer expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.LastCountryID != null && message.hasOwnProperty("LastCountryID"))
                if (!$util.isInteger(message.LastCountryID))
                    return "LastCountryID: integer expected";
            if (message.TeamDisappear != null && message.hasOwnProperty("TeamDisappear")) {
                var error = $root.pb.MyTeamDisappear.verify(message.TeamDisappear);
                if (error)
                    return "TeamDisappear." + error;
            }
            if (message.SupportCards != null && message.hasOwnProperty("SupportCards")) {
                if (!Array.isArray(message.SupportCards))
                    return "SupportCards: array expected";
                for (var i = 0; i < message.SupportCards.length; ++i)
                    if (!$util.isInteger(message.SupportCards[i]))
                        return "SupportCards: integer[] expected";
            }
            if (message.MaxContribution != null && message.hasOwnProperty("MaxContribution"))
                if (!$util.isInteger(message.MaxContribution))
                    return "MaxContribution: integer expected";
            if (message.DefPlayerAmounts != null && message.hasOwnProperty("DefPlayerAmounts")) {
                var error = $root.pb.CitysDefPlayerAmount.verify(message.DefPlayerAmounts);
                if (error)
                    return "DefPlayerAmounts." + error;
            }
            return null;
        };

        return CampaignInfo;
    })();

    pb.CreateCountryArg = (function() {

        /**
         * Properties of a CreateCountryArg.
         * @memberof pb
         * @interface ICreateCountryArg
         * @property {number|null} [Gold] CreateCountryArg Gold
         */

        /**
         * Constructs a new CreateCountryArg.
         * @memberof pb
         * @classdesc Represents a CreateCountryArg.
         * @implements ICreateCountryArg
         * @constructor
         * @param {pb.ICreateCountryArg=} [properties] Properties to set
         */
        function CreateCountryArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateCountryArg Gold.
         * @member {number} Gold
         * @memberof pb.CreateCountryArg
         * @instance
         */
        CreateCountryArg.prototype.Gold = 0;

        /**
         * Creates a new CreateCountryArg instance using the specified properties.
         * @function create
         * @memberof pb.CreateCountryArg
         * @static
         * @param {pb.ICreateCountryArg=} [properties] Properties to set
         * @returns {pb.CreateCountryArg} CreateCountryArg instance
         */
        CreateCountryArg.create = function create(properties) {
            return new CreateCountryArg(properties);
        };

        /**
         * Encodes the specified CreateCountryArg message. Does not implicitly {@link pb.CreateCountryArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CreateCountryArg
         * @static
         * @param {pb.ICreateCountryArg} message CreateCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateCountryArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified CreateCountryArg message, length delimited. Does not implicitly {@link pb.CreateCountryArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CreateCountryArg
         * @static
         * @param {pb.ICreateCountryArg} message CreateCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateCountryArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateCountryArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CreateCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CreateCountryArg} CreateCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateCountryArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CreateCountryArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateCountryArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CreateCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CreateCountryArg} CreateCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateCountryArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateCountryArg message.
         * @function verify
         * @memberof pb.CreateCountryArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateCountryArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return CreateCountryArg;
    })();

    pb.TargetCity = (function() {

        /**
         * Properties of a TargetCity.
         * @memberof pb
         * @interface ITargetCity
         * @property {number|null} [CityID] TargetCity CityID
         */

        /**
         * Constructs a new TargetCity.
         * @memberof pb
         * @classdesc Represents a TargetCity.
         * @implements ITargetCity
         * @constructor
         * @param {pb.ITargetCity=} [properties] Properties to set
         */
        function TargetCity(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetCity CityID.
         * @member {number} CityID
         * @memberof pb.TargetCity
         * @instance
         */
        TargetCity.prototype.CityID = 0;

        /**
         * Creates a new TargetCity instance using the specified properties.
         * @function create
         * @memberof pb.TargetCity
         * @static
         * @param {pb.ITargetCity=} [properties] Properties to set
         * @returns {pb.TargetCity} TargetCity instance
         */
        TargetCity.create = function create(properties) {
            return new TargetCity(properties);
        };

        /**
         * Encodes the specified TargetCity message. Does not implicitly {@link pb.TargetCity.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetCity
         * @static
         * @param {pb.ITargetCity} message TargetCity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetCity.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified TargetCity message, length delimited. Does not implicitly {@link pb.TargetCity.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetCity
         * @static
         * @param {pb.ITargetCity} message TargetCity message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetCity.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetCity message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetCity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetCity} TargetCity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetCity.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetCity();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetCity message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetCity
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetCity} TargetCity
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetCity.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetCity message.
         * @function verify
         * @memberof pb.TargetCity
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetCity.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return TargetCity;
    })();

    pb.CountryCreatedArg = (function() {

        /**
         * Properties of a CountryCreatedArg.
         * @memberof pb
         * @interface ICountryCreatedArg
         * @property {number|null} [CountryID] CountryCreatedArg CountryID
         * @property {string|null} [Name] CountryCreatedArg Name
         * @property {string|null} [Flag] CountryCreatedArg Flag
         * @property {number|null} [CityID] CountryCreatedArg CityID
         * @property {pb.ICampaignSimplePlayer|null} [YourMajesty] CountryCreatedArg YourMajesty
         */

        /**
         * Constructs a new CountryCreatedArg.
         * @memberof pb
         * @classdesc Represents a CountryCreatedArg.
         * @implements ICountryCreatedArg
         * @constructor
         * @param {pb.ICountryCreatedArg=} [properties] Properties to set
         */
        function CountryCreatedArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CountryCreatedArg CountryID.
         * @member {number} CountryID
         * @memberof pb.CountryCreatedArg
         * @instance
         */
        CountryCreatedArg.prototype.CountryID = 0;

        /**
         * CountryCreatedArg Name.
         * @member {string} Name
         * @memberof pb.CountryCreatedArg
         * @instance
         */
        CountryCreatedArg.prototype.Name = "";

        /**
         * CountryCreatedArg Flag.
         * @member {string} Flag
         * @memberof pb.CountryCreatedArg
         * @instance
         */
        CountryCreatedArg.prototype.Flag = "";

        /**
         * CountryCreatedArg CityID.
         * @member {number} CityID
         * @memberof pb.CountryCreatedArg
         * @instance
         */
        CountryCreatedArg.prototype.CityID = 0;

        /**
         * CountryCreatedArg YourMajesty.
         * @member {pb.ICampaignSimplePlayer|null|undefined} YourMajesty
         * @memberof pb.CountryCreatedArg
         * @instance
         */
        CountryCreatedArg.prototype.YourMajesty = null;

        /**
         * Creates a new CountryCreatedArg instance using the specified properties.
         * @function create
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {pb.ICountryCreatedArg=} [properties] Properties to set
         * @returns {pb.CountryCreatedArg} CountryCreatedArg instance
         */
        CountryCreatedArg.create = function create(properties) {
            return new CountryCreatedArg(properties);
        };

        /**
         * Encodes the specified CountryCreatedArg message. Does not implicitly {@link pb.CountryCreatedArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {pb.ICountryCreatedArg} message CountryCreatedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryCreatedArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Flag);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CityID);
            if (message.YourMajesty != null && message.hasOwnProperty("YourMajesty"))
                $root.pb.CampaignSimplePlayer.encode(message.YourMajesty, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CountryCreatedArg message, length delimited. Does not implicitly {@link pb.CountryCreatedArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {pb.ICountryCreatedArg} message CountryCreatedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryCreatedArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CountryCreatedArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CountryCreatedArg} CountryCreatedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryCreatedArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CountryCreatedArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Flag = reader.string();
                    break;
                case 4:
                    message.CityID = reader.int32();
                    break;
                case 5:
                    message.YourMajesty = $root.pb.CampaignSimplePlayer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CountryCreatedArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CountryCreatedArg} CountryCreatedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryCreatedArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CountryCreatedArg message.
         * @function verify
         * @memberof pb.CountryCreatedArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CountryCreatedArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                if (!$util.isString(message.Flag))
                    return "Flag: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.YourMajesty != null && message.hasOwnProperty("YourMajesty")) {
                var error = $root.pb.CampaignSimplePlayer.verify(message.YourMajesty);
                if (error)
                    return "YourMajesty." + error;
            }
            return null;
        };

        return CountryCreatedArg;
    })();

    /**
     * CampaignJob enum.
     * @name pb.CampaignJob
     * @enum {string}
     * @property {number} UnknowJob=0 UnknowJob value
     * @property {number} YourMajesty=1 YourMajesty value
     * @property {number} Counsellor=2 Counsellor value
     * @property {number} General=3 General value
     * @property {number} Prefect=4 Prefect value
     * @property {number} DuWei=5 DuWei value
     * @property {number} FieldOfficer=6 FieldOfficer value
     */
    pb.CampaignJob = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UnknowJob"] = 0;
        values[valuesById[1] = "YourMajesty"] = 1;
        values[valuesById[2] = "Counsellor"] = 2;
        values[valuesById[3] = "General"] = 3;
        values[valuesById[4] = "Prefect"] = 4;
        values[valuesById[5] = "DuWei"] = 5;
        values[valuesById[6] = "FieldOfficer"] = 6;
        return values;
    })();

    pb.CampaignPlayer = (function() {

        /**
         * Properties of a CampaignPlayer.
         * @memberof pb
         * @interface ICampaignPlayer
         * @property {number|Long|null} [Uid] CampaignPlayer Uid
         * @property {string|null} [Name] CampaignPlayer Name
         * @property {string|null} [HeadImg] CampaignPlayer HeadImg
         * @property {string|null} [HeadFrame] CampaignPlayer HeadFrame
         * @property {pb.CampaignJob|null} [CityJob] CampaignPlayer CityJob
         * @property {pb.CampaignJob|null} [CountryJob] CampaignPlayer CountryJob
         * @property {number|null} [PvpScore] CampaignPlayer PvpScore
         * @property {number|null} [Contribution] CampaignPlayer Contribution
         * @property {pb.ICampaignPlayerState|null} [State] CampaignPlayer State
         */

        /**
         * Constructs a new CampaignPlayer.
         * @memberof pb
         * @classdesc Represents a CampaignPlayer.
         * @implements ICampaignPlayer
         * @constructor
         * @param {pb.ICampaignPlayer=} [properties] Properties to set
         */
        function CampaignPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignPlayer Uid.
         * @member {number|Long} Uid
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CampaignPlayer Name.
         * @member {string} Name
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.Name = "";

        /**
         * CampaignPlayer HeadImg.
         * @member {string} HeadImg
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.HeadImg = "";

        /**
         * CampaignPlayer HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.HeadFrame = "";

        /**
         * CampaignPlayer CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.CityJob = 0;

        /**
         * CampaignPlayer CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.CountryJob = 0;

        /**
         * CampaignPlayer PvpScore.
         * @member {number} PvpScore
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.PvpScore = 0;

        /**
         * CampaignPlayer Contribution.
         * @member {number} Contribution
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.Contribution = 0;

        /**
         * CampaignPlayer State.
         * @member {pb.ICampaignPlayerState|null|undefined} State
         * @memberof pb.CampaignPlayer
         * @instance
         */
        CampaignPlayer.prototype.State = null;

        /**
         * Creates a new CampaignPlayer instance using the specified properties.
         * @function create
         * @memberof pb.CampaignPlayer
         * @static
         * @param {pb.ICampaignPlayer=} [properties] Properties to set
         * @returns {pb.CampaignPlayer} CampaignPlayer instance
         */
        CampaignPlayer.create = function create(properties) {
            return new CampaignPlayer(properties);
        };

        /**
         * Encodes the specified CampaignPlayer message. Does not implicitly {@link pb.CampaignPlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignPlayer
         * @static
         * @param {pb.ICampaignPlayer} message CampaignPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImg);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.HeadFrame);
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.CountryJob);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.PvpScore);
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Contribution);
            if (message.State != null && message.hasOwnProperty("State"))
                $root.pb.CampaignPlayerState.encode(message.State, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignPlayer message, length delimited. Does not implicitly {@link pb.CampaignPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignPlayer
         * @static
         * @param {pb.ICampaignPlayer} message CampaignPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignPlayer} CampaignPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.HeadImg = reader.string();
                    break;
                case 4:
                    message.HeadFrame = reader.string();
                    break;
                case 5:
                    message.CityJob = reader.int32();
                    break;
                case 6:
                    message.CountryJob = reader.int32();
                    break;
                case 7:
                    message.PvpScore = reader.int32();
                    break;
                case 8:
                    message.Contribution = reader.int32();
                    break;
                case 9:
                    message.State = $root.pb.CampaignPlayerState.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignPlayer} CampaignPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignPlayer message.
         * @function verify
         * @memberof pb.CampaignPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                if (!$util.isString(message.HeadImg))
                    return "HeadImg: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.State != null && message.hasOwnProperty("State")) {
                var error = $root.pb.CampaignPlayerState.verify(message.State);
                if (error)
                    return "State." + error;
            }
            return null;
        };

        return CampaignPlayer;
    })();

    pb.CampaignPlayerList = (function() {

        /**
         * Properties of a CampaignPlayerList.
         * @memberof pb
         * @interface ICampaignPlayerList
         * @property {Array.<pb.ICampaignPlayer>|null} [Players] CampaignPlayerList Players
         */

        /**
         * Constructs a new CampaignPlayerList.
         * @memberof pb
         * @classdesc Represents a CampaignPlayerList.
         * @implements ICampaignPlayerList
         * @constructor
         * @param {pb.ICampaignPlayerList=} [properties] Properties to set
         */
        function CampaignPlayerList(properties) {
            this.Players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignPlayerList Players.
         * @member {Array.<pb.ICampaignPlayer>} Players
         * @memberof pb.CampaignPlayerList
         * @instance
         */
        CampaignPlayerList.prototype.Players = $util.emptyArray;

        /**
         * Creates a new CampaignPlayerList instance using the specified properties.
         * @function create
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {pb.ICampaignPlayerList=} [properties] Properties to set
         * @returns {pb.CampaignPlayerList} CampaignPlayerList instance
         */
        CampaignPlayerList.create = function create(properties) {
            return new CampaignPlayerList(properties);
        };

        /**
         * Encodes the specified CampaignPlayerList message. Does not implicitly {@link pb.CampaignPlayerList.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {pb.ICampaignPlayerList} message CampaignPlayerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayerList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Players != null && message.Players.length)
                for (var i = 0; i < message.Players.length; ++i)
                    $root.pb.CampaignPlayer.encode(message.Players[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignPlayerList message, length delimited. Does not implicitly {@link pb.CampaignPlayerList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {pb.ICampaignPlayerList} message CampaignPlayerList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPlayerList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignPlayerList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignPlayerList} CampaignPlayerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayerList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignPlayerList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Players && message.Players.length))
                        message.Players = [];
                    message.Players.push($root.pb.CampaignPlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignPlayerList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignPlayerList} CampaignPlayerList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPlayerList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignPlayerList message.
         * @function verify
         * @memberof pb.CampaignPlayerList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignPlayerList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Players != null && message.hasOwnProperty("Players")) {
                if (!Array.isArray(message.Players))
                    return "Players: array expected";
                for (var i = 0; i < message.Players.length; ++i) {
                    var error = $root.pb.CampaignPlayer.verify(message.Players[i]);
                    if (error)
                        return "Players." + error;
                }
            }
            return null;
        };

        return CampaignPlayerList;
    })();

    pb.CityData = (function() {

        /**
         * Properties of a CityData.
         * @memberof pb
         * @interface ICityData
         * @property {number|null} [CountryID] CityData CountryID
         * @property {number|null} [PlayerAmount] CityData PlayerAmount
         * @property {number|null} [Agriculture] CityData Agriculture
         * @property {number|null} [Business] CityData Business
         * @property {number|null} [Defense] CityData Defense
         * @property {number|null} [Forage] CityData Forage
         * @property {number|null} [Gold] CityData Gold
         * @property {number|null} [Glory] CityData Glory
         * @property {Array.<pb.ICampaignPlayer>|null} [Players] CityData Players
         * @property {pb.IApplyCreateCountryData|null} [ApplyCreateCountry] CityData ApplyCreateCountry
         * @property {pb.ICampaignSimplePlayer|null} [YourMajesty] CityData YourMajesty
         * @property {number|null} [InCityPlayerAmount] CityData InCityPlayerAmount
         */

        /**
         * Constructs a new CityData.
         * @memberof pb
         * @classdesc Represents a CityData.
         * @implements ICityData
         * @constructor
         * @param {pb.ICityData=} [properties] Properties to set
         */
        function CityData(properties) {
            this.Players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityData CountryID.
         * @member {number} CountryID
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.CountryID = 0;

        /**
         * CityData PlayerAmount.
         * @member {number} PlayerAmount
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.PlayerAmount = 0;

        /**
         * CityData Agriculture.
         * @member {number} Agriculture
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Agriculture = 0;

        /**
         * CityData Business.
         * @member {number} Business
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Business = 0;

        /**
         * CityData Defense.
         * @member {number} Defense
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Defense = 0;

        /**
         * CityData Forage.
         * @member {number} Forage
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Forage = 0;

        /**
         * CityData Gold.
         * @member {number} Gold
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Gold = 0;

        /**
         * CityData Glory.
         * @member {number} Glory
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Glory = 0;

        /**
         * CityData Players.
         * @member {Array.<pb.ICampaignPlayer>} Players
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.Players = $util.emptyArray;

        /**
         * CityData ApplyCreateCountry.
         * @member {pb.IApplyCreateCountryData|null|undefined} ApplyCreateCountry
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.ApplyCreateCountry = null;

        /**
         * CityData YourMajesty.
         * @member {pb.ICampaignSimplePlayer|null|undefined} YourMajesty
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.YourMajesty = null;

        /**
         * CityData InCityPlayerAmount.
         * @member {number} InCityPlayerAmount
         * @memberof pb.CityData
         * @instance
         */
        CityData.prototype.InCityPlayerAmount = 0;

        /**
         * Creates a new CityData instance using the specified properties.
         * @function create
         * @memberof pb.CityData
         * @static
         * @param {pb.ICityData=} [properties] Properties to set
         * @returns {pb.CityData} CityData instance
         */
        CityData.create = function create(properties) {
            return new CityData(properties);
        };

        /**
         * Encodes the specified CityData message. Does not implicitly {@link pb.CityData.verify|verify} messages.
         * @function encode
         * @memberof pb.CityData
         * @static
         * @param {pb.ICityData} message CityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PlayerAmount);
            if (message.Agriculture != null && message.hasOwnProperty("Agriculture"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Agriculture);
            if (message.Business != null && message.hasOwnProperty("Business"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Business);
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Defense);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Forage);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Gold);
            if (message.Glory != null && message.hasOwnProperty("Glory"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Glory);
            if (message.Players != null && message.Players.length)
                for (var i = 0; i < message.Players.length; ++i)
                    $root.pb.CampaignPlayer.encode(message.Players[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.ApplyCreateCountry != null && message.hasOwnProperty("ApplyCreateCountry"))
                $root.pb.ApplyCreateCountryData.encode(message.ApplyCreateCountry, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.YourMajesty != null && message.hasOwnProperty("YourMajesty"))
                $root.pb.CampaignSimplePlayer.encode(message.YourMajesty, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
            if (message.InCityPlayerAmount != null && message.hasOwnProperty("InCityPlayerAmount"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.InCityPlayerAmount);
            return writer;
        };

        /**
         * Encodes the specified CityData message, length delimited. Does not implicitly {@link pb.CityData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityData
         * @static
         * @param {pb.ICityData} message CityData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityData} CityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.PlayerAmount = reader.int32();
                    break;
                case 3:
                    message.Agriculture = reader.int32();
                    break;
                case 4:
                    message.Business = reader.int32();
                    break;
                case 5:
                    message.Defense = reader.int32();
                    break;
                case 6:
                    message.Forage = reader.int32();
                    break;
                case 7:
                    message.Gold = reader.int32();
                    break;
                case 8:
                    message.Glory = reader.int32();
                    break;
                case 9:
                    if (!(message.Players && message.Players.length))
                        message.Players = [];
                    message.Players.push($root.pb.CampaignPlayer.decode(reader, reader.uint32()));
                    break;
                case 10:
                    message.ApplyCreateCountry = $root.pb.ApplyCreateCountryData.decode(reader, reader.uint32());
                    break;
                case 11:
                    message.YourMajesty = $root.pb.CampaignSimplePlayer.decode(reader, reader.uint32());
                    break;
                case 12:
                    message.InCityPlayerAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityData} CityData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityData message.
         * @function verify
         * @memberof pb.CityData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                if (!$util.isInteger(message.PlayerAmount))
                    return "PlayerAmount: integer expected";
            if (message.Agriculture != null && message.hasOwnProperty("Agriculture"))
                if (!$util.isInteger(message.Agriculture))
                    return "Agriculture: integer expected";
            if (message.Business != null && message.hasOwnProperty("Business"))
                if (!$util.isInteger(message.Business))
                    return "Business: integer expected";
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                if (!$util.isInteger(message.Defense))
                    return "Defense: integer expected";
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Glory != null && message.hasOwnProperty("Glory"))
                if (!$util.isInteger(message.Glory))
                    return "Glory: integer expected";
            if (message.Players != null && message.hasOwnProperty("Players")) {
                if (!Array.isArray(message.Players))
                    return "Players: array expected";
                for (var i = 0; i < message.Players.length; ++i) {
                    var error = $root.pb.CampaignPlayer.verify(message.Players[i]);
                    if (error)
                        return "Players." + error;
                }
            }
            if (message.ApplyCreateCountry != null && message.hasOwnProperty("ApplyCreateCountry")) {
                var error = $root.pb.ApplyCreateCountryData.verify(message.ApplyCreateCountry);
                if (error)
                    return "ApplyCreateCountry." + error;
            }
            if (message.YourMajesty != null && message.hasOwnProperty("YourMajesty")) {
                var error = $root.pb.CampaignSimplePlayer.verify(message.YourMajesty);
                if (error)
                    return "YourMajesty." + error;
            }
            if (message.InCityPlayerAmount != null && message.hasOwnProperty("InCityPlayerAmount"))
                if (!$util.isInteger(message.InCityPlayerAmount))
                    return "InCityPlayerAmount: integer expected";
            return null;
        };

        return CityData;
    })();

    pb.FetchApplyCreateCountryPlayersArg = (function() {

        /**
         * Properties of a FetchApplyCreateCountryPlayersArg.
         * @memberof pb
         * @interface IFetchApplyCreateCountryPlayersArg
         * @property {number|null} [CityID] FetchApplyCreateCountryPlayersArg CityID
         * @property {number|null} [Page] FetchApplyCreateCountryPlayersArg Page
         */

        /**
         * Constructs a new FetchApplyCreateCountryPlayersArg.
         * @memberof pb
         * @classdesc Represents a FetchApplyCreateCountryPlayersArg.
         * @implements IFetchApplyCreateCountryPlayersArg
         * @constructor
         * @param {pb.IFetchApplyCreateCountryPlayersArg=} [properties] Properties to set
         */
        function FetchApplyCreateCountryPlayersArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchApplyCreateCountryPlayersArg CityID.
         * @member {number} CityID
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @instance
         */
        FetchApplyCreateCountryPlayersArg.prototype.CityID = 0;

        /**
         * FetchApplyCreateCountryPlayersArg Page.
         * @member {number} Page
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @instance
         */
        FetchApplyCreateCountryPlayersArg.prototype.Page = 0;

        /**
         * Creates a new FetchApplyCreateCountryPlayersArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {pb.IFetchApplyCreateCountryPlayersArg=} [properties] Properties to set
         * @returns {pb.FetchApplyCreateCountryPlayersArg} FetchApplyCreateCountryPlayersArg instance
         */
        FetchApplyCreateCountryPlayersArg.create = function create(properties) {
            return new FetchApplyCreateCountryPlayersArg(properties);
        };

        /**
         * Encodes the specified FetchApplyCreateCountryPlayersArg message. Does not implicitly {@link pb.FetchApplyCreateCountryPlayersArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {pb.IFetchApplyCreateCountryPlayersArg} message FetchApplyCreateCountryPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchApplyCreateCountryPlayersArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Page != null && message.hasOwnProperty("Page"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Page);
            return writer;
        };

        /**
         * Encodes the specified FetchApplyCreateCountryPlayersArg message, length delimited. Does not implicitly {@link pb.FetchApplyCreateCountryPlayersArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {pb.IFetchApplyCreateCountryPlayersArg} message FetchApplyCreateCountryPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchApplyCreateCountryPlayersArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchApplyCreateCountryPlayersArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchApplyCreateCountryPlayersArg} FetchApplyCreateCountryPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchApplyCreateCountryPlayersArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchApplyCreateCountryPlayersArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Page = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchApplyCreateCountryPlayersArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchApplyCreateCountryPlayersArg} FetchApplyCreateCountryPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchApplyCreateCountryPlayersArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchApplyCreateCountryPlayersArg message.
         * @function verify
         * @memberof pb.FetchApplyCreateCountryPlayersArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchApplyCreateCountryPlayersArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Page != null && message.hasOwnProperty("Page"))
                if (!$util.isInteger(message.Page))
                    return "Page: integer expected";
            return null;
        };

        return FetchApplyCreateCountryPlayersArg;
    })();

    pb.ApplyCreateCountryPlayer = (function() {

        /**
         * Properties of an ApplyCreateCountryPlayer.
         * @memberof pb
         * @interface IApplyCreateCountryPlayer
         * @property {pb.ICampaignPlayer|null} [Player] ApplyCreateCountryPlayer Player
         * @property {number|null} [Gold] ApplyCreateCountryPlayer Gold
         */

        /**
         * Constructs a new ApplyCreateCountryPlayer.
         * @memberof pb
         * @classdesc Represents an ApplyCreateCountryPlayer.
         * @implements IApplyCreateCountryPlayer
         * @constructor
         * @param {pb.IApplyCreateCountryPlayer=} [properties] Properties to set
         */
        function ApplyCreateCountryPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplyCreateCountryPlayer Player.
         * @member {pb.ICampaignPlayer|null|undefined} Player
         * @memberof pb.ApplyCreateCountryPlayer
         * @instance
         */
        ApplyCreateCountryPlayer.prototype.Player = null;

        /**
         * ApplyCreateCountryPlayer Gold.
         * @member {number} Gold
         * @memberof pb.ApplyCreateCountryPlayer
         * @instance
         */
        ApplyCreateCountryPlayer.prototype.Gold = 0;

        /**
         * Creates a new ApplyCreateCountryPlayer instance using the specified properties.
         * @function create
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {pb.IApplyCreateCountryPlayer=} [properties] Properties to set
         * @returns {pb.ApplyCreateCountryPlayer} ApplyCreateCountryPlayer instance
         */
        ApplyCreateCountryPlayer.create = function create(properties) {
            return new ApplyCreateCountryPlayer(properties);
        };

        /**
         * Encodes the specified ApplyCreateCountryPlayer message. Does not implicitly {@link pb.ApplyCreateCountryPlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {pb.IApplyCreateCountryPlayer} message ApplyCreateCountryPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Player != null && message.hasOwnProperty("Player"))
                $root.pb.CampaignPlayer.encode(message.Player, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified ApplyCreateCountryPlayer message, length delimited. Does not implicitly {@link pb.ApplyCreateCountryPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {pb.IApplyCreateCountryPlayer} message ApplyCreateCountryPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplyCreateCountryPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ApplyCreateCountryPlayer} ApplyCreateCountryPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ApplyCreateCountryPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Player = $root.pb.CampaignPlayer.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplyCreateCountryPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ApplyCreateCountryPlayer} ApplyCreateCountryPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplyCreateCountryPlayer message.
         * @function verify
         * @memberof pb.ApplyCreateCountryPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplyCreateCountryPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Player != null && message.hasOwnProperty("Player")) {
                var error = $root.pb.CampaignPlayer.verify(message.Player);
                if (error)
                    return "Player." + error;
            }
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return ApplyCreateCountryPlayer;
    })();

    pb.ApplyCreateCountryPlayers = (function() {

        /**
         * Properties of an ApplyCreateCountryPlayers.
         * @memberof pb
         * @interface IApplyCreateCountryPlayers
         * @property {Array.<pb.IApplyCreateCountryPlayer>|null} [Players] ApplyCreateCountryPlayers Players
         */

        /**
         * Constructs a new ApplyCreateCountryPlayers.
         * @memberof pb
         * @classdesc Represents an ApplyCreateCountryPlayers.
         * @implements IApplyCreateCountryPlayers
         * @constructor
         * @param {pb.IApplyCreateCountryPlayers=} [properties] Properties to set
         */
        function ApplyCreateCountryPlayers(properties) {
            this.Players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplyCreateCountryPlayers Players.
         * @member {Array.<pb.IApplyCreateCountryPlayer>} Players
         * @memberof pb.ApplyCreateCountryPlayers
         * @instance
         */
        ApplyCreateCountryPlayers.prototype.Players = $util.emptyArray;

        /**
         * Creates a new ApplyCreateCountryPlayers instance using the specified properties.
         * @function create
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {pb.IApplyCreateCountryPlayers=} [properties] Properties to set
         * @returns {pb.ApplyCreateCountryPlayers} ApplyCreateCountryPlayers instance
         */
        ApplyCreateCountryPlayers.create = function create(properties) {
            return new ApplyCreateCountryPlayers(properties);
        };

        /**
         * Encodes the specified ApplyCreateCountryPlayers message. Does not implicitly {@link pb.ApplyCreateCountryPlayers.verify|verify} messages.
         * @function encode
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {pb.IApplyCreateCountryPlayers} message ApplyCreateCountryPlayers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryPlayers.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Players != null && message.Players.length)
                for (var i = 0; i < message.Players.length; ++i)
                    $root.pb.ApplyCreateCountryPlayer.encode(message.Players[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ApplyCreateCountryPlayers message, length delimited. Does not implicitly {@link pb.ApplyCreateCountryPlayers.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {pb.IApplyCreateCountryPlayers} message ApplyCreateCountryPlayers message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryPlayers.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplyCreateCountryPlayers message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ApplyCreateCountryPlayers} ApplyCreateCountryPlayers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryPlayers.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ApplyCreateCountryPlayers();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Players && message.Players.length))
                        message.Players = [];
                    message.Players.push($root.pb.ApplyCreateCountryPlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplyCreateCountryPlayers message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ApplyCreateCountryPlayers} ApplyCreateCountryPlayers
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryPlayers.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplyCreateCountryPlayers message.
         * @function verify
         * @memberof pb.ApplyCreateCountryPlayers
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplyCreateCountryPlayers.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Players != null && message.hasOwnProperty("Players")) {
                if (!Array.isArray(message.Players))
                    return "Players: array expected";
                for (var i = 0; i < message.Players.length; ++i) {
                    var error = $root.pb.ApplyCreateCountryPlayer.verify(message.Players[i]);
                    if (error)
                        return "Players." + error;
                }
            }
            return null;
        };

        return ApplyCreateCountryPlayers;
    })();

    pb.ApplyCreateCountryData = (function() {

        /**
         * Properties of an ApplyCreateCountryData.
         * @memberof pb
         * @interface IApplyCreateCountryData
         * @property {number|null} [RemainTime] ApplyCreateCountryData RemainTime
         * @property {Array.<pb.IApplyCreateCountryPlayer>|null} [Players] ApplyCreateCountryData Players
         * @property {number|null} [MyApplyMoney] ApplyCreateCountryData MyApplyMoney
         * @property {number|null} [MyCountryName] ApplyCreateCountryData MyCountryName
         */

        /**
         * Constructs a new ApplyCreateCountryData.
         * @memberof pb
         * @classdesc Represents an ApplyCreateCountryData.
         * @implements IApplyCreateCountryData
         * @constructor
         * @param {pb.IApplyCreateCountryData=} [properties] Properties to set
         */
        function ApplyCreateCountryData(properties) {
            this.Players = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ApplyCreateCountryData RemainTime.
         * @member {number} RemainTime
         * @memberof pb.ApplyCreateCountryData
         * @instance
         */
        ApplyCreateCountryData.prototype.RemainTime = 0;

        /**
         * ApplyCreateCountryData Players.
         * @member {Array.<pb.IApplyCreateCountryPlayer>} Players
         * @memberof pb.ApplyCreateCountryData
         * @instance
         */
        ApplyCreateCountryData.prototype.Players = $util.emptyArray;

        /**
         * ApplyCreateCountryData MyApplyMoney.
         * @member {number} MyApplyMoney
         * @memberof pb.ApplyCreateCountryData
         * @instance
         */
        ApplyCreateCountryData.prototype.MyApplyMoney = 0;

        /**
         * ApplyCreateCountryData MyCountryName.
         * @member {number} MyCountryName
         * @memberof pb.ApplyCreateCountryData
         * @instance
         */
        ApplyCreateCountryData.prototype.MyCountryName = 0;

        /**
         * Creates a new ApplyCreateCountryData instance using the specified properties.
         * @function create
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {pb.IApplyCreateCountryData=} [properties] Properties to set
         * @returns {pb.ApplyCreateCountryData} ApplyCreateCountryData instance
         */
        ApplyCreateCountryData.create = function create(properties) {
            return new ApplyCreateCountryData(properties);
        };

        /**
         * Encodes the specified ApplyCreateCountryData message. Does not implicitly {@link pb.ApplyCreateCountryData.verify|verify} messages.
         * @function encode
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {pb.IApplyCreateCountryData} message ApplyCreateCountryData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            if (message.Players != null && message.Players.length)
                for (var i = 0; i < message.Players.length; ++i)
                    $root.pb.ApplyCreateCountryPlayer.encode(message.Players[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.MyApplyMoney != null && message.hasOwnProperty("MyApplyMoney"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MyApplyMoney);
            if (message.MyCountryName != null && message.hasOwnProperty("MyCountryName"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MyCountryName);
            return writer;
        };

        /**
         * Encodes the specified ApplyCreateCountryData message, length delimited. Does not implicitly {@link pb.ApplyCreateCountryData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {pb.IApplyCreateCountryData} message ApplyCreateCountryData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ApplyCreateCountryData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ApplyCreateCountryData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ApplyCreateCountryData} ApplyCreateCountryData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ApplyCreateCountryData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                case 2:
                    if (!(message.Players && message.Players.length))
                        message.Players = [];
                    message.Players.push($root.pb.ApplyCreateCountryPlayer.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.MyApplyMoney = reader.int32();
                    break;
                case 4:
                    message.MyCountryName = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ApplyCreateCountryData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ApplyCreateCountryData} ApplyCreateCountryData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ApplyCreateCountryData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ApplyCreateCountryData message.
         * @function verify
         * @memberof pb.ApplyCreateCountryData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ApplyCreateCountryData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.Players != null && message.hasOwnProperty("Players")) {
                if (!Array.isArray(message.Players))
                    return "Players: array expected";
                for (var i = 0; i < message.Players.length; ++i) {
                    var error = $root.pb.ApplyCreateCountryPlayer.verify(message.Players[i]);
                    if (error)
                        return "Players." + error;
                }
            }
            if (message.MyApplyMoney != null && message.hasOwnProperty("MyApplyMoney"))
                if (!$util.isInteger(message.MyApplyMoney))
                    return "MyApplyMoney: integer expected";
            if (message.MyCountryName != null && message.hasOwnProperty("MyCountryName"))
                if (!$util.isInteger(message.MyCountryName))
                    return "MyCountryName: integer expected";
            return null;
        };

        return ApplyCreateCountryData;
    })();

    pb.UpdateForageArg = (function() {

        /**
         * Properties of an UpdateForageArg.
         * @memberof pb
         * @interface IUpdateForageArg
         * @property {number|null} [ForageAmount] UpdateForageArg ForageAmount
         */

        /**
         * Constructs a new UpdateForageArg.
         * @memberof pb
         * @classdesc Represents an UpdateForageArg.
         * @implements IUpdateForageArg
         * @constructor
         * @param {pb.IUpdateForageArg=} [properties] Properties to set
         */
        function UpdateForageArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateForageArg ForageAmount.
         * @member {number} ForageAmount
         * @memberof pb.UpdateForageArg
         * @instance
         */
        UpdateForageArg.prototype.ForageAmount = 0;

        /**
         * Creates a new UpdateForageArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateForageArg
         * @static
         * @param {pb.IUpdateForageArg=} [properties] Properties to set
         * @returns {pb.UpdateForageArg} UpdateForageArg instance
         */
        UpdateForageArg.create = function create(properties) {
            return new UpdateForageArg(properties);
        };

        /**
         * Encodes the specified UpdateForageArg message. Does not implicitly {@link pb.UpdateForageArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateForageArg
         * @static
         * @param {pb.IUpdateForageArg} message UpdateForageArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateForageArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ForageAmount != null && message.hasOwnProperty("ForageAmount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ForageAmount);
            return writer;
        };

        /**
         * Encodes the specified UpdateForageArg message, length delimited. Does not implicitly {@link pb.UpdateForageArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateForageArg
         * @static
         * @param {pb.IUpdateForageArg} message UpdateForageArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateForageArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateForageArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateForageArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateForageArg} UpdateForageArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateForageArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateForageArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ForageAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateForageArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateForageArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateForageArg} UpdateForageArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateForageArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateForageArg message.
         * @function verify
         * @memberof pb.UpdateForageArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateForageArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ForageAmount != null && message.hasOwnProperty("ForageAmount"))
                if (!$util.isInteger(message.ForageAmount))
                    return "ForageAmount: integer expected";
            return null;
        };

        return UpdateForageArg;
    })();

    /**
     * CampaignMsType enum.
     * @name pb.CampaignMsType
     * @enum {string}
     * @property {number} UnknowMsType=0 UnknowMsType value
     * @property {number} Irrigation=1 Irrigation value
     * @property {number} Trade=2 Trade value
     * @property {number} Build=3 Build value
     * @property {number} Transport=4 Transport value
     * @property {number} Dispatch=5 Dispatch value
     */
    pb.CampaignMsType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UnknowMsType"] = 0;
        values[valuesById[1] = "Irrigation"] = 1;
        values[valuesById[2] = "Trade"] = 2;
        values[valuesById[3] = "Build"] = 3;
        values[valuesById[4] = "Transport"] = 4;
        values[valuesById[5] = "Dispatch"] = 5;
        return values;
    })();

    /**
     * TransportTypeEnum enum.
     * @name pb.TransportTypeEnum
     * @enum {string}
     * @property {number} GoldTT=0 GoldTT value
     * @property {number} ForageTT=1 ForageTT value
     */
    pb.TransportTypeEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "GoldTT"] = 0;
        values[valuesById[1] = "ForageTT"] = 1;
        return values;
    })();

    pb.CampaignMission = (function() {

        /**
         * Properties of a CampaignMission.
         * @memberof pb
         * @interface ICampaignMission
         * @property {pb.CampaignMsType|null} [Type] CampaignMission Type
         * @property {number|null} [GoldReward] CampaignMission GoldReward
         * @property {number|null} [Amount] CampaignMission Amount
         * @property {pb.TransportTypeEnum|null} [TransportType] CampaignMission TransportType
         * @property {number|null} [TransportTargetCity] CampaignMission TransportTargetCity
         * @property {number|null} [TransportMaxTime] CampaignMission TransportMaxTime
         * @property {number|null} [MaxAmount] CampaignMission MaxAmount
         * @property {number|null} [Contribution] CampaignMission Contribution
         */

        /**
         * Constructs a new CampaignMission.
         * @memberof pb
         * @classdesc Represents a CampaignMission.
         * @implements ICampaignMission
         * @constructor
         * @param {pb.ICampaignMission=} [properties] Properties to set
         */
        function CampaignMission(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignMission Type.
         * @member {pb.CampaignMsType} Type
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.Type = 0;

        /**
         * CampaignMission GoldReward.
         * @member {number} GoldReward
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.GoldReward = 0;

        /**
         * CampaignMission Amount.
         * @member {number} Amount
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.Amount = 0;

        /**
         * CampaignMission TransportType.
         * @member {pb.TransportTypeEnum} TransportType
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.TransportType = 0;

        /**
         * CampaignMission TransportTargetCity.
         * @member {number} TransportTargetCity
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.TransportTargetCity = 0;

        /**
         * CampaignMission TransportMaxTime.
         * @member {number} TransportMaxTime
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.TransportMaxTime = 0;

        /**
         * CampaignMission MaxAmount.
         * @member {number} MaxAmount
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.MaxAmount = 0;

        /**
         * CampaignMission Contribution.
         * @member {number} Contribution
         * @memberof pb.CampaignMission
         * @instance
         */
        CampaignMission.prototype.Contribution = 0;

        /**
         * Creates a new CampaignMission instance using the specified properties.
         * @function create
         * @memberof pb.CampaignMission
         * @static
         * @param {pb.ICampaignMission=} [properties] Properties to set
         * @returns {pb.CampaignMission} CampaignMission instance
         */
        CampaignMission.create = function create(properties) {
            return new CampaignMission(properties);
        };

        /**
         * Encodes the specified CampaignMission message. Does not implicitly {@link pb.CampaignMission.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignMission
         * @static
         * @param {pb.ICampaignMission} message CampaignMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignMission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoldReward);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Amount);
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.TransportType);
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.TransportTargetCity);
            if (message.TransportMaxTime != null && message.hasOwnProperty("TransportMaxTime"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.TransportMaxTime);
            if (message.MaxAmount != null && message.hasOwnProperty("MaxAmount"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.MaxAmount);
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Contribution);
            return writer;
        };

        /**
         * Encodes the specified CampaignMission message, length delimited. Does not implicitly {@link pb.CampaignMission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignMission
         * @static
         * @param {pb.ICampaignMission} message CampaignMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignMission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignMission message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignMission} CampaignMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignMission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignMission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.GoldReward = reader.int32();
                    break;
                case 3:
                    message.Amount = reader.int32();
                    break;
                case 4:
                    message.TransportType = reader.int32();
                    break;
                case 5:
                    message.TransportTargetCity = reader.int32();
                    break;
                case 6:
                    message.TransportMaxTime = reader.int32();
                    break;
                case 7:
                    message.MaxAmount = reader.int32();
                    break;
                case 8:
                    message.Contribution = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignMission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignMission} CampaignMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignMission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignMission message.
         * @function verify
         * @memberof pb.CampaignMission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignMission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                if (!$util.isInteger(message.GoldReward))
                    return "GoldReward: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                switch (message.TransportType) {
                default:
                    return "TransportType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                if (!$util.isInteger(message.TransportTargetCity))
                    return "TransportTargetCity: integer expected";
            if (message.TransportMaxTime != null && message.hasOwnProperty("TransportMaxTime"))
                if (!$util.isInteger(message.TransportMaxTime))
                    return "TransportMaxTime: integer expected";
            if (message.MaxAmount != null && message.hasOwnProperty("MaxAmount"))
                if (!$util.isInteger(message.MaxAmount))
                    return "MaxAmount: integer expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            return null;
        };

        return CampaignMission;
    })();

    pb.ExecutingCampaignMission = (function() {

        /**
         * Properties of an ExecutingCampaignMission.
         * @memberof pb
         * @interface IExecutingCampaignMission
         * @property {pb.CampaignMsType|null} [Type] ExecutingCampaignMission Type
         * @property {number|null} [GoldReward] ExecutingCampaignMission GoldReward
         * @property {number|null} [RemainTime] ExecutingCampaignMission RemainTime
         * @property {Array.<number>|null} [Cards] ExecutingCampaignMission Cards
         * @property {number|null} [MaxTime] ExecutingCampaignMission MaxTime
         * @property {number|null} [Contribution] ExecutingCampaignMission Contribution
         */

        /**
         * Constructs a new ExecutingCampaignMission.
         * @memberof pb
         * @classdesc Represents an ExecutingCampaignMission.
         * @implements IExecutingCampaignMission
         * @constructor
         * @param {pb.IExecutingCampaignMission=} [properties] Properties to set
         */
        function ExecutingCampaignMission(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExecutingCampaignMission Type.
         * @member {pb.CampaignMsType} Type
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.Type = 0;

        /**
         * ExecutingCampaignMission GoldReward.
         * @member {number} GoldReward
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.GoldReward = 0;

        /**
         * ExecutingCampaignMission RemainTime.
         * @member {number} RemainTime
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.RemainTime = 0;

        /**
         * ExecutingCampaignMission Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.Cards = $util.emptyArray;

        /**
         * ExecutingCampaignMission MaxTime.
         * @member {number} MaxTime
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.MaxTime = 0;

        /**
         * ExecutingCampaignMission Contribution.
         * @member {number} Contribution
         * @memberof pb.ExecutingCampaignMission
         * @instance
         */
        ExecutingCampaignMission.prototype.Contribution = 0;

        /**
         * Creates a new ExecutingCampaignMission instance using the specified properties.
         * @function create
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {pb.IExecutingCampaignMission=} [properties] Properties to set
         * @returns {pb.ExecutingCampaignMission} ExecutingCampaignMission instance
         */
        ExecutingCampaignMission.create = function create(properties) {
            return new ExecutingCampaignMission(properties);
        };

        /**
         * Encodes the specified ExecutingCampaignMission message. Does not implicitly {@link pb.ExecutingCampaignMission.verify|verify} messages.
         * @function encode
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {pb.IExecutingCampaignMission} message ExecutingCampaignMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutingCampaignMission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoldReward);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RemainTime);
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 4, wireType 2 =*/34).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            if (message.MaxTime != null && message.hasOwnProperty("MaxTime"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.MaxTime);
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Contribution);
            return writer;
        };

        /**
         * Encodes the specified ExecutingCampaignMission message, length delimited. Does not implicitly {@link pb.ExecutingCampaignMission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {pb.IExecutingCampaignMission} message ExecutingCampaignMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExecutingCampaignMission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExecutingCampaignMission message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ExecutingCampaignMission} ExecutingCampaignMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutingCampaignMission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExecutingCampaignMission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.GoldReward = reader.int32();
                    break;
                case 3:
                    message.RemainTime = reader.int32();
                    break;
                case 4:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                case 5:
                    message.MaxTime = reader.int32();
                    break;
                case 6:
                    message.Contribution = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExecutingCampaignMission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ExecutingCampaignMission} ExecutingCampaignMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExecutingCampaignMission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExecutingCampaignMission message.
         * @function verify
         * @memberof pb.ExecutingCampaignMission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExecutingCampaignMission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                if (!$util.isInteger(message.GoldReward))
                    return "GoldReward: integer expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            if (message.MaxTime != null && message.hasOwnProperty("MaxTime"))
                if (!$util.isInteger(message.MaxTime))
                    return "MaxTime: integer expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            return null;
        };

        return ExecutingCampaignMission;
    })();

    pb.CampaignMissionInfo = (function() {

        /**
         * Properties of a CampaignMissionInfo.
         * @memberof pb
         * @interface ICampaignMissionInfo
         * @property {Array.<pb.ICampaignMission>|null} [Missions] CampaignMissionInfo Missions
         * @property {pb.IExecutingCampaignMission|null} [ExecutingMission] CampaignMissionInfo ExecutingMission
         */

        /**
         * Constructs a new CampaignMissionInfo.
         * @memberof pb
         * @classdesc Represents a CampaignMissionInfo.
         * @implements ICampaignMissionInfo
         * @constructor
         * @param {pb.ICampaignMissionInfo=} [properties] Properties to set
         */
        function CampaignMissionInfo(properties) {
            this.Missions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignMissionInfo Missions.
         * @member {Array.<pb.ICampaignMission>} Missions
         * @memberof pb.CampaignMissionInfo
         * @instance
         */
        CampaignMissionInfo.prototype.Missions = $util.emptyArray;

        /**
         * CampaignMissionInfo ExecutingMission.
         * @member {pb.IExecutingCampaignMission|null|undefined} ExecutingMission
         * @memberof pb.CampaignMissionInfo
         * @instance
         */
        CampaignMissionInfo.prototype.ExecutingMission = null;

        /**
         * Creates a new CampaignMissionInfo instance using the specified properties.
         * @function create
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {pb.ICampaignMissionInfo=} [properties] Properties to set
         * @returns {pb.CampaignMissionInfo} CampaignMissionInfo instance
         */
        CampaignMissionInfo.create = function create(properties) {
            return new CampaignMissionInfo(properties);
        };

        /**
         * Encodes the specified CampaignMissionInfo message. Does not implicitly {@link pb.CampaignMissionInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {pb.ICampaignMissionInfo} message CampaignMissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignMissionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Missions != null && message.Missions.length)
                for (var i = 0; i < message.Missions.length; ++i)
                    $root.pb.CampaignMission.encode(message.Missions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ExecutingMission != null && message.hasOwnProperty("ExecutingMission"))
                $root.pb.ExecutingCampaignMission.encode(message.ExecutingMission, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignMissionInfo message, length delimited. Does not implicitly {@link pb.CampaignMissionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {pb.ICampaignMissionInfo} message CampaignMissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignMissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignMissionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignMissionInfo} CampaignMissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignMissionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignMissionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Missions && message.Missions.length))
                        message.Missions = [];
                    message.Missions.push($root.pb.CampaignMission.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.ExecutingMission = $root.pb.ExecutingCampaignMission.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignMissionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignMissionInfo} CampaignMissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignMissionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignMissionInfo message.
         * @function verify
         * @memberof pb.CampaignMissionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignMissionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Missions != null && message.hasOwnProperty("Missions")) {
                if (!Array.isArray(message.Missions))
                    return "Missions: array expected";
                for (var i = 0; i < message.Missions.length; ++i) {
                    var error = $root.pb.CampaignMission.verify(message.Missions[i]);
                    if (error)
                        return "Missions." + error;
                }
            }
            if (message.ExecutingMission != null && message.hasOwnProperty("ExecutingMission")) {
                var error = $root.pb.ExecutingCampaignMission.verify(message.ExecutingMission);
                if (error)
                    return "ExecutingMission." + error;
            }
            return null;
        };

        return CampaignMissionInfo;
    })();

    pb.CampaignPublishMissionArg = (function() {

        /**
         * Properties of a CampaignPublishMissionArg.
         * @memberof pb
         * @interface ICampaignPublishMissionArg
         * @property {pb.CampaignMsType|null} [Type] CampaignPublishMissionArg Type
         * @property {number|null} [GoldReward] CampaignPublishMissionArg GoldReward
         * @property {number|null} [Amount] CampaignPublishMissionArg Amount
         * @property {pb.TransportTypeEnum|null} [TransportType] CampaignPublishMissionArg TransportType
         * @property {Array.<number>|null} [TransportCityPath] CampaignPublishMissionArg TransportCityPath
         */

        /**
         * Constructs a new CampaignPublishMissionArg.
         * @memberof pb
         * @classdesc Represents a CampaignPublishMissionArg.
         * @implements ICampaignPublishMissionArg
         * @constructor
         * @param {pb.ICampaignPublishMissionArg=} [properties] Properties to set
         */
        function CampaignPublishMissionArg(properties) {
            this.TransportCityPath = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignPublishMissionArg Type.
         * @member {pb.CampaignMsType} Type
         * @memberof pb.CampaignPublishMissionArg
         * @instance
         */
        CampaignPublishMissionArg.prototype.Type = 0;

        /**
         * CampaignPublishMissionArg GoldReward.
         * @member {number} GoldReward
         * @memberof pb.CampaignPublishMissionArg
         * @instance
         */
        CampaignPublishMissionArg.prototype.GoldReward = 0;

        /**
         * CampaignPublishMissionArg Amount.
         * @member {number} Amount
         * @memberof pb.CampaignPublishMissionArg
         * @instance
         */
        CampaignPublishMissionArg.prototype.Amount = 0;

        /**
         * CampaignPublishMissionArg TransportType.
         * @member {pb.TransportTypeEnum} TransportType
         * @memberof pb.CampaignPublishMissionArg
         * @instance
         */
        CampaignPublishMissionArg.prototype.TransportType = 0;

        /**
         * CampaignPublishMissionArg TransportCityPath.
         * @member {Array.<number>} TransportCityPath
         * @memberof pb.CampaignPublishMissionArg
         * @instance
         */
        CampaignPublishMissionArg.prototype.TransportCityPath = $util.emptyArray;

        /**
         * Creates a new CampaignPublishMissionArg instance using the specified properties.
         * @function create
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {pb.ICampaignPublishMissionArg=} [properties] Properties to set
         * @returns {pb.CampaignPublishMissionArg} CampaignPublishMissionArg instance
         */
        CampaignPublishMissionArg.create = function create(properties) {
            return new CampaignPublishMissionArg(properties);
        };

        /**
         * Encodes the specified CampaignPublishMissionArg message. Does not implicitly {@link pb.CampaignPublishMissionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {pb.ICampaignPublishMissionArg} message CampaignPublishMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPublishMissionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoldReward);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Amount);
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.TransportType);
            if (message.TransportCityPath != null && message.TransportCityPath.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.TransportCityPath.length; ++i)
                    writer.int32(message.TransportCityPath[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified CampaignPublishMissionArg message, length delimited. Does not implicitly {@link pb.CampaignPublishMissionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {pb.ICampaignPublishMissionArg} message CampaignPublishMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPublishMissionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignPublishMissionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignPublishMissionArg} CampaignPublishMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPublishMissionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignPublishMissionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.GoldReward = reader.int32();
                    break;
                case 3:
                    message.Amount = reader.int32();
                    break;
                case 4:
                    message.TransportType = reader.int32();
                    break;
                case 5:
                    if (!(message.TransportCityPath && message.TransportCityPath.length))
                        message.TransportCityPath = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.TransportCityPath.push(reader.int32());
                    } else
                        message.TransportCityPath.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignPublishMissionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignPublishMissionArg} CampaignPublishMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPublishMissionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignPublishMissionArg message.
         * @function verify
         * @memberof pb.CampaignPublishMissionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignPublishMissionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.GoldReward != null && message.hasOwnProperty("GoldReward"))
                if (!$util.isInteger(message.GoldReward))
                    return "GoldReward: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                switch (message.TransportType) {
                default:
                    return "TransportType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.TransportCityPath != null && message.hasOwnProperty("TransportCityPath")) {
                if (!Array.isArray(message.TransportCityPath))
                    return "TransportCityPath: array expected";
                for (var i = 0; i < message.TransportCityPath.length; ++i)
                    if (!$util.isInteger(message.TransportCityPath[i]))
                        return "TransportCityPath: integer[] expected";
            }
            return null;
        };

        return CampaignPublishMissionArg;
    })();

    pb.CampaignPublishMissionReply = (function() {

        /**
         * Properties of a CampaignPublishMissionReply.
         * @memberof pb
         * @interface ICampaignPublishMissionReply
         * @property {pb.ICampaignMissionInfo|null} [MissionInfo] CampaignPublishMissionReply MissionInfo
         * @property {number|null} [Gold] CampaignPublishMissionReply Gold
         * @property {number|null} [Forage] CampaignPublishMissionReply Forage
         */

        /**
         * Constructs a new CampaignPublishMissionReply.
         * @memberof pb
         * @classdesc Represents a CampaignPublishMissionReply.
         * @implements ICampaignPublishMissionReply
         * @constructor
         * @param {pb.ICampaignPublishMissionReply=} [properties] Properties to set
         */
        function CampaignPublishMissionReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignPublishMissionReply MissionInfo.
         * @member {pb.ICampaignMissionInfo|null|undefined} MissionInfo
         * @memberof pb.CampaignPublishMissionReply
         * @instance
         */
        CampaignPublishMissionReply.prototype.MissionInfo = null;

        /**
         * CampaignPublishMissionReply Gold.
         * @member {number} Gold
         * @memberof pb.CampaignPublishMissionReply
         * @instance
         */
        CampaignPublishMissionReply.prototype.Gold = 0;

        /**
         * CampaignPublishMissionReply Forage.
         * @member {number} Forage
         * @memberof pb.CampaignPublishMissionReply
         * @instance
         */
        CampaignPublishMissionReply.prototype.Forage = 0;

        /**
         * Creates a new CampaignPublishMissionReply instance using the specified properties.
         * @function create
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {pb.ICampaignPublishMissionReply=} [properties] Properties to set
         * @returns {pb.CampaignPublishMissionReply} CampaignPublishMissionReply instance
         */
        CampaignPublishMissionReply.create = function create(properties) {
            return new CampaignPublishMissionReply(properties);
        };

        /**
         * Encodes the specified CampaignPublishMissionReply message. Does not implicitly {@link pb.CampaignPublishMissionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {pb.ICampaignPublishMissionReply} message CampaignPublishMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPublishMissionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MissionInfo != null && message.hasOwnProperty("MissionInfo"))
                $root.pb.CampaignMissionInfo.encode(message.MissionInfo, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Forage);
            return writer;
        };

        /**
         * Encodes the specified CampaignPublishMissionReply message, length delimited. Does not implicitly {@link pb.CampaignPublishMissionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {pb.ICampaignPublishMissionReply} message CampaignPublishMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignPublishMissionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignPublishMissionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignPublishMissionReply} CampaignPublishMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPublishMissionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignPublishMissionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MissionInfo = $root.pb.CampaignMissionInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                case 3:
                    message.Forage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignPublishMissionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignPublishMissionReply} CampaignPublishMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignPublishMissionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignPublishMissionReply message.
         * @function verify
         * @memberof pb.CampaignPublishMissionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignPublishMissionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MissionInfo != null && message.hasOwnProperty("MissionInfo")) {
                var error = $root.pb.CampaignMissionInfo.verify(message.MissionInfo);
                if (error)
                    return "MissionInfo." + error;
            }
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            return null;
        };

        return CampaignPublishMissionReply;
    })();

    pb.AcceptCampaignMissionArg = (function() {

        /**
         * Properties of an AcceptCampaignMissionArg.
         * @memberof pb
         * @interface IAcceptCampaignMissionArg
         * @property {pb.CampaignMsType|null} [Type] AcceptCampaignMissionArg Type
         * @property {Array.<number>|null} [Cards] AcceptCampaignMissionArg Cards
         * @property {number|null} [TransportTargetCity] AcceptCampaignMissionArg TransportTargetCity
         */

        /**
         * Constructs a new AcceptCampaignMissionArg.
         * @memberof pb
         * @classdesc Represents an AcceptCampaignMissionArg.
         * @implements IAcceptCampaignMissionArg
         * @constructor
         * @param {pb.IAcceptCampaignMissionArg=} [properties] Properties to set
         */
        function AcceptCampaignMissionArg(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptCampaignMissionArg Type.
         * @member {pb.CampaignMsType} Type
         * @memberof pb.AcceptCampaignMissionArg
         * @instance
         */
        AcceptCampaignMissionArg.prototype.Type = 0;

        /**
         * AcceptCampaignMissionArg Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.AcceptCampaignMissionArg
         * @instance
         */
        AcceptCampaignMissionArg.prototype.Cards = $util.emptyArray;

        /**
         * AcceptCampaignMissionArg TransportTargetCity.
         * @member {number} TransportTargetCity
         * @memberof pb.AcceptCampaignMissionArg
         * @instance
         */
        AcceptCampaignMissionArg.prototype.TransportTargetCity = 0;

        /**
         * Creates a new AcceptCampaignMissionArg instance using the specified properties.
         * @function create
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {pb.IAcceptCampaignMissionArg=} [properties] Properties to set
         * @returns {pb.AcceptCampaignMissionArg} AcceptCampaignMissionArg instance
         */
        AcceptCampaignMissionArg.create = function create(properties) {
            return new AcceptCampaignMissionArg(properties);
        };

        /**
         * Encodes the specified AcceptCampaignMissionArg message. Does not implicitly {@link pb.AcceptCampaignMissionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {pb.IAcceptCampaignMissionArg} message AcceptCampaignMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptCampaignMissionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.TransportTargetCity);
            return writer;
        };

        /**
         * Encodes the specified AcceptCampaignMissionArg message, length delimited. Does not implicitly {@link pb.AcceptCampaignMissionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {pb.IAcceptCampaignMissionArg} message AcceptCampaignMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptCampaignMissionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptCampaignMissionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AcceptCampaignMissionArg} AcceptCampaignMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptCampaignMissionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AcceptCampaignMissionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                case 3:
                    message.TransportTargetCity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptCampaignMissionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AcceptCampaignMissionArg} AcceptCampaignMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptCampaignMissionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptCampaignMissionArg message.
         * @function verify
         * @memberof pb.AcceptCampaignMissionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptCampaignMissionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                if (!$util.isInteger(message.TransportTargetCity))
                    return "TransportTargetCity: integer expected";
            return null;
        };

        return AcceptCampaignMissionArg;
    })();

    pb.AcceptCampaignMissionReply = (function() {

        /**
         * Properties of an AcceptCampaignMissionReply.
         * @memberof pb
         * @interface IAcceptCampaignMissionReply
         * @property {number|null} [RemainTime] AcceptCampaignMissionReply RemainTime
         * @property {Array.<pb.ICampaignMission>|null} [Missions] AcceptCampaignMissionReply Missions
         */

        /**
         * Constructs a new AcceptCampaignMissionReply.
         * @memberof pb
         * @classdesc Represents an AcceptCampaignMissionReply.
         * @implements IAcceptCampaignMissionReply
         * @constructor
         * @param {pb.IAcceptCampaignMissionReply=} [properties] Properties to set
         */
        function AcceptCampaignMissionReply(properties) {
            this.Missions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptCampaignMissionReply RemainTime.
         * @member {number} RemainTime
         * @memberof pb.AcceptCampaignMissionReply
         * @instance
         */
        AcceptCampaignMissionReply.prototype.RemainTime = 0;

        /**
         * AcceptCampaignMissionReply Missions.
         * @member {Array.<pb.ICampaignMission>} Missions
         * @memberof pb.AcceptCampaignMissionReply
         * @instance
         */
        AcceptCampaignMissionReply.prototype.Missions = $util.emptyArray;

        /**
         * Creates a new AcceptCampaignMissionReply instance using the specified properties.
         * @function create
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {pb.IAcceptCampaignMissionReply=} [properties] Properties to set
         * @returns {pb.AcceptCampaignMissionReply} AcceptCampaignMissionReply instance
         */
        AcceptCampaignMissionReply.create = function create(properties) {
            return new AcceptCampaignMissionReply(properties);
        };

        /**
         * Encodes the specified AcceptCampaignMissionReply message. Does not implicitly {@link pb.AcceptCampaignMissionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {pb.IAcceptCampaignMissionReply} message AcceptCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptCampaignMissionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            if (message.Missions != null && message.Missions.length)
                for (var i = 0; i < message.Missions.length; ++i)
                    $root.pb.CampaignMission.encode(message.Missions[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AcceptCampaignMissionReply message, length delimited. Does not implicitly {@link pb.AcceptCampaignMissionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {pb.IAcceptCampaignMissionReply} message AcceptCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptCampaignMissionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptCampaignMissionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AcceptCampaignMissionReply} AcceptCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptCampaignMissionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AcceptCampaignMissionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                case 2:
                    if (!(message.Missions && message.Missions.length))
                        message.Missions = [];
                    message.Missions.push($root.pb.CampaignMission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptCampaignMissionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AcceptCampaignMissionReply} AcceptCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptCampaignMissionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptCampaignMissionReply message.
         * @function verify
         * @memberof pb.AcceptCampaignMissionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptCampaignMissionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.Missions != null && message.hasOwnProperty("Missions")) {
                if (!Array.isArray(message.Missions))
                    return "Missions: array expected";
                for (var i = 0; i < message.Missions.length; ++i) {
                    var error = $root.pb.CampaignMission.verify(message.Missions[i]);
                    if (error)
                        return "Missions." + error;
                }
            }
            return null;
        };

        return AcceptCampaignMissionReply;
    })();

    pb.FetchCityPlayersArg = (function() {

        /**
         * Properties of a FetchCityPlayersArg.
         * @memberof pb
         * @interface IFetchCityPlayersArg
         * @property {number|null} [CityID] FetchCityPlayersArg CityID
         * @property {number|null} [Page] FetchCityPlayersArg Page
         */

        /**
         * Constructs a new FetchCityPlayersArg.
         * @memberof pb
         * @classdesc Represents a FetchCityPlayersArg.
         * @implements IFetchCityPlayersArg
         * @constructor
         * @param {pb.IFetchCityPlayersArg=} [properties] Properties to set
         */
        function FetchCityPlayersArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchCityPlayersArg CityID.
         * @member {number} CityID
         * @memberof pb.FetchCityPlayersArg
         * @instance
         */
        FetchCityPlayersArg.prototype.CityID = 0;

        /**
         * FetchCityPlayersArg Page.
         * @member {number} Page
         * @memberof pb.FetchCityPlayersArg
         * @instance
         */
        FetchCityPlayersArg.prototype.Page = 0;

        /**
         * Creates a new FetchCityPlayersArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {pb.IFetchCityPlayersArg=} [properties] Properties to set
         * @returns {pb.FetchCityPlayersArg} FetchCityPlayersArg instance
         */
        FetchCityPlayersArg.create = function create(properties) {
            return new FetchCityPlayersArg(properties);
        };

        /**
         * Encodes the specified FetchCityPlayersArg message. Does not implicitly {@link pb.FetchCityPlayersArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {pb.IFetchCityPlayersArg} message FetchCityPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCityPlayersArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Page != null && message.hasOwnProperty("Page"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Page);
            return writer;
        };

        /**
         * Encodes the specified FetchCityPlayersArg message, length delimited. Does not implicitly {@link pb.FetchCityPlayersArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {pb.IFetchCityPlayersArg} message FetchCityPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCityPlayersArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchCityPlayersArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchCityPlayersArg} FetchCityPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCityPlayersArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchCityPlayersArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Page = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchCityPlayersArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchCityPlayersArg} FetchCityPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCityPlayersArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchCityPlayersArg message.
         * @function verify
         * @memberof pb.FetchCityPlayersArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchCityPlayersArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Page != null && message.hasOwnProperty("Page"))
                if (!$util.isInteger(message.Page))
                    return "Page: integer expected";
            return null;
        };

        return FetchCityPlayersArg;
    })();

    pb.SetForagePriceArg = (function() {

        /**
         * Properties of a SetForagePriceArg.
         * @memberof pb
         * @interface ISetForagePriceArg
         * @property {number|null} [Price] SetForagePriceArg Price
         */

        /**
         * Constructs a new SetForagePriceArg.
         * @memberof pb
         * @classdesc Represents a SetForagePriceArg.
         * @implements ISetForagePriceArg
         * @constructor
         * @param {pb.ISetForagePriceArg=} [properties] Properties to set
         */
        function SetForagePriceArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetForagePriceArg Price.
         * @member {number} Price
         * @memberof pb.SetForagePriceArg
         * @instance
         */
        SetForagePriceArg.prototype.Price = 0;

        /**
         * Creates a new SetForagePriceArg instance using the specified properties.
         * @function create
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {pb.ISetForagePriceArg=} [properties] Properties to set
         * @returns {pb.SetForagePriceArg} SetForagePriceArg instance
         */
        SetForagePriceArg.create = function create(properties) {
            return new SetForagePriceArg(properties);
        };

        /**
         * Encodes the specified SetForagePriceArg message. Does not implicitly {@link pb.SetForagePriceArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {pb.ISetForagePriceArg} message SetForagePriceArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetForagePriceArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Price != null && message.hasOwnProperty("Price"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Price);
            return writer;
        };

        /**
         * Encodes the specified SetForagePriceArg message, length delimited. Does not implicitly {@link pb.SetForagePriceArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {pb.ISetForagePriceArg} message SetForagePriceArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetForagePriceArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetForagePriceArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SetForagePriceArg} SetForagePriceArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetForagePriceArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SetForagePriceArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Price = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetForagePriceArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SetForagePriceArg} SetForagePriceArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetForagePriceArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetForagePriceArg message.
         * @function verify
         * @memberof pb.SetForagePriceArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetForagePriceArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (!$util.isInteger(message.Price))
                    return "Price: integer expected";
            return null;
        };

        return SetForagePriceArg;
    })();

    pb.FetchForagePriceReply = (function() {

        /**
         * Properties of a FetchForagePriceReply.
         * @memberof pb
         * @interface IFetchForagePriceReply
         * @property {number|null} [ForageAmount] FetchForagePriceReply ForageAmount
         * @property {number|null} [Price] FetchForagePriceReply Price
         */

        /**
         * Constructs a new FetchForagePriceReply.
         * @memberof pb
         * @classdesc Represents a FetchForagePriceReply.
         * @implements IFetchForagePriceReply
         * @constructor
         * @param {pb.IFetchForagePriceReply=} [properties] Properties to set
         */
        function FetchForagePriceReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchForagePriceReply ForageAmount.
         * @member {number} ForageAmount
         * @memberof pb.FetchForagePriceReply
         * @instance
         */
        FetchForagePriceReply.prototype.ForageAmount = 0;

        /**
         * FetchForagePriceReply Price.
         * @member {number} Price
         * @memberof pb.FetchForagePriceReply
         * @instance
         */
        FetchForagePriceReply.prototype.Price = 0;

        /**
         * Creates a new FetchForagePriceReply instance using the specified properties.
         * @function create
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {pb.IFetchForagePriceReply=} [properties] Properties to set
         * @returns {pb.FetchForagePriceReply} FetchForagePriceReply instance
         */
        FetchForagePriceReply.create = function create(properties) {
            return new FetchForagePriceReply(properties);
        };

        /**
         * Encodes the specified FetchForagePriceReply message. Does not implicitly {@link pb.FetchForagePriceReply.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {pb.IFetchForagePriceReply} message FetchForagePriceReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchForagePriceReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ForageAmount != null && message.hasOwnProperty("ForageAmount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ForageAmount);
            if (message.Price != null && message.hasOwnProperty("Price"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Price);
            return writer;
        };

        /**
         * Encodes the specified FetchForagePriceReply message, length delimited. Does not implicitly {@link pb.FetchForagePriceReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {pb.IFetchForagePriceReply} message FetchForagePriceReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchForagePriceReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchForagePriceReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchForagePriceReply} FetchForagePriceReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchForagePriceReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchForagePriceReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ForageAmount = reader.int32();
                    break;
                case 2:
                    message.Price = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchForagePriceReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchForagePriceReply} FetchForagePriceReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchForagePriceReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchForagePriceReply message.
         * @function verify
         * @memberof pb.FetchForagePriceReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchForagePriceReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ForageAmount != null && message.hasOwnProperty("ForageAmount"))
                if (!$util.isInteger(message.ForageAmount))
                    return "ForageAmount: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (!$util.isInteger(message.Price))
                    return "Price: integer expected";
            return null;
        };

        return FetchForagePriceReply;
    })();

    /**
     * CampaignNoticeType enum.
     * @name pb.CampaignNoticeType
     * @enum {string}
     * @property {number} CustomNt=0 CustomNt value
     * @property {number} NewCountryNt=1 NewCountryNt value
     * @property {number} AppointJobNt=2 AppointJobNt value
     * @property {number} RecallJobNt=3 RecallJobNt value
     * @property {number} AutocephalyNt=4 AutocephalyNt value
     * @property {number} KickOutNt=5 KickOutNt value
     * @property {number} YourMajestyChangeNt=6 YourMajestyChangeNt value
     * @property {number} ResignNt=7 ResignNt value
     * @property {number} ClearMissionNt=8 ClearMissionNt value
     * @property {number} BeOccupyNt=9 BeOccupyNt value
     * @property {number} DestoryCountryNt=10 DestoryCountryNt value
     * @property {number} UnifiedWordNt=11 UnifiedWordNt value
     * @property {number} AutocephalyVoteNt=12 AutocephalyVoteNt value
     * @property {number} CapitalInjectionNt=13 CapitalInjectionNt value
     * @property {number} ProductionNt=14 ProductionNt value
     * @property {number} SalaryNt=15 SalaryNt value
     * @property {number} TransportNt=16 TransportNt value
     * @property {number} OccupyNt=17 OccupyNt value
     * @property {number} SurrenderNt=18 SurrenderNt value
     * @property {number} BetrayNt=19 BetrayNt value
     * @property {number} EscapedNt=20 EscapedNt value
     * @property {number} EscapedReturnNt=21 EscapedReturnNt value
     * @property {number} AutoDefOrderNt=22 AutoDefOrderNt value
     * @property {number} SurrenderCity1Nt=23 SurrenderCity1Nt value
     * @property {number} SurrenderCity2Nt=24 SurrenderCity2Nt value
     * @property {number} SurrenderCity3Nt=25 SurrenderCity3Nt value
     * @property {number} SurrenderCountry1Nt=26 SurrenderCountry1Nt value
     * @property {number} SurrenderCountry2Nt=27 SurrenderCountry2Nt value
     * @property {number} AutocephalyNt2=28 AutocephalyNt2 value
     * @property {number} AutocephalyNt3=29 AutocephalyNt3 value
     */
    pb.CampaignNoticeType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CustomNt"] = 0;
        values[valuesById[1] = "NewCountryNt"] = 1;
        values[valuesById[2] = "AppointJobNt"] = 2;
        values[valuesById[3] = "RecallJobNt"] = 3;
        values[valuesById[4] = "AutocephalyNt"] = 4;
        values[valuesById[5] = "KickOutNt"] = 5;
        values[valuesById[6] = "YourMajestyChangeNt"] = 6;
        values[valuesById[7] = "ResignNt"] = 7;
        values[valuesById[8] = "ClearMissionNt"] = 8;
        values[valuesById[9] = "BeOccupyNt"] = 9;
        values[valuesById[10] = "DestoryCountryNt"] = 10;
        values[valuesById[11] = "UnifiedWordNt"] = 11;
        values[valuesById[12] = "AutocephalyVoteNt"] = 12;
        values[valuesById[13] = "CapitalInjectionNt"] = 13;
        values[valuesById[14] = "ProductionNt"] = 14;
        values[valuesById[15] = "SalaryNt"] = 15;
        values[valuesById[16] = "TransportNt"] = 16;
        values[valuesById[17] = "OccupyNt"] = 17;
        values[valuesById[18] = "SurrenderNt"] = 18;
        values[valuesById[19] = "BetrayNt"] = 19;
        values[valuesById[20] = "EscapedNt"] = 20;
        values[valuesById[21] = "EscapedReturnNt"] = 21;
        values[valuesById[22] = "AutoDefOrderNt"] = 22;
        values[valuesById[23] = "SurrenderCity1Nt"] = 23;
        values[valuesById[24] = "SurrenderCity2Nt"] = 24;
        values[valuesById[25] = "SurrenderCity3Nt"] = 25;
        values[valuesById[26] = "SurrenderCountry1Nt"] = 26;
        values[valuesById[27] = "SurrenderCountry2Nt"] = 27;
        values[valuesById[28] = "AutocephalyNt2"] = 28;
        values[valuesById[29] = "AutocephalyNt3"] = 29;
        return values;
    })();

    pb.NewCountryNtArg = (function() {

        /**
         * Properties of a NewCountryNtArg.
         * @memberof pb
         * @interface INewCountryNtArg
         * @property {string|null} [PlayerName] NewCountryNtArg PlayerName
         * @property {string|null} [CountryName] NewCountryNtArg CountryName
         * @property {number|null} [CityID] NewCountryNtArg CityID
         */

        /**
         * Constructs a new NewCountryNtArg.
         * @memberof pb
         * @classdesc Represents a NewCountryNtArg.
         * @implements INewCountryNtArg
         * @constructor
         * @param {pb.INewCountryNtArg=} [properties] Properties to set
         */
        function NewCountryNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NewCountryNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.NewCountryNtArg
         * @instance
         */
        NewCountryNtArg.prototype.PlayerName = "";

        /**
         * NewCountryNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.NewCountryNtArg
         * @instance
         */
        NewCountryNtArg.prototype.CountryName = "";

        /**
         * NewCountryNtArg CityID.
         * @member {number} CityID
         * @memberof pb.NewCountryNtArg
         * @instance
         */
        NewCountryNtArg.prototype.CityID = 0;

        /**
         * Creates a new NewCountryNtArg instance using the specified properties.
         * @function create
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {pb.INewCountryNtArg=} [properties] Properties to set
         * @returns {pb.NewCountryNtArg} NewCountryNtArg instance
         */
        NewCountryNtArg.create = function create(properties) {
            return new NewCountryNtArg(properties);
        };

        /**
         * Encodes the specified NewCountryNtArg message. Does not implicitly {@link pb.NewCountryNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {pb.INewCountryNtArg} message NewCountryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewCountryNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.CountryName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified NewCountryNtArg message, length delimited. Does not implicitly {@link pb.NewCountryNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {pb.INewCountryNtArg} message NewCountryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NewCountryNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NewCountryNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.NewCountryNtArg} NewCountryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewCountryNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.NewCountryNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.CountryName = reader.string();
                    break;
                case 3:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NewCountryNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.NewCountryNtArg} NewCountryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NewCountryNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NewCountryNtArg message.
         * @function verify
         * @memberof pb.NewCountryNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NewCountryNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return NewCountryNtArg;
    })();

    pb.AppointJobNtArg = (function() {

        /**
         * Properties of an AppointJobNtArg.
         * @memberof pb
         * @interface IAppointJobNtArg
         * @property {string|null} [PlayerName] AppointJobNtArg PlayerName
         * @property {string|null} [TargetPlayerName] AppointJobNtArg TargetPlayerName
         * @property {pb.CampaignJob|null} [Job] AppointJobNtArg Job
         * @property {number|null} [CityID] AppointJobNtArg CityID
         */

        /**
         * Constructs a new AppointJobNtArg.
         * @memberof pb
         * @classdesc Represents an AppointJobNtArg.
         * @implements IAppointJobNtArg
         * @constructor
         * @param {pb.IAppointJobNtArg=} [properties] Properties to set
         */
        function AppointJobNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppointJobNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.AppointJobNtArg
         * @instance
         */
        AppointJobNtArg.prototype.PlayerName = "";

        /**
         * AppointJobNtArg TargetPlayerName.
         * @member {string} TargetPlayerName
         * @memberof pb.AppointJobNtArg
         * @instance
         */
        AppointJobNtArg.prototype.TargetPlayerName = "";

        /**
         * AppointJobNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.AppointJobNtArg
         * @instance
         */
        AppointJobNtArg.prototype.Job = 0;

        /**
         * AppointJobNtArg CityID.
         * @member {number} CityID
         * @memberof pb.AppointJobNtArg
         * @instance
         */
        AppointJobNtArg.prototype.CityID = 0;

        /**
         * Creates a new AppointJobNtArg instance using the specified properties.
         * @function create
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {pb.IAppointJobNtArg=} [properties] Properties to set
         * @returns {pb.AppointJobNtArg} AppointJobNtArg instance
         */
        AppointJobNtArg.create = function create(properties) {
            return new AppointJobNtArg(properties);
        };

        /**
         * Encodes the specified AppointJobNtArg message. Does not implicitly {@link pb.AppointJobNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {pb.IAppointJobNtArg} message AppointJobNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppointJobNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.TargetPlayerName != null && message.hasOwnProperty("TargetPlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.TargetPlayerName);
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Job);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified AppointJobNtArg message, length delimited. Does not implicitly {@link pb.AppointJobNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {pb.IAppointJobNtArg} message AppointJobNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppointJobNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppointJobNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AppointJobNtArg} AppointJobNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppointJobNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AppointJobNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.TargetPlayerName = reader.string();
                    break;
                case 3:
                    message.Job = reader.int32();
                    break;
                case 4:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppointJobNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AppointJobNtArg} AppointJobNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppointJobNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppointJobNtArg message.
         * @function verify
         * @memberof pb.AppointJobNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppointJobNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.TargetPlayerName != null && message.hasOwnProperty("TargetPlayerName"))
                if (!$util.isString(message.TargetPlayerName))
                    return "TargetPlayerName: string expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return AppointJobNtArg;
    })();

    pb.RecallJobNtArg = (function() {

        /**
         * Properties of a RecallJobNtArg.
         * @memberof pb
         * @interface IRecallJobNtArg
         * @property {pb.CampaignJob|null} [Job] RecallJobNtArg Job
         * @property {number|null} [CityID] RecallJobNtArg CityID
         */

        /**
         * Constructs a new RecallJobNtArg.
         * @memberof pb
         * @classdesc Represents a RecallJobNtArg.
         * @implements IRecallJobNtArg
         * @constructor
         * @param {pb.IRecallJobNtArg=} [properties] Properties to set
         */
        function RecallJobNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecallJobNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.RecallJobNtArg
         * @instance
         */
        RecallJobNtArg.prototype.Job = 0;

        /**
         * RecallJobNtArg CityID.
         * @member {number} CityID
         * @memberof pb.RecallJobNtArg
         * @instance
         */
        RecallJobNtArg.prototype.CityID = 0;

        /**
         * Creates a new RecallJobNtArg instance using the specified properties.
         * @function create
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {pb.IRecallJobNtArg=} [properties] Properties to set
         * @returns {pb.RecallJobNtArg} RecallJobNtArg instance
         */
        RecallJobNtArg.create = function create(properties) {
            return new RecallJobNtArg(properties);
        };

        /**
         * Encodes the specified RecallJobNtArg message. Does not implicitly {@link pb.RecallJobNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {pb.IRecallJobNtArg} message RecallJobNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallJobNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified RecallJobNtArg message, length delimited. Does not implicitly {@link pb.RecallJobNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {pb.IRecallJobNtArg} message RecallJobNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallJobNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecallJobNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RecallJobNtArg} RecallJobNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallJobNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RecallJobNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecallJobNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RecallJobNtArg} RecallJobNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallJobNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecallJobNtArg message.
         * @function verify
         * @memberof pb.RecallJobNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecallJobNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return RecallJobNtArg;
    })();

    pb.AutocephalyNtArg = (function() {

        /**
         * Properties of an AutocephalyNtArg.
         * @memberof pb
         * @interface IAutocephalyNtArg
         * @property {pb.CampaignJob|null} [Job] AutocephalyNtArg Job
         * @property {string|null} [PlayerName] AutocephalyNtArg PlayerName
         * @property {string|null} [CountryName] AutocephalyNtArg CountryName
         * @property {string|null} [NewCountryName] AutocephalyNtArg NewCountryName
         */

        /**
         * Constructs a new AutocephalyNtArg.
         * @memberof pb
         * @classdesc Represents an AutocephalyNtArg.
         * @implements IAutocephalyNtArg
         * @constructor
         * @param {pb.IAutocephalyNtArg=} [properties] Properties to set
         */
        function AutocephalyNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.AutocephalyNtArg
         * @instance
         */
        AutocephalyNtArg.prototype.Job = 0;

        /**
         * AutocephalyNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.AutocephalyNtArg
         * @instance
         */
        AutocephalyNtArg.prototype.PlayerName = "";

        /**
         * AutocephalyNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.AutocephalyNtArg
         * @instance
         */
        AutocephalyNtArg.prototype.CountryName = "";

        /**
         * AutocephalyNtArg NewCountryName.
         * @member {string} NewCountryName
         * @memberof pb.AutocephalyNtArg
         * @instance
         */
        AutocephalyNtArg.prototype.NewCountryName = "";

        /**
         * Creates a new AutocephalyNtArg instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {pb.IAutocephalyNtArg=} [properties] Properties to set
         * @returns {pb.AutocephalyNtArg} AutocephalyNtArg instance
         */
        AutocephalyNtArg.create = function create(properties) {
            return new AutocephalyNtArg(properties);
        };

        /**
         * Encodes the specified AutocephalyNtArg message. Does not implicitly {@link pb.AutocephalyNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {pb.IAutocephalyNtArg} message AutocephalyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.CountryName);
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.NewCountryName);
            return writer;
        };

        /**
         * Encodes the specified AutocephalyNtArg message, length delimited. Does not implicitly {@link pb.AutocephalyNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {pb.IAutocephalyNtArg} message AutocephalyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyNtArg} AutocephalyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                case 3:
                    message.CountryName = reader.string();
                    break;
                case 4:
                    message.NewCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyNtArg} AutocephalyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyNtArg message.
         * @function verify
         * @memberof pb.AutocephalyNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                if (!$util.isString(message.NewCountryName))
                    return "NewCountryName: string expected";
            return null;
        };

        return AutocephalyNtArg;
    })();

    pb.KickOutNtArg = (function() {

        /**
         * Properties of a KickOutNtArg.
         * @memberof pb
         * @interface IKickOutNtArg
         * @property {pb.CampaignJob|null} [Job] KickOutNtArg Job
         * @property {string|null} [PlayerName] KickOutNtArg PlayerName
         * @property {number|null} [CityID] KickOutNtArg CityID
         */

        /**
         * Constructs a new KickOutNtArg.
         * @memberof pb
         * @classdesc Represents a KickOutNtArg.
         * @implements IKickOutNtArg
         * @constructor
         * @param {pb.IKickOutNtArg=} [properties] Properties to set
         */
        function KickOutNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KickOutNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.KickOutNtArg
         * @instance
         */
        KickOutNtArg.prototype.Job = 0;

        /**
         * KickOutNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.KickOutNtArg
         * @instance
         */
        KickOutNtArg.prototype.PlayerName = "";

        /**
         * KickOutNtArg CityID.
         * @member {number} CityID
         * @memberof pb.KickOutNtArg
         * @instance
         */
        KickOutNtArg.prototype.CityID = 0;

        /**
         * Creates a new KickOutNtArg instance using the specified properties.
         * @function create
         * @memberof pb.KickOutNtArg
         * @static
         * @param {pb.IKickOutNtArg=} [properties] Properties to set
         * @returns {pb.KickOutNtArg} KickOutNtArg instance
         */
        KickOutNtArg.create = function create(properties) {
            return new KickOutNtArg(properties);
        };

        /**
         * Encodes the specified KickOutNtArg message. Does not implicitly {@link pb.KickOutNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.KickOutNtArg
         * @static
         * @param {pb.IKickOutNtArg} message KickOutNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOutNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified KickOutNtArg message, length delimited. Does not implicitly {@link pb.KickOutNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.KickOutNtArg
         * @static
         * @param {pb.IKickOutNtArg} message KickOutNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOutNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KickOutNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.KickOutNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.KickOutNtArg} KickOutNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOutNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.KickOutNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                case 3:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KickOutNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.KickOutNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.KickOutNtArg} KickOutNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOutNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KickOutNtArg message.
         * @function verify
         * @memberof pb.KickOutNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KickOutNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return KickOutNtArg;
    })();

    pb.YourMajestyChangeNtArg = (function() {

        /**
         * Properties of a YourMajestyChangeNtArg.
         * @memberof pb
         * @interface IYourMajestyChangeNtArg
         * @property {string|null} [YourMajestyName] YourMajestyChangeNtArg YourMajestyName
         * @property {string|null} [NewYourMajestyName] YourMajestyChangeNtArg NewYourMajestyName
         */

        /**
         * Constructs a new YourMajestyChangeNtArg.
         * @memberof pb
         * @classdesc Represents a YourMajestyChangeNtArg.
         * @implements IYourMajestyChangeNtArg
         * @constructor
         * @param {pb.IYourMajestyChangeNtArg=} [properties] Properties to set
         */
        function YourMajestyChangeNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * YourMajestyChangeNtArg YourMajestyName.
         * @member {string} YourMajestyName
         * @memberof pb.YourMajestyChangeNtArg
         * @instance
         */
        YourMajestyChangeNtArg.prototype.YourMajestyName = "";

        /**
         * YourMajestyChangeNtArg NewYourMajestyName.
         * @member {string} NewYourMajestyName
         * @memberof pb.YourMajestyChangeNtArg
         * @instance
         */
        YourMajestyChangeNtArg.prototype.NewYourMajestyName = "";

        /**
         * Creates a new YourMajestyChangeNtArg instance using the specified properties.
         * @function create
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {pb.IYourMajestyChangeNtArg=} [properties] Properties to set
         * @returns {pb.YourMajestyChangeNtArg} YourMajestyChangeNtArg instance
         */
        YourMajestyChangeNtArg.create = function create(properties) {
            return new YourMajestyChangeNtArg(properties);
        };

        /**
         * Encodes the specified YourMajestyChangeNtArg message. Does not implicitly {@link pb.YourMajestyChangeNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {pb.IYourMajestyChangeNtArg} message YourMajestyChangeNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        YourMajestyChangeNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.YourMajestyName);
            if (message.NewYourMajestyName != null && message.hasOwnProperty("NewYourMajestyName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.NewYourMajestyName);
            return writer;
        };

        /**
         * Encodes the specified YourMajestyChangeNtArg message, length delimited. Does not implicitly {@link pb.YourMajestyChangeNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {pb.IYourMajestyChangeNtArg} message YourMajestyChangeNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        YourMajestyChangeNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a YourMajestyChangeNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.YourMajestyChangeNtArg} YourMajestyChangeNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YourMajestyChangeNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.YourMajestyChangeNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.YourMajestyName = reader.string();
                    break;
                case 2:
                    message.NewYourMajestyName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a YourMajestyChangeNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.YourMajestyChangeNtArg} YourMajestyChangeNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        YourMajestyChangeNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a YourMajestyChangeNtArg message.
         * @function verify
         * @memberof pb.YourMajestyChangeNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        YourMajestyChangeNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                if (!$util.isString(message.YourMajestyName))
                    return "YourMajestyName: string expected";
            if (message.NewYourMajestyName != null && message.hasOwnProperty("NewYourMajestyName"))
                if (!$util.isString(message.NewYourMajestyName))
                    return "NewYourMajestyName: string expected";
            return null;
        };

        return YourMajestyChangeNtArg;
    })();

    pb.ResignNtArg = (function() {

        /**
         * Properties of a ResignNtArg.
         * @memberof pb
         * @interface IResignNtArg
         * @property {pb.CampaignJob|null} [Job] ResignNtArg Job
         * @property {string|null} [PlayerName] ResignNtArg PlayerName
         * @property {number|null} [CityID] ResignNtArg CityID
         */

        /**
         * Constructs a new ResignNtArg.
         * @memberof pb
         * @classdesc Represents a ResignNtArg.
         * @implements IResignNtArg
         * @constructor
         * @param {pb.IResignNtArg=} [properties] Properties to set
         */
        function ResignNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResignNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.ResignNtArg
         * @instance
         */
        ResignNtArg.prototype.Job = 0;

        /**
         * ResignNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.ResignNtArg
         * @instance
         */
        ResignNtArg.prototype.PlayerName = "";

        /**
         * ResignNtArg CityID.
         * @member {number} CityID
         * @memberof pb.ResignNtArg
         * @instance
         */
        ResignNtArg.prototype.CityID = 0;

        /**
         * Creates a new ResignNtArg instance using the specified properties.
         * @function create
         * @memberof pb.ResignNtArg
         * @static
         * @param {pb.IResignNtArg=} [properties] Properties to set
         * @returns {pb.ResignNtArg} ResignNtArg instance
         */
        ResignNtArg.create = function create(properties) {
            return new ResignNtArg(properties);
        };

        /**
         * Encodes the specified ResignNtArg message. Does not implicitly {@link pb.ResignNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ResignNtArg
         * @static
         * @param {pb.IResignNtArg} message ResignNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResignNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified ResignNtArg message, length delimited. Does not implicitly {@link pb.ResignNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ResignNtArg
         * @static
         * @param {pb.IResignNtArg} message ResignNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResignNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResignNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ResignNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ResignNtArg} ResignNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResignNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ResignNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                case 3:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResignNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ResignNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ResignNtArg} ResignNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResignNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResignNtArg message.
         * @function verify
         * @memberof pb.ResignNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResignNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return ResignNtArg;
    })();

    pb.BeOccupyNtArg = (function() {

        /**
         * Properties of a BeOccupyNtArg.
         * @memberof pb
         * @interface IBeOccupyNtArg
         * @property {string|null} [CountryName] BeOccupyNtArg CountryName
         * @property {number|null} [BeOccupyCityID] BeOccupyNtArg BeOccupyCityID
         * @property {number|null} [CaptiveAmount] BeOccupyNtArg CaptiveAmount
         */

        /**
         * Constructs a new BeOccupyNtArg.
         * @memberof pb
         * @classdesc Represents a BeOccupyNtArg.
         * @implements IBeOccupyNtArg
         * @constructor
         * @param {pb.IBeOccupyNtArg=} [properties] Properties to set
         */
        function BeOccupyNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeOccupyNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.BeOccupyNtArg
         * @instance
         */
        BeOccupyNtArg.prototype.CountryName = "";

        /**
         * BeOccupyNtArg BeOccupyCityID.
         * @member {number} BeOccupyCityID
         * @memberof pb.BeOccupyNtArg
         * @instance
         */
        BeOccupyNtArg.prototype.BeOccupyCityID = 0;

        /**
         * BeOccupyNtArg CaptiveAmount.
         * @member {number} CaptiveAmount
         * @memberof pb.BeOccupyNtArg
         * @instance
         */
        BeOccupyNtArg.prototype.CaptiveAmount = 0;

        /**
         * Creates a new BeOccupyNtArg instance using the specified properties.
         * @function create
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {pb.IBeOccupyNtArg=} [properties] Properties to set
         * @returns {pb.BeOccupyNtArg} BeOccupyNtArg instance
         */
        BeOccupyNtArg.create = function create(properties) {
            return new BeOccupyNtArg(properties);
        };

        /**
         * Encodes the specified BeOccupyNtArg message. Does not implicitly {@link pb.BeOccupyNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {pb.IBeOccupyNtArg} message BeOccupyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeOccupyNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.CountryName);
            if (message.BeOccupyCityID != null && message.hasOwnProperty("BeOccupyCityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.BeOccupyCityID);
            if (message.CaptiveAmount != null && message.hasOwnProperty("CaptiveAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CaptiveAmount);
            return writer;
        };

        /**
         * Encodes the specified BeOccupyNtArg message, length delimited. Does not implicitly {@link pb.BeOccupyNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {pb.IBeOccupyNtArg} message BeOccupyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeOccupyNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeOccupyNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeOccupyNtArg} BeOccupyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeOccupyNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeOccupyNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryName = reader.string();
                    break;
                case 2:
                    message.BeOccupyCityID = reader.int32();
                    break;
                case 3:
                    message.CaptiveAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeOccupyNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeOccupyNtArg} BeOccupyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeOccupyNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeOccupyNtArg message.
         * @function verify
         * @memberof pb.BeOccupyNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeOccupyNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.BeOccupyCityID != null && message.hasOwnProperty("BeOccupyCityID"))
                if (!$util.isInteger(message.BeOccupyCityID))
                    return "BeOccupyCityID: integer expected";
            if (message.CaptiveAmount != null && message.hasOwnProperty("CaptiveAmount"))
                if (!$util.isInteger(message.CaptiveAmount))
                    return "CaptiveAmount: integer expected";
            return null;
        };

        return BeOccupyNtArg;
    })();

    pb.DestoryCountryNtArg = (function() {

        /**
         * Properties of a DestoryCountryNtArg.
         * @memberof pb
         * @interface IDestoryCountryNtArg
         * @property {string|null} [CountryName] DestoryCountryNtArg CountryName
         * @property {string|null} [BeDestoryCountryName] DestoryCountryNtArg BeDestoryCountryName
         */

        /**
         * Constructs a new DestoryCountryNtArg.
         * @memberof pb
         * @classdesc Represents a DestoryCountryNtArg.
         * @implements IDestoryCountryNtArg
         * @constructor
         * @param {pb.IDestoryCountryNtArg=} [properties] Properties to set
         */
        function DestoryCountryNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DestoryCountryNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.DestoryCountryNtArg
         * @instance
         */
        DestoryCountryNtArg.prototype.CountryName = "";

        /**
         * DestoryCountryNtArg BeDestoryCountryName.
         * @member {string} BeDestoryCountryName
         * @memberof pb.DestoryCountryNtArg
         * @instance
         */
        DestoryCountryNtArg.prototype.BeDestoryCountryName = "";

        /**
         * Creates a new DestoryCountryNtArg instance using the specified properties.
         * @function create
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {pb.IDestoryCountryNtArg=} [properties] Properties to set
         * @returns {pb.DestoryCountryNtArg} DestoryCountryNtArg instance
         */
        DestoryCountryNtArg.create = function create(properties) {
            return new DestoryCountryNtArg(properties);
        };

        /**
         * Encodes the specified DestoryCountryNtArg message. Does not implicitly {@link pb.DestoryCountryNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {pb.IDestoryCountryNtArg} message DestoryCountryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DestoryCountryNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.CountryName);
            if (message.BeDestoryCountryName != null && message.hasOwnProperty("BeDestoryCountryName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.BeDestoryCountryName);
            return writer;
        };

        /**
         * Encodes the specified DestoryCountryNtArg message, length delimited. Does not implicitly {@link pb.DestoryCountryNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {pb.IDestoryCountryNtArg} message DestoryCountryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DestoryCountryNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DestoryCountryNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DestoryCountryNtArg} DestoryCountryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DestoryCountryNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DestoryCountryNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryName = reader.string();
                    break;
                case 2:
                    message.BeDestoryCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DestoryCountryNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DestoryCountryNtArg} DestoryCountryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DestoryCountryNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DestoryCountryNtArg message.
         * @function verify
         * @memberof pb.DestoryCountryNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DestoryCountryNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.BeDestoryCountryName != null && message.hasOwnProperty("BeDestoryCountryName"))
                if (!$util.isString(message.BeDestoryCountryName))
                    return "BeDestoryCountryName: string expected";
            return null;
        };

        return DestoryCountryNtArg;
    })();

    pb.UnifiedWordNtArg = (function() {

        /**
         * Properties of an UnifiedWordNtArg.
         * @memberof pb
         * @interface IUnifiedWordNtArg
         * @property {string|null} [CountryName] UnifiedWordNtArg CountryName
         * @property {string|null} [YourMajestyName] UnifiedWordNtArg YourMajestyName
         */

        /**
         * Constructs a new UnifiedWordNtArg.
         * @memberof pb
         * @classdesc Represents an UnifiedWordNtArg.
         * @implements IUnifiedWordNtArg
         * @constructor
         * @param {pb.IUnifiedWordNtArg=} [properties] Properties to set
         */
        function UnifiedWordNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnifiedWordNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.UnifiedWordNtArg
         * @instance
         */
        UnifiedWordNtArg.prototype.CountryName = "";

        /**
         * UnifiedWordNtArg YourMajestyName.
         * @member {string} YourMajestyName
         * @memberof pb.UnifiedWordNtArg
         * @instance
         */
        UnifiedWordNtArg.prototype.YourMajestyName = "";

        /**
         * Creates a new UnifiedWordNtArg instance using the specified properties.
         * @function create
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {pb.IUnifiedWordNtArg=} [properties] Properties to set
         * @returns {pb.UnifiedWordNtArg} UnifiedWordNtArg instance
         */
        UnifiedWordNtArg.create = function create(properties) {
            return new UnifiedWordNtArg(properties);
        };

        /**
         * Encodes the specified UnifiedWordNtArg message. Does not implicitly {@link pb.UnifiedWordNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {pb.IUnifiedWordNtArg} message UnifiedWordNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnifiedWordNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.CountryName);
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.YourMajestyName);
            return writer;
        };

        /**
         * Encodes the specified UnifiedWordNtArg message, length delimited. Does not implicitly {@link pb.UnifiedWordNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {pb.IUnifiedWordNtArg} message UnifiedWordNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnifiedWordNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnifiedWordNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UnifiedWordNtArg} UnifiedWordNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnifiedWordNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UnifiedWordNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryName = reader.string();
                    break;
                case 2:
                    message.YourMajestyName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnifiedWordNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UnifiedWordNtArg} UnifiedWordNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnifiedWordNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnifiedWordNtArg message.
         * @function verify
         * @memberof pb.UnifiedWordNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnifiedWordNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                if (!$util.isString(message.YourMajestyName))
                    return "YourMajestyName: string expected";
            return null;
        };

        return UnifiedWordNtArg;
    })();

    pb.AutocephalyVoteNtArg = (function() {

        /**
         * Properties of an AutocephalyVoteNtArg.
         * @memberof pb
         * @interface IAutocephalyVoteNtArg
         * @property {pb.CampaignJob|null} [Job] AutocephalyVoteNtArg Job
         * @property {string|null} [PlayerName] AutocephalyVoteNtArg PlayerName
         * @property {number|null} [CityID] AutocephalyVoteNtArg CityID
         * @property {string|null} [CountryName] AutocephalyVoteNtArg CountryName
         */

        /**
         * Constructs a new AutocephalyVoteNtArg.
         * @memberof pb
         * @classdesc Represents an AutocephalyVoteNtArg.
         * @implements IAutocephalyVoteNtArg
         * @constructor
         * @param {pb.IAutocephalyVoteNtArg=} [properties] Properties to set
         */
        function AutocephalyVoteNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyVoteNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.AutocephalyVoteNtArg
         * @instance
         */
        AutocephalyVoteNtArg.prototype.Job = 0;

        /**
         * AutocephalyVoteNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.AutocephalyVoteNtArg
         * @instance
         */
        AutocephalyVoteNtArg.prototype.PlayerName = "";

        /**
         * AutocephalyVoteNtArg CityID.
         * @member {number} CityID
         * @memberof pb.AutocephalyVoteNtArg
         * @instance
         */
        AutocephalyVoteNtArg.prototype.CityID = 0;

        /**
         * AutocephalyVoteNtArg CountryName.
         * @member {string} CountryName
         * @memberof pb.AutocephalyVoteNtArg
         * @instance
         */
        AutocephalyVoteNtArg.prototype.CountryName = "";

        /**
         * Creates a new AutocephalyVoteNtArg instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {pb.IAutocephalyVoteNtArg=} [properties] Properties to set
         * @returns {pb.AutocephalyVoteNtArg} AutocephalyVoteNtArg instance
         */
        AutocephalyVoteNtArg.create = function create(properties) {
            return new AutocephalyVoteNtArg(properties);
        };

        /**
         * Encodes the specified AutocephalyVoteNtArg message. Does not implicitly {@link pb.AutocephalyVoteNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {pb.IAutocephalyVoteNtArg} message AutocephalyVoteNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyVoteNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CityID);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.CountryName);
            return writer;
        };

        /**
         * Encodes the specified AutocephalyVoteNtArg message, length delimited. Does not implicitly {@link pb.AutocephalyVoteNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {pb.IAutocephalyVoteNtArg} message AutocephalyVoteNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyVoteNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyVoteNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyVoteNtArg} AutocephalyVoteNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyVoteNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyVoteNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                case 3:
                    message.CityID = reader.int32();
                    break;
                case 4:
                    message.CountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyVoteNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyVoteNtArg} AutocephalyVoteNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyVoteNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyVoteNtArg message.
         * @function verify
         * @memberof pb.AutocephalyVoteNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyVoteNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            return null;
        };

        return AutocephalyVoteNtArg;
    })();

    pb.CapitalInjectionNtArg = (function() {

        /**
         * Properties of a CapitalInjectionNtArg.
         * @memberof pb
         * @interface ICapitalInjectionNtArg
         * @property {pb.CampaignJob|null} [Job] CapitalInjectionNtArg Job
         * @property {string|null} [PlayerName] CapitalInjectionNtArg PlayerName
         * @property {number|null} [Gold] CapitalInjectionNtArg Gold
         */

        /**
         * Constructs a new CapitalInjectionNtArg.
         * @memberof pb
         * @classdesc Represents a CapitalInjectionNtArg.
         * @implements ICapitalInjectionNtArg
         * @constructor
         * @param {pb.ICapitalInjectionNtArg=} [properties] Properties to set
         */
        function CapitalInjectionNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapitalInjectionNtArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.CapitalInjectionNtArg
         * @instance
         */
        CapitalInjectionNtArg.prototype.Job = 0;

        /**
         * CapitalInjectionNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.CapitalInjectionNtArg
         * @instance
         */
        CapitalInjectionNtArg.prototype.PlayerName = "";

        /**
         * CapitalInjectionNtArg Gold.
         * @member {number} Gold
         * @memberof pb.CapitalInjectionNtArg
         * @instance
         */
        CapitalInjectionNtArg.prototype.Gold = 0;

        /**
         * Creates a new CapitalInjectionNtArg instance using the specified properties.
         * @function create
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {pb.ICapitalInjectionNtArg=} [properties] Properties to set
         * @returns {pb.CapitalInjectionNtArg} CapitalInjectionNtArg instance
         */
        CapitalInjectionNtArg.create = function create(properties) {
            return new CapitalInjectionNtArg(properties);
        };

        /**
         * Encodes the specified CapitalInjectionNtArg message. Does not implicitly {@link pb.CapitalInjectionNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {pb.ICapitalInjectionNtArg} message CapitalInjectionNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalInjectionNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified CapitalInjectionNtArg message, length delimited. Does not implicitly {@link pb.CapitalInjectionNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {pb.ICapitalInjectionNtArg} message CapitalInjectionNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalInjectionNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapitalInjectionNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CapitalInjectionNtArg} CapitalInjectionNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalInjectionNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CapitalInjectionNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Job = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                case 3:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CapitalInjectionNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CapitalInjectionNtArg} CapitalInjectionNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalInjectionNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapitalInjectionNtArg message.
         * @function verify
         * @memberof pb.CapitalInjectionNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapitalInjectionNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return CapitalInjectionNtArg;
    })();

    pb.ProductionNtArg = (function() {

        /**
         * Properties of a ProductionNtArg.
         * @memberof pb
         * @interface IProductionNtArg
         * @property {number|null} [Gold] ProductionNtArg Gold
         * @property {number|null} [Forage] ProductionNtArg Forage
         */

        /**
         * Constructs a new ProductionNtArg.
         * @memberof pb
         * @classdesc Represents a ProductionNtArg.
         * @implements IProductionNtArg
         * @constructor
         * @param {pb.IProductionNtArg=} [properties] Properties to set
         */
        function ProductionNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ProductionNtArg Gold.
         * @member {number} Gold
         * @memberof pb.ProductionNtArg
         * @instance
         */
        ProductionNtArg.prototype.Gold = 0;

        /**
         * ProductionNtArg Forage.
         * @member {number} Forage
         * @memberof pb.ProductionNtArg
         * @instance
         */
        ProductionNtArg.prototype.Forage = 0;

        /**
         * Creates a new ProductionNtArg instance using the specified properties.
         * @function create
         * @memberof pb.ProductionNtArg
         * @static
         * @param {pb.IProductionNtArg=} [properties] Properties to set
         * @returns {pb.ProductionNtArg} ProductionNtArg instance
         */
        ProductionNtArg.create = function create(properties) {
            return new ProductionNtArg(properties);
        };

        /**
         * Encodes the specified ProductionNtArg message. Does not implicitly {@link pb.ProductionNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ProductionNtArg
         * @static
         * @param {pb.IProductionNtArg} message ProductionNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductionNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Forage);
            return writer;
        };

        /**
         * Encodes the specified ProductionNtArg message, length delimited. Does not implicitly {@link pb.ProductionNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ProductionNtArg
         * @static
         * @param {pb.IProductionNtArg} message ProductionNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ProductionNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ProductionNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ProductionNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ProductionNtArg} ProductionNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductionNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ProductionNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                case 2:
                    message.Forage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ProductionNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ProductionNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ProductionNtArg} ProductionNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ProductionNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ProductionNtArg message.
         * @function verify
         * @memberof pb.ProductionNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ProductionNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            return null;
        };

        return ProductionNtArg;
    })();

    pb.SalaryNtArg = (function() {

        /**
         * Properties of a SalaryNtArg.
         * @memberof pb
         * @interface ISalaryNtArg
         * @property {number|null} [Gold] SalaryNtArg Gold
         */

        /**
         * Constructs a new SalaryNtArg.
         * @memberof pb
         * @classdesc Represents a SalaryNtArg.
         * @implements ISalaryNtArg
         * @constructor
         * @param {pb.ISalaryNtArg=} [properties] Properties to set
         */
        function SalaryNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SalaryNtArg Gold.
         * @member {number} Gold
         * @memberof pb.SalaryNtArg
         * @instance
         */
        SalaryNtArg.prototype.Gold = 0;

        /**
         * Creates a new SalaryNtArg instance using the specified properties.
         * @function create
         * @memberof pb.SalaryNtArg
         * @static
         * @param {pb.ISalaryNtArg=} [properties] Properties to set
         * @returns {pb.SalaryNtArg} SalaryNtArg instance
         */
        SalaryNtArg.create = function create(properties) {
            return new SalaryNtArg(properties);
        };

        /**
         * Encodes the specified SalaryNtArg message. Does not implicitly {@link pb.SalaryNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SalaryNtArg
         * @static
         * @param {pb.ISalaryNtArg} message SalaryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SalaryNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified SalaryNtArg message, length delimited. Does not implicitly {@link pb.SalaryNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SalaryNtArg
         * @static
         * @param {pb.ISalaryNtArg} message SalaryNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SalaryNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SalaryNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SalaryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SalaryNtArg} SalaryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SalaryNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SalaryNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SalaryNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SalaryNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SalaryNtArg} SalaryNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SalaryNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SalaryNtArg message.
         * @function verify
         * @memberof pb.SalaryNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SalaryNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return SalaryNtArg;
    })();

    pb.TransportNtArg = (function() {

        /**
         * Properties of a TransportNtArg.
         * @memberof pb
         * @interface ITransportNtArg
         * @property {number|null} [FromCity] TransportNtArg FromCity
         * @property {number|null} [TargetCity] TransportNtArg TargetCity
         * @property {pb.TransportTypeEnum|null} [TransportType] TransportNtArg TransportType
         * @property {number|null} [Amount] TransportNtArg Amount
         */

        /**
         * Constructs a new TransportNtArg.
         * @memberof pb
         * @classdesc Represents a TransportNtArg.
         * @implements ITransportNtArg
         * @constructor
         * @param {pb.ITransportNtArg=} [properties] Properties to set
         */
        function TransportNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TransportNtArg FromCity.
         * @member {number} FromCity
         * @memberof pb.TransportNtArg
         * @instance
         */
        TransportNtArg.prototype.FromCity = 0;

        /**
         * TransportNtArg TargetCity.
         * @member {number} TargetCity
         * @memberof pb.TransportNtArg
         * @instance
         */
        TransportNtArg.prototype.TargetCity = 0;

        /**
         * TransportNtArg TransportType.
         * @member {pb.TransportTypeEnum} TransportType
         * @memberof pb.TransportNtArg
         * @instance
         */
        TransportNtArg.prototype.TransportType = 0;

        /**
         * TransportNtArg Amount.
         * @member {number} Amount
         * @memberof pb.TransportNtArg
         * @instance
         */
        TransportNtArg.prototype.Amount = 0;

        /**
         * Creates a new TransportNtArg instance using the specified properties.
         * @function create
         * @memberof pb.TransportNtArg
         * @static
         * @param {pb.ITransportNtArg=} [properties] Properties to set
         * @returns {pb.TransportNtArg} TransportNtArg instance
         */
        TransportNtArg.create = function create(properties) {
            return new TransportNtArg(properties);
        };

        /**
         * Encodes the specified TransportNtArg message. Does not implicitly {@link pb.TransportNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.TransportNtArg
         * @static
         * @param {pb.ITransportNtArg} message TransportNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransportNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromCity != null && message.hasOwnProperty("FromCity"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.FromCity);
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.TargetCity);
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.TransportType);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified TransportNtArg message, length delimited. Does not implicitly {@link pb.TransportNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TransportNtArg
         * @static
         * @param {pb.ITransportNtArg} message TransportNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TransportNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TransportNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TransportNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TransportNtArg} TransportNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransportNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TransportNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromCity = reader.int32();
                    break;
                case 2:
                    message.TargetCity = reader.int32();
                    break;
                case 3:
                    message.TransportType = reader.int32();
                    break;
                case 4:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TransportNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TransportNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TransportNtArg} TransportNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TransportNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TransportNtArg message.
         * @function verify
         * @memberof pb.TransportNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TransportNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromCity != null && message.hasOwnProperty("FromCity"))
                if (!$util.isInteger(message.FromCity))
                    return "FromCity: integer expected";
            if (message.TargetCity != null && message.hasOwnProperty("TargetCity"))
                if (!$util.isInteger(message.TargetCity))
                    return "TargetCity: integer expected";
            if (message.TransportType != null && message.hasOwnProperty("TransportType"))
                switch (message.TransportType) {
                default:
                    return "TransportType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return TransportNtArg;
    })();

    pb.OccupyNtArg = (function() {

        /**
         * Properties of an OccupyNtArg.
         * @memberof pb
         * @interface IOccupyNtArg
         * @property {number|null} [OccupyCityID] OccupyNtArg OccupyCityID
         * @property {number|null} [CaptiveAmount] OccupyNtArg CaptiveAmount
         */

        /**
         * Constructs a new OccupyNtArg.
         * @memberof pb
         * @classdesc Represents an OccupyNtArg.
         * @implements IOccupyNtArg
         * @constructor
         * @param {pb.IOccupyNtArg=} [properties] Properties to set
         */
        function OccupyNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OccupyNtArg OccupyCityID.
         * @member {number} OccupyCityID
         * @memberof pb.OccupyNtArg
         * @instance
         */
        OccupyNtArg.prototype.OccupyCityID = 0;

        /**
         * OccupyNtArg CaptiveAmount.
         * @member {number} CaptiveAmount
         * @memberof pb.OccupyNtArg
         * @instance
         */
        OccupyNtArg.prototype.CaptiveAmount = 0;

        /**
         * Creates a new OccupyNtArg instance using the specified properties.
         * @function create
         * @memberof pb.OccupyNtArg
         * @static
         * @param {pb.IOccupyNtArg=} [properties] Properties to set
         * @returns {pb.OccupyNtArg} OccupyNtArg instance
         */
        OccupyNtArg.create = function create(properties) {
            return new OccupyNtArg(properties);
        };

        /**
         * Encodes the specified OccupyNtArg message. Does not implicitly {@link pb.OccupyNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.OccupyNtArg
         * @static
         * @param {pb.IOccupyNtArg} message OccupyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OccupyNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OccupyCityID != null && message.hasOwnProperty("OccupyCityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.OccupyCityID);
            if (message.CaptiveAmount != null && message.hasOwnProperty("CaptiveAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CaptiveAmount);
            return writer;
        };

        /**
         * Encodes the specified OccupyNtArg message, length delimited. Does not implicitly {@link pb.OccupyNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OccupyNtArg
         * @static
         * @param {pb.IOccupyNtArg} message OccupyNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OccupyNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OccupyNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OccupyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OccupyNtArg} OccupyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OccupyNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OccupyNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.OccupyCityID = reader.int32();
                    break;
                case 2:
                    message.CaptiveAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OccupyNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OccupyNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OccupyNtArg} OccupyNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OccupyNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OccupyNtArg message.
         * @function verify
         * @memberof pb.OccupyNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OccupyNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OccupyCityID != null && message.hasOwnProperty("OccupyCityID"))
                if (!$util.isInteger(message.OccupyCityID))
                    return "OccupyCityID: integer expected";
            if (message.CaptiveAmount != null && message.hasOwnProperty("CaptiveAmount"))
                if (!$util.isInteger(message.CaptiveAmount))
                    return "CaptiveAmount: integer expected";
            return null;
        };

        return OccupyNtArg;
    })();

    pb.SurrenderNtArg = (function() {

        /**
         * Properties of a SurrenderNtArg.
         * @memberof pb
         * @interface ISurrenderNtArg
         * @property {string|null} [PlayerName] SurrenderNtArg PlayerName
         */

        /**
         * Constructs a new SurrenderNtArg.
         * @memberof pb
         * @classdesc Represents a SurrenderNtArg.
         * @implements ISurrenderNtArg
         * @constructor
         * @param {pb.ISurrenderNtArg=} [properties] Properties to set
         */
        function SurrenderNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurrenderNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.SurrenderNtArg
         * @instance
         */
        SurrenderNtArg.prototype.PlayerName = "";

        /**
         * Creates a new SurrenderNtArg instance using the specified properties.
         * @function create
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {pb.ISurrenderNtArg=} [properties] Properties to set
         * @returns {pb.SurrenderNtArg} SurrenderNtArg instance
         */
        SurrenderNtArg.create = function create(properties) {
            return new SurrenderNtArg(properties);
        };

        /**
         * Encodes the specified SurrenderNtArg message. Does not implicitly {@link pb.SurrenderNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {pb.ISurrenderNtArg} message SurrenderNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified SurrenderNtArg message, length delimited. Does not implicitly {@link pb.SurrenderNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {pb.ISurrenderNtArg} message SurrenderNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurrenderNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurrenderNtArg} SurrenderNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurrenderNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurrenderNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurrenderNtArg} SurrenderNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurrenderNtArg message.
         * @function verify
         * @memberof pb.SurrenderNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurrenderNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return SurrenderNtArg;
    })();

    pb.BetrayNtArg = (function() {

        /**
         * Properties of a BetrayNtArg.
         * @memberof pb
         * @interface IBetrayNtArg
         * @property {string|null} [PlayerName] BetrayNtArg PlayerName
         */

        /**
         * Constructs a new BetrayNtArg.
         * @memberof pb
         * @classdesc Represents a BetrayNtArg.
         * @implements IBetrayNtArg
         * @constructor
         * @param {pb.IBetrayNtArg=} [properties] Properties to set
         */
        function BetrayNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BetrayNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.BetrayNtArg
         * @instance
         */
        BetrayNtArg.prototype.PlayerName = "";

        /**
         * Creates a new BetrayNtArg instance using the specified properties.
         * @function create
         * @memberof pb.BetrayNtArg
         * @static
         * @param {pb.IBetrayNtArg=} [properties] Properties to set
         * @returns {pb.BetrayNtArg} BetrayNtArg instance
         */
        BetrayNtArg.create = function create(properties) {
            return new BetrayNtArg(properties);
        };

        /**
         * Encodes the specified BetrayNtArg message. Does not implicitly {@link pb.BetrayNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BetrayNtArg
         * @static
         * @param {pb.IBetrayNtArg} message BetrayNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BetrayNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified BetrayNtArg message, length delimited. Does not implicitly {@link pb.BetrayNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BetrayNtArg
         * @static
         * @param {pb.IBetrayNtArg} message BetrayNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BetrayNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BetrayNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BetrayNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BetrayNtArg} BetrayNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetrayNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BetrayNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BetrayNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BetrayNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BetrayNtArg} BetrayNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BetrayNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BetrayNtArg message.
         * @function verify
         * @memberof pb.BetrayNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BetrayNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return BetrayNtArg;
    })();

    pb.EscapedNtArg = (function() {

        /**
         * Properties of an EscapedNtArg.
         * @memberof pb
         * @interface IEscapedNtArg
         * @property {string|null} [PlayerName] EscapedNtArg PlayerName
         */

        /**
         * Constructs a new EscapedNtArg.
         * @memberof pb
         * @classdesc Represents an EscapedNtArg.
         * @implements IEscapedNtArg
         * @constructor
         * @param {pb.IEscapedNtArg=} [properties] Properties to set
         */
        function EscapedNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EscapedNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.EscapedNtArg
         * @instance
         */
        EscapedNtArg.prototype.PlayerName = "";

        /**
         * Creates a new EscapedNtArg instance using the specified properties.
         * @function create
         * @memberof pb.EscapedNtArg
         * @static
         * @param {pb.IEscapedNtArg=} [properties] Properties to set
         * @returns {pb.EscapedNtArg} EscapedNtArg instance
         */
        EscapedNtArg.create = function create(properties) {
            return new EscapedNtArg(properties);
        };

        /**
         * Encodes the specified EscapedNtArg message. Does not implicitly {@link pb.EscapedNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.EscapedNtArg
         * @static
         * @param {pb.IEscapedNtArg} message EscapedNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EscapedNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified EscapedNtArg message, length delimited. Does not implicitly {@link pb.EscapedNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EscapedNtArg
         * @static
         * @param {pb.IEscapedNtArg} message EscapedNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EscapedNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EscapedNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EscapedNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EscapedNtArg} EscapedNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EscapedNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EscapedNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EscapedNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EscapedNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EscapedNtArg} EscapedNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EscapedNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EscapedNtArg message.
         * @function verify
         * @memberof pb.EscapedNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EscapedNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return EscapedNtArg;
    })();

    pb.EscapedReturnNtArg = (function() {

        /**
         * Properties of an EscapedReturnNtArg.
         * @memberof pb
         * @interface IEscapedReturnNtArg
         * @property {string|null} [PlayerName] EscapedReturnNtArg PlayerName
         */

        /**
         * Constructs a new EscapedReturnNtArg.
         * @memberof pb
         * @classdesc Represents an EscapedReturnNtArg.
         * @implements IEscapedReturnNtArg
         * @constructor
         * @param {pb.IEscapedReturnNtArg=} [properties] Properties to set
         */
        function EscapedReturnNtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EscapedReturnNtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.EscapedReturnNtArg
         * @instance
         */
        EscapedReturnNtArg.prototype.PlayerName = "";

        /**
         * Creates a new EscapedReturnNtArg instance using the specified properties.
         * @function create
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {pb.IEscapedReturnNtArg=} [properties] Properties to set
         * @returns {pb.EscapedReturnNtArg} EscapedReturnNtArg instance
         */
        EscapedReturnNtArg.create = function create(properties) {
            return new EscapedReturnNtArg(properties);
        };

        /**
         * Encodes the specified EscapedReturnNtArg message. Does not implicitly {@link pb.EscapedReturnNtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {pb.IEscapedReturnNtArg} message EscapedReturnNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EscapedReturnNtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified EscapedReturnNtArg message, length delimited. Does not implicitly {@link pb.EscapedReturnNtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {pb.IEscapedReturnNtArg} message EscapedReturnNtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EscapedReturnNtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EscapedReturnNtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EscapedReturnNtArg} EscapedReturnNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EscapedReturnNtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EscapedReturnNtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EscapedReturnNtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EscapedReturnNtArg} EscapedReturnNtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EscapedReturnNtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EscapedReturnNtArg message.
         * @function verify
         * @memberof pb.EscapedReturnNtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EscapedReturnNtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return EscapedReturnNtArg;
    })();

    pb.SurrenderCity1NtArg = (function() {

        /**
         * Properties of a SurrenderCity1NtArg.
         * @memberof pb
         * @interface ISurrenderCity1NtArg
         * @property {string|null} [PlayerName] SurrenderCity1NtArg PlayerName
         * @property {number|null} [CityID] SurrenderCity1NtArg CityID
         * @property {string|null} [TargetCountryName] SurrenderCity1NtArg TargetCountryName
         */

        /**
         * Constructs a new SurrenderCity1NtArg.
         * @memberof pb
         * @classdesc Represents a SurrenderCity1NtArg.
         * @implements ISurrenderCity1NtArg
         * @constructor
         * @param {pb.ISurrenderCity1NtArg=} [properties] Properties to set
         */
        function SurrenderCity1NtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurrenderCity1NtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.SurrenderCity1NtArg
         * @instance
         */
        SurrenderCity1NtArg.prototype.PlayerName = "";

        /**
         * SurrenderCity1NtArg CityID.
         * @member {number} CityID
         * @memberof pb.SurrenderCity1NtArg
         * @instance
         */
        SurrenderCity1NtArg.prototype.CityID = 0;

        /**
         * SurrenderCity1NtArg TargetCountryName.
         * @member {string} TargetCountryName
         * @memberof pb.SurrenderCity1NtArg
         * @instance
         */
        SurrenderCity1NtArg.prototype.TargetCountryName = "";

        /**
         * Creates a new SurrenderCity1NtArg instance using the specified properties.
         * @function create
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {pb.ISurrenderCity1NtArg=} [properties] Properties to set
         * @returns {pb.SurrenderCity1NtArg} SurrenderCity1NtArg instance
         */
        SurrenderCity1NtArg.create = function create(properties) {
            return new SurrenderCity1NtArg(properties);
        };

        /**
         * Encodes the specified SurrenderCity1NtArg message. Does not implicitly {@link pb.SurrenderCity1NtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {pb.ISurrenderCity1NtArg} message SurrenderCity1NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCity1NtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            if (message.TargetCountryName != null && message.hasOwnProperty("TargetCountryName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.TargetCountryName);
            return writer;
        };

        /**
         * Encodes the specified SurrenderCity1NtArg message, length delimited. Does not implicitly {@link pb.SurrenderCity1NtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {pb.ISurrenderCity1NtArg} message SurrenderCity1NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCity1NtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurrenderCity1NtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurrenderCity1NtArg} SurrenderCity1NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCity1NtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurrenderCity1NtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                case 3:
                    message.TargetCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurrenderCity1NtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurrenderCity1NtArg} SurrenderCity1NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCity1NtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurrenderCity1NtArg message.
         * @function verify
         * @memberof pb.SurrenderCity1NtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurrenderCity1NtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.TargetCountryName != null && message.hasOwnProperty("TargetCountryName"))
                if (!$util.isString(message.TargetCountryName))
                    return "TargetCountryName: string expected";
            return null;
        };

        return SurrenderCity1NtArg;
    })();

    pb.SurrenderCity2NtArg = (function() {

        /**
         * Properties of a SurrenderCity2NtArg.
         * @memberof pb
         * @interface ISurrenderCity2NtArg
         * @property {string|null} [PlayerName] SurrenderCity2NtArg PlayerName
         * @property {number|null} [CityID] SurrenderCity2NtArg CityID
         */

        /**
         * Constructs a new SurrenderCity2NtArg.
         * @memberof pb
         * @classdesc Represents a SurrenderCity2NtArg.
         * @implements ISurrenderCity2NtArg
         * @constructor
         * @param {pb.ISurrenderCity2NtArg=} [properties] Properties to set
         */
        function SurrenderCity2NtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurrenderCity2NtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.SurrenderCity2NtArg
         * @instance
         */
        SurrenderCity2NtArg.prototype.PlayerName = "";

        /**
         * SurrenderCity2NtArg CityID.
         * @member {number} CityID
         * @memberof pb.SurrenderCity2NtArg
         * @instance
         */
        SurrenderCity2NtArg.prototype.CityID = 0;

        /**
         * Creates a new SurrenderCity2NtArg instance using the specified properties.
         * @function create
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {pb.ISurrenderCity2NtArg=} [properties] Properties to set
         * @returns {pb.SurrenderCity2NtArg} SurrenderCity2NtArg instance
         */
        SurrenderCity2NtArg.create = function create(properties) {
            return new SurrenderCity2NtArg(properties);
        };

        /**
         * Encodes the specified SurrenderCity2NtArg message. Does not implicitly {@link pb.SurrenderCity2NtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {pb.ISurrenderCity2NtArg} message SurrenderCity2NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCity2NtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            return writer;
        };

        /**
         * Encodes the specified SurrenderCity2NtArg message, length delimited. Does not implicitly {@link pb.SurrenderCity2NtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {pb.ISurrenderCity2NtArg} message SurrenderCity2NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCity2NtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurrenderCity2NtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurrenderCity2NtArg} SurrenderCity2NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCity2NtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurrenderCity2NtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurrenderCity2NtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurrenderCity2NtArg} SurrenderCity2NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCity2NtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurrenderCity2NtArg message.
         * @function verify
         * @memberof pb.SurrenderCity2NtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurrenderCity2NtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            return null;
        };

        return SurrenderCity2NtArg;
    })();

    pb.SurrenderCountry1NtArg = (function() {

        /**
         * Properties of a SurrenderCountry1NtArg.
         * @memberof pb
         * @interface ISurrenderCountry1NtArg
         * @property {string|null} [PlayerName] SurrenderCountry1NtArg PlayerName
         * @property {string|null} [TargetCountryName] SurrenderCountry1NtArg TargetCountryName
         */

        /**
         * Constructs a new SurrenderCountry1NtArg.
         * @memberof pb
         * @classdesc Represents a SurrenderCountry1NtArg.
         * @implements ISurrenderCountry1NtArg
         * @constructor
         * @param {pb.ISurrenderCountry1NtArg=} [properties] Properties to set
         */
        function SurrenderCountry1NtArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurrenderCountry1NtArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.SurrenderCountry1NtArg
         * @instance
         */
        SurrenderCountry1NtArg.prototype.PlayerName = "";

        /**
         * SurrenderCountry1NtArg TargetCountryName.
         * @member {string} TargetCountryName
         * @memberof pb.SurrenderCountry1NtArg
         * @instance
         */
        SurrenderCountry1NtArg.prototype.TargetCountryName = "";

        /**
         * Creates a new SurrenderCountry1NtArg instance using the specified properties.
         * @function create
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {pb.ISurrenderCountry1NtArg=} [properties] Properties to set
         * @returns {pb.SurrenderCountry1NtArg} SurrenderCountry1NtArg instance
         */
        SurrenderCountry1NtArg.create = function create(properties) {
            return new SurrenderCountry1NtArg(properties);
        };

        /**
         * Encodes the specified SurrenderCountry1NtArg message. Does not implicitly {@link pb.SurrenderCountry1NtArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {pb.ISurrenderCountry1NtArg} message SurrenderCountry1NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCountry1NtArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.TargetCountryName != null && message.hasOwnProperty("TargetCountryName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.TargetCountryName);
            return writer;
        };

        /**
         * Encodes the specified SurrenderCountry1NtArg message, length delimited. Does not implicitly {@link pb.SurrenderCountry1NtArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {pb.ISurrenderCountry1NtArg} message SurrenderCountry1NtArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCountry1NtArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurrenderCountry1NtArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurrenderCountry1NtArg} SurrenderCountry1NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCountry1NtArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurrenderCountry1NtArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.TargetCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurrenderCountry1NtArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurrenderCountry1NtArg} SurrenderCountry1NtArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCountry1NtArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurrenderCountry1NtArg message.
         * @function verify
         * @memberof pb.SurrenderCountry1NtArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurrenderCountry1NtArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.TargetCountryName != null && message.hasOwnProperty("TargetCountryName"))
                if (!$util.isString(message.TargetCountryName))
                    return "TargetCountryName: string expected";
            return null;
        };

        return SurrenderCountry1NtArg;
    })();

    pb.AutocephalyNt2Arg = (function() {

        /**
         * Properties of an AutocephalyNt2Arg.
         * @memberof pb
         * @interface IAutocephalyNt2Arg
         * @property {number|null} [CityID] AutocephalyNt2Arg CityID
         * @property {pb.CampaignJob|null} [Job] AutocephalyNt2Arg Job
         * @property {string|null} [PlayerName] AutocephalyNt2Arg PlayerName
         * @property {string|null} [OldCountryName] AutocephalyNt2Arg OldCountryName
         * @property {string|null} [NewCountryName] AutocephalyNt2Arg NewCountryName
         */

        /**
         * Constructs a new AutocephalyNt2Arg.
         * @memberof pb
         * @classdesc Represents an AutocephalyNt2Arg.
         * @implements IAutocephalyNt2Arg
         * @constructor
         * @param {pb.IAutocephalyNt2Arg=} [properties] Properties to set
         */
        function AutocephalyNt2Arg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyNt2Arg CityID.
         * @member {number} CityID
         * @memberof pb.AutocephalyNt2Arg
         * @instance
         */
        AutocephalyNt2Arg.prototype.CityID = 0;

        /**
         * AutocephalyNt2Arg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.AutocephalyNt2Arg
         * @instance
         */
        AutocephalyNt2Arg.prototype.Job = 0;

        /**
         * AutocephalyNt2Arg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.AutocephalyNt2Arg
         * @instance
         */
        AutocephalyNt2Arg.prototype.PlayerName = "";

        /**
         * AutocephalyNt2Arg OldCountryName.
         * @member {string} OldCountryName
         * @memberof pb.AutocephalyNt2Arg
         * @instance
         */
        AutocephalyNt2Arg.prototype.OldCountryName = "";

        /**
         * AutocephalyNt2Arg NewCountryName.
         * @member {string} NewCountryName
         * @memberof pb.AutocephalyNt2Arg
         * @instance
         */
        AutocephalyNt2Arg.prototype.NewCountryName = "";

        /**
         * Creates a new AutocephalyNt2Arg instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {pb.IAutocephalyNt2Arg=} [properties] Properties to set
         * @returns {pb.AutocephalyNt2Arg} AutocephalyNt2Arg instance
         */
        AutocephalyNt2Arg.create = function create(properties) {
            return new AutocephalyNt2Arg(properties);
        };

        /**
         * Encodes the specified AutocephalyNt2Arg message. Does not implicitly {@link pb.AutocephalyNt2Arg.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {pb.IAutocephalyNt2Arg} message AutocephalyNt2Arg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNt2Arg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Job);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.PlayerName);
            if (message.OldCountryName != null && message.hasOwnProperty("OldCountryName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.OldCountryName);
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.NewCountryName);
            return writer;
        };

        /**
         * Encodes the specified AutocephalyNt2Arg message, length delimited. Does not implicitly {@link pb.AutocephalyNt2Arg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {pb.IAutocephalyNt2Arg} message AutocephalyNt2Arg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNt2Arg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyNt2Arg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyNt2Arg} AutocephalyNt2Arg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNt2Arg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyNt2Arg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Job = reader.int32();
                    break;
                case 3:
                    message.PlayerName = reader.string();
                    break;
                case 4:
                    message.OldCountryName = reader.string();
                    break;
                case 5:
                    message.NewCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyNt2Arg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyNt2Arg} AutocephalyNt2Arg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNt2Arg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyNt2Arg message.
         * @function verify
         * @memberof pb.AutocephalyNt2Arg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyNt2Arg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.OldCountryName != null && message.hasOwnProperty("OldCountryName"))
                if (!$util.isString(message.OldCountryName))
                    return "OldCountryName: string expected";
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                if (!$util.isString(message.NewCountryName))
                    return "NewCountryName: string expected";
            return null;
        };

        return AutocephalyNt2Arg;
    })();

    pb.AutocephalyNt3Arg = (function() {

        /**
         * Properties of an AutocephalyNt3Arg.
         * @memberof pb
         * @interface IAutocephalyNt3Arg
         * @property {string|null} [PlayerName] AutocephalyNt3Arg PlayerName
         * @property {number|null} [CityID] AutocephalyNt3Arg CityID
         * @property {string|null} [NewCountryName] AutocephalyNt3Arg NewCountryName
         */

        /**
         * Constructs a new AutocephalyNt3Arg.
         * @memberof pb
         * @classdesc Represents an AutocephalyNt3Arg.
         * @implements IAutocephalyNt3Arg
         * @constructor
         * @param {pb.IAutocephalyNt3Arg=} [properties] Properties to set
         */
        function AutocephalyNt3Arg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyNt3Arg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.AutocephalyNt3Arg
         * @instance
         */
        AutocephalyNt3Arg.prototype.PlayerName = "";

        /**
         * AutocephalyNt3Arg CityID.
         * @member {number} CityID
         * @memberof pb.AutocephalyNt3Arg
         * @instance
         */
        AutocephalyNt3Arg.prototype.CityID = 0;

        /**
         * AutocephalyNt3Arg NewCountryName.
         * @member {string} NewCountryName
         * @memberof pb.AutocephalyNt3Arg
         * @instance
         */
        AutocephalyNt3Arg.prototype.NewCountryName = "";

        /**
         * Creates a new AutocephalyNt3Arg instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {pb.IAutocephalyNt3Arg=} [properties] Properties to set
         * @returns {pb.AutocephalyNt3Arg} AutocephalyNt3Arg instance
         */
        AutocephalyNt3Arg.create = function create(properties) {
            return new AutocephalyNt3Arg(properties);
        };

        /**
         * Encodes the specified AutocephalyNt3Arg message. Does not implicitly {@link pb.AutocephalyNt3Arg.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {pb.IAutocephalyNt3Arg} message AutocephalyNt3Arg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNt3Arg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.PlayerName);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.NewCountryName);
            return writer;
        };

        /**
         * Encodes the specified AutocephalyNt3Arg message, length delimited. Does not implicitly {@link pb.AutocephalyNt3Arg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {pb.IAutocephalyNt3Arg} message AutocephalyNt3Arg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyNt3Arg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyNt3Arg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyNt3Arg} AutocephalyNt3Arg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNt3Arg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyNt3Arg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PlayerName = reader.string();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                case 3:
                    message.NewCountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyNt3Arg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyNt3Arg} AutocephalyNt3Arg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyNt3Arg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyNt3Arg message.
         * @function verify
         * @memberof pb.AutocephalyNt3Arg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyNt3Arg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.NewCountryName != null && message.hasOwnProperty("NewCountryName"))
                if (!$util.isString(message.NewCountryName))
                    return "NewCountryName: string expected";
            return null;
        };

        return AutocephalyNt3Arg;
    })();

    pb.CampaignNotice = (function() {

        /**
         * Properties of a CampaignNotice.
         * @memberof pb
         * @interface ICampaignNotice
         * @property {number|null} [ID] CampaignNotice ID
         * @property {pb.CampaignNoticeType|null} [Type] CampaignNotice Type
         * @property {number|null} [Time] CampaignNotice Time
         * @property {Uint8Array|null} [Args] CampaignNotice Args
         */

        /**
         * Constructs a new CampaignNotice.
         * @memberof pb
         * @classdesc Represents a CampaignNotice.
         * @implements ICampaignNotice
         * @constructor
         * @param {pb.ICampaignNotice=} [properties] Properties to set
         */
        function CampaignNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignNotice ID.
         * @member {number} ID
         * @memberof pb.CampaignNotice
         * @instance
         */
        CampaignNotice.prototype.ID = 0;

        /**
         * CampaignNotice Type.
         * @member {pb.CampaignNoticeType} Type
         * @memberof pb.CampaignNotice
         * @instance
         */
        CampaignNotice.prototype.Type = 0;

        /**
         * CampaignNotice Time.
         * @member {number} Time
         * @memberof pb.CampaignNotice
         * @instance
         */
        CampaignNotice.prototype.Time = 0;

        /**
         * CampaignNotice Args.
         * @member {Uint8Array} Args
         * @memberof pb.CampaignNotice
         * @instance
         */
        CampaignNotice.prototype.Args = $util.newBuffer([]);

        /**
         * Creates a new CampaignNotice instance using the specified properties.
         * @function create
         * @memberof pb.CampaignNotice
         * @static
         * @param {pb.ICampaignNotice=} [properties] Properties to set
         * @returns {pb.CampaignNotice} CampaignNotice instance
         */
        CampaignNotice.create = function create(properties) {
            return new CampaignNotice(properties);
        };

        /**
         * Encodes the specified CampaignNotice message. Does not implicitly {@link pb.CampaignNotice.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignNotice
         * @static
         * @param {pb.ICampaignNotice} message CampaignNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Type);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Time);
            if (message.Args != null && message.hasOwnProperty("Args"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Args);
            return writer;
        };

        /**
         * Encodes the specified CampaignNotice message, length delimited. Does not implicitly {@link pb.CampaignNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignNotice
         * @static
         * @param {pb.ICampaignNotice} message CampaignNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignNotice message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignNotice} CampaignNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Type = reader.int32();
                    break;
                case 3:
                    message.Time = reader.int32();
                    break;
                case 4:
                    message.Args = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignNotice} CampaignNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignNotice message.
         * @function verify
         * @memberof pb.CampaignNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                case 18:
                case 19:
                case 20:
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                case 29:
                    break;
                }
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.Args != null && message.hasOwnProperty("Args"))
                if (!(message.Args && typeof message.Args.length === "number" || $util.isString(message.Args)))
                    return "Args: buffer expected";
            return null;
        };

        return CampaignNotice;
    })();

    pb.CampaignNoticeInfo = (function() {

        /**
         * Properties of a CampaignNoticeInfo.
         * @memberof pb
         * @interface ICampaignNoticeInfo
         * @property {Array.<pb.ICampaignNotice>|null} [Notices] CampaignNoticeInfo Notices
         */

        /**
         * Constructs a new CampaignNoticeInfo.
         * @memberof pb
         * @classdesc Represents a CampaignNoticeInfo.
         * @implements ICampaignNoticeInfo
         * @constructor
         * @param {pb.ICampaignNoticeInfo=} [properties] Properties to set
         */
        function CampaignNoticeInfo(properties) {
            this.Notices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignNoticeInfo Notices.
         * @member {Array.<pb.ICampaignNotice>} Notices
         * @memberof pb.CampaignNoticeInfo
         * @instance
         */
        CampaignNoticeInfo.prototype.Notices = $util.emptyArray;

        /**
         * Creates a new CampaignNoticeInfo instance using the specified properties.
         * @function create
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {pb.ICampaignNoticeInfo=} [properties] Properties to set
         * @returns {pb.CampaignNoticeInfo} CampaignNoticeInfo instance
         */
        CampaignNoticeInfo.create = function create(properties) {
            return new CampaignNoticeInfo(properties);
        };

        /**
         * Encodes the specified CampaignNoticeInfo message. Does not implicitly {@link pb.CampaignNoticeInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {pb.ICampaignNoticeInfo} message CampaignNoticeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNoticeInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Notices != null && message.Notices.length)
                for (var i = 0; i < message.Notices.length; ++i)
                    $root.pb.CampaignNotice.encode(message.Notices[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignNoticeInfo message, length delimited. Does not implicitly {@link pb.CampaignNoticeInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {pb.ICampaignNoticeInfo} message CampaignNoticeInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNoticeInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignNoticeInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignNoticeInfo} CampaignNoticeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNoticeInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignNoticeInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Notices && message.Notices.length))
                        message.Notices = [];
                    message.Notices.push($root.pb.CampaignNotice.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignNoticeInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignNoticeInfo} CampaignNoticeInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNoticeInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignNoticeInfo message.
         * @function verify
         * @memberof pb.CampaignNoticeInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignNoticeInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Notices != null && message.hasOwnProperty("Notices")) {
                if (!Array.isArray(message.Notices))
                    return "Notices: array expected";
                for (var i = 0; i < message.Notices.length; ++i) {
                    var error = $root.pb.CampaignNotice.verify(message.Notices[i]);
                    if (error)
                        return "Notices." + error;
                }
            }
            return null;
        };

        return CampaignNoticeInfo;
    })();

    pb.CityPlayerAmount = (function() {

        /**
         * Properties of a CityPlayerAmount.
         * @memberof pb
         * @interface ICityPlayerAmount
         * @property {number|null} [CityID] CityPlayerAmount CityID
         * @property {number|null} [PlayerAmount] CityPlayerAmount PlayerAmount
         * @property {number|null} [Glory] CityPlayerAmount Glory
         * @property {number|null} [MaxApplyCountryGold] CityPlayerAmount MaxApplyCountryGold
         * @property {number|null} [AvgMissionReward] CityPlayerAmount AvgMissionReward
         */

        /**
         * Constructs a new CityPlayerAmount.
         * @memberof pb
         * @classdesc Represents a CityPlayerAmount.
         * @implements ICityPlayerAmount
         * @constructor
         * @param {pb.ICityPlayerAmount=} [properties] Properties to set
         */
        function CityPlayerAmount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityPlayerAmount CityID.
         * @member {number} CityID
         * @memberof pb.CityPlayerAmount
         * @instance
         */
        CityPlayerAmount.prototype.CityID = 0;

        /**
         * CityPlayerAmount PlayerAmount.
         * @member {number} PlayerAmount
         * @memberof pb.CityPlayerAmount
         * @instance
         */
        CityPlayerAmount.prototype.PlayerAmount = 0;

        /**
         * CityPlayerAmount Glory.
         * @member {number} Glory
         * @memberof pb.CityPlayerAmount
         * @instance
         */
        CityPlayerAmount.prototype.Glory = 0;

        /**
         * CityPlayerAmount MaxApplyCountryGold.
         * @member {number} MaxApplyCountryGold
         * @memberof pb.CityPlayerAmount
         * @instance
         */
        CityPlayerAmount.prototype.MaxApplyCountryGold = 0;

        /**
         * CityPlayerAmount AvgMissionReward.
         * @member {number} AvgMissionReward
         * @memberof pb.CityPlayerAmount
         * @instance
         */
        CityPlayerAmount.prototype.AvgMissionReward = 0;

        /**
         * Creates a new CityPlayerAmount instance using the specified properties.
         * @function create
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {pb.ICityPlayerAmount=} [properties] Properties to set
         * @returns {pb.CityPlayerAmount} CityPlayerAmount instance
         */
        CityPlayerAmount.create = function create(properties) {
            return new CityPlayerAmount(properties);
        };

        /**
         * Encodes the specified CityPlayerAmount message. Does not implicitly {@link pb.CityPlayerAmount.verify|verify} messages.
         * @function encode
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {pb.ICityPlayerAmount} message CityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityPlayerAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PlayerAmount);
            if (message.Glory != null && message.hasOwnProperty("Glory"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Glory);
            if (message.MaxApplyCountryGold != null && message.hasOwnProperty("MaxApplyCountryGold"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.MaxApplyCountryGold);
            if (message.AvgMissionReward != null && message.hasOwnProperty("AvgMissionReward"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.AvgMissionReward);
            return writer;
        };

        /**
         * Encodes the specified CityPlayerAmount message, length delimited. Does not implicitly {@link pb.CityPlayerAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {pb.ICityPlayerAmount} message CityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityPlayerAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityPlayerAmount message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityPlayerAmount} CityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityPlayerAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityPlayerAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.PlayerAmount = reader.int32();
                    break;
                case 3:
                    message.Glory = reader.int32();
                    break;
                case 4:
                    message.MaxApplyCountryGold = reader.int32();
                    break;
                case 5:
                    message.AvgMissionReward = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityPlayerAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityPlayerAmount} CityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityPlayerAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityPlayerAmount message.
         * @function verify
         * @memberof pb.CityPlayerAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityPlayerAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                if (!$util.isInteger(message.PlayerAmount))
                    return "PlayerAmount: integer expected";
            if (message.Glory != null && message.hasOwnProperty("Glory"))
                if (!$util.isInteger(message.Glory))
                    return "Glory: integer expected";
            if (message.MaxApplyCountryGold != null && message.hasOwnProperty("MaxApplyCountryGold"))
                if (!$util.isInteger(message.MaxApplyCountryGold))
                    return "MaxApplyCountryGold: integer expected";
            if (message.AvgMissionReward != null && message.hasOwnProperty("AvgMissionReward"))
                if (!$util.isInteger(message.AvgMissionReward))
                    return "AvgMissionReward: integer expected";
            return null;
        };

        return CityPlayerAmount;
    })();

    pb.AllCityPlayerAmount = (function() {

        /**
         * Properties of an AllCityPlayerAmount.
         * @memberof pb
         * @interface IAllCityPlayerAmount
         * @property {Array.<pb.ICityPlayerAmount>|null} [PlayerAmounts] AllCityPlayerAmount PlayerAmounts
         */

        /**
         * Constructs a new AllCityPlayerAmount.
         * @memberof pb
         * @classdesc Represents an AllCityPlayerAmount.
         * @implements IAllCityPlayerAmount
         * @constructor
         * @param {pb.IAllCityPlayerAmount=} [properties] Properties to set
         */
        function AllCityPlayerAmount(properties) {
            this.PlayerAmounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllCityPlayerAmount PlayerAmounts.
         * @member {Array.<pb.ICityPlayerAmount>} PlayerAmounts
         * @memberof pb.AllCityPlayerAmount
         * @instance
         */
        AllCityPlayerAmount.prototype.PlayerAmounts = $util.emptyArray;

        /**
         * Creates a new AllCityPlayerAmount instance using the specified properties.
         * @function create
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {pb.IAllCityPlayerAmount=} [properties] Properties to set
         * @returns {pb.AllCityPlayerAmount} AllCityPlayerAmount instance
         */
        AllCityPlayerAmount.create = function create(properties) {
            return new AllCityPlayerAmount(properties);
        };

        /**
         * Encodes the specified AllCityPlayerAmount message. Does not implicitly {@link pb.AllCityPlayerAmount.verify|verify} messages.
         * @function encode
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {pb.IAllCityPlayerAmount} message AllCityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllCityPlayerAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PlayerAmounts != null && message.PlayerAmounts.length)
                for (var i = 0; i < message.PlayerAmounts.length; ++i)
                    $root.pb.CityPlayerAmount.encode(message.PlayerAmounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AllCityPlayerAmount message, length delimited. Does not implicitly {@link pb.AllCityPlayerAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {pb.IAllCityPlayerAmount} message AllCityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllCityPlayerAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllCityPlayerAmount message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AllCityPlayerAmount} AllCityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllCityPlayerAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AllCityPlayerAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.PlayerAmounts && message.PlayerAmounts.length))
                        message.PlayerAmounts = [];
                    message.PlayerAmounts.push($root.pb.CityPlayerAmount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllCityPlayerAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AllCityPlayerAmount} AllCityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllCityPlayerAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllCityPlayerAmount message.
         * @function verify
         * @memberof pb.AllCityPlayerAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllCityPlayerAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PlayerAmounts != null && message.hasOwnProperty("PlayerAmounts")) {
                if (!Array.isArray(message.PlayerAmounts))
                    return "PlayerAmounts: array expected";
                for (var i = 0; i < message.PlayerAmounts.length; ++i) {
                    var error = $root.pb.CityPlayerAmount.verify(message.PlayerAmounts[i]);
                    if (error)
                        return "PlayerAmounts." + error;
                }
            }
            return null;
        };

        return AllCityPlayerAmount;
    })();

    pb.FetchCountryPlayersArg = (function() {

        /**
         * Properties of a FetchCountryPlayersArg.
         * @memberof pb
         * @interface IFetchCountryPlayersArg
         * @property {number|null} [CountryID] FetchCountryPlayersArg CountryID
         * @property {number|null} [Page] FetchCountryPlayersArg Page
         */

        /**
         * Constructs a new FetchCountryPlayersArg.
         * @memberof pb
         * @classdesc Represents a FetchCountryPlayersArg.
         * @implements IFetchCountryPlayersArg
         * @constructor
         * @param {pb.IFetchCountryPlayersArg=} [properties] Properties to set
         */
        function FetchCountryPlayersArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchCountryPlayersArg CountryID.
         * @member {number} CountryID
         * @memberof pb.FetchCountryPlayersArg
         * @instance
         */
        FetchCountryPlayersArg.prototype.CountryID = 0;

        /**
         * FetchCountryPlayersArg Page.
         * @member {number} Page
         * @memberof pb.FetchCountryPlayersArg
         * @instance
         */
        FetchCountryPlayersArg.prototype.Page = 0;

        /**
         * Creates a new FetchCountryPlayersArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {pb.IFetchCountryPlayersArg=} [properties] Properties to set
         * @returns {pb.FetchCountryPlayersArg} FetchCountryPlayersArg instance
         */
        FetchCountryPlayersArg.create = function create(properties) {
            return new FetchCountryPlayersArg(properties);
        };

        /**
         * Encodes the specified FetchCountryPlayersArg message. Does not implicitly {@link pb.FetchCountryPlayersArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {pb.IFetchCountryPlayersArg} message FetchCountryPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCountryPlayersArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.Page != null && message.hasOwnProperty("Page"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Page);
            return writer;
        };

        /**
         * Encodes the specified FetchCountryPlayersArg message, length delimited. Does not implicitly {@link pb.FetchCountryPlayersArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {pb.IFetchCountryPlayersArg} message FetchCountryPlayersArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCountryPlayersArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchCountryPlayersArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchCountryPlayersArg} FetchCountryPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCountryPlayersArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchCountryPlayersArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.Page = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchCountryPlayersArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchCountryPlayersArg} FetchCountryPlayersArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCountryPlayersArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchCountryPlayersArg message.
         * @function verify
         * @memberof pb.FetchCountryPlayersArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchCountryPlayersArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.Page != null && message.hasOwnProperty("Page"))
                if (!$util.isInteger(message.Page))
                    return "Page: integer expected";
            return null;
        };

        return FetchCountryPlayersArg;
    })();

    pb.CampaignNotifyRedDotArg = (function() {

        /**
         * Properties of a CampaignNotifyRedDotArg.
         * @memberof pb
         * @interface ICampaignNotifyRedDotArg
         * @property {pb.CampaignNotifyRedDotArg.RedDotType|null} [Type] CampaignNotifyRedDotArg Type
         */

        /**
         * Constructs a new CampaignNotifyRedDotArg.
         * @memberof pb
         * @classdesc Represents a CampaignNotifyRedDotArg.
         * @implements ICampaignNotifyRedDotArg
         * @constructor
         * @param {pb.ICampaignNotifyRedDotArg=} [properties] Properties to set
         */
        function CampaignNotifyRedDotArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignNotifyRedDotArg Type.
         * @member {pb.CampaignNotifyRedDotArg.RedDotType} Type
         * @memberof pb.CampaignNotifyRedDotArg
         * @instance
         */
        CampaignNotifyRedDotArg.prototype.Type = 0;

        /**
         * Creates a new CampaignNotifyRedDotArg instance using the specified properties.
         * @function create
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {pb.ICampaignNotifyRedDotArg=} [properties] Properties to set
         * @returns {pb.CampaignNotifyRedDotArg} CampaignNotifyRedDotArg instance
         */
        CampaignNotifyRedDotArg.create = function create(properties) {
            return new CampaignNotifyRedDotArg(properties);
        };

        /**
         * Encodes the specified CampaignNotifyRedDotArg message. Does not implicitly {@link pb.CampaignNotifyRedDotArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {pb.ICampaignNotifyRedDotArg} message CampaignNotifyRedDotArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNotifyRedDotArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            return writer;
        };

        /**
         * Encodes the specified CampaignNotifyRedDotArg message, length delimited. Does not implicitly {@link pb.CampaignNotifyRedDotArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {pb.ICampaignNotifyRedDotArg} message CampaignNotifyRedDotArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignNotifyRedDotArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignNotifyRedDotArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignNotifyRedDotArg} CampaignNotifyRedDotArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNotifyRedDotArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignNotifyRedDotArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignNotifyRedDotArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignNotifyRedDotArg} CampaignNotifyRedDotArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignNotifyRedDotArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignNotifyRedDotArg message.
         * @function verify
         * @memberof pb.CampaignNotifyRedDotArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignNotifyRedDotArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * RedDotType enum.
         * @name pb.CampaignNotifyRedDotArg.RedDotType
         * @enum {string}
         * @property {number} Misson=0 Misson value
         * @property {number} Notice=1 Notice value
         */
        CampaignNotifyRedDotArg.RedDotType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Misson"] = 0;
            values[valuesById[1] = "Notice"] = 1;
            return values;
        })();

        return CampaignNotifyRedDotArg;
    })();

    pb.AppointJobArg = (function() {

        /**
         * Properties of an AppointJobArg.
         * @memberof pb
         * @interface IAppointJobArg
         * @property {number|Long|null} [Uid] AppointJobArg Uid
         * @property {pb.CampaignJob|null} [Job] AppointJobArg Job
         * @property {number|Long|null} [OldUid] AppointJobArg OldUid
         */

        /**
         * Constructs a new AppointJobArg.
         * @memberof pb
         * @classdesc Represents an AppointJobArg.
         * @implements IAppointJobArg
         * @constructor
         * @param {pb.IAppointJobArg=} [properties] Properties to set
         */
        function AppointJobArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppointJobArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.AppointJobArg
         * @instance
         */
        AppointJobArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * AppointJobArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.AppointJobArg
         * @instance
         */
        AppointJobArg.prototype.Job = 0;

        /**
         * AppointJobArg OldUid.
         * @member {number|Long} OldUid
         * @memberof pb.AppointJobArg
         * @instance
         */
        AppointJobArg.prototype.OldUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new AppointJobArg instance using the specified properties.
         * @function create
         * @memberof pb.AppointJobArg
         * @static
         * @param {pb.IAppointJobArg=} [properties] Properties to set
         * @returns {pb.AppointJobArg} AppointJobArg instance
         */
        AppointJobArg.create = function create(properties) {
            return new AppointJobArg(properties);
        };

        /**
         * Encodes the specified AppointJobArg message. Does not implicitly {@link pb.AppointJobArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AppointJobArg
         * @static
         * @param {pb.IAppointJobArg} message AppointJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppointJobArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Job);
            if (message.OldUid != null && message.hasOwnProperty("OldUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.OldUid);
            return writer;
        };

        /**
         * Encodes the specified AppointJobArg message, length delimited. Does not implicitly {@link pb.AppointJobArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AppointJobArg
         * @static
         * @param {pb.IAppointJobArg} message AppointJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppointJobArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppointJobArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AppointJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AppointJobArg} AppointJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppointJobArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AppointJobArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Job = reader.int32();
                    break;
                case 3:
                    message.OldUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppointJobArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AppointJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AppointJobArg} AppointJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppointJobArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppointJobArg message.
         * @function verify
         * @memberof pb.AppointJobArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppointJobArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.OldUid != null && message.hasOwnProperty("OldUid"))
                if (!$util.isInteger(message.OldUid) && !(message.OldUid && $util.isInteger(message.OldUid.low) && $util.isInteger(message.OldUid.high)))
                    return "OldUid: integer|Long expected";
            return null;
        };

        return AppointJobArg;
    })();

    pb.RecallJobArg = (function() {

        /**
         * Properties of a RecallJobArg.
         * @memberof pb
         * @interface IRecallJobArg
         * @property {number|Long|null} [Uid] RecallJobArg Uid
         * @property {pb.CampaignJob|null} [Job] RecallJobArg Job
         */

        /**
         * Constructs a new RecallJobArg.
         * @memberof pb
         * @classdesc Represents a RecallJobArg.
         * @implements IRecallJobArg
         * @constructor
         * @param {pb.IRecallJobArg=} [properties] Properties to set
         */
        function RecallJobArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RecallJobArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.RecallJobArg
         * @instance
         */
        RecallJobArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RecallJobArg Job.
         * @member {pb.CampaignJob} Job
         * @memberof pb.RecallJobArg
         * @instance
         */
        RecallJobArg.prototype.Job = 0;

        /**
         * Creates a new RecallJobArg instance using the specified properties.
         * @function create
         * @memberof pb.RecallJobArg
         * @static
         * @param {pb.IRecallJobArg=} [properties] Properties to set
         * @returns {pb.RecallJobArg} RecallJobArg instance
         */
        RecallJobArg.create = function create(properties) {
            return new RecallJobArg(properties);
        };

        /**
         * Encodes the specified RecallJobArg message. Does not implicitly {@link pb.RecallJobArg.verify|verify} messages.
         * @function encode
         * @memberof pb.RecallJobArg
         * @static
         * @param {pb.IRecallJobArg} message RecallJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallJobArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Job != null && message.hasOwnProperty("Job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Job);
            return writer;
        };

        /**
         * Encodes the specified RecallJobArg message, length delimited. Does not implicitly {@link pb.RecallJobArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RecallJobArg
         * @static
         * @param {pb.IRecallJobArg} message RecallJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RecallJobArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RecallJobArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RecallJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RecallJobArg} RecallJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallJobArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RecallJobArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Job = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RecallJobArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RecallJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RecallJobArg} RecallJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RecallJobArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RecallJobArg message.
         * @function verify
         * @memberof pb.RecallJobArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RecallJobArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Job != null && message.hasOwnProperty("Job"))
                switch (message.Job) {
                default:
                    return "Job: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        return RecallJobArg;
    })();

    pb.CityDefense = (function() {

        /**
         * Properties of a CityDefense.
         * @memberof pb
         * @interface ICityDefense
         * @property {number|null} [CityID] CityDefense CityID
         * @property {number|null} [Defense] CityDefense Defense
         */

        /**
         * Constructs a new CityDefense.
         * @memberof pb
         * @classdesc Represents a CityDefense.
         * @implements ICityDefense
         * @constructor
         * @param {pb.ICityDefense=} [properties] Properties to set
         */
        function CityDefense(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityDefense CityID.
         * @member {number} CityID
         * @memberof pb.CityDefense
         * @instance
         */
        CityDefense.prototype.CityID = 0;

        /**
         * CityDefense Defense.
         * @member {number} Defense
         * @memberof pb.CityDefense
         * @instance
         */
        CityDefense.prototype.Defense = 0;

        /**
         * Creates a new CityDefense instance using the specified properties.
         * @function create
         * @memberof pb.CityDefense
         * @static
         * @param {pb.ICityDefense=} [properties] Properties to set
         * @returns {pb.CityDefense} CityDefense instance
         */
        CityDefense.create = function create(properties) {
            return new CityDefense(properties);
        };

        /**
         * Encodes the specified CityDefense message. Does not implicitly {@link pb.CityDefense.verify|verify} messages.
         * @function encode
         * @memberof pb.CityDefense
         * @static
         * @param {pb.ICityDefense} message CityDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityDefense.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Defense);
            return writer;
        };

        /**
         * Encodes the specified CityDefense message, length delimited. Does not implicitly {@link pb.CityDefense.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityDefense
         * @static
         * @param {pb.ICityDefense} message CityDefense message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityDefense.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityDefense message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityDefense} CityDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityDefense.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityDefense();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Defense = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityDefense message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityDefense
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityDefense} CityDefense
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityDefense.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityDefense message.
         * @function verify
         * @memberof pb.CityDefense
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityDefense.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Defense != null && message.hasOwnProperty("Defense"))
                if (!$util.isInteger(message.Defense))
                    return "Defense: integer expected";
            return null;
        };

        return CityDefense;
    })();

    pb.SyncCityDefenseArg = (function() {

        /**
         * Properties of a SyncCityDefenseArg.
         * @memberof pb
         * @interface ISyncCityDefenseArg
         * @property {Array.<pb.ICityDefense>|null} [CityDefenses] SyncCityDefenseArg CityDefenses
         */

        /**
         * Constructs a new SyncCityDefenseArg.
         * @memberof pb
         * @classdesc Represents a SyncCityDefenseArg.
         * @implements ISyncCityDefenseArg
         * @constructor
         * @param {pb.ISyncCityDefenseArg=} [properties] Properties to set
         */
        function SyncCityDefenseArg(properties) {
            this.CityDefenses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncCityDefenseArg CityDefenses.
         * @member {Array.<pb.ICityDefense>} CityDefenses
         * @memberof pb.SyncCityDefenseArg
         * @instance
         */
        SyncCityDefenseArg.prototype.CityDefenses = $util.emptyArray;

        /**
         * Creates a new SyncCityDefenseArg instance using the specified properties.
         * @function create
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {pb.ISyncCityDefenseArg=} [properties] Properties to set
         * @returns {pb.SyncCityDefenseArg} SyncCityDefenseArg instance
         */
        SyncCityDefenseArg.create = function create(properties) {
            return new SyncCityDefenseArg(properties);
        };

        /**
         * Encodes the specified SyncCityDefenseArg message. Does not implicitly {@link pb.SyncCityDefenseArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {pb.ISyncCityDefenseArg} message SyncCityDefenseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCityDefenseArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityDefenses != null && message.CityDefenses.length)
                for (var i = 0; i < message.CityDefenses.length; ++i)
                    $root.pb.CityDefense.encode(message.CityDefenses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SyncCityDefenseArg message, length delimited. Does not implicitly {@link pb.SyncCityDefenseArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {pb.ISyncCityDefenseArg} message SyncCityDefenseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCityDefenseArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncCityDefenseArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SyncCityDefenseArg} SyncCityDefenseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCityDefenseArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SyncCityDefenseArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CityDefenses && message.CityDefenses.length))
                        message.CityDefenses = [];
                    message.CityDefenses.push($root.pb.CityDefense.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncCityDefenseArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SyncCityDefenseArg} SyncCityDefenseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCityDefenseArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncCityDefenseArg message.
         * @function verify
         * @memberof pb.SyncCityDefenseArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncCityDefenseArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityDefenses != null && message.hasOwnProperty("CityDefenses")) {
                if (!Array.isArray(message.CityDefenses))
                    return "CityDefenses: array expected";
                for (var i = 0; i < message.CityDefenses.length; ++i) {
                    var error = $root.pb.CityDefense.verify(message.CityDefenses[i]);
                    if (error)
                        return "CityDefenses." + error;
                }
            }
            return null;
        };

        return SyncCityDefenseArg;
    })();

    pb.CampaignUpdateJobArg = (function() {

        /**
         * Properties of a CampaignUpdateJobArg.
         * @memberof pb
         * @interface ICampaignUpdateJobArg
         * @property {pb.CampaignJob|null} [CityJob] CampaignUpdateJobArg CityJob
         * @property {pb.CampaignJob|null} [CountryJob] CampaignUpdateJobArg CountryJob
         */

        /**
         * Constructs a new CampaignUpdateJobArg.
         * @memberof pb
         * @classdesc Represents a CampaignUpdateJobArg.
         * @implements ICampaignUpdateJobArg
         * @constructor
         * @param {pb.ICampaignUpdateJobArg=} [properties] Properties to set
         */
        function CampaignUpdateJobArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignUpdateJobArg CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.CampaignUpdateJobArg
         * @instance
         */
        CampaignUpdateJobArg.prototype.CityJob = 0;

        /**
         * CampaignUpdateJobArg CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.CampaignUpdateJobArg
         * @instance
         */
        CampaignUpdateJobArg.prototype.CountryJob = 0;

        /**
         * Creates a new CampaignUpdateJobArg instance using the specified properties.
         * @function create
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {pb.ICampaignUpdateJobArg=} [properties] Properties to set
         * @returns {pb.CampaignUpdateJobArg} CampaignUpdateJobArg instance
         */
        CampaignUpdateJobArg.create = function create(properties) {
            return new CampaignUpdateJobArg(properties);
        };

        /**
         * Encodes the specified CampaignUpdateJobArg message. Does not implicitly {@link pb.CampaignUpdateJobArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {pb.ICampaignUpdateJobArg} message CampaignUpdateJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignUpdateJobArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CountryJob);
            return writer;
        };

        /**
         * Encodes the specified CampaignUpdateJobArg message, length delimited. Does not implicitly {@link pb.CampaignUpdateJobArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {pb.ICampaignUpdateJobArg} message CampaignUpdateJobArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignUpdateJobArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignUpdateJobArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignUpdateJobArg} CampaignUpdateJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignUpdateJobArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignUpdateJobArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityJob = reader.int32();
                    break;
                case 2:
                    message.CountryJob = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignUpdateJobArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignUpdateJobArg} CampaignUpdateJobArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignUpdateJobArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignUpdateJobArg message.
         * @function verify
         * @memberof pb.CampaignUpdateJobArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignUpdateJobArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        return CampaignUpdateJobArg;
    })();

    pb.PatrolCityReply = (function() {

        /**
         * Properties of a PatrolCityReply.
         * @memberof pb
         * @interface IPatrolCityReply
         * @property {number|null} [Contribution] PatrolCityReply Contribution
         * @property {number|null} [Salary] PatrolCityReply Salary
         */

        /**
         * Constructs a new PatrolCityReply.
         * @memberof pb
         * @classdesc Represents a PatrolCityReply.
         * @implements IPatrolCityReply
         * @constructor
         * @param {pb.IPatrolCityReply=} [properties] Properties to set
         */
        function PatrolCityReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PatrolCityReply Contribution.
         * @member {number} Contribution
         * @memberof pb.PatrolCityReply
         * @instance
         */
        PatrolCityReply.prototype.Contribution = 0;

        /**
         * PatrolCityReply Salary.
         * @member {number} Salary
         * @memberof pb.PatrolCityReply
         * @instance
         */
        PatrolCityReply.prototype.Salary = 0;

        /**
         * Creates a new PatrolCityReply instance using the specified properties.
         * @function create
         * @memberof pb.PatrolCityReply
         * @static
         * @param {pb.IPatrolCityReply=} [properties] Properties to set
         * @returns {pb.PatrolCityReply} PatrolCityReply instance
         */
        PatrolCityReply.create = function create(properties) {
            return new PatrolCityReply(properties);
        };

        /**
         * Encodes the specified PatrolCityReply message. Does not implicitly {@link pb.PatrolCityReply.verify|verify} messages.
         * @function encode
         * @memberof pb.PatrolCityReply
         * @static
         * @param {pb.IPatrolCityReply} message PatrolCityReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatrolCityReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Contribution);
            if (message.Salary != null && message.hasOwnProperty("Salary"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Salary);
            return writer;
        };

        /**
         * Encodes the specified PatrolCityReply message, length delimited. Does not implicitly {@link pb.PatrolCityReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PatrolCityReply
         * @static
         * @param {pb.IPatrolCityReply} message PatrolCityReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PatrolCityReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PatrolCityReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PatrolCityReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PatrolCityReply} PatrolCityReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatrolCityReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PatrolCityReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Contribution = reader.int32();
                    break;
                case 2:
                    message.Salary = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PatrolCityReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PatrolCityReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PatrolCityReply} PatrolCityReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PatrolCityReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PatrolCityReply message.
         * @function verify
         * @memberof pb.PatrolCityReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PatrolCityReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.Salary != null && message.hasOwnProperty("Salary"))
                if (!$util.isInteger(message.Salary))
                    return "Salary: integer expected";
            return null;
        };

        return PatrolCityReply;
    })();

    pb.CityCapitalInjectionArg = (function() {

        /**
         * Properties of a CityCapitalInjectionArg.
         * @memberof pb
         * @interface ICityCapitalInjectionArg
         * @property {number|null} [CityID] CityCapitalInjectionArg CityID
         * @property {number|null} [Gold] CityCapitalInjectionArg Gold
         */

        /**
         * Constructs a new CityCapitalInjectionArg.
         * @memberof pb
         * @classdesc Represents a CityCapitalInjectionArg.
         * @implements ICityCapitalInjectionArg
         * @constructor
         * @param {pb.ICityCapitalInjectionArg=} [properties] Properties to set
         */
        function CityCapitalInjectionArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityCapitalInjectionArg CityID.
         * @member {number} CityID
         * @memberof pb.CityCapitalInjectionArg
         * @instance
         */
        CityCapitalInjectionArg.prototype.CityID = 0;

        /**
         * CityCapitalInjectionArg Gold.
         * @member {number} Gold
         * @memberof pb.CityCapitalInjectionArg
         * @instance
         */
        CityCapitalInjectionArg.prototype.Gold = 0;

        /**
         * Creates a new CityCapitalInjectionArg instance using the specified properties.
         * @function create
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {pb.ICityCapitalInjectionArg=} [properties] Properties to set
         * @returns {pb.CityCapitalInjectionArg} CityCapitalInjectionArg instance
         */
        CityCapitalInjectionArg.create = function create(properties) {
            return new CityCapitalInjectionArg(properties);
        };

        /**
         * Encodes the specified CityCapitalInjectionArg message. Does not implicitly {@link pb.CityCapitalInjectionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {pb.ICityCapitalInjectionArg} message CityCapitalInjectionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified CityCapitalInjectionArg message, length delimited. Does not implicitly {@link pb.CityCapitalInjectionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {pb.ICityCapitalInjectionArg} message CityCapitalInjectionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityCapitalInjectionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityCapitalInjectionArg} CityCapitalInjectionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityCapitalInjectionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityCapitalInjectionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityCapitalInjectionArg} CityCapitalInjectionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityCapitalInjectionArg message.
         * @function verify
         * @memberof pb.CityCapitalInjectionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityCapitalInjectionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return CityCapitalInjectionArg;
    })();

    pb.CityCapitalInjectionReply = (function() {

        /**
         * Properties of a CityCapitalInjectionReply.
         * @memberof pb
         * @interface ICityCapitalInjectionReply
         * @property {number|null} [CurGold] CityCapitalInjectionReply CurGold
         */

        /**
         * Constructs a new CityCapitalInjectionReply.
         * @memberof pb
         * @classdesc Represents a CityCapitalInjectionReply.
         * @implements ICityCapitalInjectionReply
         * @constructor
         * @param {pb.ICityCapitalInjectionReply=} [properties] Properties to set
         */
        function CityCapitalInjectionReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityCapitalInjectionReply CurGold.
         * @member {number} CurGold
         * @memberof pb.CityCapitalInjectionReply
         * @instance
         */
        CityCapitalInjectionReply.prototype.CurGold = 0;

        /**
         * Creates a new CityCapitalInjectionReply instance using the specified properties.
         * @function create
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {pb.ICityCapitalInjectionReply=} [properties] Properties to set
         * @returns {pb.CityCapitalInjectionReply} CityCapitalInjectionReply instance
         */
        CityCapitalInjectionReply.create = function create(properties) {
            return new CityCapitalInjectionReply(properties);
        };

        /**
         * Encodes the specified CityCapitalInjectionReply message. Does not implicitly {@link pb.CityCapitalInjectionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {pb.ICityCapitalInjectionReply} message CityCapitalInjectionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CurGold != null && message.hasOwnProperty("CurGold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurGold);
            return writer;
        };

        /**
         * Encodes the specified CityCapitalInjectionReply message, length delimited. Does not implicitly {@link pb.CityCapitalInjectionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {pb.ICityCapitalInjectionReply} message CityCapitalInjectionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityCapitalInjectionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityCapitalInjectionReply} CityCapitalInjectionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityCapitalInjectionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CurGold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityCapitalInjectionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityCapitalInjectionReply} CityCapitalInjectionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityCapitalInjectionReply message.
         * @function verify
         * @memberof pb.CityCapitalInjectionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityCapitalInjectionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CurGold != null && message.hasOwnProperty("CurGold"))
                if (!$util.isInteger(message.CurGold))
                    return "CurGold: integer expected";
            return null;
        };

        return CityCapitalInjectionReply;
    })();

    pb.UpdateMyCityArg = (function() {

        /**
         * Properties of an UpdateMyCityArg.
         * @memberof pb
         * @interface IUpdateMyCityArg
         * @property {number|null} [CityID] UpdateMyCityArg CityID
         * @property {number|null} [LocationCityID] UpdateMyCityArg LocationCityID
         */

        /**
         * Constructs a new UpdateMyCityArg.
         * @memberof pb
         * @classdesc Represents an UpdateMyCityArg.
         * @implements IUpdateMyCityArg
         * @constructor
         * @param {pb.IUpdateMyCityArg=} [properties] Properties to set
         */
        function UpdateMyCityArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMyCityArg CityID.
         * @member {number} CityID
         * @memberof pb.UpdateMyCityArg
         * @instance
         */
        UpdateMyCityArg.prototype.CityID = 0;

        /**
         * UpdateMyCityArg LocationCityID.
         * @member {number} LocationCityID
         * @memberof pb.UpdateMyCityArg
         * @instance
         */
        UpdateMyCityArg.prototype.LocationCityID = 0;

        /**
         * Creates a new UpdateMyCityArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {pb.IUpdateMyCityArg=} [properties] Properties to set
         * @returns {pb.UpdateMyCityArg} UpdateMyCityArg instance
         */
        UpdateMyCityArg.create = function create(properties) {
            return new UpdateMyCityArg(properties);
        };

        /**
         * Encodes the specified UpdateMyCityArg message. Does not implicitly {@link pb.UpdateMyCityArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {pb.IUpdateMyCityArg} message UpdateMyCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyCityArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.LocationCityID != null && message.hasOwnProperty("LocationCityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LocationCityID);
            return writer;
        };

        /**
         * Encodes the specified UpdateMyCityArg message, length delimited. Does not implicitly {@link pb.UpdateMyCityArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {pb.IUpdateMyCityArg} message UpdateMyCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyCityArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMyCityArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateMyCityArg} UpdateMyCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyCityArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateMyCityArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.LocationCityID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMyCityArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateMyCityArg} UpdateMyCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyCityArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMyCityArg message.
         * @function verify
         * @memberof pb.UpdateMyCityArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMyCityArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.LocationCityID != null && message.hasOwnProperty("LocationCityID"))
                if (!$util.isInteger(message.LocationCityID))
                    return "LocationCityID: integer expected";
            return null;
        };

        return UpdateMyCityArg;
    })();

    pb.CampaignTargetPlayer = (function() {

        /**
         * Properties of a CampaignTargetPlayer.
         * @memberof pb
         * @interface ICampaignTargetPlayer
         * @property {number|Long|null} [Uid] CampaignTargetPlayer Uid
         */

        /**
         * Constructs a new CampaignTargetPlayer.
         * @memberof pb
         * @classdesc Represents a CampaignTargetPlayer.
         * @implements ICampaignTargetPlayer
         * @constructor
         * @param {pb.ICampaignTargetPlayer=} [properties] Properties to set
         */
        function CampaignTargetPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignTargetPlayer Uid.
         * @member {number|Long} Uid
         * @memberof pb.CampaignTargetPlayer
         * @instance
         */
        CampaignTargetPlayer.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new CampaignTargetPlayer instance using the specified properties.
         * @function create
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {pb.ICampaignTargetPlayer=} [properties] Properties to set
         * @returns {pb.CampaignTargetPlayer} CampaignTargetPlayer instance
         */
        CampaignTargetPlayer.create = function create(properties) {
            return new CampaignTargetPlayer(properties);
        };

        /**
         * Encodes the specified CampaignTargetPlayer message. Does not implicitly {@link pb.CampaignTargetPlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {pb.ICampaignTargetPlayer} message CampaignTargetPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignTargetPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified CampaignTargetPlayer message, length delimited. Does not implicitly {@link pb.CampaignTargetPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {pb.ICampaignTargetPlayer} message CampaignTargetPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignTargetPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignTargetPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignTargetPlayer} CampaignTargetPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignTargetPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignTargetPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignTargetPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignTargetPlayer} CampaignTargetPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignTargetPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignTargetPlayer message.
         * @function verify
         * @memberof pb.CampaignTargetPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignTargetPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return CampaignTargetPlayer;
    })();

    pb.UpdateMyCountryArg = (function() {

        /**
         * Properties of an UpdateMyCountryArg.
         * @memberof pb
         * @interface IUpdateMyCountryArg
         * @property {number|null} [CountryID] UpdateMyCountryArg CountryID
         * @property {number|null} [LastCountryID] UpdateMyCountryArg LastCountryID
         */

        /**
         * Constructs a new UpdateMyCountryArg.
         * @memberof pb
         * @classdesc Represents an UpdateMyCountryArg.
         * @implements IUpdateMyCountryArg
         * @constructor
         * @param {pb.IUpdateMyCountryArg=} [properties] Properties to set
         */
        function UpdateMyCountryArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMyCountryArg CountryID.
         * @member {number} CountryID
         * @memberof pb.UpdateMyCountryArg
         * @instance
         */
        UpdateMyCountryArg.prototype.CountryID = 0;

        /**
         * UpdateMyCountryArg LastCountryID.
         * @member {number} LastCountryID
         * @memberof pb.UpdateMyCountryArg
         * @instance
         */
        UpdateMyCountryArg.prototype.LastCountryID = 0;

        /**
         * Creates a new UpdateMyCountryArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {pb.IUpdateMyCountryArg=} [properties] Properties to set
         * @returns {pb.UpdateMyCountryArg} UpdateMyCountryArg instance
         */
        UpdateMyCountryArg.create = function create(properties) {
            return new UpdateMyCountryArg(properties);
        };

        /**
         * Encodes the specified UpdateMyCountryArg message. Does not implicitly {@link pb.UpdateMyCountryArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {pb.IUpdateMyCountryArg} message UpdateMyCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyCountryArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.LastCountryID != null && message.hasOwnProperty("LastCountryID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.LastCountryID);
            return writer;
        };

        /**
         * Encodes the specified UpdateMyCountryArg message, length delimited. Does not implicitly {@link pb.UpdateMyCountryArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {pb.IUpdateMyCountryArg} message UpdateMyCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMyCountryArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMyCountryArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateMyCountryArg} UpdateMyCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyCountryArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateMyCountryArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.LastCountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMyCountryArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateMyCountryArg} UpdateMyCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMyCountryArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMyCountryArg message.
         * @function verify
         * @memberof pb.UpdateMyCountryArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMyCountryArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.LastCountryID != null && message.hasOwnProperty("LastCountryID"))
                if (!$util.isInteger(message.LastCountryID))
                    return "LastCountryID: integer expected";
            return null;
        };

        return UpdateMyCountryArg;
    })();

    pb.AutocephalyInfo = (function() {

        /**
         * Properties of an AutocephalyInfo.
         * @memberof pb
         * @interface IAutocephalyInfo
         * @property {string|null} [CountryName] AutocephalyInfo CountryName
         * @property {Array.<pb.ICampaignPlayer>|null} [AgreePlayers] AutocephalyInfo AgreePlayers
         */

        /**
         * Constructs a new AutocephalyInfo.
         * @memberof pb
         * @classdesc Represents an AutocephalyInfo.
         * @implements IAutocephalyInfo
         * @constructor
         * @param {pb.IAutocephalyInfo=} [properties] Properties to set
         */
        function AutocephalyInfo(properties) {
            this.AgreePlayers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyInfo CountryName.
         * @member {string} CountryName
         * @memberof pb.AutocephalyInfo
         * @instance
         */
        AutocephalyInfo.prototype.CountryName = "";

        /**
         * AutocephalyInfo AgreePlayers.
         * @member {Array.<pb.ICampaignPlayer>} AgreePlayers
         * @memberof pb.AutocephalyInfo
         * @instance
         */
        AutocephalyInfo.prototype.AgreePlayers = $util.emptyArray;

        /**
         * Creates a new AutocephalyInfo instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {pb.IAutocephalyInfo=} [properties] Properties to set
         * @returns {pb.AutocephalyInfo} AutocephalyInfo instance
         */
        AutocephalyInfo.create = function create(properties) {
            return new AutocephalyInfo(properties);
        };

        /**
         * Encodes the specified AutocephalyInfo message. Does not implicitly {@link pb.AutocephalyInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {pb.IAutocephalyInfo} message AutocephalyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.CountryName);
            if (message.AgreePlayers != null && message.AgreePlayers.length)
                for (var i = 0; i < message.AgreePlayers.length; ++i)
                    $root.pb.CampaignPlayer.encode(message.AgreePlayers[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AutocephalyInfo message, length delimited. Does not implicitly {@link pb.AutocephalyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {pb.IAutocephalyInfo} message AutocephalyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyInfo} AutocephalyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryName = reader.string();
                    break;
                case 2:
                    if (!(message.AgreePlayers && message.AgreePlayers.length))
                        message.AgreePlayers = [];
                    message.AgreePlayers.push($root.pb.CampaignPlayer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyInfo} AutocephalyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyInfo message.
         * @function verify
         * @memberof pb.AutocephalyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.AgreePlayers != null && message.hasOwnProperty("AgreePlayers")) {
                if (!Array.isArray(message.AgreePlayers))
                    return "AgreePlayers: array expected";
                for (var i = 0; i < message.AgreePlayers.length; ++i) {
                    var error = $root.pb.CampaignPlayer.verify(message.AgreePlayers[i]);
                    if (error)
                        return "AgreePlayers." + error;
                }
            }
            return null;
        };

        return AutocephalyInfo;
    })();

    pb.AutocephalyArg = (function() {

        /**
         * Properties of an AutocephalyArg.
         * @memberof pb
         * @interface IAutocephalyArg
         * @property {string|null} [CountryName] AutocephalyArg CountryName
         */

        /**
         * Constructs a new AutocephalyArg.
         * @memberof pb
         * @classdesc Represents an AutocephalyArg.
         * @implements IAutocephalyArg
         * @constructor
         * @param {pb.IAutocephalyArg=} [properties] Properties to set
         */
        function AutocephalyArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AutocephalyArg CountryName.
         * @member {string} CountryName
         * @memberof pb.AutocephalyArg
         * @instance
         */
        AutocephalyArg.prototype.CountryName = "";

        /**
         * Creates a new AutocephalyArg instance using the specified properties.
         * @function create
         * @memberof pb.AutocephalyArg
         * @static
         * @param {pb.IAutocephalyArg=} [properties] Properties to set
         * @returns {pb.AutocephalyArg} AutocephalyArg instance
         */
        AutocephalyArg.create = function create(properties) {
            return new AutocephalyArg(properties);
        };

        /**
         * Encodes the specified AutocephalyArg message. Does not implicitly {@link pb.AutocephalyArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AutocephalyArg
         * @static
         * @param {pb.IAutocephalyArg} message AutocephalyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.CountryName);
            return writer;
        };

        /**
         * Encodes the specified AutocephalyArg message, length delimited. Does not implicitly {@link pb.AutocephalyArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AutocephalyArg
         * @static
         * @param {pb.IAutocephalyArg} message AutocephalyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AutocephalyArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AutocephalyArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AutocephalyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AutocephalyArg} AutocephalyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AutocephalyArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AutocephalyArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AutocephalyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AutocephalyArg} AutocephalyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AutocephalyArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AutocephalyArg message.
         * @function verify
         * @memberof pb.AutocephalyArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AutocephalyArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            return null;
        };

        return AutocephalyArg;
    })();

    pb.VoteAutocephalyArg = (function() {

        /**
         * Properties of a VoteAutocephalyArg.
         * @memberof pb
         * @interface IVoteAutocephalyArg
         * @property {boolean|null} [IsAgree] VoteAutocephalyArg IsAgree
         * @property {number|null} [NoticeID] VoteAutocephalyArg NoticeID
         */

        /**
         * Constructs a new VoteAutocephalyArg.
         * @memberof pb
         * @classdesc Represents a VoteAutocephalyArg.
         * @implements IVoteAutocephalyArg
         * @constructor
         * @param {pb.IVoteAutocephalyArg=} [properties] Properties to set
         */
        function VoteAutocephalyArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VoteAutocephalyArg IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.VoteAutocephalyArg
         * @instance
         */
        VoteAutocephalyArg.prototype.IsAgree = false;

        /**
         * VoteAutocephalyArg NoticeID.
         * @member {number} NoticeID
         * @memberof pb.VoteAutocephalyArg
         * @instance
         */
        VoteAutocephalyArg.prototype.NoticeID = 0;

        /**
         * Creates a new VoteAutocephalyArg instance using the specified properties.
         * @function create
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {pb.IVoteAutocephalyArg=} [properties] Properties to set
         * @returns {pb.VoteAutocephalyArg} VoteAutocephalyArg instance
         */
        VoteAutocephalyArg.create = function create(properties) {
            return new VoteAutocephalyArg(properties);
        };

        /**
         * Encodes the specified VoteAutocephalyArg message. Does not implicitly {@link pb.VoteAutocephalyArg.verify|verify} messages.
         * @function encode
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {pb.IVoteAutocephalyArg} message VoteAutocephalyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAutocephalyArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsAgree);
            if (message.NoticeID != null && message.hasOwnProperty("NoticeID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NoticeID);
            return writer;
        };

        /**
         * Encodes the specified VoteAutocephalyArg message, length delimited. Does not implicitly {@link pb.VoteAutocephalyArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {pb.IVoteAutocephalyArg} message VoteAutocephalyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VoteAutocephalyArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VoteAutocephalyArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VoteAutocephalyArg} VoteAutocephalyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAutocephalyArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VoteAutocephalyArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsAgree = reader.bool();
                    break;
                case 2:
                    message.NoticeID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VoteAutocephalyArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VoteAutocephalyArg} VoteAutocephalyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VoteAutocephalyArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VoteAutocephalyArg message.
         * @function verify
         * @memberof pb.VoteAutocephalyArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VoteAutocephalyArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            if (message.NoticeID != null && message.hasOwnProperty("NoticeID"))
                if (!$util.isInteger(message.NoticeID))
                    return "NoticeID: integer expected";
            return null;
        };

        return VoteAutocephalyArg;
    })();

    pb.AccDefCityLoseLoadingReply = (function() {

        /**
         * Properties of an AccDefCityLoseLoadingReply.
         * @memberof pb
         * @interface IAccDefCityLoseLoadingReply
         * @property {number|null} [RemainTime] AccDefCityLoseLoadingReply RemainTime
         */

        /**
         * Constructs a new AccDefCityLoseLoadingReply.
         * @memberof pb
         * @classdesc Represents an AccDefCityLoseLoadingReply.
         * @implements IAccDefCityLoseLoadingReply
         * @constructor
         * @param {pb.IAccDefCityLoseLoadingReply=} [properties] Properties to set
         */
        function AccDefCityLoseLoadingReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccDefCityLoseLoadingReply RemainTime.
         * @member {number} RemainTime
         * @memberof pb.AccDefCityLoseLoadingReply
         * @instance
         */
        AccDefCityLoseLoadingReply.prototype.RemainTime = 0;

        /**
         * Creates a new AccDefCityLoseLoadingReply instance using the specified properties.
         * @function create
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {pb.IAccDefCityLoseLoadingReply=} [properties] Properties to set
         * @returns {pb.AccDefCityLoseLoadingReply} AccDefCityLoseLoadingReply instance
         */
        AccDefCityLoseLoadingReply.create = function create(properties) {
            return new AccDefCityLoseLoadingReply(properties);
        };

        /**
         * Encodes the specified AccDefCityLoseLoadingReply message. Does not implicitly {@link pb.AccDefCityLoseLoadingReply.verify|verify} messages.
         * @function encode
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {pb.IAccDefCityLoseLoadingReply} message AccDefCityLoseLoadingReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccDefCityLoseLoadingReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified AccDefCityLoseLoadingReply message, length delimited. Does not implicitly {@link pb.AccDefCityLoseLoadingReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {pb.IAccDefCityLoseLoadingReply} message AccDefCityLoseLoadingReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccDefCityLoseLoadingReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccDefCityLoseLoadingReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AccDefCityLoseLoadingReply} AccDefCityLoseLoadingReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccDefCityLoseLoadingReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AccDefCityLoseLoadingReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccDefCityLoseLoadingReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AccDefCityLoseLoadingReply} AccDefCityLoseLoadingReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccDefCityLoseLoadingReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccDefCityLoseLoadingReply message.
         * @function verify
         * @memberof pb.AccDefCityLoseLoadingReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccDefCityLoseLoadingReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return AccDefCityLoseLoadingReply;
    })();

    pb.CountryModifyNameArg = (function() {

        /**
         * Properties of a CountryModifyNameArg.
         * @memberof pb
         * @interface ICountryModifyNameArg
         * @property {string|null} [Name] CountryModifyNameArg Name
         */

        /**
         * Constructs a new CountryModifyNameArg.
         * @memberof pb
         * @classdesc Represents a CountryModifyNameArg.
         * @implements ICountryModifyNameArg
         * @constructor
         * @param {pb.ICountryModifyNameArg=} [properties] Properties to set
         */
        function CountryModifyNameArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CountryModifyNameArg Name.
         * @member {string} Name
         * @memberof pb.CountryModifyNameArg
         * @instance
         */
        CountryModifyNameArg.prototype.Name = "";

        /**
         * Creates a new CountryModifyNameArg instance using the specified properties.
         * @function create
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {pb.ICountryModifyNameArg=} [properties] Properties to set
         * @returns {pb.CountryModifyNameArg} CountryModifyNameArg instance
         */
        CountryModifyNameArg.create = function create(properties) {
            return new CountryModifyNameArg(properties);
        };

        /**
         * Encodes the specified CountryModifyNameArg message. Does not implicitly {@link pb.CountryModifyNameArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {pb.ICountryModifyNameArg} message CountryModifyNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryModifyNameArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified CountryModifyNameArg message, length delimited. Does not implicitly {@link pb.CountryModifyNameArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {pb.ICountryModifyNameArg} message CountryModifyNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryModifyNameArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CountryModifyNameArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CountryModifyNameArg} CountryModifyNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryModifyNameArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CountryModifyNameArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CountryModifyNameArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CountryModifyNameArg} CountryModifyNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryModifyNameArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CountryModifyNameArg message.
         * @function verify
         * @memberof pb.CountryModifyNameArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CountryModifyNameArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return CountryModifyNameArg;
    })();

    pb.CountryModifyFlagArg = (function() {

        /**
         * Properties of a CountryModifyFlagArg.
         * @memberof pb
         * @interface ICountryModifyFlagArg
         * @property {string|null} [Flag] CountryModifyFlagArg Flag
         */

        /**
         * Constructs a new CountryModifyFlagArg.
         * @memberof pb
         * @classdesc Represents a CountryModifyFlagArg.
         * @implements ICountryModifyFlagArg
         * @constructor
         * @param {pb.ICountryModifyFlagArg=} [properties] Properties to set
         */
        function CountryModifyFlagArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CountryModifyFlagArg Flag.
         * @member {string} Flag
         * @memberof pb.CountryModifyFlagArg
         * @instance
         */
        CountryModifyFlagArg.prototype.Flag = "";

        /**
         * Creates a new CountryModifyFlagArg instance using the specified properties.
         * @function create
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {pb.ICountryModifyFlagArg=} [properties] Properties to set
         * @returns {pb.CountryModifyFlagArg} CountryModifyFlagArg instance
         */
        CountryModifyFlagArg.create = function create(properties) {
            return new CountryModifyFlagArg(properties);
        };

        /**
         * Encodes the specified CountryModifyFlagArg message. Does not implicitly {@link pb.CountryModifyFlagArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {pb.ICountryModifyFlagArg} message CountryModifyFlagArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryModifyFlagArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Flag);
            return writer;
        };

        /**
         * Encodes the specified CountryModifyFlagArg message, length delimited. Does not implicitly {@link pb.CountryModifyFlagArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {pb.ICountryModifyFlagArg} message CountryModifyFlagArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryModifyFlagArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CountryModifyFlagArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CountryModifyFlagArg} CountryModifyFlagArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryModifyFlagArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CountryModifyFlagArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Flag = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CountryModifyFlagArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CountryModifyFlagArg} CountryModifyFlagArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryModifyFlagArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CountryModifyFlagArg message.
         * @function verify
         * @memberof pb.CountryModifyFlagArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CountryModifyFlagArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                if (!$util.isString(message.Flag))
                    return "Flag: string expected";
            return null;
        };

        return CountryModifyFlagArg;
    })();

    pb.UpdateCountryNameArg = (function() {

        /**
         * Properties of an UpdateCountryNameArg.
         * @memberof pb
         * @interface IUpdateCountryNameArg
         * @property {number|null} [CountryID] UpdateCountryNameArg CountryID
         * @property {string|null} [Name] UpdateCountryNameArg Name
         */

        /**
         * Constructs a new UpdateCountryNameArg.
         * @memberof pb
         * @classdesc Represents an UpdateCountryNameArg.
         * @implements IUpdateCountryNameArg
         * @constructor
         * @param {pb.IUpdateCountryNameArg=} [properties] Properties to set
         */
        function UpdateCountryNameArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateCountryNameArg CountryID.
         * @member {number} CountryID
         * @memberof pb.UpdateCountryNameArg
         * @instance
         */
        UpdateCountryNameArg.prototype.CountryID = 0;

        /**
         * UpdateCountryNameArg Name.
         * @member {string} Name
         * @memberof pb.UpdateCountryNameArg
         * @instance
         */
        UpdateCountryNameArg.prototype.Name = "";

        /**
         * Creates a new UpdateCountryNameArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {pb.IUpdateCountryNameArg=} [properties] Properties to set
         * @returns {pb.UpdateCountryNameArg} UpdateCountryNameArg instance
         */
        UpdateCountryNameArg.create = function create(properties) {
            return new UpdateCountryNameArg(properties);
        };

        /**
         * Encodes the specified UpdateCountryNameArg message. Does not implicitly {@link pb.UpdateCountryNameArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {pb.IUpdateCountryNameArg} message UpdateCountryNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCountryNameArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified UpdateCountryNameArg message, length delimited. Does not implicitly {@link pb.UpdateCountryNameArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {pb.IUpdateCountryNameArg} message UpdateCountryNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCountryNameArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateCountryNameArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateCountryNameArg} UpdateCountryNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCountryNameArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateCountryNameArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateCountryNameArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateCountryNameArg} UpdateCountryNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCountryNameArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateCountryNameArg message.
         * @function verify
         * @memberof pb.UpdateCountryNameArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateCountryNameArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return UpdateCountryNameArg;
    })();

    pb.UpdateCountryFlagArg = (function() {

        /**
         * Properties of an UpdateCountryFlagArg.
         * @memberof pb
         * @interface IUpdateCountryFlagArg
         * @property {number|null} [CountryID] UpdateCountryFlagArg CountryID
         * @property {string|null} [Flag] UpdateCountryFlagArg Flag
         */

        /**
         * Constructs a new UpdateCountryFlagArg.
         * @memberof pb
         * @classdesc Represents an UpdateCountryFlagArg.
         * @implements IUpdateCountryFlagArg
         * @constructor
         * @param {pb.IUpdateCountryFlagArg=} [properties] Properties to set
         */
        function UpdateCountryFlagArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateCountryFlagArg CountryID.
         * @member {number} CountryID
         * @memberof pb.UpdateCountryFlagArg
         * @instance
         */
        UpdateCountryFlagArg.prototype.CountryID = 0;

        /**
         * UpdateCountryFlagArg Flag.
         * @member {string} Flag
         * @memberof pb.UpdateCountryFlagArg
         * @instance
         */
        UpdateCountryFlagArg.prototype.Flag = "";

        /**
         * Creates a new UpdateCountryFlagArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {pb.IUpdateCountryFlagArg=} [properties] Properties to set
         * @returns {pb.UpdateCountryFlagArg} UpdateCountryFlagArg instance
         */
        UpdateCountryFlagArg.create = function create(properties) {
            return new UpdateCountryFlagArg(properties);
        };

        /**
         * Encodes the specified UpdateCountryFlagArg message. Does not implicitly {@link pb.UpdateCountryFlagArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {pb.IUpdateCountryFlagArg} message UpdateCountryFlagArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCountryFlagArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Flag);
            return writer;
        };

        /**
         * Encodes the specified UpdateCountryFlagArg message, length delimited. Does not implicitly {@link pb.UpdateCountryFlagArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {pb.IUpdateCountryFlagArg} message UpdateCountryFlagArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCountryFlagArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateCountryFlagArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateCountryFlagArg} UpdateCountryFlagArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCountryFlagArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateCountryFlagArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.Flag = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateCountryFlagArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateCountryFlagArg} UpdateCountryFlagArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCountryFlagArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateCountryFlagArg message.
         * @function verify
         * @memberof pb.UpdateCountryFlagArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateCountryFlagArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.Flag != null && message.hasOwnProperty("Flag"))
                if (!$util.isString(message.Flag))
                    return "Flag: string expected";
            return null;
        };

        return UpdateCountryFlagArg;
    })();

    pb.CancelPublishMissionArg = (function() {

        /**
         * Properties of a CancelPublishMissionArg.
         * @memberof pb
         * @interface ICancelPublishMissionArg
         * @property {pb.CampaignMsType|null} [Type] CancelPublishMissionArg Type
         * @property {number|null} [TransportTargetCity] CancelPublishMissionArg TransportTargetCity
         */

        /**
         * Constructs a new CancelPublishMissionArg.
         * @memberof pb
         * @classdesc Represents a CancelPublishMissionArg.
         * @implements ICancelPublishMissionArg
         * @constructor
         * @param {pb.ICancelPublishMissionArg=} [properties] Properties to set
         */
        function CancelPublishMissionArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelPublishMissionArg Type.
         * @member {pb.CampaignMsType} Type
         * @memberof pb.CancelPublishMissionArg
         * @instance
         */
        CancelPublishMissionArg.prototype.Type = 0;

        /**
         * CancelPublishMissionArg TransportTargetCity.
         * @member {number} TransportTargetCity
         * @memberof pb.CancelPublishMissionArg
         * @instance
         */
        CancelPublishMissionArg.prototype.TransportTargetCity = 0;

        /**
         * Creates a new CancelPublishMissionArg instance using the specified properties.
         * @function create
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {pb.ICancelPublishMissionArg=} [properties] Properties to set
         * @returns {pb.CancelPublishMissionArg} CancelPublishMissionArg instance
         */
        CancelPublishMissionArg.create = function create(properties) {
            return new CancelPublishMissionArg(properties);
        };

        /**
         * Encodes the specified CancelPublishMissionArg message. Does not implicitly {@link pb.CancelPublishMissionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {pb.ICancelPublishMissionArg} message CancelPublishMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPublishMissionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.TransportTargetCity);
            return writer;
        };

        /**
         * Encodes the specified CancelPublishMissionArg message, length delimited. Does not implicitly {@link pb.CancelPublishMissionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {pb.ICancelPublishMissionArg} message CancelPublishMissionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPublishMissionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelPublishMissionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CancelPublishMissionArg} CancelPublishMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPublishMissionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelPublishMissionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 5:
                    message.TransportTargetCity = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelPublishMissionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CancelPublishMissionArg} CancelPublishMissionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPublishMissionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelPublishMissionArg message.
         * @function verify
         * @memberof pb.CancelPublishMissionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelPublishMissionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.TransportTargetCity != null && message.hasOwnProperty("TransportTargetCity"))
                if (!$util.isInteger(message.TransportTargetCity))
                    return "TransportTargetCity: integer expected";
            return null;
        };

        return CancelPublishMissionArg;
    })();

    pb.CancelPublishMissionReply = (function() {

        /**
         * Properties of a CancelPublishMissionReply.
         * @memberof pb
         * @interface ICancelPublishMissionReply
         * @property {number|null} [Gold] CancelPublishMissionReply Gold
         * @property {number|null} [Forage] CancelPublishMissionReply Forage
         */

        /**
         * Constructs a new CancelPublishMissionReply.
         * @memberof pb
         * @classdesc Represents a CancelPublishMissionReply.
         * @implements ICancelPublishMissionReply
         * @constructor
         * @param {pb.ICancelPublishMissionReply=} [properties] Properties to set
         */
        function CancelPublishMissionReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelPublishMissionReply Gold.
         * @member {number} Gold
         * @memberof pb.CancelPublishMissionReply
         * @instance
         */
        CancelPublishMissionReply.prototype.Gold = 0;

        /**
         * CancelPublishMissionReply Forage.
         * @member {number} Forage
         * @memberof pb.CancelPublishMissionReply
         * @instance
         */
        CancelPublishMissionReply.prototype.Forage = 0;

        /**
         * Creates a new CancelPublishMissionReply instance using the specified properties.
         * @function create
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {pb.ICancelPublishMissionReply=} [properties] Properties to set
         * @returns {pb.CancelPublishMissionReply} CancelPublishMissionReply instance
         */
        CancelPublishMissionReply.create = function create(properties) {
            return new CancelPublishMissionReply(properties);
        };

        /**
         * Encodes the specified CancelPublishMissionReply message. Does not implicitly {@link pb.CancelPublishMissionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {pb.ICancelPublishMissionReply} message CancelPublishMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPublishMissionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Forage);
            return writer;
        };

        /**
         * Encodes the specified CancelPublishMissionReply message, length delimited. Does not implicitly {@link pb.CancelPublishMissionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {pb.ICancelPublishMissionReply} message CancelPublishMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelPublishMissionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelPublishMissionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CancelPublishMissionReply} CancelPublishMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPublishMissionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelPublishMissionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                case 2:
                    message.Forage = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelPublishMissionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CancelPublishMissionReply} CancelPublishMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelPublishMissionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelPublishMissionReply message.
         * @function verify
         * @memberof pb.CancelPublishMissionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelPublishMissionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Forage != null && message.hasOwnProperty("Forage"))
                if (!$util.isInteger(message.Forage))
                    return "Forage: integer expected";
            return null;
        };

        return CancelPublishMissionReply;
    })();

    pb.CampaignTeams = (function() {

        /**
         * Properties of a CampaignTeams.
         * @memberof pb
         * @interface ICampaignTeams
         * @property {Array.<pb.ITeamData>|null} [Teams] CampaignTeams Teams
         */

        /**
         * Constructs a new CampaignTeams.
         * @memberof pb
         * @classdesc Represents a CampaignTeams.
         * @implements ICampaignTeams
         * @constructor
         * @param {pb.ICampaignTeams=} [properties] Properties to set
         */
        function CampaignTeams(properties) {
            this.Teams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignTeams Teams.
         * @member {Array.<pb.ITeamData>} Teams
         * @memberof pb.CampaignTeams
         * @instance
         */
        CampaignTeams.prototype.Teams = $util.emptyArray;

        /**
         * Creates a new CampaignTeams instance using the specified properties.
         * @function create
         * @memberof pb.CampaignTeams
         * @static
         * @param {pb.ICampaignTeams=} [properties] Properties to set
         * @returns {pb.CampaignTeams} CampaignTeams instance
         */
        CampaignTeams.create = function create(properties) {
            return new CampaignTeams(properties);
        };

        /**
         * Encodes the specified CampaignTeams message. Does not implicitly {@link pb.CampaignTeams.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignTeams
         * @static
         * @param {pb.ICampaignTeams} message CampaignTeams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignTeams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Teams != null && message.Teams.length)
                for (var i = 0; i < message.Teams.length; ++i)
                    $root.pb.TeamData.encode(message.Teams[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CampaignTeams message, length delimited. Does not implicitly {@link pb.CampaignTeams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignTeams
         * @static
         * @param {pb.ICampaignTeams} message CampaignTeams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignTeams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignTeams message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignTeams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignTeams} CampaignTeams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignTeams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignTeams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Teams && message.Teams.length))
                        message.Teams = [];
                    message.Teams.push($root.pb.TeamData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignTeams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignTeams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignTeams} CampaignTeams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignTeams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignTeams message.
         * @function verify
         * @memberof pb.CampaignTeams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignTeams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Teams != null && message.hasOwnProperty("Teams")) {
                if (!Array.isArray(message.Teams))
                    return "Teams: array expected";
                for (var i = 0; i < message.Teams.length; ++i) {
                    var error = $root.pb.TeamData.verify(message.Teams[i]);
                    if (error)
                        return "Teams." + error;
                }
            }
            return null;
        };

        return CampaignTeams;
    })();

    pb.CountryDestoryed = (function() {

        /**
         * Properties of a CountryDestoryed.
         * @memberof pb
         * @interface ICountryDestoryed
         * @property {number|null} [CountryID] CountryDestoryed CountryID
         */

        /**
         * Constructs a new CountryDestoryed.
         * @memberof pb
         * @classdesc Represents a CountryDestoryed.
         * @implements ICountryDestoryed
         * @constructor
         * @param {pb.ICountryDestoryed=} [properties] Properties to set
         */
        function CountryDestoryed(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CountryDestoryed CountryID.
         * @member {number} CountryID
         * @memberof pb.CountryDestoryed
         * @instance
         */
        CountryDestoryed.prototype.CountryID = 0;

        /**
         * Creates a new CountryDestoryed instance using the specified properties.
         * @function create
         * @memberof pb.CountryDestoryed
         * @static
         * @param {pb.ICountryDestoryed=} [properties] Properties to set
         * @returns {pb.CountryDestoryed} CountryDestoryed instance
         */
        CountryDestoryed.create = function create(properties) {
            return new CountryDestoryed(properties);
        };

        /**
         * Encodes the specified CountryDestoryed message. Does not implicitly {@link pb.CountryDestoryed.verify|verify} messages.
         * @function encode
         * @memberof pb.CountryDestoryed
         * @static
         * @param {pb.ICountryDestoryed} message CountryDestoryed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryDestoryed.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            return writer;
        };

        /**
         * Encodes the specified CountryDestoryed message, length delimited. Does not implicitly {@link pb.CountryDestoryed.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CountryDestoryed
         * @static
         * @param {pb.ICountryDestoryed} message CountryDestoryed message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CountryDestoryed.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CountryDestoryed message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CountryDestoryed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CountryDestoryed} CountryDestoryed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryDestoryed.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CountryDestoryed();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CountryDestoryed message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CountryDestoryed
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CountryDestoryed} CountryDestoryed
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CountryDestoryed.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CountryDestoryed message.
         * @function verify
         * @memberof pb.CountryDestoryed
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CountryDestoryed.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            return null;
        };

        return CountryDestoryed;
    })();

    pb.CapitalInjectionRecord = (function() {

        /**
         * Properties of a CapitalInjectionRecord.
         * @memberof pb
         * @interface ICapitalInjectionRecord
         * @property {pb.ICampaignPlayer|null} [Player] CapitalInjectionRecord Player
         * @property {number|null} [Gold] CapitalInjectionRecord Gold
         * @property {number|null} [Time] CapitalInjectionRecord Time
         */

        /**
         * Constructs a new CapitalInjectionRecord.
         * @memberof pb
         * @classdesc Represents a CapitalInjectionRecord.
         * @implements ICapitalInjectionRecord
         * @constructor
         * @param {pb.ICapitalInjectionRecord=} [properties] Properties to set
         */
        function CapitalInjectionRecord(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CapitalInjectionRecord Player.
         * @member {pb.ICampaignPlayer|null|undefined} Player
         * @memberof pb.CapitalInjectionRecord
         * @instance
         */
        CapitalInjectionRecord.prototype.Player = null;

        /**
         * CapitalInjectionRecord Gold.
         * @member {number} Gold
         * @memberof pb.CapitalInjectionRecord
         * @instance
         */
        CapitalInjectionRecord.prototype.Gold = 0;

        /**
         * CapitalInjectionRecord Time.
         * @member {number} Time
         * @memberof pb.CapitalInjectionRecord
         * @instance
         */
        CapitalInjectionRecord.prototype.Time = 0;

        /**
         * Creates a new CapitalInjectionRecord instance using the specified properties.
         * @function create
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {pb.ICapitalInjectionRecord=} [properties] Properties to set
         * @returns {pb.CapitalInjectionRecord} CapitalInjectionRecord instance
         */
        CapitalInjectionRecord.create = function create(properties) {
            return new CapitalInjectionRecord(properties);
        };

        /**
         * Encodes the specified CapitalInjectionRecord message. Does not implicitly {@link pb.CapitalInjectionRecord.verify|verify} messages.
         * @function encode
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {pb.ICapitalInjectionRecord} message CapitalInjectionRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalInjectionRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Player != null && message.hasOwnProperty("Player"))
                $root.pb.CampaignPlayer.encode(message.Player, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Time);
            return writer;
        };

        /**
         * Encodes the specified CapitalInjectionRecord message, length delimited. Does not implicitly {@link pb.CapitalInjectionRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {pb.ICapitalInjectionRecord} message CapitalInjectionRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CapitalInjectionRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CapitalInjectionRecord message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CapitalInjectionRecord} CapitalInjectionRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalInjectionRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CapitalInjectionRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Player = $root.pb.CampaignPlayer.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                case 3:
                    message.Time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CapitalInjectionRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CapitalInjectionRecord} CapitalInjectionRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CapitalInjectionRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CapitalInjectionRecord message.
         * @function verify
         * @memberof pb.CapitalInjectionRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CapitalInjectionRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Player != null && message.hasOwnProperty("Player")) {
                var error = $root.pb.CampaignPlayer.verify(message.Player);
                if (error)
                    return "Player." + error;
            }
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            return null;
        };

        return CapitalInjectionRecord;
    })();

    pb.CityCapitalInjectionHistory = (function() {

        /**
         * Properties of a CityCapitalInjectionHistory.
         * @memberof pb
         * @interface ICityCapitalInjectionHistory
         * @property {Array.<pb.ICapitalInjectionRecord>|null} [Records] CityCapitalInjectionHistory Records
         */

        /**
         * Constructs a new CityCapitalInjectionHistory.
         * @memberof pb
         * @classdesc Represents a CityCapitalInjectionHistory.
         * @implements ICityCapitalInjectionHistory
         * @constructor
         * @param {pb.ICityCapitalInjectionHistory=} [properties] Properties to set
         */
        function CityCapitalInjectionHistory(properties) {
            this.Records = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityCapitalInjectionHistory Records.
         * @member {Array.<pb.ICapitalInjectionRecord>} Records
         * @memberof pb.CityCapitalInjectionHistory
         * @instance
         */
        CityCapitalInjectionHistory.prototype.Records = $util.emptyArray;

        /**
         * Creates a new CityCapitalInjectionHistory instance using the specified properties.
         * @function create
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {pb.ICityCapitalInjectionHistory=} [properties] Properties to set
         * @returns {pb.CityCapitalInjectionHistory} CityCapitalInjectionHistory instance
         */
        CityCapitalInjectionHistory.create = function create(properties) {
            return new CityCapitalInjectionHistory(properties);
        };

        /**
         * Encodes the specified CityCapitalInjectionHistory message. Does not implicitly {@link pb.CityCapitalInjectionHistory.verify|verify} messages.
         * @function encode
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {pb.ICityCapitalInjectionHistory} message CityCapitalInjectionHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionHistory.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Records != null && message.Records.length)
                for (var i = 0; i < message.Records.length; ++i)
                    $root.pb.CapitalInjectionRecord.encode(message.Records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CityCapitalInjectionHistory message, length delimited. Does not implicitly {@link pb.CityCapitalInjectionHistory.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {pb.ICityCapitalInjectionHistory} message CityCapitalInjectionHistory message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityCapitalInjectionHistory.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityCapitalInjectionHistory message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityCapitalInjectionHistory} CityCapitalInjectionHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionHistory.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityCapitalInjectionHistory();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Records && message.Records.length))
                        message.Records = [];
                    message.Records.push($root.pb.CapitalInjectionRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityCapitalInjectionHistory message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityCapitalInjectionHistory} CityCapitalInjectionHistory
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityCapitalInjectionHistory.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityCapitalInjectionHistory message.
         * @function verify
         * @memberof pb.CityCapitalInjectionHistory
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityCapitalInjectionHistory.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Records != null && message.hasOwnProperty("Records")) {
                if (!Array.isArray(message.Records))
                    return "Records: array expected";
                for (var i = 0; i < message.Records.length; ++i) {
                    var error = $root.pb.CapitalInjectionRecord.verify(message.Records[i]);
                    if (error)
                        return "Records." + error;
                }
            }
            return null;
        };

        return CityCapitalInjectionHistory;
    })();

    pb.UpdateContributionArg = (function() {

        /**
         * Properties of an UpdateContributionArg.
         * @memberof pb
         * @interface IUpdateContributionArg
         * @property {number|null} [Contribution] UpdateContributionArg Contribution
         * @property {number|null} [MaxContribution] UpdateContributionArg MaxContribution
         */

        /**
         * Constructs a new UpdateContributionArg.
         * @memberof pb
         * @classdesc Represents an UpdateContributionArg.
         * @implements IUpdateContributionArg
         * @constructor
         * @param {pb.IUpdateContributionArg=} [properties] Properties to set
         */
        function UpdateContributionArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateContributionArg Contribution.
         * @member {number} Contribution
         * @memberof pb.UpdateContributionArg
         * @instance
         */
        UpdateContributionArg.prototype.Contribution = 0;

        /**
         * UpdateContributionArg MaxContribution.
         * @member {number} MaxContribution
         * @memberof pb.UpdateContributionArg
         * @instance
         */
        UpdateContributionArg.prototype.MaxContribution = 0;

        /**
         * Creates a new UpdateContributionArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {pb.IUpdateContributionArg=} [properties] Properties to set
         * @returns {pb.UpdateContributionArg} UpdateContributionArg instance
         */
        UpdateContributionArg.create = function create(properties) {
            return new UpdateContributionArg(properties);
        };

        /**
         * Encodes the specified UpdateContributionArg message. Does not implicitly {@link pb.UpdateContributionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {pb.IUpdateContributionArg} message UpdateContributionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContributionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Contribution);
            if (message.MaxContribution != null && message.hasOwnProperty("MaxContribution"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.MaxContribution);
            return writer;
        };

        /**
         * Encodes the specified UpdateContributionArg message, length delimited. Does not implicitly {@link pb.UpdateContributionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {pb.IUpdateContributionArg} message UpdateContributionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateContributionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateContributionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateContributionArg} UpdateContributionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContributionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateContributionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Contribution = reader.int32();
                    break;
                case 2:
                    message.MaxContribution = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateContributionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateContributionArg} UpdateContributionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateContributionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateContributionArg message.
         * @function verify
         * @memberof pb.UpdateContributionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateContributionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.MaxContribution != null && message.hasOwnProperty("MaxContribution"))
                if (!$util.isInteger(message.MaxContribution))
                    return "MaxContribution: integer expected";
            return null;
        };

        return UpdateContributionArg;
    })();

    pb.CityNotice = (function() {

        /**
         * Properties of a CityNotice.
         * @memberof pb
         * @interface ICityNotice
         * @property {string|null} [Notice] CityNotice Notice
         */

        /**
         * Constructs a new CityNotice.
         * @memberof pb
         * @classdesc Represents a CityNotice.
         * @implements ICityNotice
         * @constructor
         * @param {pb.ICityNotice=} [properties] Properties to set
         */
        function CityNotice(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CityNotice Notice.
         * @member {string} Notice
         * @memberof pb.CityNotice
         * @instance
         */
        CityNotice.prototype.Notice = "";

        /**
         * Creates a new CityNotice instance using the specified properties.
         * @function create
         * @memberof pb.CityNotice
         * @static
         * @param {pb.ICityNotice=} [properties] Properties to set
         * @returns {pb.CityNotice} CityNotice instance
         */
        CityNotice.create = function create(properties) {
            return new CityNotice(properties);
        };

        /**
         * Encodes the specified CityNotice message. Does not implicitly {@link pb.CityNotice.verify|verify} messages.
         * @function encode
         * @memberof pb.CityNotice
         * @static
         * @param {pb.ICityNotice} message CityNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityNotice.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Notice != null && message.hasOwnProperty("Notice"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Notice);
            return writer;
        };

        /**
         * Encodes the specified CityNotice message, length delimited. Does not implicitly {@link pb.CityNotice.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CityNotice
         * @static
         * @param {pb.ICityNotice} message CityNotice message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CityNotice.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CityNotice message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CityNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CityNotice} CityNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityNotice.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CityNotice();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Notice = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CityNotice message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CityNotice
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CityNotice} CityNotice
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CityNotice.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CityNotice message.
         * @function verify
         * @memberof pb.CityNotice
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CityNotice.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Notice != null && message.hasOwnProperty("Notice"))
                if (!$util.isString(message.Notice))
                    return "Notice: string expected";
            return null;
        };

        return CityNotice;
    })();

    pb.FetchCityCapitalInjectionArg = (function() {

        /**
         * Properties of a FetchCityCapitalInjectionArg.
         * @memberof pb
         * @interface IFetchCityCapitalInjectionArg
         * @property {number|null} [CityID] FetchCityCapitalInjectionArg CityID
         * @property {number|null} [Page] FetchCityCapitalInjectionArg Page
         */

        /**
         * Constructs a new FetchCityCapitalInjectionArg.
         * @memberof pb
         * @classdesc Represents a FetchCityCapitalInjectionArg.
         * @implements IFetchCityCapitalInjectionArg
         * @constructor
         * @param {pb.IFetchCityCapitalInjectionArg=} [properties] Properties to set
         */
        function FetchCityCapitalInjectionArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchCityCapitalInjectionArg CityID.
         * @member {number} CityID
         * @memberof pb.FetchCityCapitalInjectionArg
         * @instance
         */
        FetchCityCapitalInjectionArg.prototype.CityID = 0;

        /**
         * FetchCityCapitalInjectionArg Page.
         * @member {number} Page
         * @memberof pb.FetchCityCapitalInjectionArg
         * @instance
         */
        FetchCityCapitalInjectionArg.prototype.Page = 0;

        /**
         * Creates a new FetchCityCapitalInjectionArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {pb.IFetchCityCapitalInjectionArg=} [properties] Properties to set
         * @returns {pb.FetchCityCapitalInjectionArg} FetchCityCapitalInjectionArg instance
         */
        FetchCityCapitalInjectionArg.create = function create(properties) {
            return new FetchCityCapitalInjectionArg(properties);
        };

        /**
         * Encodes the specified FetchCityCapitalInjectionArg message. Does not implicitly {@link pb.FetchCityCapitalInjectionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {pb.IFetchCityCapitalInjectionArg} message FetchCityCapitalInjectionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCityCapitalInjectionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Page != null && message.hasOwnProperty("Page"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Page);
            return writer;
        };

        /**
         * Encodes the specified FetchCityCapitalInjectionArg message, length delimited. Does not implicitly {@link pb.FetchCityCapitalInjectionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {pb.IFetchCityCapitalInjectionArg} message FetchCityCapitalInjectionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchCityCapitalInjectionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchCityCapitalInjectionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchCityCapitalInjectionArg} FetchCityCapitalInjectionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCityCapitalInjectionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchCityCapitalInjectionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Page = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchCityCapitalInjectionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchCityCapitalInjectionArg} FetchCityCapitalInjectionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchCityCapitalInjectionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchCityCapitalInjectionArg message.
         * @function verify
         * @memberof pb.FetchCityCapitalInjectionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchCityCapitalInjectionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Page != null && message.hasOwnProperty("Page"))
                if (!$util.isInteger(message.Page))
                    return "Page: integer expected";
            return null;
        };

        return FetchCityCapitalInjectionArg;
    })();

    pb.CampaignSimplePlayer = (function() {

        /**
         * Properties of a CampaignSimplePlayer.
         * @memberof pb
         * @interface ICampaignSimplePlayer
         * @property {number|Long|null} [Uid] CampaignSimplePlayer Uid
         * @property {string|null} [Name] CampaignSimplePlayer Name
         * @property {string|null} [HeadImg] CampaignSimplePlayer HeadImg
         * @property {string|null} [HeadFrame] CampaignSimplePlayer HeadFrame
         * @property {number|null} [PvpScore] CampaignSimplePlayer PvpScore
         */

        /**
         * Constructs a new CampaignSimplePlayer.
         * @memberof pb
         * @classdesc Represents a CampaignSimplePlayer.
         * @implements ICampaignSimplePlayer
         * @constructor
         * @param {pb.ICampaignSimplePlayer=} [properties] Properties to set
         */
        function CampaignSimplePlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignSimplePlayer Uid.
         * @member {number|Long} Uid
         * @memberof pb.CampaignSimplePlayer
         * @instance
         */
        CampaignSimplePlayer.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CampaignSimplePlayer Name.
         * @member {string} Name
         * @memberof pb.CampaignSimplePlayer
         * @instance
         */
        CampaignSimplePlayer.prototype.Name = "";

        /**
         * CampaignSimplePlayer HeadImg.
         * @member {string} HeadImg
         * @memberof pb.CampaignSimplePlayer
         * @instance
         */
        CampaignSimplePlayer.prototype.HeadImg = "";

        /**
         * CampaignSimplePlayer HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.CampaignSimplePlayer
         * @instance
         */
        CampaignSimplePlayer.prototype.HeadFrame = "";

        /**
         * CampaignSimplePlayer PvpScore.
         * @member {number} PvpScore
         * @memberof pb.CampaignSimplePlayer
         * @instance
         */
        CampaignSimplePlayer.prototype.PvpScore = 0;

        /**
         * Creates a new CampaignSimplePlayer instance using the specified properties.
         * @function create
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {pb.ICampaignSimplePlayer=} [properties] Properties to set
         * @returns {pb.CampaignSimplePlayer} CampaignSimplePlayer instance
         */
        CampaignSimplePlayer.create = function create(properties) {
            return new CampaignSimplePlayer(properties);
        };

        /**
         * Encodes the specified CampaignSimplePlayer message. Does not implicitly {@link pb.CampaignSimplePlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {pb.ICampaignSimplePlayer} message CampaignSimplePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignSimplePlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImg);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.HeadFrame);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.PvpScore);
            return writer;
        };

        /**
         * Encodes the specified CampaignSimplePlayer message, length delimited. Does not implicitly {@link pb.CampaignSimplePlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {pb.ICampaignSimplePlayer} message CampaignSimplePlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignSimplePlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignSimplePlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignSimplePlayer} CampaignSimplePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignSimplePlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignSimplePlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.HeadImg = reader.string();
                    break;
                case 4:
                    message.HeadFrame = reader.string();
                    break;
                case 5:
                    message.PvpScore = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignSimplePlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignSimplePlayer} CampaignSimplePlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignSimplePlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignSimplePlayer message.
         * @function verify
         * @memberof pb.CampaignSimplePlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignSimplePlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                if (!$util.isString(message.HeadImg))
                    return "HeadImg: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            return null;
        };

        return CampaignSimplePlayer;
    })();

    pb.SyncCityPlayerAmount = (function() {

        /**
         * Properties of a SyncCityPlayerAmount.
         * @memberof pb
         * @interface ISyncCityPlayerAmount
         * @property {number|null} [CityID] SyncCityPlayerAmount CityID
         * @property {number|null} [Amount] SyncCityPlayerAmount Amount
         */

        /**
         * Constructs a new SyncCityPlayerAmount.
         * @memberof pb
         * @classdesc Represents a SyncCityPlayerAmount.
         * @implements ISyncCityPlayerAmount
         * @constructor
         * @param {pb.ISyncCityPlayerAmount=} [properties] Properties to set
         */
        function SyncCityPlayerAmount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SyncCityPlayerAmount CityID.
         * @member {number} CityID
         * @memberof pb.SyncCityPlayerAmount
         * @instance
         */
        SyncCityPlayerAmount.prototype.CityID = 0;

        /**
         * SyncCityPlayerAmount Amount.
         * @member {number} Amount
         * @memberof pb.SyncCityPlayerAmount
         * @instance
         */
        SyncCityPlayerAmount.prototype.Amount = 0;

        /**
         * Creates a new SyncCityPlayerAmount instance using the specified properties.
         * @function create
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {pb.ISyncCityPlayerAmount=} [properties] Properties to set
         * @returns {pb.SyncCityPlayerAmount} SyncCityPlayerAmount instance
         */
        SyncCityPlayerAmount.create = function create(properties) {
            return new SyncCityPlayerAmount(properties);
        };

        /**
         * Encodes the specified SyncCityPlayerAmount message. Does not implicitly {@link pb.SyncCityPlayerAmount.verify|verify} messages.
         * @function encode
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {pb.ISyncCityPlayerAmount} message SyncCityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCityPlayerAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified SyncCityPlayerAmount message, length delimited. Does not implicitly {@link pb.SyncCityPlayerAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {pb.ISyncCityPlayerAmount} message SyncCityPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SyncCityPlayerAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SyncCityPlayerAmount message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SyncCityPlayerAmount} SyncCityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCityPlayerAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SyncCityPlayerAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SyncCityPlayerAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SyncCityPlayerAmount} SyncCityPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SyncCityPlayerAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SyncCityPlayerAmount message.
         * @function verify
         * @memberof pb.SyncCityPlayerAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SyncCityPlayerAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return SyncCityPlayerAmount;
    })();

    pb.CampaignSupportCard = (function() {

        /**
         * Properties of a CampaignSupportCard.
         * @memberof pb
         * @interface ICampaignSupportCard
         * @property {Array.<number>|null} [CardIDs] CampaignSupportCard CardIDs
         */

        /**
         * Constructs a new CampaignSupportCard.
         * @memberof pb
         * @classdesc Represents a CampaignSupportCard.
         * @implements ICampaignSupportCard
         * @constructor
         * @param {pb.ICampaignSupportCard=} [properties] Properties to set
         */
        function CampaignSupportCard(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignSupportCard CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.CampaignSupportCard
         * @instance
         */
        CampaignSupportCard.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new CampaignSupportCard instance using the specified properties.
         * @function create
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {pb.ICampaignSupportCard=} [properties] Properties to set
         * @returns {pb.CampaignSupportCard} CampaignSupportCard instance
         */
        CampaignSupportCard.create = function create(properties) {
            return new CampaignSupportCard(properties);
        };

        /**
         * Encodes the specified CampaignSupportCard message. Does not implicitly {@link pb.CampaignSupportCard.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {pb.ICampaignSupportCard} message CampaignSupportCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignSupportCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified CampaignSupportCard message, length delimited. Does not implicitly {@link pb.CampaignSupportCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {pb.ICampaignSupportCard} message CampaignSupportCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignSupportCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignSupportCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignSupportCard} CampaignSupportCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignSupportCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignSupportCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignSupportCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignSupportCard} CampaignSupportCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignSupportCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignSupportCard message.
         * @function verify
         * @memberof pb.CampaignSupportCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignSupportCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return CampaignSupportCard;
    })();

    pb.SurrenderCityArg = (function() {

        /**
         * Properties of a SurrenderCityArg.
         * @memberof pb
         * @interface ISurrenderCityArg
         * @property {number|null} [CountryID] SurrenderCityArg CountryID
         */

        /**
         * Constructs a new SurrenderCityArg.
         * @memberof pb
         * @classdesc Represents a SurrenderCityArg.
         * @implements ISurrenderCityArg
         * @constructor
         * @param {pb.ISurrenderCityArg=} [properties] Properties to set
         */
        function SurrenderCityArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurrenderCityArg CountryID.
         * @member {number} CountryID
         * @memberof pb.SurrenderCityArg
         * @instance
         */
        SurrenderCityArg.prototype.CountryID = 0;

        /**
         * Creates a new SurrenderCityArg instance using the specified properties.
         * @function create
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {pb.ISurrenderCityArg=} [properties] Properties to set
         * @returns {pb.SurrenderCityArg} SurrenderCityArg instance
         */
        SurrenderCityArg.create = function create(properties) {
            return new SurrenderCityArg(properties);
        };

        /**
         * Encodes the specified SurrenderCityArg message. Does not implicitly {@link pb.SurrenderCityArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {pb.ISurrenderCityArg} message SurrenderCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCityArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            return writer;
        };

        /**
         * Encodes the specified SurrenderCityArg message, length delimited. Does not implicitly {@link pb.SurrenderCityArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {pb.ISurrenderCityArg} message SurrenderCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurrenderCityArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurrenderCityArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurrenderCityArg} SurrenderCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCityArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurrenderCityArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurrenderCityArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurrenderCityArg} SurrenderCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurrenderCityArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurrenderCityArg message.
         * @function verify
         * @memberof pb.SurrenderCityArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurrenderCityArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            return null;
        };

        return SurrenderCityArg;
    })();

    pb.UpdateCityCountryArg = (function() {

        /**
         * Properties of an UpdateCityCountryArg.
         * @memberof pb
         * @interface IUpdateCityCountryArg
         * @property {number|null} [CityID] UpdateCityCountryArg CityID
         * @property {number|null} [CountryID] UpdateCityCountryArg CountryID
         */

        /**
         * Constructs a new UpdateCityCountryArg.
         * @memberof pb
         * @classdesc Represents an UpdateCityCountryArg.
         * @implements IUpdateCityCountryArg
         * @constructor
         * @param {pb.IUpdateCityCountryArg=} [properties] Properties to set
         */
        function UpdateCityCountryArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateCityCountryArg CityID.
         * @member {number} CityID
         * @memberof pb.UpdateCityCountryArg
         * @instance
         */
        UpdateCityCountryArg.prototype.CityID = 0;

        /**
         * UpdateCityCountryArg CountryID.
         * @member {number} CountryID
         * @memberof pb.UpdateCityCountryArg
         * @instance
         */
        UpdateCityCountryArg.prototype.CountryID = 0;

        /**
         * Creates a new UpdateCityCountryArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {pb.IUpdateCityCountryArg=} [properties] Properties to set
         * @returns {pb.UpdateCityCountryArg} UpdateCityCountryArg instance
         */
        UpdateCityCountryArg.create = function create(properties) {
            return new UpdateCityCountryArg(properties);
        };

        /**
         * Encodes the specified UpdateCityCountryArg message. Does not implicitly {@link pb.UpdateCityCountryArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {pb.IUpdateCityCountryArg} message UpdateCityCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCityCountryArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.CountryID);
            return writer;
        };

        /**
         * Encodes the specified UpdateCityCountryArg message, length delimited. Does not implicitly {@link pb.UpdateCityCountryArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {pb.IUpdateCityCountryArg} message UpdateCityCountryArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateCityCountryArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateCityCountryArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateCityCountryArg} UpdateCityCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCityCountryArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateCityCountryArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.CountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateCityCountryArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateCityCountryArg} UpdateCityCountryArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateCityCountryArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateCityCountryArg message.
         * @function verify
         * @memberof pb.UpdateCityCountryArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateCityCountryArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            return null;
        };

        return UpdateCityCountryArg;
    })();

    pb.CitysDefPlayerAmount = (function() {

        /**
         * Properties of a CitysDefPlayerAmount.
         * @memberof pb
         * @interface ICitysDefPlayerAmount
         * @property {Array.<pb.ISyncCityPlayerAmount>|null} [Amounts] CitysDefPlayerAmount Amounts
         */

        /**
         * Constructs a new CitysDefPlayerAmount.
         * @memberof pb
         * @classdesc Represents a CitysDefPlayerAmount.
         * @implements ICitysDefPlayerAmount
         * @constructor
         * @param {pb.ICitysDefPlayerAmount=} [properties] Properties to set
         */
        function CitysDefPlayerAmount(properties) {
            this.Amounts = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CitysDefPlayerAmount Amounts.
         * @member {Array.<pb.ISyncCityPlayerAmount>} Amounts
         * @memberof pb.CitysDefPlayerAmount
         * @instance
         */
        CitysDefPlayerAmount.prototype.Amounts = $util.emptyArray;

        /**
         * Creates a new CitysDefPlayerAmount instance using the specified properties.
         * @function create
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {pb.ICitysDefPlayerAmount=} [properties] Properties to set
         * @returns {pb.CitysDefPlayerAmount} CitysDefPlayerAmount instance
         */
        CitysDefPlayerAmount.create = function create(properties) {
            return new CitysDefPlayerAmount(properties);
        };

        /**
         * Encodes the specified CitysDefPlayerAmount message. Does not implicitly {@link pb.CitysDefPlayerAmount.verify|verify} messages.
         * @function encode
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {pb.ICitysDefPlayerAmount} message CitysDefPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CitysDefPlayerAmount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Amounts != null && message.Amounts.length)
                for (var i = 0; i < message.Amounts.length; ++i)
                    $root.pb.SyncCityPlayerAmount.encode(message.Amounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CitysDefPlayerAmount message, length delimited. Does not implicitly {@link pb.CitysDefPlayerAmount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {pb.ICitysDefPlayerAmount} message CitysDefPlayerAmount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CitysDefPlayerAmount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CitysDefPlayerAmount message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CitysDefPlayerAmount} CitysDefPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CitysDefPlayerAmount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CitysDefPlayerAmount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Amounts && message.Amounts.length))
                        message.Amounts = [];
                    message.Amounts.push($root.pb.SyncCityPlayerAmount.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CitysDefPlayerAmount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CitysDefPlayerAmount} CitysDefPlayerAmount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CitysDefPlayerAmount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CitysDefPlayerAmount message.
         * @function verify
         * @memberof pb.CitysDefPlayerAmount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CitysDefPlayerAmount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Amounts != null && message.hasOwnProperty("Amounts")) {
                if (!Array.isArray(message.Amounts))
                    return "Amounts: array expected";
                for (var i = 0; i < message.Amounts.length; ++i) {
                    var error = $root.pb.SyncCityPlayerAmount.verify(message.Amounts[i]);
                    if (error)
                        return "Amounts." + error;
                }
            }
            return null;
        };

        return CitysDefPlayerAmount;
    })();

    pb.CampaignBuyGoodsArg = (function() {

        /**
         * Properties of a CampaignBuyGoodsArg.
         * @memberof pb
         * @interface ICampaignBuyGoodsArg
         * @property {string|null} [Type] CampaignBuyGoodsArg Type
         * @property {number|null} [GoodsID] CampaignBuyGoodsArg GoodsID
         */

        /**
         * Constructs a new CampaignBuyGoodsArg.
         * @memberof pb
         * @classdesc Represents a CampaignBuyGoodsArg.
         * @implements ICampaignBuyGoodsArg
         * @constructor
         * @param {pb.ICampaignBuyGoodsArg=} [properties] Properties to set
         */
        function CampaignBuyGoodsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignBuyGoodsArg Type.
         * @member {string} Type
         * @memberof pb.CampaignBuyGoodsArg
         * @instance
         */
        CampaignBuyGoodsArg.prototype.Type = "";

        /**
         * CampaignBuyGoodsArg GoodsID.
         * @member {number} GoodsID
         * @memberof pb.CampaignBuyGoodsArg
         * @instance
         */
        CampaignBuyGoodsArg.prototype.GoodsID = 0;

        /**
         * Creates a new CampaignBuyGoodsArg instance using the specified properties.
         * @function create
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {pb.ICampaignBuyGoodsArg=} [properties] Properties to set
         * @returns {pb.CampaignBuyGoodsArg} CampaignBuyGoodsArg instance
         */
        CampaignBuyGoodsArg.create = function create(properties) {
            return new CampaignBuyGoodsArg(properties);
        };

        /**
         * Encodes the specified CampaignBuyGoodsArg message. Does not implicitly {@link pb.CampaignBuyGoodsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {pb.ICampaignBuyGoodsArg} message CampaignBuyGoodsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignBuyGoodsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Type);
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified CampaignBuyGoodsArg message, length delimited. Does not implicitly {@link pb.CampaignBuyGoodsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {pb.ICampaignBuyGoodsArg} message CampaignBuyGoodsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignBuyGoodsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignBuyGoodsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignBuyGoodsArg} CampaignBuyGoodsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignBuyGoodsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignBuyGoodsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.string();
                    break;
                case 2:
                    message.GoodsID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignBuyGoodsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignBuyGoodsArg} CampaignBuyGoodsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignBuyGoodsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignBuyGoodsArg message.
         * @function verify
         * @memberof pb.CampaignBuyGoodsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignBuyGoodsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                if (!$util.isString(message.Type))
                    return "Type: string expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isInteger(message.GoodsID))
                    return "GoodsID: integer expected";
            return null;
        };

        return CampaignBuyGoodsArg;
    })();

    pb.GSettleCityArg = (function() {

        /**
         * Properties of a GSettleCityArg.
         * @memberof pb
         * @interface IGSettleCityArg
         * @property {number|null} [CityID] GSettleCityArg CityID
         * @property {pb.ICampaignSimplePlayer|null} [Player] GSettleCityArg Player
         */

        /**
         * Constructs a new GSettleCityArg.
         * @memberof pb
         * @classdesc Represents a GSettleCityArg.
         * @implements IGSettleCityArg
         * @constructor
         * @param {pb.IGSettleCityArg=} [properties] Properties to set
         */
        function GSettleCityArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GSettleCityArg CityID.
         * @member {number} CityID
         * @memberof pb.GSettleCityArg
         * @instance
         */
        GSettleCityArg.prototype.CityID = 0;

        /**
         * GSettleCityArg Player.
         * @member {pb.ICampaignSimplePlayer|null|undefined} Player
         * @memberof pb.GSettleCityArg
         * @instance
         */
        GSettleCityArg.prototype.Player = null;

        /**
         * Creates a new GSettleCityArg instance using the specified properties.
         * @function create
         * @memberof pb.GSettleCityArg
         * @static
         * @param {pb.IGSettleCityArg=} [properties] Properties to set
         * @returns {pb.GSettleCityArg} GSettleCityArg instance
         */
        GSettleCityArg.create = function create(properties) {
            return new GSettleCityArg(properties);
        };

        /**
         * Encodes the specified GSettleCityArg message. Does not implicitly {@link pb.GSettleCityArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GSettleCityArg
         * @static
         * @param {pb.IGSettleCityArg} message GSettleCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GSettleCityArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Player != null && message.hasOwnProperty("Player"))
                $root.pb.CampaignSimplePlayer.encode(message.Player, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GSettleCityArg message, length delimited. Does not implicitly {@link pb.GSettleCityArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GSettleCityArg
         * @static
         * @param {pb.IGSettleCityArg} message GSettleCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GSettleCityArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GSettleCityArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GSettleCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GSettleCityArg} GSettleCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GSettleCityArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GSettleCityArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Player = $root.pb.CampaignSimplePlayer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GSettleCityArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GSettleCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GSettleCityArg} GSettleCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GSettleCityArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GSettleCityArg message.
         * @function verify
         * @memberof pb.GSettleCityArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GSettleCityArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Player != null && message.hasOwnProperty("Player")) {
                var error = $root.pb.CampaignSimplePlayer.verify(message.Player);
                if (error)
                    return "Player." + error;
            }
            return null;
        };

        return GSettleCityArg;
    })();

    pb.GCancelCampaignMissionReply = (function() {

        /**
         * Properties of a GCancelCampaignMissionReply.
         * @memberof pb
         * @interface IGCancelCampaignMissionReply
         * @property {Array.<number>|null} [CardIDs] GCancelCampaignMissionReply CardIDs
         */

        /**
         * Constructs a new GCancelCampaignMissionReply.
         * @memberof pb
         * @classdesc Represents a GCancelCampaignMissionReply.
         * @implements IGCancelCampaignMissionReply
         * @constructor
         * @param {pb.IGCancelCampaignMissionReply=} [properties] Properties to set
         */
        function GCancelCampaignMissionReply(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GCancelCampaignMissionReply CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.GCancelCampaignMissionReply
         * @instance
         */
        GCancelCampaignMissionReply.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new GCancelCampaignMissionReply instance using the specified properties.
         * @function create
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {pb.IGCancelCampaignMissionReply=} [properties] Properties to set
         * @returns {pb.GCancelCampaignMissionReply} GCancelCampaignMissionReply instance
         */
        GCancelCampaignMissionReply.create = function create(properties) {
            return new GCancelCampaignMissionReply(properties);
        };

        /**
         * Encodes the specified GCancelCampaignMissionReply message. Does not implicitly {@link pb.GCancelCampaignMissionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {pb.IGCancelCampaignMissionReply} message GCancelCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCancelCampaignMissionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GCancelCampaignMissionReply message, length delimited. Does not implicitly {@link pb.GCancelCampaignMissionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {pb.IGCancelCampaignMissionReply} message GCancelCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCancelCampaignMissionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GCancelCampaignMissionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GCancelCampaignMissionReply} GCancelCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCancelCampaignMissionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GCancelCampaignMissionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GCancelCampaignMissionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GCancelCampaignMissionReply} GCancelCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCancelCampaignMissionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GCancelCampaignMissionReply message.
         * @function verify
         * @memberof pb.GCancelCampaignMissionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GCancelCampaignMissionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return GCancelCampaignMissionReply;
    })();

    pb.GGetCampaignMissionRewardReply = (function() {

        /**
         * Properties of a GGetCampaignMissionRewardReply.
         * @memberof pb
         * @interface IGGetCampaignMissionRewardReply
         * @property {number|null} [Gold] GGetCampaignMissionRewardReply Gold
         * @property {Array.<number>|null} [CardIDs] GGetCampaignMissionRewardReply CardIDs
         */

        /**
         * Constructs a new GGetCampaignMissionRewardReply.
         * @memberof pb
         * @classdesc Represents a GGetCampaignMissionRewardReply.
         * @implements IGGetCampaignMissionRewardReply
         * @constructor
         * @param {pb.IGGetCampaignMissionRewardReply=} [properties] Properties to set
         */
        function GGetCampaignMissionRewardReply(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GGetCampaignMissionRewardReply Gold.
         * @member {number} Gold
         * @memberof pb.GGetCampaignMissionRewardReply
         * @instance
         */
        GGetCampaignMissionRewardReply.prototype.Gold = 0;

        /**
         * GGetCampaignMissionRewardReply CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.GGetCampaignMissionRewardReply
         * @instance
         */
        GGetCampaignMissionRewardReply.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new GGetCampaignMissionRewardReply instance using the specified properties.
         * @function create
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {pb.IGGetCampaignMissionRewardReply=} [properties] Properties to set
         * @returns {pb.GGetCampaignMissionRewardReply} GGetCampaignMissionRewardReply instance
         */
        GGetCampaignMissionRewardReply.create = function create(properties) {
            return new GGetCampaignMissionRewardReply(properties);
        };

        /**
         * Encodes the specified GGetCampaignMissionRewardReply message. Does not implicitly {@link pb.GGetCampaignMissionRewardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {pb.IGGetCampaignMissionRewardReply} message GGetCampaignMissionRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GGetCampaignMissionRewardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified GGetCampaignMissionRewardReply message, length delimited. Does not implicitly {@link pb.GGetCampaignMissionRewardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {pb.IGGetCampaignMissionRewardReply} message GGetCampaignMissionRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GGetCampaignMissionRewardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GGetCampaignMissionRewardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GGetCampaignMissionRewardReply} GGetCampaignMissionRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GGetCampaignMissionRewardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GGetCampaignMissionRewardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3:
                    message.Gold = reader.int32();
                    break;
                case 2:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GGetCampaignMissionRewardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GGetCampaignMissionRewardReply} GGetCampaignMissionRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GGetCampaignMissionRewardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GGetCampaignMissionRewardReply message.
         * @function verify
         * @memberof pb.GGetCampaignMissionRewardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GGetCampaignMissionRewardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return GGetCampaignMissionRewardReply;
    })();

    pb.GetMyCountryReply = (function() {

        /**
         * Properties of a GetMyCountryReply.
         * @memberof pb
         * @interface IGetMyCountryReply
         * @property {number|null} [CountryID] GetMyCountryReply CountryID
         */

        /**
         * Constructs a new GetMyCountryReply.
         * @memberof pb
         * @classdesc Represents a GetMyCountryReply.
         * @implements IGetMyCountryReply
         * @constructor
         * @param {pb.IGetMyCountryReply=} [properties] Properties to set
         */
        function GetMyCountryReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMyCountryReply CountryID.
         * @member {number} CountryID
         * @memberof pb.GetMyCountryReply
         * @instance
         */
        GetMyCountryReply.prototype.CountryID = 0;

        /**
         * Creates a new GetMyCountryReply instance using the specified properties.
         * @function create
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {pb.IGetMyCountryReply=} [properties] Properties to set
         * @returns {pb.GetMyCountryReply} GetMyCountryReply instance
         */
        GetMyCountryReply.create = function create(properties) {
            return new GetMyCountryReply(properties);
        };

        /**
         * Encodes the specified GetMyCountryReply message. Does not implicitly {@link pb.GetMyCountryReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {pb.IGetMyCountryReply} message GetMyCountryReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMyCountryReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            return writer;
        };

        /**
         * Encodes the specified GetMyCountryReply message, length delimited. Does not implicitly {@link pb.GetMyCountryReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {pb.IGetMyCountryReply} message GetMyCountryReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMyCountryReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMyCountryReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetMyCountryReply} GetMyCountryReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMyCountryReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetMyCountryReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMyCountryReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetMyCountryReply} GetMyCountryReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMyCountryReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMyCountryReply message.
         * @function verify
         * @memberof pb.GetMyCountryReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMyCountryReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            return null;
        };

        return GetMyCountryReply;
    })();

    pb.MoveCityArg = (function() {

        /**
         * Properties of a MoveCityArg.
         * @memberof pb
         * @interface IMoveCityArg
         * @property {number|null} [CityID] MoveCityArg CityID
         * @property {number|null} [Gold] MoveCityArg Gold
         */

        /**
         * Constructs a new MoveCityArg.
         * @memberof pb
         * @classdesc Represents a MoveCityArg.
         * @implements IMoveCityArg
         * @constructor
         * @param {pb.IMoveCityArg=} [properties] Properties to set
         */
        function MoveCityArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveCityArg CityID.
         * @member {number} CityID
         * @memberof pb.MoveCityArg
         * @instance
         */
        MoveCityArg.prototype.CityID = 0;

        /**
         * MoveCityArg Gold.
         * @member {number} Gold
         * @memberof pb.MoveCityArg
         * @instance
         */
        MoveCityArg.prototype.Gold = 0;

        /**
         * Creates a new MoveCityArg instance using the specified properties.
         * @function create
         * @memberof pb.MoveCityArg
         * @static
         * @param {pb.IMoveCityArg=} [properties] Properties to set
         * @returns {pb.MoveCityArg} MoveCityArg instance
         */
        MoveCityArg.create = function create(properties) {
            return new MoveCityArg(properties);
        };

        /**
         * Encodes the specified MoveCityArg message. Does not implicitly {@link pb.MoveCityArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MoveCityArg
         * @static
         * @param {pb.IMoveCityArg} message MoveCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCityArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CityID);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified MoveCityArg message, length delimited. Does not implicitly {@link pb.MoveCityArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MoveCityArg
         * @static
         * @param {pb.IMoveCityArg} message MoveCityArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCityArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveCityArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MoveCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MoveCityArg} MoveCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCityArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveCityArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CityID = reader.int32();
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveCityArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MoveCityArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MoveCityArg} MoveCityArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCityArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveCityArg message.
         * @function verify
         * @memberof pb.MoveCityArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveCityArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return MoveCityArg;
    })();

    pb.MoveCityRelpy = (function() {

        /**
         * Properties of a MoveCityRelpy.
         * @memberof pb
         * @interface IMoveCityRelpy
         * @property {boolean|null} [NeedGold] MoveCityRelpy NeedGold
         */

        /**
         * Constructs a new MoveCityRelpy.
         * @memberof pb
         * @classdesc Represents a MoveCityRelpy.
         * @implements IMoveCityRelpy
         * @constructor
         * @param {pb.IMoveCityRelpy=} [properties] Properties to set
         */
        function MoveCityRelpy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MoveCityRelpy NeedGold.
         * @member {boolean} NeedGold
         * @memberof pb.MoveCityRelpy
         * @instance
         */
        MoveCityRelpy.prototype.NeedGold = false;

        /**
         * Creates a new MoveCityRelpy instance using the specified properties.
         * @function create
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {pb.IMoveCityRelpy=} [properties] Properties to set
         * @returns {pb.MoveCityRelpy} MoveCityRelpy instance
         */
        MoveCityRelpy.create = function create(properties) {
            return new MoveCityRelpy(properties);
        };

        /**
         * Encodes the specified MoveCityRelpy message. Does not implicitly {@link pb.MoveCityRelpy.verify|verify} messages.
         * @function encode
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {pb.IMoveCityRelpy} message MoveCityRelpy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCityRelpy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.NeedGold != null && message.hasOwnProperty("NeedGold"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.NeedGold);
            return writer;
        };

        /**
         * Encodes the specified MoveCityRelpy message, length delimited. Does not implicitly {@link pb.MoveCityRelpy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {pb.IMoveCityRelpy} message MoveCityRelpy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MoveCityRelpy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MoveCityRelpy message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MoveCityRelpy} MoveCityRelpy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCityRelpy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MoveCityRelpy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.NeedGold = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MoveCityRelpy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MoveCityRelpy} MoveCityRelpy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MoveCityRelpy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MoveCityRelpy message.
         * @function verify
         * @memberof pb.MoveCityRelpy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MoveCityRelpy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.NeedGold != null && message.hasOwnProperty("NeedGold"))
                if (typeof message.NeedGold !== "boolean")
                    return "NeedGold: boolean expected";
            return null;
        };

        return MoveCityRelpy;
    })();

    pb.CampaignBattleEnd = (function() {

        /**
         * Properties of a CampaignBattleEnd.
         * @memberof pb
         * @interface ICampaignBattleEnd
         * @property {boolean|null} [IsWin] CampaignBattleEnd IsWin
         */

        /**
         * Constructs a new CampaignBattleEnd.
         * @memberof pb
         * @classdesc Represents a CampaignBattleEnd.
         * @implements ICampaignBattleEnd
         * @constructor
         * @param {pb.ICampaignBattleEnd=} [properties] Properties to set
         */
        function CampaignBattleEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CampaignBattleEnd IsWin.
         * @member {boolean} IsWin
         * @memberof pb.CampaignBattleEnd
         * @instance
         */
        CampaignBattleEnd.prototype.IsWin = false;

        /**
         * Creates a new CampaignBattleEnd instance using the specified properties.
         * @function create
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {pb.ICampaignBattleEnd=} [properties] Properties to set
         * @returns {pb.CampaignBattleEnd} CampaignBattleEnd instance
         */
        CampaignBattleEnd.create = function create(properties) {
            return new CampaignBattleEnd(properties);
        };

        /**
         * Encodes the specified CampaignBattleEnd message. Does not implicitly {@link pb.CampaignBattleEnd.verify|verify} messages.
         * @function encode
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {pb.ICampaignBattleEnd} message CampaignBattleEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignBattleEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsWin);
            return writer;
        };

        /**
         * Encodes the specified CampaignBattleEnd message, length delimited. Does not implicitly {@link pb.CampaignBattleEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {pb.ICampaignBattleEnd} message CampaignBattleEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CampaignBattleEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CampaignBattleEnd message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CampaignBattleEnd} CampaignBattleEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignBattleEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CampaignBattleEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsWin = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CampaignBattleEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CampaignBattleEnd} CampaignBattleEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CampaignBattleEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CampaignBattleEnd message.
         * @function verify
         * @memberof pb.CampaignBattleEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CampaignBattleEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                if (typeof message.IsWin !== "boolean")
                    return "IsWin: boolean expected";
            return null;
        };

        return CampaignBattleEnd;
    })();

    pb.GCampaignPlayerInfo = (function() {

        /**
         * Properties of a GCampaignPlayerInfo.
         * @memberof pb
         * @interface IGCampaignPlayerInfo
         * @property {number|null} [CountryID] GCampaignPlayerInfo CountryID
         * @property {number|null} [CityID] GCampaignPlayerInfo CityID
         * @property {pb.CampaignJob|null} [CityJob] GCampaignPlayerInfo CityJob
         * @property {pb.CampaignJob|null} [CountryJob] GCampaignPlayerInfo CountryJob
         * @property {string|null} [CountryName] GCampaignPlayerInfo CountryName
         * @property {Array.<pb.ICampaignNotice>|null} [Notices] GCampaignPlayerInfo Notices
         */

        /**
         * Constructs a new GCampaignPlayerInfo.
         * @memberof pb
         * @classdesc Represents a GCampaignPlayerInfo.
         * @implements IGCampaignPlayerInfo
         * @constructor
         * @param {pb.IGCampaignPlayerInfo=} [properties] Properties to set
         */
        function GCampaignPlayerInfo(properties) {
            this.Notices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GCampaignPlayerInfo CountryID.
         * @member {number} CountryID
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.CountryID = 0;

        /**
         * GCampaignPlayerInfo CityID.
         * @member {number} CityID
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.CityID = 0;

        /**
         * GCampaignPlayerInfo CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.CityJob = 0;

        /**
         * GCampaignPlayerInfo CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.CountryJob = 0;

        /**
         * GCampaignPlayerInfo CountryName.
         * @member {string} CountryName
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.CountryName = "";

        /**
         * GCampaignPlayerInfo Notices.
         * @member {Array.<pb.ICampaignNotice>} Notices
         * @memberof pb.GCampaignPlayerInfo
         * @instance
         */
        GCampaignPlayerInfo.prototype.Notices = $util.emptyArray;

        /**
         * Creates a new GCampaignPlayerInfo instance using the specified properties.
         * @function create
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {pb.IGCampaignPlayerInfo=} [properties] Properties to set
         * @returns {pb.GCampaignPlayerInfo} GCampaignPlayerInfo instance
         */
        GCampaignPlayerInfo.create = function create(properties) {
            return new GCampaignPlayerInfo(properties);
        };

        /**
         * Encodes the specified GCampaignPlayerInfo message. Does not implicitly {@link pb.GCampaignPlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {pb.IGCampaignPlayerInfo} message GCampaignPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCampaignPlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CountryID);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CityID);
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.CountryJob);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.CountryName);
            if (message.Notices != null && message.Notices.length)
                for (var i = 0; i < message.Notices.length; ++i)
                    $root.pb.CampaignNotice.encode(message.Notices[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GCampaignPlayerInfo message, length delimited. Does not implicitly {@link pb.GCampaignPlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {pb.IGCampaignPlayerInfo} message GCampaignPlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCampaignPlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GCampaignPlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GCampaignPlayerInfo} GCampaignPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCampaignPlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GCampaignPlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CountryID = reader.uint32();
                    break;
                case 2:
                    message.CityID = reader.int32();
                    break;
                case 3:
                    message.CityJob = reader.int32();
                    break;
                case 4:
                    message.CountryJob = reader.int32();
                    break;
                case 5:
                    message.CountryName = reader.string();
                    break;
                case 6:
                    if (!(message.Notices && message.Notices.length))
                        message.Notices = [];
                    message.Notices.push($root.pb.CampaignNotice.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GCampaignPlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GCampaignPlayerInfo} GCampaignPlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCampaignPlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GCampaignPlayerInfo message.
         * @function verify
         * @memberof pb.GCampaignPlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GCampaignPlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            if (message.Notices != null && message.hasOwnProperty("Notices")) {
                if (!Array.isArray(message.Notices))
                    return "Notices: array expected";
                for (var i = 0; i < message.Notices.length; ++i) {
                    var error = $root.pb.CampaignNotice.verify(message.Notices[i]);
                    if (error)
                        return "Notices." + error;
                }
            }
            return null;
        };

        return GCampaignPlayerInfo;
    })();

    pb.GCampaignInfo = (function() {

        /**
         * Properties of a GCampaignInfo.
         * @memberof pb
         * @interface IGCampaignInfo
         * @property {number|null} [Version] GCampaignInfo Version
         * @property {number|null} [CampaignState] GCampaignInfo CampaignState
         */

        /**
         * Constructs a new GCampaignInfo.
         * @memberof pb
         * @classdesc Represents a GCampaignInfo.
         * @implements IGCampaignInfo
         * @constructor
         * @param {pb.IGCampaignInfo=} [properties] Properties to set
         */
        function GCampaignInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GCampaignInfo Version.
         * @member {number} Version
         * @memberof pb.GCampaignInfo
         * @instance
         */
        GCampaignInfo.prototype.Version = 0;

        /**
         * GCampaignInfo CampaignState.
         * @member {number} CampaignState
         * @memberof pb.GCampaignInfo
         * @instance
         */
        GCampaignInfo.prototype.CampaignState = 0;

        /**
         * Creates a new GCampaignInfo instance using the specified properties.
         * @function create
         * @memberof pb.GCampaignInfo
         * @static
         * @param {pb.IGCampaignInfo=} [properties] Properties to set
         * @returns {pb.GCampaignInfo} GCampaignInfo instance
         */
        GCampaignInfo.create = function create(properties) {
            return new GCampaignInfo(properties);
        };

        /**
         * Encodes the specified GCampaignInfo message. Does not implicitly {@link pb.GCampaignInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.GCampaignInfo
         * @static
         * @param {pb.IGCampaignInfo} message GCampaignInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCampaignInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Version != null && message.hasOwnProperty("Version"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Version);
            if (message.CampaignState != null && message.hasOwnProperty("CampaignState"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CampaignState);
            return writer;
        };

        /**
         * Encodes the specified GCampaignInfo message, length delimited. Does not implicitly {@link pb.GCampaignInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GCampaignInfo
         * @static
         * @param {pb.IGCampaignInfo} message GCampaignInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCampaignInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GCampaignInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GCampaignInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GCampaignInfo} GCampaignInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCampaignInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GCampaignInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Version = reader.int32();
                    break;
                case 2:
                    message.CampaignState = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GCampaignInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GCampaignInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GCampaignInfo} GCampaignInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCampaignInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GCampaignInfo message.
         * @function verify
         * @memberof pb.GCampaignInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GCampaignInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Version != null && message.hasOwnProperty("Version"))
                if (!$util.isInteger(message.Version))
                    return "Version: integer expected";
            if (message.CampaignState != null && message.hasOwnProperty("CampaignState"))
                if (!$util.isInteger(message.CampaignState))
                    return "CampaignState: integer expected";
            return null;
        };

        return GCampaignInfo;
    })();

    pb.ModifyContributionArg = (function() {

        /**
         * Properties of a ModifyContributionArg.
         * @memberof pb
         * @interface IModifyContributionArg
         * @property {number|Long|null} [Uid] ModifyContributionArg Uid
         * @property {number|null} [Amount] ModifyContributionArg Amount
         */

        /**
         * Constructs a new ModifyContributionArg.
         * @memberof pb
         * @classdesc Represents a ModifyContributionArg.
         * @implements IModifyContributionArg
         * @constructor
         * @param {pb.IModifyContributionArg=} [properties] Properties to set
         */
        function ModifyContributionArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyContributionArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.ModifyContributionArg
         * @instance
         */
        ModifyContributionArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ModifyContributionArg Amount.
         * @member {number} Amount
         * @memberof pb.ModifyContributionArg
         * @instance
         */
        ModifyContributionArg.prototype.Amount = 0;

        /**
         * Creates a new ModifyContributionArg instance using the specified properties.
         * @function create
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {pb.IModifyContributionArg=} [properties] Properties to set
         * @returns {pb.ModifyContributionArg} ModifyContributionArg instance
         */
        ModifyContributionArg.create = function create(properties) {
            return new ModifyContributionArg(properties);
        };

        /**
         * Encodes the specified ModifyContributionArg message. Does not implicitly {@link pb.ModifyContributionArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {pb.IModifyContributionArg} message ModifyContributionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyContributionArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified ModifyContributionArg message, length delimited. Does not implicitly {@link pb.ModifyContributionArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {pb.IModifyContributionArg} message ModifyContributionArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyContributionArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyContributionArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ModifyContributionArg} ModifyContributionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyContributionArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ModifyContributionArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyContributionArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ModifyContributionArg} ModifyContributionArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyContributionArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyContributionArg message.
         * @function verify
         * @memberof pb.ModifyContributionArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyContributionArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return ModifyContributionArg;
    })();

    pb.GAcceptCampaignMissionReply = (function() {

        /**
         * Properties of a GAcceptCampaignMissionReply.
         * @memberof pb
         * @interface IGAcceptCampaignMissionReply
         * @property {pb.IAcceptCampaignMissionReply|null} [AcceptReply] GAcceptCampaignMissionReply AcceptReply
         * @property {number|null} [RewardGold] GAcceptCampaignMissionReply RewardGold
         */

        /**
         * Constructs a new GAcceptCampaignMissionReply.
         * @memberof pb
         * @classdesc Represents a GAcceptCampaignMissionReply.
         * @implements IGAcceptCampaignMissionReply
         * @constructor
         * @param {pb.IGAcceptCampaignMissionReply=} [properties] Properties to set
         */
        function GAcceptCampaignMissionReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GAcceptCampaignMissionReply AcceptReply.
         * @member {pb.IAcceptCampaignMissionReply|null|undefined} AcceptReply
         * @memberof pb.GAcceptCampaignMissionReply
         * @instance
         */
        GAcceptCampaignMissionReply.prototype.AcceptReply = null;

        /**
         * GAcceptCampaignMissionReply RewardGold.
         * @member {number} RewardGold
         * @memberof pb.GAcceptCampaignMissionReply
         * @instance
         */
        GAcceptCampaignMissionReply.prototype.RewardGold = 0;

        /**
         * Creates a new GAcceptCampaignMissionReply instance using the specified properties.
         * @function create
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {pb.IGAcceptCampaignMissionReply=} [properties] Properties to set
         * @returns {pb.GAcceptCampaignMissionReply} GAcceptCampaignMissionReply instance
         */
        GAcceptCampaignMissionReply.create = function create(properties) {
            return new GAcceptCampaignMissionReply(properties);
        };

        /**
         * Encodes the specified GAcceptCampaignMissionReply message. Does not implicitly {@link pb.GAcceptCampaignMissionReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {pb.IGAcceptCampaignMissionReply} message GAcceptCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GAcceptCampaignMissionReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AcceptReply != null && message.hasOwnProperty("AcceptReply"))
                $root.pb.AcceptCampaignMissionReply.encode(message.AcceptReply, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.RewardGold != null && message.hasOwnProperty("RewardGold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RewardGold);
            return writer;
        };

        /**
         * Encodes the specified GAcceptCampaignMissionReply message, length delimited. Does not implicitly {@link pb.GAcceptCampaignMissionReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {pb.IGAcceptCampaignMissionReply} message GAcceptCampaignMissionReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GAcceptCampaignMissionReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GAcceptCampaignMissionReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GAcceptCampaignMissionReply} GAcceptCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GAcceptCampaignMissionReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GAcceptCampaignMissionReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AcceptReply = $root.pb.AcceptCampaignMissionReply.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.RewardGold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GAcceptCampaignMissionReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GAcceptCampaignMissionReply} GAcceptCampaignMissionReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GAcceptCampaignMissionReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GAcceptCampaignMissionReply message.
         * @function verify
         * @memberof pb.GAcceptCampaignMissionReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GAcceptCampaignMissionReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AcceptReply != null && message.hasOwnProperty("AcceptReply")) {
                var error = $root.pb.AcceptCampaignMissionReply.verify(message.AcceptReply);
                if (error)
                    return "AcceptReply." + error;
            }
            if (message.RewardGold != null && message.hasOwnProperty("RewardGold"))
                if (!$util.isInteger(message.RewardGold))
                    return "RewardGold: integer expected";
            return null;
        };

        return GAcceptCampaignMissionReply;
    })();

    pb.GmCommand = (function() {

        /**
         * Properties of a GmCommand.
         * @memberof pb
         * @interface IGmCommand
         * @property {string|null} [Command] GmCommand Command
         */

        /**
         * Constructs a new GmCommand.
         * @memberof pb
         * @classdesc Represents a GmCommand.
         * @implements IGmCommand
         * @constructor
         * @param {pb.IGmCommand=} [properties] Properties to set
         */
        function GmCommand(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GmCommand Command.
         * @member {string} Command
         * @memberof pb.GmCommand
         * @instance
         */
        GmCommand.prototype.Command = "";

        /**
         * Creates a new GmCommand instance using the specified properties.
         * @function create
         * @memberof pb.GmCommand
         * @static
         * @param {pb.IGmCommand=} [properties] Properties to set
         * @returns {pb.GmCommand} GmCommand instance
         */
        GmCommand.create = function create(properties) {
            return new GmCommand(properties);
        };

        /**
         * Encodes the specified GmCommand message. Does not implicitly {@link pb.GmCommand.verify|verify} messages.
         * @function encode
         * @memberof pb.GmCommand
         * @static
         * @param {pb.IGmCommand} message GmCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GmCommand.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Command != null && message.hasOwnProperty("Command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Command);
            return writer;
        };

        /**
         * Encodes the specified GmCommand message, length delimited. Does not implicitly {@link pb.GmCommand.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GmCommand
         * @static
         * @param {pb.IGmCommand} message GmCommand message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GmCommand.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GmCommand message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GmCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GmCommand} GmCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GmCommand.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GmCommand();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GmCommand message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GmCommand
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GmCommand} GmCommand
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GmCommand.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GmCommand message.
         * @function verify
         * @memberof pb.GmCommand
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GmCommand.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Command != null && message.hasOwnProperty("Command"))
                if (!$util.isString(message.Command))
                    return "Command: string expected";
            return null;
        };

        return GmCommand;
    })();

    pb.ExchangeCodeArg = (function() {

        /**
         * Properties of an ExchangeCodeArg.
         * @memberof pb
         * @interface IExchangeCodeArg
         * @property {string|null} [Code] ExchangeCodeArg Code
         */

        /**
         * Constructs a new ExchangeCodeArg.
         * @memberof pb
         * @classdesc Represents an ExchangeCodeArg.
         * @implements IExchangeCodeArg
         * @constructor
         * @param {pb.IExchangeCodeArg=} [properties] Properties to set
         */
        function ExchangeCodeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeCodeArg Code.
         * @member {string} Code
         * @memberof pb.ExchangeCodeArg
         * @instance
         */
        ExchangeCodeArg.prototype.Code = "";

        /**
         * Creates a new ExchangeCodeArg instance using the specified properties.
         * @function create
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {pb.IExchangeCodeArg=} [properties] Properties to set
         * @returns {pb.ExchangeCodeArg} ExchangeCodeArg instance
         */
        ExchangeCodeArg.create = function create(properties) {
            return new ExchangeCodeArg(properties);
        };

        /**
         * Encodes the specified ExchangeCodeArg message. Does not implicitly {@link pb.ExchangeCodeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {pb.IExchangeCodeArg} message ExchangeCodeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCodeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Code != null && message.hasOwnProperty("Code"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Code);
            return writer;
        };

        /**
         * Encodes the specified ExchangeCodeArg message, length delimited. Does not implicitly {@link pb.ExchangeCodeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {pb.IExchangeCodeArg} message ExchangeCodeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCodeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeCodeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ExchangeCodeArg} ExchangeCodeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCodeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExchangeCodeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeCodeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ExchangeCodeArg} ExchangeCodeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCodeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeCodeArg message.
         * @function verify
         * @memberof pb.ExchangeCodeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeCodeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Code != null && message.hasOwnProperty("Code"))
                if (!$util.isString(message.Code))
                    return "Code: string expected";
            return null;
        };

        return ExchangeCodeArg;
    })();

    pb.ExchangeCodeReward = (function() {

        /**
         * Properties of an ExchangeCodeReward.
         * @memberof pb
         * @interface IExchangeCodeReward
         * @property {string|null} [TreasureID] ExchangeCodeReward TreasureID
         * @property {pb.IOpenTreasureReply|null} [Reward] ExchangeCodeReward Reward
         */

        /**
         * Constructs a new ExchangeCodeReward.
         * @memberof pb
         * @classdesc Represents an ExchangeCodeReward.
         * @implements IExchangeCodeReward
         * @constructor
         * @param {pb.IExchangeCodeReward=} [properties] Properties to set
         */
        function ExchangeCodeReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ExchangeCodeReward TreasureID.
         * @member {string} TreasureID
         * @memberof pb.ExchangeCodeReward
         * @instance
         */
        ExchangeCodeReward.prototype.TreasureID = "";

        /**
         * ExchangeCodeReward Reward.
         * @member {pb.IOpenTreasureReply|null|undefined} Reward
         * @memberof pb.ExchangeCodeReward
         * @instance
         */
        ExchangeCodeReward.prototype.Reward = null;

        /**
         * Creates a new ExchangeCodeReward instance using the specified properties.
         * @function create
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {pb.IExchangeCodeReward=} [properties] Properties to set
         * @returns {pb.ExchangeCodeReward} ExchangeCodeReward instance
         */
        ExchangeCodeReward.create = function create(properties) {
            return new ExchangeCodeReward(properties);
        };

        /**
         * Encodes the specified ExchangeCodeReward message. Does not implicitly {@link pb.ExchangeCodeReward.verify|verify} messages.
         * @function encode
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {pb.IExchangeCodeReward} message ExchangeCodeReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCodeReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.TreasureID);
            if (message.Reward != null && message.hasOwnProperty("Reward"))
                $root.pb.OpenTreasureReply.encode(message.Reward, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ExchangeCodeReward message, length delimited. Does not implicitly {@link pb.ExchangeCodeReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {pb.IExchangeCodeReward} message ExchangeCodeReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ExchangeCodeReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ExchangeCodeReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ExchangeCodeReward} ExchangeCodeReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCodeReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ExchangeCodeReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.string();
                    break;
                case 2:
                    message.Reward = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ExchangeCodeReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ExchangeCodeReward} ExchangeCodeReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ExchangeCodeReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ExchangeCodeReward message.
         * @function verify
         * @memberof pb.ExchangeCodeReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ExchangeCodeReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isString(message.TreasureID))
                    return "TreasureID: string expected";
            if (message.Reward != null && message.hasOwnProperty("Reward")) {
                var error = $root.pb.OpenTreasureReply.verify(message.Reward);
                if (error)
                    return "Reward." + error;
            }
            return null;
        };

        return ExchangeCodeReward;
    })();

    pb.Equip = (function() {

        /**
         * Properties of an Equip.
         * @memberof pb
         * @interface IEquip
         * @property {string|null} [EquipID] Equip EquipID
         * @property {number|null} [OwnerCardID] Equip OwnerCardID
         */

        /**
         * Constructs a new Equip.
         * @memberof pb
         * @classdesc Represents an Equip.
         * @implements IEquip
         * @constructor
         * @param {pb.IEquip=} [properties] Properties to set
         */
        function Equip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Equip EquipID.
         * @member {string} EquipID
         * @memberof pb.Equip
         * @instance
         */
        Equip.prototype.EquipID = "";

        /**
         * Equip OwnerCardID.
         * @member {number} OwnerCardID
         * @memberof pb.Equip
         * @instance
         */
        Equip.prototype.OwnerCardID = 0;

        /**
         * Creates a new Equip instance using the specified properties.
         * @function create
         * @memberof pb.Equip
         * @static
         * @param {pb.IEquip=} [properties] Properties to set
         * @returns {pb.Equip} Equip instance
         */
        Equip.create = function create(properties) {
            return new Equip(properties);
        };

        /**
         * Encodes the specified Equip message. Does not implicitly {@link pb.Equip.verify|verify} messages.
         * @function encode
         * @memberof pb.Equip
         * @static
         * @param {pb.IEquip} message Equip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Equip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.EquipID);
            if (message.OwnerCardID != null && message.hasOwnProperty("OwnerCardID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.OwnerCardID);
            return writer;
        };

        /**
         * Encodes the specified Equip message, length delimited. Does not implicitly {@link pb.Equip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Equip
         * @static
         * @param {pb.IEquip} message Equip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Equip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Equip message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Equip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Equip} Equip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Equip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Equip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.EquipID = reader.string();
                    break;
                case 2:
                    message.OwnerCardID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Equip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Equip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Equip} Equip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Equip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Equip message.
         * @function verify
         * @memberof pb.Equip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Equip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                if (!$util.isString(message.EquipID))
                    return "EquipID: string expected";
            if (message.OwnerCardID != null && message.hasOwnProperty("OwnerCardID"))
                if (!$util.isInteger(message.OwnerCardID))
                    return "OwnerCardID: integer expected";
            return null;
        };

        return Equip;
    })();

    pb.EquipData = (function() {

        /**
         * Properties of an EquipData.
         * @memberof pb
         * @interface IEquipData
         * @property {Array.<pb.IEquip>|null} [Equips] EquipData Equips
         */

        /**
         * Constructs a new EquipData.
         * @memberof pb
         * @classdesc Represents an EquipData.
         * @implements IEquipData
         * @constructor
         * @param {pb.IEquipData=} [properties] Properties to set
         */
        function EquipData(properties) {
            this.Equips = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EquipData Equips.
         * @member {Array.<pb.IEquip>} Equips
         * @memberof pb.EquipData
         * @instance
         */
        EquipData.prototype.Equips = $util.emptyArray;

        /**
         * Creates a new EquipData instance using the specified properties.
         * @function create
         * @memberof pb.EquipData
         * @static
         * @param {pb.IEquipData=} [properties] Properties to set
         * @returns {pb.EquipData} EquipData instance
         */
        EquipData.create = function create(properties) {
            return new EquipData(properties);
        };

        /**
         * Encodes the specified EquipData message. Does not implicitly {@link pb.EquipData.verify|verify} messages.
         * @function encode
         * @memberof pb.EquipData
         * @static
         * @param {pb.IEquipData} message EquipData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Equips != null && message.Equips.length)
                for (var i = 0; i < message.Equips.length; ++i)
                    $root.pb.Equip.encode(message.Equips[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EquipData message, length delimited. Does not implicitly {@link pb.EquipData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EquipData
         * @static
         * @param {pb.IEquipData} message EquipData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EquipData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EquipData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EquipData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EquipData} EquipData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EquipData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Equips && message.Equips.length))
                        message.Equips = [];
                    message.Equips.push($root.pb.Equip.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EquipData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EquipData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EquipData} EquipData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EquipData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EquipData message.
         * @function verify
         * @memberof pb.EquipData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EquipData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Equips != null && message.hasOwnProperty("Equips")) {
                if (!Array.isArray(message.Equips))
                    return "Equips: array expected";
                for (var i = 0; i < message.Equips.length; ++i) {
                    var error = $root.pb.Equip.verify(message.Equips[i]);
                    if (error)
                        return "Equips." + error;
                }
            }
            return null;
        };

        return EquipData;
    })();

    pb.TargetEquip = (function() {

        /**
         * Properties of a TargetEquip.
         * @memberof pb
         * @interface ITargetEquip
         * @property {string|null} [EquipID] TargetEquip EquipID
         */

        /**
         * Constructs a new TargetEquip.
         * @memberof pb
         * @classdesc Represents a TargetEquip.
         * @implements ITargetEquip
         * @constructor
         * @param {pb.ITargetEquip=} [properties] Properties to set
         */
        function TargetEquip(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetEquip EquipID.
         * @member {string} EquipID
         * @memberof pb.TargetEquip
         * @instance
         */
        TargetEquip.prototype.EquipID = "";

        /**
         * Creates a new TargetEquip instance using the specified properties.
         * @function create
         * @memberof pb.TargetEquip
         * @static
         * @param {pb.ITargetEquip=} [properties] Properties to set
         * @returns {pb.TargetEquip} TargetEquip instance
         */
        TargetEquip.create = function create(properties) {
            return new TargetEquip(properties);
        };

        /**
         * Encodes the specified TargetEquip message. Does not implicitly {@link pb.TargetEquip.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetEquip
         * @static
         * @param {pb.ITargetEquip} message TargetEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetEquip.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.EquipID);
            return writer;
        };

        /**
         * Encodes the specified TargetEquip message, length delimited. Does not implicitly {@link pb.TargetEquip.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetEquip
         * @static
         * @param {pb.ITargetEquip} message TargetEquip message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetEquip.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetEquip message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetEquip} TargetEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetEquip.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetEquip();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.EquipID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetEquip message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetEquip
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetEquip} TargetEquip
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetEquip.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetEquip message.
         * @function verify
         * @memberof pb.TargetEquip
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetEquip.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EquipID != null && message.hasOwnProperty("EquipID"))
                if (!$util.isString(message.EquipID))
                    return "EquipID: string expected";
            return null;
        };

        return TargetEquip;
    })();

    pb.AccountTypeOnlineInfo = (function() {

        /**
         * Properties of an AccountTypeOnlineInfo.
         * @memberof pb
         * @interface IAccountTypeOnlineInfo
         * @property {pb.AccountTypeEnum|null} [AccountType] AccountTypeOnlineInfo AccountType
         * @property {number|null} [PlayerAmount] AccountTypeOnlineInfo PlayerAmount
         * @property {number|null} [TotalOnlineTime] AccountTypeOnlineInfo TotalOnlineTime
         */

        /**
         * Constructs a new AccountTypeOnlineInfo.
         * @memberof pb
         * @classdesc Represents an AccountTypeOnlineInfo.
         * @implements IAccountTypeOnlineInfo
         * @constructor
         * @param {pb.IAccountTypeOnlineInfo=} [properties] Properties to set
         */
        function AccountTypeOnlineInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountTypeOnlineInfo AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.AccountTypeOnlineInfo
         * @instance
         */
        AccountTypeOnlineInfo.prototype.AccountType = 0;

        /**
         * AccountTypeOnlineInfo PlayerAmount.
         * @member {number} PlayerAmount
         * @memberof pb.AccountTypeOnlineInfo
         * @instance
         */
        AccountTypeOnlineInfo.prototype.PlayerAmount = 0;

        /**
         * AccountTypeOnlineInfo TotalOnlineTime.
         * @member {number} TotalOnlineTime
         * @memberof pb.AccountTypeOnlineInfo
         * @instance
         */
        AccountTypeOnlineInfo.prototype.TotalOnlineTime = 0;

        /**
         * Creates a new AccountTypeOnlineInfo instance using the specified properties.
         * @function create
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {pb.IAccountTypeOnlineInfo=} [properties] Properties to set
         * @returns {pb.AccountTypeOnlineInfo} AccountTypeOnlineInfo instance
         */
        AccountTypeOnlineInfo.create = function create(properties) {
            return new AccountTypeOnlineInfo(properties);
        };

        /**
         * Encodes the specified AccountTypeOnlineInfo message. Does not implicitly {@link pb.AccountTypeOnlineInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {pb.IAccountTypeOnlineInfo} message AccountTypeOnlineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTypeOnlineInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PlayerAmount);
            if (message.TotalOnlineTime != null && message.hasOwnProperty("TotalOnlineTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.TotalOnlineTime);
            return writer;
        };

        /**
         * Encodes the specified AccountTypeOnlineInfo message, length delimited. Does not implicitly {@link pb.AccountTypeOnlineInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {pb.IAccountTypeOnlineInfo} message AccountTypeOnlineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountTypeOnlineInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountTypeOnlineInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AccountTypeOnlineInfo} AccountTypeOnlineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTypeOnlineInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AccountTypeOnlineInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    message.PlayerAmount = reader.int32();
                    break;
                case 3:
                    message.TotalOnlineTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountTypeOnlineInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AccountTypeOnlineInfo} AccountTypeOnlineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountTypeOnlineInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountTypeOnlineInfo message.
         * @function verify
         * @memberof pb.AccountTypeOnlineInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountTypeOnlineInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.PlayerAmount != null && message.hasOwnProperty("PlayerAmount"))
                if (!$util.isInteger(message.PlayerAmount))
                    return "PlayerAmount: integer expected";
            if (message.TotalOnlineTime != null && message.hasOwnProperty("TotalOnlineTime"))
                if (!$util.isInteger(message.TotalOnlineTime))
                    return "TotalOnlineTime: integer expected";
            return null;
        };

        return AccountTypeOnlineInfo;
    })();

    pb.OnlineInfo = (function() {

        /**
         * Properties of an OnlineInfo.
         * @memberof pb
         * @interface IOnlineInfo
         * @property {Array.<pb.IAccountTypeOnlineInfo>|null} [Infos] OnlineInfo Infos
         */

        /**
         * Constructs a new OnlineInfo.
         * @memberof pb
         * @classdesc Represents an OnlineInfo.
         * @implements IOnlineInfo
         * @constructor
         * @param {pb.IOnlineInfo=} [properties] Properties to set
         */
        function OnlineInfo(properties) {
            this.Infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OnlineInfo Infos.
         * @member {Array.<pb.IAccountTypeOnlineInfo>} Infos
         * @memberof pb.OnlineInfo
         * @instance
         */
        OnlineInfo.prototype.Infos = $util.emptyArray;

        /**
         * Creates a new OnlineInfo instance using the specified properties.
         * @function create
         * @memberof pb.OnlineInfo
         * @static
         * @param {pb.IOnlineInfo=} [properties] Properties to set
         * @returns {pb.OnlineInfo} OnlineInfo instance
         */
        OnlineInfo.create = function create(properties) {
            return new OnlineInfo(properties);
        };

        /**
         * Encodes the specified OnlineInfo message. Does not implicitly {@link pb.OnlineInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.OnlineInfo
         * @static
         * @param {pb.IOnlineInfo} message OnlineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Infos != null && message.Infos.length)
                for (var i = 0; i < message.Infos.length; ++i)
                    $root.pb.AccountTypeOnlineInfo.encode(message.Infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OnlineInfo message, length delimited. Does not implicitly {@link pb.OnlineInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OnlineInfo
         * @static
         * @param {pb.IOnlineInfo} message OnlineInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OnlineInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OnlineInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OnlineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OnlineInfo} OnlineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OnlineInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Infos && message.Infos.length))
                        message.Infos = [];
                    message.Infos.push($root.pb.AccountTypeOnlineInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OnlineInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OnlineInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OnlineInfo} OnlineInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OnlineInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OnlineInfo message.
         * @function verify
         * @memberof pb.OnlineInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OnlineInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Infos != null && message.hasOwnProperty("Infos")) {
                if (!Array.isArray(message.Infos))
                    return "Infos: array expected";
                for (var i = 0; i < message.Infos.length; ++i) {
                    var error = $root.pb.AccountTypeOnlineInfo.verify(message.Infos[i]);
                    if (error)
                        return "Infos." + error;
                }
            }
            return null;
        };

        return OnlineInfo;
    })();

    pb.GetCardAmountLogArg = (function() {

        /**
         * Properties of a GetCardAmountLogArg.
         * @memberof pb
         * @interface IGetCardAmountLogArg
         * @property {pb.AccountTypeEnum|null} [AccountType] GetCardAmountLogArg AccountType
         */

        /**
         * Constructs a new GetCardAmountLogArg.
         * @memberof pb
         * @classdesc Represents a GetCardAmountLogArg.
         * @implements IGetCardAmountLogArg
         * @constructor
         * @param {pb.IGetCardAmountLogArg=} [properties] Properties to set
         */
        function GetCardAmountLogArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardAmountLogArg AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.GetCardAmountLogArg
         * @instance
         */
        GetCardAmountLogArg.prototype.AccountType = 0;

        /**
         * Creates a new GetCardAmountLogArg instance using the specified properties.
         * @function create
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {pb.IGetCardAmountLogArg=} [properties] Properties to set
         * @returns {pb.GetCardAmountLogArg} GetCardAmountLogArg instance
         */
        GetCardAmountLogArg.create = function create(properties) {
            return new GetCardAmountLogArg(properties);
        };

        /**
         * Encodes the specified GetCardAmountLogArg message. Does not implicitly {@link pb.GetCardAmountLogArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {pb.IGetCardAmountLogArg} message GetCardAmountLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardAmountLogArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            return writer;
        };

        /**
         * Encodes the specified GetCardAmountLogArg message, length delimited. Does not implicitly {@link pb.GetCardAmountLogArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {pb.IGetCardAmountLogArg} message GetCardAmountLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardAmountLogArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardAmountLogArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardAmountLogArg} GetCardAmountLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardAmountLogArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardAmountLogArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardAmountLogArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardAmountLogArg} GetCardAmountLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardAmountLogArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardAmountLogArg message.
         * @function verify
         * @memberof pb.GetCardAmountLogArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardAmountLogArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            return null;
        };

        return GetCardAmountLogArg;
    })();

    pb.CardAmountLog = (function() {

        /**
         * Properties of a CardAmountLog.
         * @memberof pb
         * @interface ICardAmountLog
         * @property {number|null} [CardID] CardAmountLog CardID
         * @property {number|null} [Amount] CardAmountLog Amount
         * @property {string|null} [CardName] CardAmountLog CardName
         */

        /**
         * Constructs a new CardAmountLog.
         * @memberof pb
         * @classdesc Represents a CardAmountLog.
         * @implements ICardAmountLog
         * @constructor
         * @param {pb.ICardAmountLog=} [properties] Properties to set
         */
        function CardAmountLog(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardAmountLog CardID.
         * @member {number} CardID
         * @memberof pb.CardAmountLog
         * @instance
         */
        CardAmountLog.prototype.CardID = 0;

        /**
         * CardAmountLog Amount.
         * @member {number} Amount
         * @memberof pb.CardAmountLog
         * @instance
         */
        CardAmountLog.prototype.Amount = 0;

        /**
         * CardAmountLog CardName.
         * @member {string} CardName
         * @memberof pb.CardAmountLog
         * @instance
         */
        CardAmountLog.prototype.CardName = "";

        /**
         * Creates a new CardAmountLog instance using the specified properties.
         * @function create
         * @memberof pb.CardAmountLog
         * @static
         * @param {pb.ICardAmountLog=} [properties] Properties to set
         * @returns {pb.CardAmountLog} CardAmountLog instance
         */
        CardAmountLog.create = function create(properties) {
            return new CardAmountLog(properties);
        };

        /**
         * Encodes the specified CardAmountLog message. Does not implicitly {@link pb.CardAmountLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardAmountLog
         * @static
         * @param {pb.ICardAmountLog} message CardAmountLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardAmountLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardID);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            if (message.CardName != null && message.hasOwnProperty("CardName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.CardName);
            return writer;
        };

        /**
         * Encodes the specified CardAmountLog message, length delimited. Does not implicitly {@link pb.CardAmountLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardAmountLog
         * @static
         * @param {pb.ICardAmountLog} message CardAmountLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardAmountLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardAmountLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardAmountLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardAmountLog} CardAmountLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardAmountLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardAmountLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardID = reader.uint32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                case 3:
                    message.CardName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardAmountLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardAmountLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardAmountLog} CardAmountLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardAmountLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardAmountLog message.
         * @function verify
         * @memberof pb.CardAmountLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardAmountLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.CardName != null && message.hasOwnProperty("CardName"))
                if (!$util.isString(message.CardName))
                    return "CardName: string expected";
            return null;
        };

        return CardAmountLog;
    })();

    pb.CardsAmountLog = (function() {

        /**
         * Properties of a CardsAmountLog.
         * @memberof pb
         * @interface ICardsAmountLog
         * @property {pb.AccountTypeEnum|null} [AccountType] CardsAmountLog AccountType
         * @property {Array.<pb.ICardAmountLog>|null} [Logs] CardsAmountLog Logs
         */

        /**
         * Constructs a new CardsAmountLog.
         * @memberof pb
         * @classdesc Represents a CardsAmountLog.
         * @implements ICardsAmountLog
         * @constructor
         * @param {pb.ICardsAmountLog=} [properties] Properties to set
         */
        function CardsAmountLog(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardsAmountLog AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.CardsAmountLog
         * @instance
         */
        CardsAmountLog.prototype.AccountType = 0;

        /**
         * CardsAmountLog Logs.
         * @member {Array.<pb.ICardAmountLog>} Logs
         * @memberof pb.CardsAmountLog
         * @instance
         */
        CardsAmountLog.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new CardsAmountLog instance using the specified properties.
         * @function create
         * @memberof pb.CardsAmountLog
         * @static
         * @param {pb.ICardsAmountLog=} [properties] Properties to set
         * @returns {pb.CardsAmountLog} CardsAmountLog instance
         */
        CardsAmountLog.create = function create(properties) {
            return new CardsAmountLog(properties);
        };

        /**
         * Encodes the specified CardsAmountLog message. Does not implicitly {@link pb.CardsAmountLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardsAmountLog
         * @static
         * @param {pb.ICardsAmountLog} message CardsAmountLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardsAmountLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardAmountLog.encode(message.Logs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CardsAmountLog message, length delimited. Does not implicitly {@link pb.CardsAmountLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardsAmountLog
         * @static
         * @param {pb.ICardsAmountLog} message CardsAmountLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardsAmountLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardsAmountLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardsAmountLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardsAmountLog} CardsAmountLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardsAmountLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardsAmountLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardAmountLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardsAmountLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardsAmountLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardsAmountLog} CardsAmountLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardsAmountLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardsAmountLog message.
         * @function verify
         * @memberof pb.CardsAmountLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardsAmountLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardAmountLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return CardsAmountLog;
    })();

    pb.GetCardAmountLogReply = (function() {

        /**
         * Properties of a GetCardAmountLogReply.
         * @memberof pb
         * @interface IGetCardAmountLogReply
         * @property {Array.<pb.ICardsAmountLog>|null} [Logs] GetCardAmountLogReply Logs
         */

        /**
         * Constructs a new GetCardAmountLogReply.
         * @memberof pb
         * @classdesc Represents a GetCardAmountLogReply.
         * @implements IGetCardAmountLogReply
         * @constructor
         * @param {pb.IGetCardAmountLogReply=} [properties] Properties to set
         */
        function GetCardAmountLogReply(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardAmountLogReply Logs.
         * @member {Array.<pb.ICardsAmountLog>} Logs
         * @memberof pb.GetCardAmountLogReply
         * @instance
         */
        GetCardAmountLogReply.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new GetCardAmountLogReply instance using the specified properties.
         * @function create
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {pb.IGetCardAmountLogReply=} [properties] Properties to set
         * @returns {pb.GetCardAmountLogReply} GetCardAmountLogReply instance
         */
        GetCardAmountLogReply.create = function create(properties) {
            return new GetCardAmountLogReply(properties);
        };

        /**
         * Encodes the specified GetCardAmountLogReply message. Does not implicitly {@link pb.GetCardAmountLogReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {pb.IGetCardAmountLogReply} message GetCardAmountLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardAmountLogReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardsAmountLog.encode(message.Logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetCardAmountLogReply message, length delimited. Does not implicitly {@link pb.GetCardAmountLogReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {pb.IGetCardAmountLogReply} message GetCardAmountLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardAmountLogReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardAmountLogReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardAmountLogReply} GetCardAmountLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardAmountLogReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardAmountLogReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardsAmountLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardAmountLogReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardAmountLogReply} GetCardAmountLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardAmountLogReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardAmountLogReply message.
         * @function verify
         * @memberof pb.GetCardAmountLogReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardAmountLogReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardsAmountLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return GetCardAmountLogReply;
    })();

    pb.GetCardLevelLogArg = (function() {

        /**
         * Properties of a GetCardLevelLogArg.
         * @memberof pb
         * @interface IGetCardLevelLogArg
         * @property {pb.AccountTypeEnum|null} [AccountType] GetCardLevelLogArg AccountType
         * @property {number|null} [CardID] GetCardLevelLogArg CardID
         */

        /**
         * Constructs a new GetCardLevelLogArg.
         * @memberof pb
         * @classdesc Represents a GetCardLevelLogArg.
         * @implements IGetCardLevelLogArg
         * @constructor
         * @param {pb.IGetCardLevelLogArg=} [properties] Properties to set
         */
        function GetCardLevelLogArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardLevelLogArg AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.GetCardLevelLogArg
         * @instance
         */
        GetCardLevelLogArg.prototype.AccountType = 0;

        /**
         * GetCardLevelLogArg CardID.
         * @member {number} CardID
         * @memberof pb.GetCardLevelLogArg
         * @instance
         */
        GetCardLevelLogArg.prototype.CardID = 0;

        /**
         * Creates a new GetCardLevelLogArg instance using the specified properties.
         * @function create
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {pb.IGetCardLevelLogArg=} [properties] Properties to set
         * @returns {pb.GetCardLevelLogArg} GetCardLevelLogArg instance
         */
        GetCardLevelLogArg.create = function create(properties) {
            return new GetCardLevelLogArg(properties);
        };

        /**
         * Encodes the specified GetCardLevelLogArg message. Does not implicitly {@link pb.GetCardLevelLogArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {pb.IGetCardLevelLogArg} message GetCardLevelLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardLevelLogArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.CardID);
            return writer;
        };

        /**
         * Encodes the specified GetCardLevelLogArg message, length delimited. Does not implicitly {@link pb.GetCardLevelLogArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {pb.IGetCardLevelLogArg} message GetCardLevelLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardLevelLogArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardLevelLogArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardLevelLogArg} GetCardLevelLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardLevelLogArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardLevelLogArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    message.CardID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardLevelLogArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardLevelLogArg} GetCardLevelLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardLevelLogArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardLevelLogArg message.
         * @function verify
         * @memberof pb.GetCardLevelLogArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardLevelLogArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            return null;
        };

        return GetCardLevelLogArg;
    })();

    pb.CardLevelLog = (function() {

        /**
         * Properties of a CardLevelLog.
         * @memberof pb
         * @interface ICardLevelLog
         * @property {number|null} [CardID] CardLevelLog CardID
         * @property {Array.<pb.CardLevelLog.ILevelAmount>|null} [Levels] CardLevelLog Levels
         * @property {string|null} [CardName] CardLevelLog CardName
         */

        /**
         * Constructs a new CardLevelLog.
         * @memberof pb
         * @classdesc Represents a CardLevelLog.
         * @implements ICardLevelLog
         * @constructor
         * @param {pb.ICardLevelLog=} [properties] Properties to set
         */
        function CardLevelLog(properties) {
            this.Levels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardLevelLog CardID.
         * @member {number} CardID
         * @memberof pb.CardLevelLog
         * @instance
         */
        CardLevelLog.prototype.CardID = 0;

        /**
         * CardLevelLog Levels.
         * @member {Array.<pb.CardLevelLog.ILevelAmount>} Levels
         * @memberof pb.CardLevelLog
         * @instance
         */
        CardLevelLog.prototype.Levels = $util.emptyArray;

        /**
         * CardLevelLog CardName.
         * @member {string} CardName
         * @memberof pb.CardLevelLog
         * @instance
         */
        CardLevelLog.prototype.CardName = "";

        /**
         * Creates a new CardLevelLog instance using the specified properties.
         * @function create
         * @memberof pb.CardLevelLog
         * @static
         * @param {pb.ICardLevelLog=} [properties] Properties to set
         * @returns {pb.CardLevelLog} CardLevelLog instance
         */
        CardLevelLog.create = function create(properties) {
            return new CardLevelLog(properties);
        };

        /**
         * Encodes the specified CardLevelLog message. Does not implicitly {@link pb.CardLevelLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardLevelLog
         * @static
         * @param {pb.ICardLevelLog} message CardLevelLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardLevelLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardID);
            if (message.Levels != null && message.Levels.length)
                for (var i = 0; i < message.Levels.length; ++i)
                    $root.pb.CardLevelLog.LevelAmount.encode(message.Levels[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.CardName != null && message.hasOwnProperty("CardName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.CardName);
            return writer;
        };

        /**
         * Encodes the specified CardLevelLog message, length delimited. Does not implicitly {@link pb.CardLevelLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardLevelLog
         * @static
         * @param {pb.ICardLevelLog} message CardLevelLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardLevelLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardLevelLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardLevelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardLevelLog} CardLevelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardLevelLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardLevelLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardID = reader.uint32();
                    break;
                case 2:
                    if (!(message.Levels && message.Levels.length))
                        message.Levels = [];
                    message.Levels.push($root.pb.CardLevelLog.LevelAmount.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.CardName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardLevelLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardLevelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardLevelLog} CardLevelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardLevelLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardLevelLog message.
         * @function verify
         * @memberof pb.CardLevelLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardLevelLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            if (message.Levels != null && message.hasOwnProperty("Levels")) {
                if (!Array.isArray(message.Levels))
                    return "Levels: array expected";
                for (var i = 0; i < message.Levels.length; ++i) {
                    var error = $root.pb.CardLevelLog.LevelAmount.verify(message.Levels[i]);
                    if (error)
                        return "Levels." + error;
                }
            }
            if (message.CardName != null && message.hasOwnProperty("CardName"))
                if (!$util.isString(message.CardName))
                    return "CardName: string expected";
            return null;
        };

        CardLevelLog.LevelAmount = (function() {

            /**
             * Properties of a LevelAmount.
             * @memberof pb.CardLevelLog
             * @interface ILevelAmount
             * @property {number|null} [Level] LevelAmount Level
             * @property {number|null} [Amount] LevelAmount Amount
             */

            /**
             * Constructs a new LevelAmount.
             * @memberof pb.CardLevelLog
             * @classdesc Represents a LevelAmount.
             * @implements ILevelAmount
             * @constructor
             * @param {pb.CardLevelLog.ILevelAmount=} [properties] Properties to set
             */
            function LevelAmount(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * LevelAmount Level.
             * @member {number} Level
             * @memberof pb.CardLevelLog.LevelAmount
             * @instance
             */
            LevelAmount.prototype.Level = 0;

            /**
             * LevelAmount Amount.
             * @member {number} Amount
             * @memberof pb.CardLevelLog.LevelAmount
             * @instance
             */
            LevelAmount.prototype.Amount = 0;

            /**
             * Creates a new LevelAmount instance using the specified properties.
             * @function create
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {pb.CardLevelLog.ILevelAmount=} [properties] Properties to set
             * @returns {pb.CardLevelLog.LevelAmount} LevelAmount instance
             */
            LevelAmount.create = function create(properties) {
                return new LevelAmount(properties);
            };

            /**
             * Encodes the specified LevelAmount message. Does not implicitly {@link pb.CardLevelLog.LevelAmount.verify|verify} messages.
             * @function encode
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {pb.CardLevelLog.ILevelAmount} message LevelAmount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LevelAmount.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.Level != null && message.hasOwnProperty("Level"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Level);
                if (message.Amount != null && message.hasOwnProperty("Amount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
                return writer;
            };

            /**
             * Encodes the specified LevelAmount message, length delimited. Does not implicitly {@link pb.CardLevelLog.LevelAmount.verify|verify} messages.
             * @function encodeDelimited
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {pb.CardLevelLog.ILevelAmount} message LevelAmount message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            LevelAmount.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a LevelAmount message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CardLevelLog.LevelAmount} LevelAmount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LevelAmount.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardLevelLog.LevelAmount();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.Level = reader.int32();
                        break;
                    case 2:
                        message.Amount = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a LevelAmount message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {pb.CardLevelLog.LevelAmount} LevelAmount
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            LevelAmount.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a LevelAmount message.
             * @function verify
             * @memberof pb.CardLevelLog.LevelAmount
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            LevelAmount.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.Level != null && message.hasOwnProperty("Level"))
                    if (!$util.isInteger(message.Level))
                        return "Level: integer expected";
                if (message.Amount != null && message.hasOwnProperty("Amount"))
                    if (!$util.isInteger(message.Amount))
                        return "Amount: integer expected";
                return null;
            };

            return LevelAmount;
        })();

        return CardLevelLog;
    })();

    pb.CardsLevelLog = (function() {

        /**
         * Properties of a CardsLevelLog.
         * @memberof pb
         * @interface ICardsLevelLog
         * @property {pb.AccountTypeEnum|null} [AccountType] CardsLevelLog AccountType
         * @property {Array.<pb.ICardLevelLog>|null} [Logs] CardsLevelLog Logs
         */

        /**
         * Constructs a new CardsLevelLog.
         * @memberof pb
         * @classdesc Represents a CardsLevelLog.
         * @implements ICardsLevelLog
         * @constructor
         * @param {pb.ICardsLevelLog=} [properties] Properties to set
         */
        function CardsLevelLog(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardsLevelLog AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.CardsLevelLog
         * @instance
         */
        CardsLevelLog.prototype.AccountType = 0;

        /**
         * CardsLevelLog Logs.
         * @member {Array.<pb.ICardLevelLog>} Logs
         * @memberof pb.CardsLevelLog
         * @instance
         */
        CardsLevelLog.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new CardsLevelLog instance using the specified properties.
         * @function create
         * @memberof pb.CardsLevelLog
         * @static
         * @param {pb.ICardsLevelLog=} [properties] Properties to set
         * @returns {pb.CardsLevelLog} CardsLevelLog instance
         */
        CardsLevelLog.create = function create(properties) {
            return new CardsLevelLog(properties);
        };

        /**
         * Encodes the specified CardsLevelLog message. Does not implicitly {@link pb.CardsLevelLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardsLevelLog
         * @static
         * @param {pb.ICardsLevelLog} message CardsLevelLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardsLevelLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardLevelLog.encode(message.Logs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CardsLevelLog message, length delimited. Does not implicitly {@link pb.CardsLevelLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardsLevelLog
         * @static
         * @param {pb.ICardsLevelLog} message CardsLevelLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardsLevelLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardsLevelLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardsLevelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardsLevelLog} CardsLevelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardsLevelLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardsLevelLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardLevelLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardsLevelLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardsLevelLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardsLevelLog} CardsLevelLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardsLevelLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardsLevelLog message.
         * @function verify
         * @memberof pb.CardsLevelLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardsLevelLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardLevelLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return CardsLevelLog;
    })();

    pb.GetCardLevelLogReply = (function() {

        /**
         * Properties of a GetCardLevelLogReply.
         * @memberof pb
         * @interface IGetCardLevelLogReply
         * @property {Array.<pb.ICardsLevelLog>|null} [Logs] GetCardLevelLogReply Logs
         */

        /**
         * Constructs a new GetCardLevelLogReply.
         * @memberof pb
         * @classdesc Represents a GetCardLevelLogReply.
         * @implements IGetCardLevelLogReply
         * @constructor
         * @param {pb.IGetCardLevelLogReply=} [properties] Properties to set
         */
        function GetCardLevelLogReply(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardLevelLogReply Logs.
         * @member {Array.<pb.ICardsLevelLog>} Logs
         * @memberof pb.GetCardLevelLogReply
         * @instance
         */
        GetCardLevelLogReply.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new GetCardLevelLogReply instance using the specified properties.
         * @function create
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {pb.IGetCardLevelLogReply=} [properties] Properties to set
         * @returns {pb.GetCardLevelLogReply} GetCardLevelLogReply instance
         */
        GetCardLevelLogReply.create = function create(properties) {
            return new GetCardLevelLogReply(properties);
        };

        /**
         * Encodes the specified GetCardLevelLogReply message. Does not implicitly {@link pb.GetCardLevelLogReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {pb.IGetCardLevelLogReply} message GetCardLevelLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardLevelLogReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardsLevelLog.encode(message.Logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetCardLevelLogReply message, length delimited. Does not implicitly {@link pb.GetCardLevelLogReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {pb.IGetCardLevelLogReply} message GetCardLevelLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardLevelLogReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardLevelLogReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardLevelLogReply} GetCardLevelLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardLevelLogReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardLevelLogReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardsLevelLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardLevelLogReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardLevelLogReply} GetCardLevelLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardLevelLogReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardLevelLogReply message.
         * @function verify
         * @memberof pb.GetCardLevelLogReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardLevelLogReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardsLevelLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return GetCardLevelLogReply;
    })();

    pb.GetCardPoolLogArg = (function() {

        /**
         * Properties of a GetCardPoolLogArg.
         * @memberof pb
         * @interface IGetCardPoolLogArg
         * @property {pb.AccountTypeEnum|null} [AccountType] GetCardPoolLogArg AccountType
         * @property {number|null} [PvpLevel] GetCardPoolLogArg PvpLevel
         */

        /**
         * Constructs a new GetCardPoolLogArg.
         * @memberof pb
         * @classdesc Represents a GetCardPoolLogArg.
         * @implements IGetCardPoolLogArg
         * @constructor
         * @param {pb.IGetCardPoolLogArg=} [properties] Properties to set
         */
        function GetCardPoolLogArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardPoolLogArg AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.GetCardPoolLogArg
         * @instance
         */
        GetCardPoolLogArg.prototype.AccountType = 0;

        /**
         * GetCardPoolLogArg PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.GetCardPoolLogArg
         * @instance
         */
        GetCardPoolLogArg.prototype.PvpLevel = 0;

        /**
         * Creates a new GetCardPoolLogArg instance using the specified properties.
         * @function create
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {pb.IGetCardPoolLogArg=} [properties] Properties to set
         * @returns {pb.GetCardPoolLogArg} GetCardPoolLogArg instance
         */
        GetCardPoolLogArg.create = function create(properties) {
            return new GetCardPoolLogArg(properties);
        };

        /**
         * Encodes the specified GetCardPoolLogArg message. Does not implicitly {@link pb.GetCardPoolLogArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {pb.IGetCardPoolLogArg} message GetCardPoolLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardPoolLogArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PvpLevel);
            return writer;
        };

        /**
         * Encodes the specified GetCardPoolLogArg message, length delimited. Does not implicitly {@link pb.GetCardPoolLogArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {pb.IGetCardPoolLogArg} message GetCardPoolLogArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardPoolLogArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardPoolLogArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardPoolLogArg} GetCardPoolLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardPoolLogArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardPoolLogArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    message.PvpLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardPoolLogArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardPoolLogArg} GetCardPoolLogArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardPoolLogArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardPoolLogArg message.
         * @function verify
         * @memberof pb.GetCardPoolLogArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardPoolLogArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            return null;
        };

        return GetCardPoolLogArg;
    })();

    pb.CardPoolLog = (function() {

        /**
         * Properties of a CardPoolLog.
         * @memberof pb
         * @interface ICardPoolLog
         * @property {number|null} [PvpLevel] CardPoolLog PvpLevel
         * @property {number|null} [BattleAmount] CardPoolLog BattleAmount
         * @property {Array.<pb.CardPoolLog.ICardLog>|null} [CardLogs] CardPoolLog CardLogs
         */

        /**
         * Constructs a new CardPoolLog.
         * @memberof pb
         * @classdesc Represents a CardPoolLog.
         * @implements ICardPoolLog
         * @constructor
         * @param {pb.ICardPoolLog=} [properties] Properties to set
         */
        function CardPoolLog(properties) {
            this.CardLogs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardPoolLog PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.CardPoolLog
         * @instance
         */
        CardPoolLog.prototype.PvpLevel = 0;

        /**
         * CardPoolLog BattleAmount.
         * @member {number} BattleAmount
         * @memberof pb.CardPoolLog
         * @instance
         */
        CardPoolLog.prototype.BattleAmount = 0;

        /**
         * CardPoolLog CardLogs.
         * @member {Array.<pb.CardPoolLog.ICardLog>} CardLogs
         * @memberof pb.CardPoolLog
         * @instance
         */
        CardPoolLog.prototype.CardLogs = $util.emptyArray;

        /**
         * Creates a new CardPoolLog instance using the specified properties.
         * @function create
         * @memberof pb.CardPoolLog
         * @static
         * @param {pb.ICardPoolLog=} [properties] Properties to set
         * @returns {pb.CardPoolLog} CardPoolLog instance
         */
        CardPoolLog.create = function create(properties) {
            return new CardPoolLog(properties);
        };

        /**
         * Encodes the specified CardPoolLog message. Does not implicitly {@link pb.CardPoolLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardPoolLog
         * @static
         * @param {pb.ICardPoolLog} message CardPoolLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPoolLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PvpLevel);
            if (message.BattleAmount != null && message.hasOwnProperty("BattleAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.BattleAmount);
            if (message.CardLogs != null && message.CardLogs.length)
                for (var i = 0; i < message.CardLogs.length; ++i)
                    $root.pb.CardPoolLog.CardLog.encode(message.CardLogs[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CardPoolLog message, length delimited. Does not implicitly {@link pb.CardPoolLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardPoolLog
         * @static
         * @param {pb.ICardPoolLog} message CardPoolLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPoolLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardPoolLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardPoolLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardPoolLog} CardPoolLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPoolLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardPoolLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PvpLevel = reader.int32();
                    break;
                case 2:
                    message.BattleAmount = reader.int32();
                    break;
                case 3:
                    if (!(message.CardLogs && message.CardLogs.length))
                        message.CardLogs = [];
                    message.CardLogs.push($root.pb.CardPoolLog.CardLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardPoolLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardPoolLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardPoolLog} CardPoolLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPoolLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardPoolLog message.
         * @function verify
         * @memberof pb.CardPoolLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardPoolLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            if (message.BattleAmount != null && message.hasOwnProperty("BattleAmount"))
                if (!$util.isInteger(message.BattleAmount))
                    return "BattleAmount: integer expected";
            if (message.CardLogs != null && message.hasOwnProperty("CardLogs")) {
                if (!Array.isArray(message.CardLogs))
                    return "CardLogs: array expected";
                for (var i = 0; i < message.CardLogs.length; ++i) {
                    var error = $root.pb.CardPoolLog.CardLog.verify(message.CardLogs[i]);
                    if (error)
                        return "CardLogs." + error;
                }
            }
            return null;
        };

        CardPoolLog.CardLog = (function() {

            /**
             * Properties of a CardLog.
             * @memberof pb.CardPoolLog
             * @interface ICardLog
             * @property {number|null} [CardID] CardLog CardID
             * @property {number|null} [Amount] CardLog Amount
             * @property {string|null} [CardName] CardLog CardName
             */

            /**
             * Constructs a new CardLog.
             * @memberof pb.CardPoolLog
             * @classdesc Represents a CardLog.
             * @implements ICardLog
             * @constructor
             * @param {pb.CardPoolLog.ICardLog=} [properties] Properties to set
             */
            function CardLog(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CardLog CardID.
             * @member {number} CardID
             * @memberof pb.CardPoolLog.CardLog
             * @instance
             */
            CardLog.prototype.CardID = 0;

            /**
             * CardLog Amount.
             * @member {number} Amount
             * @memberof pb.CardPoolLog.CardLog
             * @instance
             */
            CardLog.prototype.Amount = 0;

            /**
             * CardLog CardName.
             * @member {string} CardName
             * @memberof pb.CardPoolLog.CardLog
             * @instance
             */
            CardLog.prototype.CardName = "";

            /**
             * Creates a new CardLog instance using the specified properties.
             * @function create
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {pb.CardPoolLog.ICardLog=} [properties] Properties to set
             * @returns {pb.CardPoolLog.CardLog} CardLog instance
             */
            CardLog.create = function create(properties) {
                return new CardLog(properties);
            };

            /**
             * Encodes the specified CardLog message. Does not implicitly {@link pb.CardPoolLog.CardLog.verify|verify} messages.
             * @function encode
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {pb.CardPoolLog.ICardLog} message CardLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CardLog.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.CardID != null && message.hasOwnProperty("CardID"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardID);
                if (message.Amount != null && message.hasOwnProperty("Amount"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
                if (message.CardName != null && message.hasOwnProperty("CardName"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.CardName);
                return writer;
            };

            /**
             * Encodes the specified CardLog message, length delimited. Does not implicitly {@link pb.CardPoolLog.CardLog.verify|verify} messages.
             * @function encodeDelimited
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {pb.CardPoolLog.ICardLog} message CardLog message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CardLog.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CardLog message from the specified reader or buffer.
             * @function decode
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {pb.CardPoolLog.CardLog} CardLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CardLog.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardPoolLog.CardLog();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.CardID = reader.uint32();
                        break;
                    case 2:
                        message.Amount = reader.int32();
                        break;
                    case 3:
                        message.CardName = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CardLog message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {pb.CardPoolLog.CardLog} CardLog
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CardLog.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CardLog message.
             * @function verify
             * @memberof pb.CardPoolLog.CardLog
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CardLog.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.CardID != null && message.hasOwnProperty("CardID"))
                    if (!$util.isInteger(message.CardID))
                        return "CardID: integer expected";
                if (message.Amount != null && message.hasOwnProperty("Amount"))
                    if (!$util.isInteger(message.Amount))
                        return "Amount: integer expected";
                if (message.CardName != null && message.hasOwnProperty("CardName"))
                    if (!$util.isString(message.CardName))
                        return "CardName: string expected";
                return null;
            };

            return CardLog;
        })();

        return CardPoolLog;
    })();

    pb.CardPoolsLog = (function() {

        /**
         * Properties of a CardPoolsLog.
         * @memberof pb
         * @interface ICardPoolsLog
         * @property {pb.AccountTypeEnum|null} [AccountType] CardPoolsLog AccountType
         * @property {Array.<pb.ICardPoolLog>|null} [Logs] CardPoolsLog Logs
         */

        /**
         * Constructs a new CardPoolsLog.
         * @memberof pb
         * @classdesc Represents a CardPoolsLog.
         * @implements ICardPoolsLog
         * @constructor
         * @param {pb.ICardPoolsLog=} [properties] Properties to set
         */
        function CardPoolsLog(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CardPoolsLog AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.CardPoolsLog
         * @instance
         */
        CardPoolsLog.prototype.AccountType = 0;

        /**
         * CardPoolsLog Logs.
         * @member {Array.<pb.ICardPoolLog>} Logs
         * @memberof pb.CardPoolsLog
         * @instance
         */
        CardPoolsLog.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new CardPoolsLog instance using the specified properties.
         * @function create
         * @memberof pb.CardPoolsLog
         * @static
         * @param {pb.ICardPoolsLog=} [properties] Properties to set
         * @returns {pb.CardPoolsLog} CardPoolsLog instance
         */
        CardPoolsLog.create = function create(properties) {
            return new CardPoolsLog(properties);
        };

        /**
         * Encodes the specified CardPoolsLog message. Does not implicitly {@link pb.CardPoolsLog.verify|verify} messages.
         * @function encode
         * @memberof pb.CardPoolsLog
         * @static
         * @param {pb.ICardPoolsLog} message CardPoolsLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPoolsLog.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AccountType);
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardPoolLog.encode(message.Logs[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CardPoolsLog message, length delimited. Does not implicitly {@link pb.CardPoolsLog.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CardPoolsLog
         * @static
         * @param {pb.ICardPoolsLog} message CardPoolsLog message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CardPoolsLog.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CardPoolsLog message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CardPoolsLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CardPoolsLog} CardPoolsLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPoolsLog.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CardPoolsLog();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AccountType = reader.int32();
                    break;
                case 2:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardPoolLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CardPoolsLog message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CardPoolsLog
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CardPoolsLog} CardPoolsLog
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CardPoolsLog.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CardPoolsLog message.
         * @function verify
         * @memberof pb.CardPoolsLog
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CardPoolsLog.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardPoolLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return CardPoolsLog;
    })();

    pb.GetCardPoolLogReply = (function() {

        /**
         * Properties of a GetCardPoolLogReply.
         * @memberof pb
         * @interface IGetCardPoolLogReply
         * @property {Array.<pb.ICardPoolsLog>|null} [Logs] GetCardPoolLogReply Logs
         */

        /**
         * Constructs a new GetCardPoolLogReply.
         * @memberof pb
         * @classdesc Represents a GetCardPoolLogReply.
         * @implements IGetCardPoolLogReply
         * @constructor
         * @param {pb.IGetCardPoolLogReply=} [properties] Properties to set
         */
        function GetCardPoolLogReply(properties) {
            this.Logs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCardPoolLogReply Logs.
         * @member {Array.<pb.ICardPoolsLog>} Logs
         * @memberof pb.GetCardPoolLogReply
         * @instance
         */
        GetCardPoolLogReply.prototype.Logs = $util.emptyArray;

        /**
         * Creates a new GetCardPoolLogReply instance using the specified properties.
         * @function create
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {pb.IGetCardPoolLogReply=} [properties] Properties to set
         * @returns {pb.GetCardPoolLogReply} GetCardPoolLogReply instance
         */
        GetCardPoolLogReply.create = function create(properties) {
            return new GetCardPoolLogReply(properties);
        };

        /**
         * Encodes the specified GetCardPoolLogReply message. Does not implicitly {@link pb.GetCardPoolLogReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {pb.IGetCardPoolLogReply} message GetCardPoolLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardPoolLogReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Logs != null && message.Logs.length)
                for (var i = 0; i < message.Logs.length; ++i)
                    $root.pb.CardPoolsLog.encode(message.Logs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetCardPoolLogReply message, length delimited. Does not implicitly {@link pb.GetCardPoolLogReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {pb.IGetCardPoolLogReply} message GetCardPoolLogReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCardPoolLogReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCardPoolLogReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCardPoolLogReply} GetCardPoolLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardPoolLogReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCardPoolLogReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Logs && message.Logs.length))
                        message.Logs = [];
                    message.Logs.push($root.pb.CardPoolsLog.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCardPoolLogReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCardPoolLogReply} GetCardPoolLogReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCardPoolLogReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCardPoolLogReply message.
         * @function verify
         * @memberof pb.GetCardPoolLogReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCardPoolLogReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Logs != null && message.hasOwnProperty("Logs")) {
                if (!Array.isArray(message.Logs))
                    return "Logs: array expected";
                for (var i = 0; i < message.Logs.length; ++i) {
                    var error = $root.pb.CardPoolsLog.verify(message.Logs[i]);
                    if (error)
                        return "Logs." + error;
                }
            }
            return null;
        };

        return GetCardPoolLogReply;
    })();

    pb.KickOut = (function() {

        /**
         * Properties of a KickOut.
         * @memberof pb
         * @interface IKickOut
         * @property {number|null} [Reason] KickOut Reason
         */

        /**
         * Constructs a new KickOut.
         * @memberof pb
         * @classdesc Represents a KickOut.
         * @implements IKickOut
         * @constructor
         * @param {pb.IKickOut=} [properties] Properties to set
         */
        function KickOut(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KickOut Reason.
         * @member {number} Reason
         * @memberof pb.KickOut
         * @instance
         */
        KickOut.prototype.Reason = 0;

        /**
         * Creates a new KickOut instance using the specified properties.
         * @function create
         * @memberof pb.KickOut
         * @static
         * @param {pb.IKickOut=} [properties] Properties to set
         * @returns {pb.KickOut} KickOut instance
         */
        KickOut.create = function create(properties) {
            return new KickOut(properties);
        };

        /**
         * Encodes the specified KickOut message. Does not implicitly {@link pb.KickOut.verify|verify} messages.
         * @function encode
         * @memberof pb.KickOut
         * @static
         * @param {pb.IKickOut} message KickOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOut.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Reason);
            return writer;
        };

        /**
         * Encodes the specified KickOut message, length delimited. Does not implicitly {@link pb.KickOut.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.KickOut
         * @static
         * @param {pb.IKickOut} message KickOut message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOut.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KickOut message from the specified reader or buffer.
         * @function decode
         * @memberof pb.KickOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.KickOut} KickOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOut.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.KickOut();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Reason = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KickOut message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.KickOut
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.KickOut} KickOut
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOut.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KickOut message.
         * @function verify
         * @memberof pb.KickOut
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KickOut.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Reason != null && message.hasOwnProperty("Reason"))
                if (!$util.isInteger(message.Reason))
                    return "Reason: integer expected";
            return null;
        };

        return KickOut;
    })();

    pb.FinishGuide = (function() {

        /**
         * Properties of a FinishGuide.
         * @memberof pb
         * @interface IFinishGuide
         * @property {number|null} [GuideID] FinishGuide GuideID
         */

        /**
         * Constructs a new FinishGuide.
         * @memberof pb
         * @classdesc Represents a FinishGuide.
         * @implements IFinishGuide
         * @constructor
         * @param {pb.IFinishGuide=} [properties] Properties to set
         */
        function FinishGuide(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinishGuide GuideID.
         * @member {number} GuideID
         * @memberof pb.FinishGuide
         * @instance
         */
        FinishGuide.prototype.GuideID = 0;

        /**
         * Creates a new FinishGuide instance using the specified properties.
         * @function create
         * @memberof pb.FinishGuide
         * @static
         * @param {pb.IFinishGuide=} [properties] Properties to set
         * @returns {pb.FinishGuide} FinishGuide instance
         */
        FinishGuide.create = function create(properties) {
            return new FinishGuide(properties);
        };

        /**
         * Encodes the specified FinishGuide message. Does not implicitly {@link pb.FinishGuide.verify|verify} messages.
         * @function encode
         * @memberof pb.FinishGuide
         * @static
         * @param {pb.IFinishGuide} message FinishGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishGuide.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GuideID != null && message.hasOwnProperty("GuideID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.GuideID);
            return writer;
        };

        /**
         * Encodes the specified FinishGuide message, length delimited. Does not implicitly {@link pb.FinishGuide.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FinishGuide
         * @static
         * @param {pb.IFinishGuide} message FinishGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishGuide.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinishGuide message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FinishGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FinishGuide} FinishGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishGuide.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FinishGuide();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GuideID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FinishGuide message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FinishGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FinishGuide} FinishGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishGuide.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinishGuide message.
         * @function verify
         * @memberof pb.FinishGuide
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinishGuide.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GuideID != null && message.hasOwnProperty("GuideID"))
                if (!$util.isInteger(message.GuideID))
                    return "GuideID: integer expected";
            return null;
        };

        return FinishGuide;
    })();

    pb.AllFinishGuide = (function() {

        /**
         * Properties of an AllFinishGuide.
         * @memberof pb
         * @interface IAllFinishGuide
         * @property {Array.<number>|null} [GuideIDs] AllFinishGuide GuideIDs
         */

        /**
         * Constructs a new AllFinishGuide.
         * @memberof pb
         * @classdesc Represents an AllFinishGuide.
         * @implements IAllFinishGuide
         * @constructor
         * @param {pb.IAllFinishGuide=} [properties] Properties to set
         */
        function AllFinishGuide(properties) {
            this.GuideIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllFinishGuide GuideIDs.
         * @member {Array.<number>} GuideIDs
         * @memberof pb.AllFinishGuide
         * @instance
         */
        AllFinishGuide.prototype.GuideIDs = $util.emptyArray;

        /**
         * Creates a new AllFinishGuide instance using the specified properties.
         * @function create
         * @memberof pb.AllFinishGuide
         * @static
         * @param {pb.IAllFinishGuide=} [properties] Properties to set
         * @returns {pb.AllFinishGuide} AllFinishGuide instance
         */
        AllFinishGuide.create = function create(properties) {
            return new AllFinishGuide(properties);
        };

        /**
         * Encodes the specified AllFinishGuide message. Does not implicitly {@link pb.AllFinishGuide.verify|verify} messages.
         * @function encode
         * @memberof pb.AllFinishGuide
         * @static
         * @param {pb.IAllFinishGuide} message AllFinishGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFinishGuide.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GuideIDs != null && message.GuideIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.GuideIDs.length; ++i)
                    writer.int32(message.GuideIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified AllFinishGuide message, length delimited. Does not implicitly {@link pb.AllFinishGuide.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AllFinishGuide
         * @static
         * @param {pb.IAllFinishGuide} message AllFinishGuide message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFinishGuide.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllFinishGuide message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AllFinishGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AllFinishGuide} AllFinishGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFinishGuide.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AllFinishGuide();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.GuideIDs && message.GuideIDs.length))
                        message.GuideIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.GuideIDs.push(reader.int32());
                    } else
                        message.GuideIDs.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllFinishGuide message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AllFinishGuide
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AllFinishGuide} AllFinishGuide
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFinishGuide.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllFinishGuide message.
         * @function verify
         * @memberof pb.AllFinishGuide
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllFinishGuide.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GuideIDs != null && message.hasOwnProperty("GuideIDs")) {
                if (!Array.isArray(message.GuideIDs))
                    return "GuideIDs: array expected";
                for (var i = 0; i < message.GuideIDs.length; ++i)
                    if (!$util.isInteger(message.GuideIDs[i]))
                        return "GuideIDs: integer[] expected";
            }
            return null;
        };

        return AllFinishGuide;
    })();

    pb.GuideGroup = (function() {

        /**
         * Properties of a GuideGroup.
         * @memberof pb
         * @interface IGuideGroup
         * @property {number|null} [GroupID] GuideGroup GroupID
         */

        /**
         * Constructs a new GuideGroup.
         * @memberof pb
         * @classdesc Represents a GuideGroup.
         * @implements IGuideGroup
         * @constructor
         * @param {pb.IGuideGroup=} [properties] Properties to set
         */
        function GuideGroup(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuideGroup GroupID.
         * @member {number} GroupID
         * @memberof pb.GuideGroup
         * @instance
         */
        GuideGroup.prototype.GroupID = 0;

        /**
         * Creates a new GuideGroup instance using the specified properties.
         * @function create
         * @memberof pb.GuideGroup
         * @static
         * @param {pb.IGuideGroup=} [properties] Properties to set
         * @returns {pb.GuideGroup} GuideGroup instance
         */
        GuideGroup.create = function create(properties) {
            return new GuideGroup(properties);
        };

        /**
         * Encodes the specified GuideGroup message. Does not implicitly {@link pb.GuideGroup.verify|verify} messages.
         * @function encode
         * @memberof pb.GuideGroup
         * @static
         * @param {pb.IGuideGroup} message GuideGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideGroup.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GroupID != null && message.hasOwnProperty("GroupID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.GroupID);
            return writer;
        };

        /**
         * Encodes the specified GuideGroup message, length delimited. Does not implicitly {@link pb.GuideGroup.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GuideGroup
         * @static
         * @param {pb.IGuideGroup} message GuideGroup message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideGroup.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuideGroup message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GuideGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GuideGroup} GuideGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideGroup.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GuideGroup();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GroupID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuideGroup message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GuideGroup
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GuideGroup} GuideGroup
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideGroup.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuideGroup message.
         * @function verify
         * @memberof pb.GuideGroup
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuideGroup.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GroupID != null && message.hasOwnProperty("GroupID"))
                if (!$util.isInteger(message.GroupID))
                    return "GroupID: integer expected";
            return null;
        };

        return GuideGroup;
    })();

    /**
     * AccountTypeEnum enum.
     * @name pb.AccountTypeEnum
     * @enum {string}
     * @property {number} UnknowAccountType=0 UnknowAccountType value
     * @property {number} Ios=1 Ios value
     * @property {number} Android=2 Android value
     * @property {number} Wxgame=3 Wxgame value
     * @property {number} WxgameIos=4 WxgameIos value
     */
    pb.AccountTypeEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UnknowAccountType"] = 0;
        values[valuesById[1] = "Ios"] = 1;
        values[valuesById[2] = "Android"] = 2;
        values[valuesById[3] = "Wxgame"] = 3;
        values[valuesById[4] = "WxgameIos"] = 4;
        return values;
    })();

    pb.LoginArg = (function() {

        /**
         * Properties of a LoginArg.
         * @memberof pb
         * @interface ILoginArg
         * @property {number|null} [ArchiveID] LoginArg ArchiveID
         * @property {string|null} [Channel] LoginArg Channel
         * @property {string|null} [ChannelID] LoginArg ChannelID
         * @property {pb.AccountTypeEnum|null} [AccountType] LoginArg AccountType
         * @property {boolean|null} [IsTourist] LoginArg IsTourist
         * @property {string|null} [LoginChannel] LoginArg LoginChannel
         * @property {string|null} [Country] LoginArg Country
         */

        /**
         * Constructs a new LoginArg.
         * @memberof pb
         * @classdesc Represents a LoginArg.
         * @implements ILoginArg
         * @constructor
         * @param {pb.ILoginArg=} [properties] Properties to set
         */
        function LoginArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginArg ArchiveID.
         * @member {number} ArchiveID
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.ArchiveID = 0;

        /**
         * LoginArg Channel.
         * @member {string} Channel
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.Channel = "";

        /**
         * LoginArg ChannelID.
         * @member {string} ChannelID
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.ChannelID = "";

        /**
         * LoginArg AccountType.
         * @member {pb.AccountTypeEnum} AccountType
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.AccountType = 0;

        /**
         * LoginArg IsTourist.
         * @member {boolean} IsTourist
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.IsTourist = false;

        /**
         * LoginArg LoginChannel.
         * @member {string} LoginChannel
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.LoginChannel = "";

        /**
         * LoginArg Country.
         * @member {string} Country
         * @memberof pb.LoginArg
         * @instance
         */
        LoginArg.prototype.Country = "";

        /**
         * Creates a new LoginArg instance using the specified properties.
         * @function create
         * @memberof pb.LoginArg
         * @static
         * @param {pb.ILoginArg=} [properties] Properties to set
         * @returns {pb.LoginArg} LoginArg instance
         */
        LoginArg.create = function create(properties) {
            return new LoginArg(properties);
        };

        /**
         * Encodes the specified LoginArg message. Does not implicitly {@link pb.LoginArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LoginArg
         * @static
         * @param {pb.ILoginArg} message LoginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ArchiveID != null && message.hasOwnProperty("ArchiveID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ArchiveID);
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Channel);
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ChannelID);
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.AccountType);
            if (message.IsTourist != null && message.hasOwnProperty("IsTourist"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsTourist);
            if (message.LoginChannel != null && message.hasOwnProperty("LoginChannel"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.LoginChannel);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Country);
            return writer;
        };

        /**
         * Encodes the specified LoginArg message, length delimited. Does not implicitly {@link pb.LoginArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LoginArg
         * @static
         * @param {pb.ILoginArg} message LoginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LoginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LoginArg} LoginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoginArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ArchiveID = reader.int32();
                    break;
                case 2:
                    message.Channel = reader.string();
                    break;
                case 3:
                    message.ChannelID = reader.string();
                    break;
                case 4:
                    message.AccountType = reader.int32();
                    break;
                case 5:
                    message.IsTourist = reader.bool();
                    break;
                case 6:
                    message.LoginChannel = reader.string();
                    break;
                case 7:
                    message.Country = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LoginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LoginArg} LoginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginArg message.
         * @function verify
         * @memberof pb.LoginArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ArchiveID != null && message.hasOwnProperty("ArchiveID"))
                if (!$util.isInteger(message.ArchiveID))
                    return "ArchiveID: integer expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                if (!$util.isString(message.ChannelID))
                    return "ChannelID: string expected";
            if (message.AccountType != null && message.hasOwnProperty("AccountType"))
                switch (message.AccountType) {
                default:
                    return "AccountType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.IsTourist != null && message.hasOwnProperty("IsTourist"))
                if (typeof message.IsTourist !== "boolean")
                    return "IsTourist: boolean expected";
            if (message.LoginChannel != null && message.hasOwnProperty("LoginChannel"))
                if (!$util.isString(message.LoginChannel))
                    return "LoginChannel: string expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            return null;
        };

        return LoginArg;
    })();

    pb.LoginReply = (function() {

        /**
         * Properties of a LoginReply.
         * @memberof pb
         * @interface ILoginReply
         * @property {number|Long|null} [Uid] LoginReply Uid
         * @property {Array.<pb.ICardInfo>|null} [Cards] LoginReply Cards
         * @property {Array.<pb.IResource>|null} [Res] LoginReply Res
         * @property {Array.<pb.IDiyCardData>|null} [DiyCards] LoginReply DiyCards
         * @property {number|Long|null} [FightID] LoginReply FightID
         * @property {string|null} [ServerID] LoginReply ServerID
         * @property {number|null} [GuideCamp] LoginReply GuideCamp
         * @property {string|null} [Name] LoginReply Name
         * @property {pb.IVersion|null} [Ver] LoginReply Ver
         * @property {boolean|null} [IsExamined] LoginReply IsExamined
         * @property {string|null} [HeadImg] LoginReply HeadImg
         * @property {number|null} [CumulativePay] LoginReply CumulativePay
         * @property {boolean|null} [IsIosShared] LoginReply IsIosShared
         * @property {number|null} [SeasonPvpLimitTime] LoginReply SeasonPvpLimitTime
         * @property {number|null} [VipRemainTime] LoginReply VipRemainTime
         * @property {Array.<string>|null} [CardSkins] LoginReply CardSkins
         * @property {string|null} [HeadFrame] LoginReply HeadFrame
         * @property {Array.<number>|null} [Privileges] LoginReply Privileges
         * @property {boolean|null} [IsSeasonPvpChooseCard] LoginReply IsSeasonPvpChooseCard
         * @property {boolean|null} [IsInCampaignMatch] LoginReply IsInCampaignMatch
         * @property {number|null} [MiniVipRemainTime] LoginReply MiniVipRemainTime
         * @property {Array.<pb.IHuodongData>|null} [Huodongs] LoginReply Huodongs
         * @property {number|null} [RebornCnt] LoginReply RebornCnt
         */

        /**
         * Constructs a new LoginReply.
         * @memberof pb
         * @classdesc Represents a LoginReply.
         * @implements ILoginReply
         * @constructor
         * @param {pb.ILoginReply=} [properties] Properties to set
         */
        function LoginReply(properties) {
            this.Cards = [];
            this.Res = [];
            this.DiyCards = [];
            this.CardSkins = [];
            this.Privileges = [];
            this.Huodongs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginReply Uid.
         * @member {number|Long} Uid
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginReply Cards.
         * @member {Array.<pb.ICardInfo>} Cards
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Cards = $util.emptyArray;

        /**
         * LoginReply Res.
         * @member {Array.<pb.IResource>} Res
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Res = $util.emptyArray;

        /**
         * LoginReply DiyCards.
         * @member {Array.<pb.IDiyCardData>} DiyCards
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.DiyCards = $util.emptyArray;

        /**
         * LoginReply FightID.
         * @member {number|Long} FightID
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.FightID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LoginReply ServerID.
         * @member {string} ServerID
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.ServerID = "";

        /**
         * LoginReply GuideCamp.
         * @member {number} GuideCamp
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.GuideCamp = 0;

        /**
         * LoginReply Name.
         * @member {string} Name
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Name = "";

        /**
         * LoginReply Ver.
         * @member {pb.IVersion|null|undefined} Ver
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Ver = null;

        /**
         * LoginReply IsExamined.
         * @member {boolean} IsExamined
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.IsExamined = false;

        /**
         * LoginReply HeadImg.
         * @member {string} HeadImg
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.HeadImg = "";

        /**
         * LoginReply CumulativePay.
         * @member {number} CumulativePay
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.CumulativePay = 0;

        /**
         * LoginReply IsIosShared.
         * @member {boolean} IsIosShared
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.IsIosShared = false;

        /**
         * LoginReply SeasonPvpLimitTime.
         * @member {number} SeasonPvpLimitTime
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.SeasonPvpLimitTime = 0;

        /**
         * LoginReply VipRemainTime.
         * @member {number} VipRemainTime
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.VipRemainTime = 0;

        /**
         * LoginReply CardSkins.
         * @member {Array.<string>} CardSkins
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.CardSkins = $util.emptyArray;

        /**
         * LoginReply HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.HeadFrame = "";

        /**
         * LoginReply Privileges.
         * @member {Array.<number>} Privileges
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Privileges = $util.emptyArray;

        /**
         * LoginReply IsSeasonPvpChooseCard.
         * @member {boolean} IsSeasonPvpChooseCard
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.IsSeasonPvpChooseCard = false;

        /**
         * LoginReply IsInCampaignMatch.
         * @member {boolean} IsInCampaignMatch
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.IsInCampaignMatch = false;

        /**
         * LoginReply MiniVipRemainTime.
         * @member {number} MiniVipRemainTime
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.MiniVipRemainTime = 0;

        /**
         * LoginReply Huodongs.
         * @member {Array.<pb.IHuodongData>} Huodongs
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.Huodongs = $util.emptyArray;

        /**
         * LoginReply RebornCnt.
         * @member {number} RebornCnt
         * @memberof pb.LoginReply
         * @instance
         */
        LoginReply.prototype.RebornCnt = 0;

        /**
         * Creates a new LoginReply instance using the specified properties.
         * @function create
         * @memberof pb.LoginReply
         * @static
         * @param {pb.ILoginReply=} [properties] Properties to set
         * @returns {pb.LoginReply} LoginReply instance
         */
        LoginReply.create = function create(properties) {
            return new LoginReply(properties);
        };

        /**
         * Encodes the specified LoginReply message. Does not implicitly {@link pb.LoginReply.verify|verify} messages.
         * @function encode
         * @memberof pb.LoginReply
         * @static
         * @param {pb.ILoginReply} message LoginReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Cards != null && message.Cards.length)
                for (var i = 0; i < message.Cards.length; ++i)
                    $root.pb.CardInfo.encode(message.Cards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Res != null && message.Res.length)
                for (var i = 0; i < message.Res.length; ++i)
                    $root.pb.Resource.encode(message.Res[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.DiyCards != null && message.DiyCards.length)
                for (var i = 0; i < message.DiyCards.length; ++i)
                    $root.pb.DiyCardData.encode(message.DiyCards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.FightID != null && message.hasOwnProperty("FightID"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.FightID);
            if (message.ServerID != null && message.hasOwnProperty("ServerID"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.ServerID);
            if (message.GuideCamp != null && message.hasOwnProperty("GuideCamp"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.GuideCamp);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.Name);
            if (message.Ver != null && message.hasOwnProperty("Ver"))
                $root.pb.Version.encode(message.Ver, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.IsExamined != null && message.hasOwnProperty("IsExamined"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.IsExamined);
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.HeadImg);
            if (message.CumulativePay != null && message.hasOwnProperty("CumulativePay"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.CumulativePay);
            if (message.IsIosShared != null && message.hasOwnProperty("IsIosShared"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.IsIosShared);
            if (message.SeasonPvpLimitTime != null && message.hasOwnProperty("SeasonPvpLimitTime"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.SeasonPvpLimitTime);
            if (message.VipRemainTime != null && message.hasOwnProperty("VipRemainTime"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.VipRemainTime);
            if (message.CardSkins != null && message.CardSkins.length)
                for (var i = 0; i < message.CardSkins.length; ++i)
                    writer.uint32(/* id 16, wireType 2 =*/130).string(message.CardSkins[i]);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.HeadFrame);
            if (message.Privileges != null && message.Privileges.length) {
                writer.uint32(/* id 18, wireType 2 =*/146).fork();
                for (var i = 0; i < message.Privileges.length; ++i)
                    writer.int32(message.Privileges[i]);
                writer.ldelim();
            }
            if (message.IsSeasonPvpChooseCard != null && message.hasOwnProperty("IsSeasonPvpChooseCard"))
                writer.uint32(/* id 19, wireType 0 =*/152).bool(message.IsSeasonPvpChooseCard);
            if (message.IsInCampaignMatch != null && message.hasOwnProperty("IsInCampaignMatch"))
                writer.uint32(/* id 20, wireType 0 =*/160).bool(message.IsInCampaignMatch);
            if (message.MiniVipRemainTime != null && message.hasOwnProperty("MiniVipRemainTime"))
                writer.uint32(/* id 21, wireType 0 =*/168).int32(message.MiniVipRemainTime);
            if (message.Huodongs != null && message.Huodongs.length)
                for (var i = 0; i < message.Huodongs.length; ++i)
                    $root.pb.HuodongData.encode(message.Huodongs[i], writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                writer.uint32(/* id 23, wireType 0 =*/184).int32(message.RebornCnt);
            return writer;
        };

        /**
         * Encodes the specified LoginReply message, length delimited. Does not implicitly {@link pb.LoginReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LoginReply
         * @static
         * @param {pb.ILoginReply} message LoginReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LoginReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LoginReply} LoginReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoginReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    message.Cards.push($root.pb.CardInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.Res && message.Res.length))
                        message.Res = [];
                    message.Res.push($root.pb.Resource.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.DiyCards && message.DiyCards.length))
                        message.DiyCards = [];
                    message.DiyCards.push($root.pb.DiyCardData.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.FightID = reader.uint64();
                    break;
                case 6:
                    message.ServerID = reader.string();
                    break;
                case 7:
                    message.GuideCamp = reader.int32();
                    break;
                case 8:
                    message.Name = reader.string();
                    break;
                case 9:
                    message.Ver = $root.pb.Version.decode(reader, reader.uint32());
                    break;
                case 10:
                    message.IsExamined = reader.bool();
                    break;
                case 11:
                    message.HeadImg = reader.string();
                    break;
                case 12:
                    message.CumulativePay = reader.int32();
                    break;
                case 13:
                    message.IsIosShared = reader.bool();
                    break;
                case 14:
                    message.SeasonPvpLimitTime = reader.int32();
                    break;
                case 15:
                    message.VipRemainTime = reader.int32();
                    break;
                case 16:
                    if (!(message.CardSkins && message.CardSkins.length))
                        message.CardSkins = [];
                    message.CardSkins.push(reader.string());
                    break;
                case 17:
                    message.HeadFrame = reader.string();
                    break;
                case 18:
                    if (!(message.Privileges && message.Privileges.length))
                        message.Privileges = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Privileges.push(reader.int32());
                    } else
                        message.Privileges.push(reader.int32());
                    break;
                case 19:
                    message.IsSeasonPvpChooseCard = reader.bool();
                    break;
                case 20:
                    message.IsInCampaignMatch = reader.bool();
                    break;
                case 21:
                    message.MiniVipRemainTime = reader.int32();
                    break;
                case 22:
                    if (!(message.Huodongs && message.Huodongs.length))
                        message.Huodongs = [];
                    message.Huodongs.push($root.pb.HuodongData.decode(reader, reader.uint32()));
                    break;
                case 23:
                    message.RebornCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LoginReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LoginReply} LoginReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginReply message.
         * @function verify
         * @memberof pb.LoginReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i) {
                    var error = $root.pb.CardInfo.verify(message.Cards[i]);
                    if (error)
                        return "Cards." + error;
                }
            }
            if (message.Res != null && message.hasOwnProperty("Res")) {
                if (!Array.isArray(message.Res))
                    return "Res: array expected";
                for (var i = 0; i < message.Res.length; ++i) {
                    var error = $root.pb.Resource.verify(message.Res[i]);
                    if (error)
                        return "Res." + error;
                }
            }
            if (message.DiyCards != null && message.hasOwnProperty("DiyCards")) {
                if (!Array.isArray(message.DiyCards))
                    return "DiyCards: array expected";
                for (var i = 0; i < message.DiyCards.length; ++i) {
                    var error = $root.pb.DiyCardData.verify(message.DiyCards[i]);
                    if (error)
                        return "DiyCards." + error;
                }
            }
            if (message.FightID != null && message.hasOwnProperty("FightID"))
                if (!$util.isInteger(message.FightID) && !(message.FightID && $util.isInteger(message.FightID.low) && $util.isInteger(message.FightID.high)))
                    return "FightID: integer|Long expected";
            if (message.ServerID != null && message.hasOwnProperty("ServerID"))
                if (!$util.isString(message.ServerID))
                    return "ServerID: string expected";
            if (message.GuideCamp != null && message.hasOwnProperty("GuideCamp"))
                if (!$util.isInteger(message.GuideCamp))
                    return "GuideCamp: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Ver != null && message.hasOwnProperty("Ver")) {
                var error = $root.pb.Version.verify(message.Ver);
                if (error)
                    return "Ver." + error;
            }
            if (message.IsExamined != null && message.hasOwnProperty("IsExamined"))
                if (typeof message.IsExamined !== "boolean")
                    return "IsExamined: boolean expected";
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                if (!$util.isString(message.HeadImg))
                    return "HeadImg: string expected";
            if (message.CumulativePay != null && message.hasOwnProperty("CumulativePay"))
                if (!$util.isInteger(message.CumulativePay))
                    return "CumulativePay: integer expected";
            if (message.IsIosShared != null && message.hasOwnProperty("IsIosShared"))
                if (typeof message.IsIosShared !== "boolean")
                    return "IsIosShared: boolean expected";
            if (message.SeasonPvpLimitTime != null && message.hasOwnProperty("SeasonPvpLimitTime"))
                if (!$util.isInteger(message.SeasonPvpLimitTime))
                    return "SeasonPvpLimitTime: integer expected";
            if (message.VipRemainTime != null && message.hasOwnProperty("VipRemainTime"))
                if (!$util.isInteger(message.VipRemainTime))
                    return "VipRemainTime: integer expected";
            if (message.CardSkins != null && message.hasOwnProperty("CardSkins")) {
                if (!Array.isArray(message.CardSkins))
                    return "CardSkins: array expected";
                for (var i = 0; i < message.CardSkins.length; ++i)
                    if (!$util.isString(message.CardSkins[i]))
                        return "CardSkins: string[] expected";
            }
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.Privileges != null && message.hasOwnProperty("Privileges")) {
                if (!Array.isArray(message.Privileges))
                    return "Privileges: array expected";
                for (var i = 0; i < message.Privileges.length; ++i)
                    if (!$util.isInteger(message.Privileges[i]))
                        return "Privileges: integer[] expected";
            }
            if (message.IsSeasonPvpChooseCard != null && message.hasOwnProperty("IsSeasonPvpChooseCard"))
                if (typeof message.IsSeasonPvpChooseCard !== "boolean")
                    return "IsSeasonPvpChooseCard: boolean expected";
            if (message.IsInCampaignMatch != null && message.hasOwnProperty("IsInCampaignMatch"))
                if (typeof message.IsInCampaignMatch !== "boolean")
                    return "IsInCampaignMatch: boolean expected";
            if (message.MiniVipRemainTime != null && message.hasOwnProperty("MiniVipRemainTime"))
                if (!$util.isInteger(message.MiniVipRemainTime))
                    return "MiniVipRemainTime: integer expected";
            if (message.Huodongs != null && message.hasOwnProperty("Huodongs")) {
                if (!Array.isArray(message.Huodongs))
                    return "Huodongs: array expected";
                for (var i = 0; i < message.Huodongs.length; ++i) {
                    var error = $root.pb.HuodongData.verify(message.Huodongs[i]);
                    if (error)
                        return "Huodongs." + error;
                }
            }
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                if (!$util.isInteger(message.RebornCnt))
                    return "RebornCnt: integer expected";
            return null;
        };

        return LoginReply;
    })();

    pb.AccountLoginArg = (function() {

        /**
         * Properties of an AccountLoginArg.
         * @memberof pb
         * @interface IAccountLoginArg
         * @property {string|null} [Channel] AccountLoginArg Channel
         * @property {string|null} [ChannelID] AccountLoginArg ChannelID
         * @property {string|null} [Account] AccountLoginArg Account
         * @property {string|null} [Password] AccountLoginArg Password
         * @property {string|null} [SdkToken] AccountLoginArg SdkToken
         * @property {boolean|null} [IsTourist] AccountLoginArg IsTourist
         * @property {string|null} [LoginChannel] AccountLoginArg LoginChannel
         */

        /**
         * Constructs a new AccountLoginArg.
         * @memberof pb
         * @classdesc Represents an AccountLoginArg.
         * @implements IAccountLoginArg
         * @constructor
         * @param {pb.IAccountLoginArg=} [properties] Properties to set
         */
        function AccountLoginArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountLoginArg Channel.
         * @member {string} Channel
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.Channel = "";

        /**
         * AccountLoginArg ChannelID.
         * @member {string} ChannelID
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.ChannelID = "";

        /**
         * AccountLoginArg Account.
         * @member {string} Account
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.Account = "";

        /**
         * AccountLoginArg Password.
         * @member {string} Password
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.Password = "";

        /**
         * AccountLoginArg SdkToken.
         * @member {string} SdkToken
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.SdkToken = "";

        /**
         * AccountLoginArg IsTourist.
         * @member {boolean} IsTourist
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.IsTourist = false;

        /**
         * AccountLoginArg LoginChannel.
         * @member {string} LoginChannel
         * @memberof pb.AccountLoginArg
         * @instance
         */
        AccountLoginArg.prototype.LoginChannel = "";

        /**
         * Creates a new AccountLoginArg instance using the specified properties.
         * @function create
         * @memberof pb.AccountLoginArg
         * @static
         * @param {pb.IAccountLoginArg=} [properties] Properties to set
         * @returns {pb.AccountLoginArg} AccountLoginArg instance
         */
        AccountLoginArg.create = function create(properties) {
            return new AccountLoginArg(properties);
        };

        /**
         * Encodes the specified AccountLoginArg message. Does not implicitly {@link pb.AccountLoginArg.verify|verify} messages.
         * @function encode
         * @memberof pb.AccountLoginArg
         * @static
         * @param {pb.IAccountLoginArg} message AccountLoginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Channel);
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ChannelID);
            if (message.Account != null && message.hasOwnProperty("Account"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Account);
            if (message.Password != null && message.hasOwnProperty("Password"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Password);
            if (message.SdkToken != null && message.hasOwnProperty("SdkToken"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.SdkToken);
            if (message.IsTourist != null && message.hasOwnProperty("IsTourist"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsTourist);
            if (message.LoginChannel != null && message.hasOwnProperty("LoginChannel"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.LoginChannel);
            return writer;
        };

        /**
         * Encodes the specified AccountLoginArg message, length delimited. Does not implicitly {@link pb.AccountLoginArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AccountLoginArg
         * @static
         * @param {pb.IAccountLoginArg} message AccountLoginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountLoginArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountLoginArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AccountLoginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AccountLoginArg} AccountLoginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AccountLoginArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.string();
                    break;
                case 2:
                    message.ChannelID = reader.string();
                    break;
                case 3:
                    message.Account = reader.string();
                    break;
                case 4:
                    message.Password = reader.string();
                    break;
                case 5:
                    message.SdkToken = reader.string();
                    break;
                case 6:
                    message.IsTourist = reader.bool();
                    break;
                case 7:
                    message.LoginChannel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountLoginArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AccountLoginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AccountLoginArg} AccountLoginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountLoginArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountLoginArg message.
         * @function verify
         * @memberof pb.AccountLoginArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountLoginArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                if (!$util.isString(message.ChannelID))
                    return "ChannelID: string expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            if (message.SdkToken != null && message.hasOwnProperty("SdkToken"))
                if (!$util.isString(message.SdkToken))
                    return "SdkToken: string expected";
            if (message.IsTourist != null && message.hasOwnProperty("IsTourist"))
                if (typeof message.IsTourist !== "boolean")
                    return "IsTourist: boolean expected";
            if (message.LoginChannel != null && message.hasOwnProperty("LoginChannel"))
                if (!$util.isString(message.LoginChannel))
                    return "LoginChannel: string expected";
            return null;
        };

        return AccountLoginArg;
    })();

    pb.Archive = (function() {

        /**
         * Properties of an Archive.
         * @memberof pb
         * @interface IArchive
         * @property {number|null} [ID] Archive ID
         * @property {number|Long|null} [Uid] Archive Uid
         * @property {number|null} [LastTime] Archive LastTime
         */

        /**
         * Constructs a new Archive.
         * @memberof pb
         * @classdesc Represents an Archive.
         * @implements IArchive
         * @constructor
         * @param {pb.IArchive=} [properties] Properties to set
         */
        function Archive(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Archive ID.
         * @member {number} ID
         * @memberof pb.Archive
         * @instance
         */
        Archive.prototype.ID = 0;

        /**
         * Archive Uid.
         * @member {number|Long} Uid
         * @memberof pb.Archive
         * @instance
         */
        Archive.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Archive LastTime.
         * @member {number} LastTime
         * @memberof pb.Archive
         * @instance
         */
        Archive.prototype.LastTime = 0;

        /**
         * Creates a new Archive instance using the specified properties.
         * @function create
         * @memberof pb.Archive
         * @static
         * @param {pb.IArchive=} [properties] Properties to set
         * @returns {pb.Archive} Archive instance
         */
        Archive.create = function create(properties) {
            return new Archive(properties);
        };

        /**
         * Encodes the specified Archive message. Does not implicitly {@link pb.Archive.verify|verify} messages.
         * @function encode
         * @memberof pb.Archive
         * @static
         * @param {pb.IArchive} message Archive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Archive.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.Uid);
            if (message.LastTime != null && message.hasOwnProperty("LastTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.LastTime);
            return writer;
        };

        /**
         * Encodes the specified Archive message, length delimited. Does not implicitly {@link pb.Archive.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Archive
         * @static
         * @param {pb.IArchive} message Archive message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Archive.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Archive message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Archive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Archive} Archive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Archive.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Archive();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Uid = reader.uint64();
                    break;
                case 3:
                    message.LastTime = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Archive message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Archive
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Archive} Archive
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Archive.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Archive message.
         * @function verify
         * @memberof pb.Archive
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Archive.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.LastTime != null && message.hasOwnProperty("LastTime"))
                if (!$util.isInteger(message.LastTime))
                    return "LastTime: integer expected";
            return null;
        };

        return Archive;
    })();

    pb.AccountArchives = (function() {

        /**
         * Properties of an AccountArchives.
         * @memberof pb
         * @interface IAccountArchives
         * @property {Array.<pb.IArchive>|null} [Archives] AccountArchives Archives
         */

        /**
         * Constructs a new AccountArchives.
         * @memberof pb
         * @classdesc Represents an AccountArchives.
         * @implements IAccountArchives
         * @constructor
         * @param {pb.IAccountArchives=} [properties] Properties to set
         */
        function AccountArchives(properties) {
            this.Archives = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AccountArchives Archives.
         * @member {Array.<pb.IArchive>} Archives
         * @memberof pb.AccountArchives
         * @instance
         */
        AccountArchives.prototype.Archives = $util.emptyArray;

        /**
         * Creates a new AccountArchives instance using the specified properties.
         * @function create
         * @memberof pb.AccountArchives
         * @static
         * @param {pb.IAccountArchives=} [properties] Properties to set
         * @returns {pb.AccountArchives} AccountArchives instance
         */
        AccountArchives.create = function create(properties) {
            return new AccountArchives(properties);
        };

        /**
         * Encodes the specified AccountArchives message. Does not implicitly {@link pb.AccountArchives.verify|verify} messages.
         * @function encode
         * @memberof pb.AccountArchives
         * @static
         * @param {pb.IAccountArchives} message AccountArchives message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountArchives.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Archives != null && message.Archives.length)
                for (var i = 0; i < message.Archives.length; ++i)
                    $root.pb.Archive.encode(message.Archives[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AccountArchives message, length delimited. Does not implicitly {@link pb.AccountArchives.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.AccountArchives
         * @static
         * @param {pb.IAccountArchives} message AccountArchives message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AccountArchives.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AccountArchives message from the specified reader or buffer.
         * @function decode
         * @memberof pb.AccountArchives
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.AccountArchives} AccountArchives
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountArchives.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.AccountArchives();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Archives && message.Archives.length))
                        message.Archives = [];
                    message.Archives.push($root.pb.Archive.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AccountArchives message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.AccountArchives
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.AccountArchives} AccountArchives
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AccountArchives.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AccountArchives message.
         * @function verify
         * @memberof pb.AccountArchives
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AccountArchives.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Archives != null && message.hasOwnProperty("Archives")) {
                if (!Array.isArray(message.Archives))
                    return "Archives: array expected";
                for (var i = 0; i < message.Archives.length; ++i) {
                    var error = $root.pb.Archive.verify(message.Archives[i]);
                    if (error)
                        return "Archives." + error;
                }
            }
            return null;
        };

        return AccountArchives;
    })();

    pb.RegisterAccount = (function() {

        /**
         * Properties of a RegisterAccount.
         * @memberof pb
         * @interface IRegisterAccount
         * @property {string|null} [Channel] RegisterAccount Channel
         * @property {string|null} [Account] RegisterAccount Account
         * @property {string|null} [Password] RegisterAccount Password
         */

        /**
         * Constructs a new RegisterAccount.
         * @memberof pb
         * @classdesc Represents a RegisterAccount.
         * @implements IRegisterAccount
         * @constructor
         * @param {pb.IRegisterAccount=} [properties] Properties to set
         */
        function RegisterAccount(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RegisterAccount Channel.
         * @member {string} Channel
         * @memberof pb.RegisterAccount
         * @instance
         */
        RegisterAccount.prototype.Channel = "";

        /**
         * RegisterAccount Account.
         * @member {string} Account
         * @memberof pb.RegisterAccount
         * @instance
         */
        RegisterAccount.prototype.Account = "";

        /**
         * RegisterAccount Password.
         * @member {string} Password
         * @memberof pb.RegisterAccount
         * @instance
         */
        RegisterAccount.prototype.Password = "";

        /**
         * Creates a new RegisterAccount instance using the specified properties.
         * @function create
         * @memberof pb.RegisterAccount
         * @static
         * @param {pb.IRegisterAccount=} [properties] Properties to set
         * @returns {pb.RegisterAccount} RegisterAccount instance
         */
        RegisterAccount.create = function create(properties) {
            return new RegisterAccount(properties);
        };

        /**
         * Encodes the specified RegisterAccount message. Does not implicitly {@link pb.RegisterAccount.verify|verify} messages.
         * @function encode
         * @memberof pb.RegisterAccount
         * @static
         * @param {pb.IRegisterAccount} message RegisterAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterAccount.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Channel);
            if (message.Account != null && message.hasOwnProperty("Account"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Account);
            if (message.Password != null && message.hasOwnProperty("Password"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified RegisterAccount message, length delimited. Does not implicitly {@link pb.RegisterAccount.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RegisterAccount
         * @static
         * @param {pb.IRegisterAccount} message RegisterAccount message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RegisterAccount.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RegisterAccount message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RegisterAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RegisterAccount} RegisterAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterAccount.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RegisterAccount();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.string();
                    break;
                case 2:
                    message.Account = reader.string();
                    break;
                case 3:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RegisterAccount message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RegisterAccount
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RegisterAccount} RegisterAccount
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RegisterAccount.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RegisterAccount message.
         * @function verify
         * @memberof pb.RegisterAccount
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RegisterAccount.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        return RegisterAccount;
    })();

    pb.DelArchiveArg = (function() {

        /**
         * Properties of a DelArchiveArg.
         * @memberof pb
         * @interface IDelArchiveArg
         * @property {string|null} [Channel] DelArchiveArg Channel
         * @property {string|null} [ChannelID] DelArchiveArg ChannelID
         * @property {number|null} [ArchiveID] DelArchiveArg ArchiveID
         */

        /**
         * Constructs a new DelArchiveArg.
         * @memberof pb
         * @classdesc Represents a DelArchiveArg.
         * @implements IDelArchiveArg
         * @constructor
         * @param {pb.IDelArchiveArg=} [properties] Properties to set
         */
        function DelArchiveArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelArchiveArg Channel.
         * @member {string} Channel
         * @memberof pb.DelArchiveArg
         * @instance
         */
        DelArchiveArg.prototype.Channel = "";

        /**
         * DelArchiveArg ChannelID.
         * @member {string} ChannelID
         * @memberof pb.DelArchiveArg
         * @instance
         */
        DelArchiveArg.prototype.ChannelID = "";

        /**
         * DelArchiveArg ArchiveID.
         * @member {number} ArchiveID
         * @memberof pb.DelArchiveArg
         * @instance
         */
        DelArchiveArg.prototype.ArchiveID = 0;

        /**
         * Creates a new DelArchiveArg instance using the specified properties.
         * @function create
         * @memberof pb.DelArchiveArg
         * @static
         * @param {pb.IDelArchiveArg=} [properties] Properties to set
         * @returns {pb.DelArchiveArg} DelArchiveArg instance
         */
        DelArchiveArg.create = function create(properties) {
            return new DelArchiveArg(properties);
        };

        /**
         * Encodes the specified DelArchiveArg message. Does not implicitly {@link pb.DelArchiveArg.verify|verify} messages.
         * @function encode
         * @memberof pb.DelArchiveArg
         * @static
         * @param {pb.IDelArchiveArg} message DelArchiveArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelArchiveArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Channel);
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ChannelID);
            if (message.ArchiveID != null && message.hasOwnProperty("ArchiveID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ArchiveID);
            return writer;
        };

        /**
         * Encodes the specified DelArchiveArg message, length delimited. Does not implicitly {@link pb.DelArchiveArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.DelArchiveArg
         * @static
         * @param {pb.IDelArchiveArg} message DelArchiveArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelArchiveArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelArchiveArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.DelArchiveArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.DelArchiveArg} DelArchiveArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelArchiveArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.DelArchiveArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.string();
                    break;
                case 2:
                    message.ChannelID = reader.string();
                    break;
                case 3:
                    message.ArchiveID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelArchiveArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.DelArchiveArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.DelArchiveArg} DelArchiveArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelArchiveArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelArchiveArg message.
         * @function verify
         * @memberof pb.DelArchiveArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelArchiveArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            if (message.ChannelID != null && message.hasOwnProperty("ChannelID"))
                if (!$util.isString(message.ChannelID))
                    return "ChannelID: string expected";
            if (message.ArchiveID != null && message.hasOwnProperty("ArchiveID"))
                if (!$util.isInteger(message.ArchiveID))
                    return "ArchiveID: integer expected";
            return null;
        };

        return DelArchiveArg;
    })();

    pb.ResourceModify = (function() {

        /**
         * Properties of a ResourceModify.
         * @memberof pb
         * @interface IResourceModify
         * @property {Array.<pb.IResource>|null} [Res] ResourceModify Res
         */

        /**
         * Constructs a new ResourceModify.
         * @memberof pb
         * @classdesc Represents a ResourceModify.
         * @implements IResourceModify
         * @constructor
         * @param {pb.IResourceModify=} [properties] Properties to set
         */
        function ResourceModify(properties) {
            this.Res = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ResourceModify Res.
         * @member {Array.<pb.IResource>} Res
         * @memberof pb.ResourceModify
         * @instance
         */
        ResourceModify.prototype.Res = $util.emptyArray;

        /**
         * Creates a new ResourceModify instance using the specified properties.
         * @function create
         * @memberof pb.ResourceModify
         * @static
         * @param {pb.IResourceModify=} [properties] Properties to set
         * @returns {pb.ResourceModify} ResourceModify instance
         */
        ResourceModify.create = function create(properties) {
            return new ResourceModify(properties);
        };

        /**
         * Encodes the specified ResourceModify message. Does not implicitly {@link pb.ResourceModify.verify|verify} messages.
         * @function encode
         * @memberof pb.ResourceModify
         * @static
         * @param {pb.IResourceModify} message ResourceModify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceModify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Res != null && message.Res.length)
                for (var i = 0; i < message.Res.length; ++i)
                    $root.pb.Resource.encode(message.Res[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ResourceModify message, length delimited. Does not implicitly {@link pb.ResourceModify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ResourceModify
         * @static
         * @param {pb.IResourceModify} message ResourceModify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ResourceModify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ResourceModify message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ResourceModify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ResourceModify} ResourceModify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceModify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ResourceModify();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Res && message.Res.length))
                        message.Res = [];
                    message.Res.push($root.pb.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ResourceModify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ResourceModify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ResourceModify} ResourceModify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ResourceModify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ResourceModify message.
         * @function verify
         * @memberof pb.ResourceModify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ResourceModify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Res != null && message.hasOwnProperty("Res")) {
                if (!Array.isArray(message.Res))
                    return "Res: array expected";
                for (var i = 0; i < message.Res.length; ++i) {
                    var error = $root.pb.Resource.verify(message.Res[i]);
                    if (error)
                        return "Res." + error;
                }
            }
            return null;
        };

        return ResourceModify;
    })();

    pb.ModifyNameArg = (function() {

        /**
         * Properties of a ModifyNameArg.
         * @memberof pb
         * @interface IModifyNameArg
         * @property {string|null} [Name] ModifyNameArg Name
         */

        /**
         * Constructs a new ModifyNameArg.
         * @memberof pb
         * @classdesc Represents a ModifyNameArg.
         * @implements IModifyNameArg
         * @constructor
         * @param {pb.IModifyNameArg=} [properties] Properties to set
         */
        function ModifyNameArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ModifyNameArg Name.
         * @member {string} Name
         * @memberof pb.ModifyNameArg
         * @instance
         */
        ModifyNameArg.prototype.Name = "";

        /**
         * Creates a new ModifyNameArg instance using the specified properties.
         * @function create
         * @memberof pb.ModifyNameArg
         * @static
         * @param {pb.IModifyNameArg=} [properties] Properties to set
         * @returns {pb.ModifyNameArg} ModifyNameArg instance
         */
        ModifyNameArg.create = function create(properties) {
            return new ModifyNameArg(properties);
        };

        /**
         * Encodes the specified ModifyNameArg message. Does not implicitly {@link pb.ModifyNameArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ModifyNameArg
         * @static
         * @param {pb.IModifyNameArg} message ModifyNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNameArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified ModifyNameArg message, length delimited. Does not implicitly {@link pb.ModifyNameArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ModifyNameArg
         * @static
         * @param {pb.IModifyNameArg} message ModifyNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ModifyNameArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ModifyNameArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ModifyNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ModifyNameArg} ModifyNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNameArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ModifyNameArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ModifyNameArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ModifyNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ModifyNameArg} ModifyNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ModifyNameArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ModifyNameArg message.
         * @function verify
         * @memberof pb.ModifyNameArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ModifyNameArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return ModifyNameArg;
    })();

    pb.UpdateNameArg = (function() {

        /**
         * Properties of an UpdateNameArg.
         * @memberof pb
         * @interface IUpdateNameArg
         * @property {string|null} [Name] UpdateNameArg Name
         */

        /**
         * Constructs a new UpdateNameArg.
         * @memberof pb
         * @classdesc Represents an UpdateNameArg.
         * @implements IUpdateNameArg
         * @constructor
         * @param {pb.IUpdateNameArg=} [properties] Properties to set
         */
        function UpdateNameArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateNameArg Name.
         * @member {string} Name
         * @memberof pb.UpdateNameArg
         * @instance
         */
        UpdateNameArg.prototype.Name = "";

        /**
         * Creates a new UpdateNameArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateNameArg
         * @static
         * @param {pb.IUpdateNameArg=} [properties] Properties to set
         * @returns {pb.UpdateNameArg} UpdateNameArg instance
         */
        UpdateNameArg.create = function create(properties) {
            return new UpdateNameArg(properties);
        };

        /**
         * Encodes the specified UpdateNameArg message. Does not implicitly {@link pb.UpdateNameArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateNameArg
         * @static
         * @param {pb.IUpdateNameArg} message UpdateNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateNameArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified UpdateNameArg message, length delimited. Does not implicitly {@link pb.UpdateNameArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateNameArg
         * @static
         * @param {pb.IUpdateNameArg} message UpdateNameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateNameArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateNameArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateNameArg} UpdateNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateNameArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateNameArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateNameArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateNameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateNameArg} UpdateNameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateNameArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateNameArg message.
         * @function verify
         * @memberof pb.UpdateNameArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateNameArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return UpdateNameArg;
    })();

    pb.Version = (function() {

        /**
         * Properties of a Version.
         * @memberof pb
         * @interface IVersion
         * @property {number|null} [V1] Version V1
         * @property {number|null} [V2] Version V2
         * @property {number|null} [V3] Version V3
         */

        /**
         * Constructs a new Version.
         * @memberof pb
         * @classdesc Represents a Version.
         * @implements IVersion
         * @constructor
         * @param {pb.IVersion=} [properties] Properties to set
         */
        function Version(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Version V1.
         * @member {number} V1
         * @memberof pb.Version
         * @instance
         */
        Version.prototype.V1 = 0;

        /**
         * Version V2.
         * @member {number} V2
         * @memberof pb.Version
         * @instance
         */
        Version.prototype.V2 = 0;

        /**
         * Version V3.
         * @member {number} V3
         * @memberof pb.Version
         * @instance
         */
        Version.prototype.V3 = 0;

        /**
         * Creates a new Version instance using the specified properties.
         * @function create
         * @memberof pb.Version
         * @static
         * @param {pb.IVersion=} [properties] Properties to set
         * @returns {pb.Version} Version instance
         */
        Version.create = function create(properties) {
            return new Version(properties);
        };

        /**
         * Encodes the specified Version message. Does not implicitly {@link pb.Version.verify|verify} messages.
         * @function encode
         * @memberof pb.Version
         * @static
         * @param {pb.IVersion} message Version message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Version.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.V1 != null && message.hasOwnProperty("V1"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.V1);
            if (message.V2 != null && message.hasOwnProperty("V2"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.V2);
            if (message.V3 != null && message.hasOwnProperty("V3"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.V3);
            return writer;
        };

        /**
         * Encodes the specified Version message, length delimited. Does not implicitly {@link pb.Version.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Version
         * @static
         * @param {pb.IVersion} message Version message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Version.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Version message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Version
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Version} Version
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Version.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Version();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.V1 = reader.int32();
                    break;
                case 2:
                    message.V2 = reader.int32();
                    break;
                case 3:
                    message.V3 = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Version message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Version
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Version} Version
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Version.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Version message.
         * @function verify
         * @memberof pb.Version
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Version.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.V1 != null && message.hasOwnProperty("V1"))
                if (!$util.isInteger(message.V1))
                    return "V1: integer expected";
            if (message.V2 != null && message.hasOwnProperty("V2"))
                if (!$util.isInteger(message.V2))
                    return "V2: integer expected";
            if (message.V3 != null && message.hasOwnProperty("V3"))
                if (!$util.isInteger(message.V3))
                    return "V3: integer expected";
            return null;
        };

        return Version;
    })();

    pb.LoadPlayerArg = (function() {

        /**
         * Properties of a LoadPlayerArg.
         * @memberof pb
         * @interface ILoadPlayerArg
         * @property {number|Long|null} [Uid] LoadPlayerArg Uid
         */

        /**
         * Constructs a new LoadPlayerArg.
         * @memberof pb
         * @classdesc Represents a LoadPlayerArg.
         * @implements ILoadPlayerArg
         * @constructor
         * @param {pb.ILoadPlayerArg=} [properties] Properties to set
         */
        function LoadPlayerArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoadPlayerArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.LoadPlayerArg
         * @instance
         */
        LoadPlayerArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new LoadPlayerArg instance using the specified properties.
         * @function create
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {pb.ILoadPlayerArg=} [properties] Properties to set
         * @returns {pb.LoadPlayerArg} LoadPlayerArg instance
         */
        LoadPlayerArg.create = function create(properties) {
            return new LoadPlayerArg(properties);
        };

        /**
         * Encodes the specified LoadPlayerArg message. Does not implicitly {@link pb.LoadPlayerArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {pb.ILoadPlayerArg} message LoadPlayerArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadPlayerArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified LoadPlayerArg message, length delimited. Does not implicitly {@link pb.LoadPlayerArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {pb.ILoadPlayerArg} message LoadPlayerArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoadPlayerArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoadPlayerArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LoadPlayerArg} LoadPlayerArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadPlayerArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LoadPlayerArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoadPlayerArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LoadPlayerArg} LoadPlayerArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoadPlayerArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoadPlayerArg message.
         * @function verify
         * @memberof pb.LoadPlayerArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoadPlayerArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return LoadPlayerArg;
    })();

    pb.SimplePlayerInfo = (function() {

        /**
         * Properties of a SimplePlayerInfo.
         * @memberof pb
         * @interface ISimplePlayerInfo
         * @property {string|null} [Name] SimplePlayerInfo Name
         * @property {number|null} [PvpScore] SimplePlayerInfo PvpScore
         * @property {string|null} [HeadImgUrl] SimplePlayerInfo HeadImgUrl
         * @property {number|null} [FirstHandAmount] SimplePlayerInfo FirstHandAmount
         * @property {number|null} [BackHandAmount] SimplePlayerInfo BackHandAmount
         * @property {number|null} [FirstHandWinAmount] SimplePlayerInfo FirstHandWinAmount
         * @property {number|null} [BackHandWinAmount] SimplePlayerInfo BackHandWinAmount
         * @property {number|null} [RankScore] SimplePlayerInfo RankScore
         * @property {Array.<pb.ISkinGCard>|null} [FavoriteCards] SimplePlayerInfo FavoriteCards
         * @property {Array.<pb.ISkinGCard>|null} [FightCards] SimplePlayerInfo FightCards
         * @property {boolean|null} [IsWechatFriend] SimplePlayerInfo IsWechatFriend
         * @property {boolean|null} [IsOnline] SimplePlayerInfo IsOnline
         * @property {boolean|null} [IsInBattle] SimplePlayerInfo IsInBattle
         * @property {number|null} [LastOnlineTime] SimplePlayerInfo LastOnlineTime
         * @property {number|Long|null} [Uid] SimplePlayerInfo Uid
         * @property {number|null} [PvpCamp] SimplePlayerInfo PvpCamp
         * @property {string|null} [Country] SimplePlayerInfo Country
         * @property {string|null} [HeadFrame] SimplePlayerInfo HeadFrame
         * @property {number|null} [RebornCnt] SimplePlayerInfo RebornCnt
         */

        /**
         * Constructs a new SimplePlayerInfo.
         * @memberof pb
         * @classdesc Represents a SimplePlayerInfo.
         * @implements ISimplePlayerInfo
         * @constructor
         * @param {pb.ISimplePlayerInfo=} [properties] Properties to set
         */
        function SimplePlayerInfo(properties) {
            this.FavoriteCards = [];
            this.FightCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimplePlayerInfo Name.
         * @member {string} Name
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.Name = "";

        /**
         * SimplePlayerInfo PvpScore.
         * @member {number} PvpScore
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.PvpScore = 0;

        /**
         * SimplePlayerInfo HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.HeadImgUrl = "";

        /**
         * SimplePlayerInfo FirstHandAmount.
         * @member {number} FirstHandAmount
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.FirstHandAmount = 0;

        /**
         * SimplePlayerInfo BackHandAmount.
         * @member {number} BackHandAmount
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.BackHandAmount = 0;

        /**
         * SimplePlayerInfo FirstHandWinAmount.
         * @member {number} FirstHandWinAmount
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.FirstHandWinAmount = 0;

        /**
         * SimplePlayerInfo BackHandWinAmount.
         * @member {number} BackHandWinAmount
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.BackHandWinAmount = 0;

        /**
         * SimplePlayerInfo RankScore.
         * @member {number} RankScore
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.RankScore = 0;

        /**
         * SimplePlayerInfo FavoriteCards.
         * @member {Array.<pb.ISkinGCard>} FavoriteCards
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.FavoriteCards = $util.emptyArray;

        /**
         * SimplePlayerInfo FightCards.
         * @member {Array.<pb.ISkinGCard>} FightCards
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.FightCards = $util.emptyArray;

        /**
         * SimplePlayerInfo IsWechatFriend.
         * @member {boolean} IsWechatFriend
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.IsWechatFriend = false;

        /**
         * SimplePlayerInfo IsOnline.
         * @member {boolean} IsOnline
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.IsOnline = false;

        /**
         * SimplePlayerInfo IsInBattle.
         * @member {boolean} IsInBattle
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.IsInBattle = false;

        /**
         * SimplePlayerInfo LastOnlineTime.
         * @member {number} LastOnlineTime
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.LastOnlineTime = 0;

        /**
         * SimplePlayerInfo Uid.
         * @member {number|Long} Uid
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SimplePlayerInfo PvpCamp.
         * @member {number} PvpCamp
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.PvpCamp = 0;

        /**
         * SimplePlayerInfo Country.
         * @member {string} Country
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.Country = "";

        /**
         * SimplePlayerInfo HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.HeadFrame = "";

        /**
         * SimplePlayerInfo RebornCnt.
         * @member {number} RebornCnt
         * @memberof pb.SimplePlayerInfo
         * @instance
         */
        SimplePlayerInfo.prototype.RebornCnt = 0;

        /**
         * Creates a new SimplePlayerInfo instance using the specified properties.
         * @function create
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {pb.ISimplePlayerInfo=} [properties] Properties to set
         * @returns {pb.SimplePlayerInfo} SimplePlayerInfo instance
         */
        SimplePlayerInfo.create = function create(properties) {
            return new SimplePlayerInfo(properties);
        };

        /**
         * Encodes the specified SimplePlayerInfo message. Does not implicitly {@link pb.SimplePlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {pb.ISimplePlayerInfo} message SimplePlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimplePlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PvpScore);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImgUrl);
            if (message.FirstHandAmount != null && message.hasOwnProperty("FirstHandAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.FirstHandAmount);
            if (message.BackHandAmount != null && message.hasOwnProperty("BackHandAmount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.BackHandAmount);
            if (message.FirstHandWinAmount != null && message.hasOwnProperty("FirstHandWinAmount"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.FirstHandWinAmount);
            if (message.BackHandWinAmount != null && message.hasOwnProperty("BackHandWinAmount"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.BackHandWinAmount);
            if (message.RankScore != null && message.hasOwnProperty("RankScore"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.RankScore);
            if (message.FavoriteCards != null && message.FavoriteCards.length)
                for (var i = 0; i < message.FavoriteCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FavoriteCards[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.FightCards != null && message.FightCards.length)
                for (var i = 0; i < message.FightCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FightCards[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.IsWechatFriend);
            if (message.IsOnline != null && message.hasOwnProperty("IsOnline"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.IsOnline);
            if (message.IsInBattle != null && message.hasOwnProperty("IsInBattle"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.IsInBattle);
            if (message.LastOnlineTime != null && message.hasOwnProperty("LastOnlineTime"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.LastOnlineTime);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 15, wireType 0 =*/120).uint64(message.Uid);
            if (message.PvpCamp != null && message.hasOwnProperty("PvpCamp"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.PvpCamp);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 17, wireType 2 =*/138).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.HeadFrame);
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.RebornCnt);
            return writer;
        };

        /**
         * Encodes the specified SimplePlayerInfo message, length delimited. Does not implicitly {@link pb.SimplePlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {pb.ISimplePlayerInfo} message SimplePlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimplePlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimplePlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SimplePlayerInfo} SimplePlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimplePlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SimplePlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.PvpScore = reader.int32();
                    break;
                case 3:
                    message.HeadImgUrl = reader.string();
                    break;
                case 4:
                    message.FirstHandAmount = reader.int32();
                    break;
                case 5:
                    message.BackHandAmount = reader.int32();
                    break;
                case 6:
                    message.FirstHandWinAmount = reader.int32();
                    break;
                case 7:
                    message.BackHandWinAmount = reader.int32();
                    break;
                case 8:
                    message.RankScore = reader.int32();
                    break;
                case 9:
                    if (!(message.FavoriteCards && message.FavoriteCards.length))
                        message.FavoriteCards = [];
                    message.FavoriteCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.FightCards && message.FightCards.length))
                        message.FightCards = [];
                    message.FightCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.IsWechatFriend = reader.bool();
                    break;
                case 12:
                    message.IsOnline = reader.bool();
                    break;
                case 13:
                    message.IsInBattle = reader.bool();
                    break;
                case 14:
                    message.LastOnlineTime = reader.int32();
                    break;
                case 15:
                    message.Uid = reader.uint64();
                    break;
                case 16:
                    message.PvpCamp = reader.int32();
                    break;
                case 17:
                    message.Country = reader.string();
                    break;
                case 18:
                    message.HeadFrame = reader.string();
                    break;
                case 19:
                    message.RebornCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimplePlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SimplePlayerInfo} SimplePlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimplePlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimplePlayerInfo message.
         * @function verify
         * @memberof pb.SimplePlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimplePlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.FirstHandAmount != null && message.hasOwnProperty("FirstHandAmount"))
                if (!$util.isInteger(message.FirstHandAmount))
                    return "FirstHandAmount: integer expected";
            if (message.BackHandAmount != null && message.hasOwnProperty("BackHandAmount"))
                if (!$util.isInteger(message.BackHandAmount))
                    return "BackHandAmount: integer expected";
            if (message.FirstHandWinAmount != null && message.hasOwnProperty("FirstHandWinAmount"))
                if (!$util.isInteger(message.FirstHandWinAmount))
                    return "FirstHandWinAmount: integer expected";
            if (message.BackHandWinAmount != null && message.hasOwnProperty("BackHandWinAmount"))
                if (!$util.isInteger(message.BackHandWinAmount))
                    return "BackHandWinAmount: integer expected";
            if (message.RankScore != null && message.hasOwnProperty("RankScore"))
                if (!$util.isInteger(message.RankScore))
                    return "RankScore: integer expected";
            if (message.FavoriteCards != null && message.hasOwnProperty("FavoriteCards")) {
                if (!Array.isArray(message.FavoriteCards))
                    return "FavoriteCards: array expected";
                for (var i = 0; i < message.FavoriteCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FavoriteCards[i]);
                    if (error)
                        return "FavoriteCards." + error;
                }
            }
            if (message.FightCards != null && message.hasOwnProperty("FightCards")) {
                if (!Array.isArray(message.FightCards))
                    return "FightCards: array expected";
                for (var i = 0; i < message.FightCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FightCards[i]);
                    if (error)
                        return "FightCards." + error;
                }
            }
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                if (typeof message.IsWechatFriend !== "boolean")
                    return "IsWechatFriend: boolean expected";
            if (message.IsOnline != null && message.hasOwnProperty("IsOnline"))
                if (typeof message.IsOnline !== "boolean")
                    return "IsOnline: boolean expected";
            if (message.IsInBattle != null && message.hasOwnProperty("IsInBattle"))
                if (typeof message.IsInBattle !== "boolean")
                    return "IsInBattle: boolean expected";
            if (message.LastOnlineTime != null && message.hasOwnProperty("LastOnlineTime"))
                if (!$util.isInteger(message.LastOnlineTime))
                    return "LastOnlineTime: integer expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.PvpCamp != null && message.hasOwnProperty("PvpCamp"))
                if (!$util.isInteger(message.PvpCamp))
                    return "PvpCamp: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                if (!$util.isInteger(message.RebornCnt))
                    return "RebornCnt: integer expected";
            return null;
        };

        return SimplePlayerInfo;
    })();

    pb.SdkUserInfo = (function() {

        /**
         * Properties of a SdkUserInfo.
         * @memberof pb
         * @interface ISdkUserInfo
         * @property {string|null} [NickName] SdkUserInfo NickName
         * @property {string|null} [HeadImgUrl] SdkUserInfo HeadImgUrl
         * @property {number|Long|null} [InviterUid] SdkUserInfo InviterUid
         */

        /**
         * Constructs a new SdkUserInfo.
         * @memberof pb
         * @classdesc Represents a SdkUserInfo.
         * @implements ISdkUserInfo
         * @constructor
         * @param {pb.ISdkUserInfo=} [properties] Properties to set
         */
        function SdkUserInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SdkUserInfo NickName.
         * @member {string} NickName
         * @memberof pb.SdkUserInfo
         * @instance
         */
        SdkUserInfo.prototype.NickName = "";

        /**
         * SdkUserInfo HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.SdkUserInfo
         * @instance
         */
        SdkUserInfo.prototype.HeadImgUrl = "";

        /**
         * SdkUserInfo InviterUid.
         * @member {number|Long} InviterUid
         * @memberof pb.SdkUserInfo
         * @instance
         */
        SdkUserInfo.prototype.InviterUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SdkUserInfo instance using the specified properties.
         * @function create
         * @memberof pb.SdkUserInfo
         * @static
         * @param {pb.ISdkUserInfo=} [properties] Properties to set
         * @returns {pb.SdkUserInfo} SdkUserInfo instance
         */
        SdkUserInfo.create = function create(properties) {
            return new SdkUserInfo(properties);
        };

        /**
         * Encodes the specified SdkUserInfo message. Does not implicitly {@link pb.SdkUserInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.SdkUserInfo
         * @static
         * @param {pb.ISdkUserInfo} message SdkUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkUserInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.NickName != null && message.hasOwnProperty("NickName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.NickName);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.HeadImgUrl);
            if (message.InviterUid != null && message.hasOwnProperty("InviterUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.InviterUid);
            return writer;
        };

        /**
         * Encodes the specified SdkUserInfo message, length delimited. Does not implicitly {@link pb.SdkUserInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SdkUserInfo
         * @static
         * @param {pb.ISdkUserInfo} message SdkUserInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkUserInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkUserInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SdkUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SdkUserInfo} SdkUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkUserInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SdkUserInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.NickName = reader.string();
                    break;
                case 2:
                    message.HeadImgUrl = reader.string();
                    break;
                case 3:
                    message.InviterUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkUserInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SdkUserInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SdkUserInfo} SdkUserInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkUserInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkUserInfo message.
         * @function verify
         * @memberof pb.SdkUserInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkUserInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.NickName != null && message.hasOwnProperty("NickName"))
                if (!$util.isString(message.NickName))
                    return "NickName: string expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.InviterUid != null && message.hasOwnProperty("InviterUid"))
                if (!$util.isInteger(message.InviterUid) && !(message.InviterUid && $util.isInteger(message.InviterUid.low) && $util.isInteger(message.InviterUid.high)))
                    return "InviterUid: integer|Long expected";
            return null;
        };

        return SdkUserInfo;
    })();

    pb.UpdateHeadImgArg = (function() {

        /**
         * Properties of an UpdateHeadImgArg.
         * @memberof pb
         * @interface IUpdateHeadImgArg
         * @property {string|null} [HeadImg] UpdateHeadImgArg HeadImg
         */

        /**
         * Constructs a new UpdateHeadImgArg.
         * @memberof pb
         * @classdesc Represents an UpdateHeadImgArg.
         * @implements IUpdateHeadImgArg
         * @constructor
         * @param {pb.IUpdateHeadImgArg=} [properties] Properties to set
         */
        function UpdateHeadImgArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateHeadImgArg HeadImg.
         * @member {string} HeadImg
         * @memberof pb.UpdateHeadImgArg
         * @instance
         */
        UpdateHeadImgArg.prototype.HeadImg = "";

        /**
         * Creates a new UpdateHeadImgArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {pb.IUpdateHeadImgArg=} [properties] Properties to set
         * @returns {pb.UpdateHeadImgArg} UpdateHeadImgArg instance
         */
        UpdateHeadImgArg.create = function create(properties) {
            return new UpdateHeadImgArg(properties);
        };

        /**
         * Encodes the specified UpdateHeadImgArg message. Does not implicitly {@link pb.UpdateHeadImgArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {pb.IUpdateHeadImgArg} message UpdateHeadImgArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateHeadImgArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HeadImg);
            return writer;
        };

        /**
         * Encodes the specified UpdateHeadImgArg message, length delimited. Does not implicitly {@link pb.UpdateHeadImgArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {pb.IUpdateHeadImgArg} message UpdateHeadImgArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateHeadImgArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateHeadImgArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateHeadImgArg} UpdateHeadImgArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateHeadImgArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateHeadImgArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HeadImg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateHeadImgArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateHeadImgArg} UpdateHeadImgArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateHeadImgArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateHeadImgArg message.
         * @function verify
         * @memberof pb.UpdateHeadImgArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateHeadImgArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HeadImg != null && message.hasOwnProperty("HeadImg"))
                if (!$util.isString(message.HeadImg))
                    return "HeadImg: string expected";
            return null;
        };

        return UpdateHeadImgArg;
    })();

    pb.TouristRegisterAccountArg = (function() {

        /**
         * Properties of a TouristRegisterAccountArg.
         * @memberof pb
         * @interface ITouristRegisterAccountArg
         * @property {string|null} [Channel] TouristRegisterAccountArg Channel
         */

        /**
         * Constructs a new TouristRegisterAccountArg.
         * @memberof pb
         * @classdesc Represents a TouristRegisterAccountArg.
         * @implements ITouristRegisterAccountArg
         * @constructor
         * @param {pb.ITouristRegisterAccountArg=} [properties] Properties to set
         */
        function TouristRegisterAccountArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TouristRegisterAccountArg Channel.
         * @member {string} Channel
         * @memberof pb.TouristRegisterAccountArg
         * @instance
         */
        TouristRegisterAccountArg.prototype.Channel = "";

        /**
         * Creates a new TouristRegisterAccountArg instance using the specified properties.
         * @function create
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {pb.ITouristRegisterAccountArg=} [properties] Properties to set
         * @returns {pb.TouristRegisterAccountArg} TouristRegisterAccountArg instance
         */
        TouristRegisterAccountArg.create = function create(properties) {
            return new TouristRegisterAccountArg(properties);
        };

        /**
         * Encodes the specified TouristRegisterAccountArg message. Does not implicitly {@link pb.TouristRegisterAccountArg.verify|verify} messages.
         * @function encode
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {pb.ITouristRegisterAccountArg} message TouristRegisterAccountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristRegisterAccountArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Channel);
            return writer;
        };

        /**
         * Encodes the specified TouristRegisterAccountArg message, length delimited. Does not implicitly {@link pb.TouristRegisterAccountArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {pb.ITouristRegisterAccountArg} message TouristRegisterAccountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristRegisterAccountArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TouristRegisterAccountArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TouristRegisterAccountArg} TouristRegisterAccountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristRegisterAccountArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TouristRegisterAccountArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TouristRegisterAccountArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TouristRegisterAccountArg} TouristRegisterAccountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristRegisterAccountArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TouristRegisterAccountArg message.
         * @function verify
         * @memberof pb.TouristRegisterAccountArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TouristRegisterAccountArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            return null;
        };

        return TouristRegisterAccountArg;
    })();

    pb.TouristRegisterAccountRelpy = (function() {

        /**
         * Properties of a TouristRegisterAccountRelpy.
         * @memberof pb
         * @interface ITouristRegisterAccountRelpy
         * @property {string|null} [Account] TouristRegisterAccountRelpy Account
         * @property {string|null} [Password] TouristRegisterAccountRelpy Password
         */

        /**
         * Constructs a new TouristRegisterAccountRelpy.
         * @memberof pb
         * @classdesc Represents a TouristRegisterAccountRelpy.
         * @implements ITouristRegisterAccountRelpy
         * @constructor
         * @param {pb.ITouristRegisterAccountRelpy=} [properties] Properties to set
         */
        function TouristRegisterAccountRelpy(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TouristRegisterAccountRelpy Account.
         * @member {string} Account
         * @memberof pb.TouristRegisterAccountRelpy
         * @instance
         */
        TouristRegisterAccountRelpy.prototype.Account = "";

        /**
         * TouristRegisterAccountRelpy Password.
         * @member {string} Password
         * @memberof pb.TouristRegisterAccountRelpy
         * @instance
         */
        TouristRegisterAccountRelpy.prototype.Password = "";

        /**
         * Creates a new TouristRegisterAccountRelpy instance using the specified properties.
         * @function create
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {pb.ITouristRegisterAccountRelpy=} [properties] Properties to set
         * @returns {pb.TouristRegisterAccountRelpy} TouristRegisterAccountRelpy instance
         */
        TouristRegisterAccountRelpy.create = function create(properties) {
            return new TouristRegisterAccountRelpy(properties);
        };

        /**
         * Encodes the specified TouristRegisterAccountRelpy message. Does not implicitly {@link pb.TouristRegisterAccountRelpy.verify|verify} messages.
         * @function encode
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {pb.ITouristRegisterAccountRelpy} message TouristRegisterAccountRelpy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristRegisterAccountRelpy.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Account != null && message.hasOwnProperty("Account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Account);
            if (message.Password != null && message.hasOwnProperty("Password"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Password);
            return writer;
        };

        /**
         * Encodes the specified TouristRegisterAccountRelpy message, length delimited. Does not implicitly {@link pb.TouristRegisterAccountRelpy.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {pb.ITouristRegisterAccountRelpy} message TouristRegisterAccountRelpy message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristRegisterAccountRelpy.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TouristRegisterAccountRelpy message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TouristRegisterAccountRelpy} TouristRegisterAccountRelpy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristRegisterAccountRelpy.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TouristRegisterAccountRelpy();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Account = reader.string();
                    break;
                case 2:
                    message.Password = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TouristRegisterAccountRelpy message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TouristRegisterAccountRelpy} TouristRegisterAccountRelpy
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristRegisterAccountRelpy.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TouristRegisterAccountRelpy message.
         * @function verify
         * @memberof pb.TouristRegisterAccountRelpy
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TouristRegisterAccountRelpy.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Account != null && message.hasOwnProperty("Account"))
                if (!$util.isString(message.Account))
                    return "Account: string expected";
            if (message.Password != null && message.hasOwnProperty("Password"))
                if (!$util.isString(message.Password))
                    return "Password: string expected";
            return null;
        };

        return TouristRegisterAccountRelpy;
    })();

    pb.TouristBindAccountArg = (function() {

        /**
         * Properties of a TouristBindAccountArg.
         * @memberof pb
         * @interface ITouristBindAccountArg
         * @property {string|null} [Channel] TouristBindAccountArg Channel
         * @property {string|null} [TouristAccount] TouristBindAccountArg TouristAccount
         * @property {string|null} [TouristPassword] TouristBindAccountArg TouristPassword
         * @property {pb.IAccountLoginArg|null} [BindAccount] TouristBindAccountArg BindAccount
         */

        /**
         * Constructs a new TouristBindAccountArg.
         * @memberof pb
         * @classdesc Represents a TouristBindAccountArg.
         * @implements ITouristBindAccountArg
         * @constructor
         * @param {pb.ITouristBindAccountArg=} [properties] Properties to set
         */
        function TouristBindAccountArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TouristBindAccountArg Channel.
         * @member {string} Channel
         * @memberof pb.TouristBindAccountArg
         * @instance
         */
        TouristBindAccountArg.prototype.Channel = "";

        /**
         * TouristBindAccountArg TouristAccount.
         * @member {string} TouristAccount
         * @memberof pb.TouristBindAccountArg
         * @instance
         */
        TouristBindAccountArg.prototype.TouristAccount = "";

        /**
         * TouristBindAccountArg TouristPassword.
         * @member {string} TouristPassword
         * @memberof pb.TouristBindAccountArg
         * @instance
         */
        TouristBindAccountArg.prototype.TouristPassword = "";

        /**
         * TouristBindAccountArg BindAccount.
         * @member {pb.IAccountLoginArg|null|undefined} BindAccount
         * @memberof pb.TouristBindAccountArg
         * @instance
         */
        TouristBindAccountArg.prototype.BindAccount = null;

        /**
         * Creates a new TouristBindAccountArg instance using the specified properties.
         * @function create
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {pb.ITouristBindAccountArg=} [properties] Properties to set
         * @returns {pb.TouristBindAccountArg} TouristBindAccountArg instance
         */
        TouristBindAccountArg.create = function create(properties) {
            return new TouristBindAccountArg(properties);
        };

        /**
         * Encodes the specified TouristBindAccountArg message. Does not implicitly {@link pb.TouristBindAccountArg.verify|verify} messages.
         * @function encode
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {pb.ITouristBindAccountArg} message TouristBindAccountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristBindAccountArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Channel);
            if (message.TouristAccount != null && message.hasOwnProperty("TouristAccount"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.TouristAccount);
            if (message.TouristPassword != null && message.hasOwnProperty("TouristPassword"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.TouristPassword);
            if (message.BindAccount != null && message.hasOwnProperty("BindAccount"))
                $root.pb.AccountLoginArg.encode(message.BindAccount, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TouristBindAccountArg message, length delimited. Does not implicitly {@link pb.TouristBindAccountArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {pb.ITouristBindAccountArg} message TouristBindAccountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TouristBindAccountArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TouristBindAccountArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TouristBindAccountArg} TouristBindAccountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristBindAccountArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TouristBindAccountArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.string();
                    break;
                case 2:
                    message.TouristAccount = reader.string();
                    break;
                case 3:
                    message.TouristPassword = reader.string();
                    break;
                case 4:
                    message.BindAccount = $root.pb.AccountLoginArg.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TouristBindAccountArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TouristBindAccountArg} TouristBindAccountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TouristBindAccountArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TouristBindAccountArg message.
         * @function verify
         * @memberof pb.TouristBindAccountArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TouristBindAccountArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                if (!$util.isString(message.Channel))
                    return "Channel: string expected";
            if (message.TouristAccount != null && message.hasOwnProperty("TouristAccount"))
                if (!$util.isString(message.TouristAccount))
                    return "TouristAccount: string expected";
            if (message.TouristPassword != null && message.hasOwnProperty("TouristPassword"))
                if (!$util.isString(message.TouristPassword))
                    return "TouristPassword: string expected";
            if (message.BindAccount != null && message.hasOwnProperty("BindAccount")) {
                var error = $root.pb.AccountLoginArg.verify(message.BindAccount);
                if (error)
                    return "BindAccount." + error;
            }
            return null;
        };

        return TouristBindAccountArg;
    })();

    pb.FetchHeadFrameReply = (function() {

        /**
         * Properties of a FetchHeadFrameReply.
         * @memberof pb
         * @interface IFetchHeadFrameReply
         * @property {Array.<string>|null} [HeadFrames] FetchHeadFrameReply HeadFrames
         */

        /**
         * Constructs a new FetchHeadFrameReply.
         * @memberof pb
         * @classdesc Represents a FetchHeadFrameReply.
         * @implements IFetchHeadFrameReply
         * @constructor
         * @param {pb.IFetchHeadFrameReply=} [properties] Properties to set
         */
        function FetchHeadFrameReply(properties) {
            this.HeadFrames = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchHeadFrameReply HeadFrames.
         * @member {Array.<string>} HeadFrames
         * @memberof pb.FetchHeadFrameReply
         * @instance
         */
        FetchHeadFrameReply.prototype.HeadFrames = $util.emptyArray;

        /**
         * Creates a new FetchHeadFrameReply instance using the specified properties.
         * @function create
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {pb.IFetchHeadFrameReply=} [properties] Properties to set
         * @returns {pb.FetchHeadFrameReply} FetchHeadFrameReply instance
         */
        FetchHeadFrameReply.create = function create(properties) {
            return new FetchHeadFrameReply(properties);
        };

        /**
         * Encodes the specified FetchHeadFrameReply message. Does not implicitly {@link pb.FetchHeadFrameReply.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {pb.IFetchHeadFrameReply} message FetchHeadFrameReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchHeadFrameReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HeadFrames != null && message.HeadFrames.length)
                for (var i = 0; i < message.HeadFrames.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.HeadFrames[i]);
            return writer;
        };

        /**
         * Encodes the specified FetchHeadFrameReply message, length delimited. Does not implicitly {@link pb.FetchHeadFrameReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {pb.IFetchHeadFrameReply} message FetchHeadFrameReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchHeadFrameReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchHeadFrameReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchHeadFrameReply} FetchHeadFrameReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchHeadFrameReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchHeadFrameReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.HeadFrames && message.HeadFrames.length))
                        message.HeadFrames = [];
                    message.HeadFrames.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchHeadFrameReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchHeadFrameReply} FetchHeadFrameReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchHeadFrameReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchHeadFrameReply message.
         * @function verify
         * @memberof pb.FetchHeadFrameReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchHeadFrameReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HeadFrames != null && message.hasOwnProperty("HeadFrames")) {
                if (!Array.isArray(message.HeadFrames))
                    return "HeadFrames: array expected";
                for (var i = 0; i < message.HeadFrames.length; ++i)
                    if (!$util.isString(message.HeadFrames[i]))
                        return "HeadFrames: string[] expected";
            }
            return null;
        };

        return FetchHeadFrameReply;
    })();

    pb.UpdateHeadFrameArg = (function() {

        /**
         * Properties of an UpdateHeadFrameArg.
         * @memberof pb
         * @interface IUpdateHeadFrameArg
         * @property {string|null} [HeadFrame] UpdateHeadFrameArg HeadFrame
         */

        /**
         * Constructs a new UpdateHeadFrameArg.
         * @memberof pb
         * @classdesc Represents an UpdateHeadFrameArg.
         * @implements IUpdateHeadFrameArg
         * @constructor
         * @param {pb.IUpdateHeadFrameArg=} [properties] Properties to set
         */
        function UpdateHeadFrameArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateHeadFrameArg HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.UpdateHeadFrameArg
         * @instance
         */
        UpdateHeadFrameArg.prototype.HeadFrame = "";

        /**
         * Creates a new UpdateHeadFrameArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {pb.IUpdateHeadFrameArg=} [properties] Properties to set
         * @returns {pb.UpdateHeadFrameArg} UpdateHeadFrameArg instance
         */
        UpdateHeadFrameArg.create = function create(properties) {
            return new UpdateHeadFrameArg(properties);
        };

        /**
         * Encodes the specified UpdateHeadFrameArg message. Does not implicitly {@link pb.UpdateHeadFrameArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {pb.IUpdateHeadFrameArg} message UpdateHeadFrameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateHeadFrameArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified UpdateHeadFrameArg message, length delimited. Does not implicitly {@link pb.UpdateHeadFrameArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {pb.IUpdateHeadFrameArg} message UpdateHeadFrameArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateHeadFrameArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateHeadFrameArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateHeadFrameArg} UpdateHeadFrameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateHeadFrameArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateHeadFrameArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateHeadFrameArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateHeadFrameArg} UpdateHeadFrameArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateHeadFrameArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateHeadFrameArg message.
         * @function verify
         * @memberof pb.UpdateHeadFrameArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateHeadFrameArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return UpdateHeadFrameArg;
    })();

    pb.HeadData = (function() {

        /**
         * Properties of a HeadData.
         * @memberof pb
         * @interface IHeadData
         * @property {Array.<number>|null} [OnceCards] HeadData OnceCards
         */

        /**
         * Constructs a new HeadData.
         * @memberof pb
         * @classdesc Represents a HeadData.
         * @implements IHeadData
         * @constructor
         * @param {pb.IHeadData=} [properties] Properties to set
         */
        function HeadData(properties) {
            this.OnceCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeadData OnceCards.
         * @member {Array.<number>} OnceCards
         * @memberof pb.HeadData
         * @instance
         */
        HeadData.prototype.OnceCards = $util.emptyArray;

        /**
         * Creates a new HeadData instance using the specified properties.
         * @function create
         * @memberof pb.HeadData
         * @static
         * @param {pb.IHeadData=} [properties] Properties to set
         * @returns {pb.HeadData} HeadData instance
         */
        HeadData.create = function create(properties) {
            return new HeadData(properties);
        };

        /**
         * Encodes the specified HeadData message. Does not implicitly {@link pb.HeadData.verify|verify} messages.
         * @function encode
         * @memberof pb.HeadData
         * @static
         * @param {pb.IHeadData} message HeadData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OnceCards != null && message.OnceCards.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.OnceCards.length; ++i)
                    writer.uint32(message.OnceCards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified HeadData message, length delimited. Does not implicitly {@link pb.HeadData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HeadData
         * @static
         * @param {pb.IHeadData} message HeadData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeadData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeadData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HeadData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HeadData} HeadData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HeadData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.OnceCards && message.OnceCards.length))
                        message.OnceCards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.OnceCards.push(reader.uint32());
                    } else
                        message.OnceCards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeadData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HeadData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HeadData} HeadData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeadData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeadData message.
         * @function verify
         * @memberof pb.HeadData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeadData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OnceCards != null && message.hasOwnProperty("OnceCards")) {
                if (!Array.isArray(message.OnceCards))
                    return "OnceCards: array expected";
                for (var i = 0; i < message.OnceCards.length; ++i)
                    if (!$util.isInteger(message.OnceCards[i]))
                        return "OnceCards: integer[] expected";
            }
            return null;
        };

        return HeadData;
    })();

    pb.EmojiData = (function() {

        /**
         * Properties of an EmojiData.
         * @memberof pb
         * @interface IEmojiData
         * @property {Array.<number>|null} [EmojiTeams] EmojiData EmojiTeams
         */

        /**
         * Constructs a new EmojiData.
         * @memberof pb
         * @classdesc Represents an EmojiData.
         * @implements IEmojiData
         * @constructor
         * @param {pb.IEmojiData=} [properties] Properties to set
         */
        function EmojiData(properties) {
            this.EmojiTeams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EmojiData EmojiTeams.
         * @member {Array.<number>} EmojiTeams
         * @memberof pb.EmojiData
         * @instance
         */
        EmojiData.prototype.EmojiTeams = $util.emptyArray;

        /**
         * Creates a new EmojiData instance using the specified properties.
         * @function create
         * @memberof pb.EmojiData
         * @static
         * @param {pb.IEmojiData=} [properties] Properties to set
         * @returns {pb.EmojiData} EmojiData instance
         */
        EmojiData.create = function create(properties) {
            return new EmojiData(properties);
        };

        /**
         * Encodes the specified EmojiData message. Does not implicitly {@link pb.EmojiData.verify|verify} messages.
         * @function encode
         * @memberof pb.EmojiData
         * @static
         * @param {pb.IEmojiData} message EmojiData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmojiData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EmojiTeams != null && message.EmojiTeams.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    writer.int32(message.EmojiTeams[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified EmojiData message, length delimited. Does not implicitly {@link pb.EmojiData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EmojiData
         * @static
         * @param {pb.IEmojiData} message EmojiData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EmojiData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EmojiData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EmojiData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EmojiData} EmojiData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmojiData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EmojiData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.EmojiTeams && message.EmojiTeams.length))
                        message.EmojiTeams = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.EmojiTeams.push(reader.int32());
                    } else
                        message.EmojiTeams.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EmojiData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EmojiData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EmojiData} EmojiData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EmojiData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EmojiData message.
         * @function verify
         * @memberof pb.EmojiData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EmojiData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EmojiTeams != null && message.hasOwnProperty("EmojiTeams")) {
                if (!Array.isArray(message.EmojiTeams))
                    return "EmojiTeams: array expected";
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    if (!$util.isInteger(message.EmojiTeams[i]))
                        return "EmojiTeams: integer[] expected";
            }
            return null;
        };

        return EmojiData;
    })();

    pb.TellMe = (function() {

        /**
         * Properties of a TellMe.
         * @memberof pb
         * @interface ITellMe
         * @property {string|null} [Msg] TellMe Msg
         * @property {number|null} [Text] TellMe Text
         */

        /**
         * Constructs a new TellMe.
         * @memberof pb
         * @classdesc Represents a TellMe.
         * @implements ITellMe
         * @constructor
         * @param {pb.ITellMe=} [properties] Properties to set
         */
        function TellMe(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TellMe Msg.
         * @member {string} Msg
         * @memberof pb.TellMe
         * @instance
         */
        TellMe.prototype.Msg = "";

        /**
         * TellMe Text.
         * @member {number} Text
         * @memberof pb.TellMe
         * @instance
         */
        TellMe.prototype.Text = 0;

        /**
         * Creates a new TellMe instance using the specified properties.
         * @function create
         * @memberof pb.TellMe
         * @static
         * @param {pb.ITellMe=} [properties] Properties to set
         * @returns {pb.TellMe} TellMe instance
         */
        TellMe.create = function create(properties) {
            return new TellMe(properties);
        };

        /**
         * Encodes the specified TellMe message. Does not implicitly {@link pb.TellMe.verify|verify} messages.
         * @function encode
         * @memberof pb.TellMe
         * @static
         * @param {pb.ITellMe} message TellMe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TellMe.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Msg);
            if (message.Text != null && message.hasOwnProperty("Text"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Text);
            return writer;
        };

        /**
         * Encodes the specified TellMe message, length delimited. Does not implicitly {@link pb.TellMe.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TellMe
         * @static
         * @param {pb.ITellMe} message TellMe message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TellMe.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TellMe message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TellMe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TellMe} TellMe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TellMe.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TellMe();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Msg = reader.string();
                    break;
                case 2:
                    message.Text = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TellMe message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TellMe
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TellMe} TellMe
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TellMe.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TellMe message.
         * @function verify
         * @memberof pb.TellMe
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TellMe.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.Text != null && message.hasOwnProperty("Text"))
                if (!$util.isInteger(message.Text))
                    return "Text: integer expected";
            return null;
        };

        return TellMe;
    })();

    pb.UnlockEmojiArg = (function() {

        /**
         * Properties of an UnlockEmojiArg.
         * @memberof pb
         * @interface IUnlockEmojiArg
         * @property {number|null} [EmojiTeam] UnlockEmojiArg EmojiTeam
         */

        /**
         * Constructs a new UnlockEmojiArg.
         * @memberof pb
         * @classdesc Represents an UnlockEmojiArg.
         * @implements IUnlockEmojiArg
         * @constructor
         * @param {pb.IUnlockEmojiArg=} [properties] Properties to set
         */
        function UnlockEmojiArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UnlockEmojiArg EmojiTeam.
         * @member {number} EmojiTeam
         * @memberof pb.UnlockEmojiArg
         * @instance
         */
        UnlockEmojiArg.prototype.EmojiTeam = 0;

        /**
         * Creates a new UnlockEmojiArg instance using the specified properties.
         * @function create
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {pb.IUnlockEmojiArg=} [properties] Properties to set
         * @returns {pb.UnlockEmojiArg} UnlockEmojiArg instance
         */
        UnlockEmojiArg.create = function create(properties) {
            return new UnlockEmojiArg(properties);
        };

        /**
         * Encodes the specified UnlockEmojiArg message. Does not implicitly {@link pb.UnlockEmojiArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {pb.IUnlockEmojiArg} message UnlockEmojiArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockEmojiArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.EmojiTeam != null && message.hasOwnProperty("EmojiTeam"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.EmojiTeam);
            return writer;
        };

        /**
         * Encodes the specified UnlockEmojiArg message, length delimited. Does not implicitly {@link pb.UnlockEmojiArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {pb.IUnlockEmojiArg} message UnlockEmojiArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UnlockEmojiArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UnlockEmojiArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UnlockEmojiArg} UnlockEmojiArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockEmojiArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UnlockEmojiArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.EmojiTeam = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UnlockEmojiArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UnlockEmojiArg} UnlockEmojiArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UnlockEmojiArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UnlockEmojiArg message.
         * @function verify
         * @memberof pb.UnlockEmojiArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UnlockEmojiArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.EmojiTeam != null && message.hasOwnProperty("EmojiTeam"))
                if (!$util.isInteger(message.EmojiTeam))
                    return "EmojiTeam: integer expected";
            return null;
        };

        return UnlockEmojiArg;
    })();

    pb.VipRemainTime = (function() {

        /**
         * Properties of a VipRemainTime.
         * @memberof pb
         * @interface IVipRemainTime
         * @property {number|null} [RemainTime] VipRemainTime RemainTime
         */

        /**
         * Constructs a new VipRemainTime.
         * @memberof pb
         * @classdesc Represents a VipRemainTime.
         * @implements IVipRemainTime
         * @constructor
         * @param {pb.IVipRemainTime=} [properties] Properties to set
         */
        function VipRemainTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VipRemainTime RemainTime.
         * @member {number} RemainTime
         * @memberof pb.VipRemainTime
         * @instance
         */
        VipRemainTime.prototype.RemainTime = 0;

        /**
         * Creates a new VipRemainTime instance using the specified properties.
         * @function create
         * @memberof pb.VipRemainTime
         * @static
         * @param {pb.IVipRemainTime=} [properties] Properties to set
         * @returns {pb.VipRemainTime} VipRemainTime instance
         */
        VipRemainTime.create = function create(properties) {
            return new VipRemainTime(properties);
        };

        /**
         * Encodes the specified VipRemainTime message. Does not implicitly {@link pb.VipRemainTime.verify|verify} messages.
         * @function encode
         * @memberof pb.VipRemainTime
         * @static
         * @param {pb.IVipRemainTime} message VipRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipRemainTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified VipRemainTime message, length delimited. Does not implicitly {@link pb.VipRemainTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VipRemainTime
         * @static
         * @param {pb.IVipRemainTime} message VipRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipRemainTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VipRemainTime message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VipRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VipRemainTime} VipRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipRemainTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VipRemainTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VipRemainTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VipRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VipRemainTime} VipRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipRemainTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VipRemainTime message.
         * @function verify
         * @memberof pb.VipRemainTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VipRemainTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return VipRemainTime;
    })();

    pb.MinVipRemainTime = (function() {

        /**
         * Properties of a MinVipRemainTime.
         * @memberof pb
         * @interface IMinVipRemainTime
         * @property {number|null} [RemainTime] MinVipRemainTime RemainTime
         */

        /**
         * Constructs a new MinVipRemainTime.
         * @memberof pb
         * @classdesc Represents a MinVipRemainTime.
         * @implements IMinVipRemainTime
         * @constructor
         * @param {pb.IMinVipRemainTime=} [properties] Properties to set
         */
        function MinVipRemainTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MinVipRemainTime RemainTime.
         * @member {number} RemainTime
         * @memberof pb.MinVipRemainTime
         * @instance
         */
        MinVipRemainTime.prototype.RemainTime = 0;

        /**
         * Creates a new MinVipRemainTime instance using the specified properties.
         * @function create
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {pb.IMinVipRemainTime=} [properties] Properties to set
         * @returns {pb.MinVipRemainTime} MinVipRemainTime instance
         */
        MinVipRemainTime.create = function create(properties) {
            return new MinVipRemainTime(properties);
        };

        /**
         * Encodes the specified MinVipRemainTime message. Does not implicitly {@link pb.MinVipRemainTime.verify|verify} messages.
         * @function encode
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {pb.IMinVipRemainTime} message MinVipRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinVipRemainTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified MinVipRemainTime message, length delimited. Does not implicitly {@link pb.MinVipRemainTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {pb.IMinVipRemainTime} message MinVipRemainTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MinVipRemainTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MinVipRemainTime message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MinVipRemainTime} MinVipRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinVipRemainTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MinVipRemainTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MinVipRemainTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MinVipRemainTime} MinVipRemainTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MinVipRemainTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MinVipRemainTime message.
         * @function verify
         * @memberof pb.MinVipRemainTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MinVipRemainTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return MinVipRemainTime;
    })();

    pb.MatchPlayer = (function() {

        /**
         * Properties of a MatchPlayer.
         * @memberof pb
         * @interface IMatchPlayer
         * @property {number|Long|null} [Uid] MatchPlayer Uid
         * @property {string|null} [Name] MatchPlayer Name
         * @property {number|null} [Camp] MatchPlayer Camp
         */

        /**
         * Constructs a new MatchPlayer.
         * @memberof pb
         * @classdesc Represents a MatchPlayer.
         * @implements IMatchPlayer
         * @constructor
         * @param {pb.IMatchPlayer=} [properties] Properties to set
         */
        function MatchPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchPlayer Uid.
         * @member {number|Long} Uid
         * @memberof pb.MatchPlayer
         * @instance
         */
        MatchPlayer.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MatchPlayer Name.
         * @member {string} Name
         * @memberof pb.MatchPlayer
         * @instance
         */
        MatchPlayer.prototype.Name = "";

        /**
         * MatchPlayer Camp.
         * @member {number} Camp
         * @memberof pb.MatchPlayer
         * @instance
         */
        MatchPlayer.prototype.Camp = 0;

        /**
         * Creates a new MatchPlayer instance using the specified properties.
         * @function create
         * @memberof pb.MatchPlayer
         * @static
         * @param {pb.IMatchPlayer=} [properties] Properties to set
         * @returns {pb.MatchPlayer} MatchPlayer instance
         */
        MatchPlayer.create = function create(properties) {
            return new MatchPlayer(properties);
        };

        /**
         * Encodes the specified MatchPlayer message. Does not implicitly {@link pb.MatchPlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.MatchPlayer
         * @static
         * @param {pb.IMatchPlayer} message MatchPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Camp);
            return writer;
        };

        /**
         * Encodes the specified MatchPlayer message, length delimited. Does not implicitly {@link pb.MatchPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MatchPlayer
         * @static
         * @param {pb.IMatchPlayer} message MatchPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MatchPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MatchPlayer} MatchPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Camp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MatchPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MatchPlayer} MatchPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchPlayer message.
         * @function verify
         * @memberof pb.MatchPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            return null;
        };

        return MatchPlayer;
    })();

    pb.MatchArg = (function() {

        /**
         * Properties of a MatchArg.
         * @memberof pb
         * @interface IMatchArg
         * @property {number|null} [Camp] MatchArg Camp
         * @property {pb.MatchArg.MatchType|null} [Type] MatchArg Type
         */

        /**
         * Constructs a new MatchArg.
         * @memberof pb
         * @classdesc Represents a MatchArg.
         * @implements IMatchArg
         * @constructor
         * @param {pb.IMatchArg=} [properties] Properties to set
         */
        function MatchArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchArg Camp.
         * @member {number} Camp
         * @memberof pb.MatchArg
         * @instance
         */
        MatchArg.prototype.Camp = 0;

        /**
         * MatchArg Type.
         * @member {pb.MatchArg.MatchType} Type
         * @memberof pb.MatchArg
         * @instance
         */
        MatchArg.prototype.Type = 0;

        /**
         * Creates a new MatchArg instance using the specified properties.
         * @function create
         * @memberof pb.MatchArg
         * @static
         * @param {pb.IMatchArg=} [properties] Properties to set
         * @returns {pb.MatchArg} MatchArg instance
         */
        MatchArg.create = function create(properties) {
            return new MatchArg(properties);
        };

        /**
         * Encodes the specified MatchArg message. Does not implicitly {@link pb.MatchArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MatchArg
         * @static
         * @param {pb.IMatchArg} message MatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Camp);
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Type);
            return writer;
        };

        /**
         * Encodes the specified MatchArg message, length delimited. Does not implicitly {@link pb.MatchArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MatchArg
         * @static
         * @param {pb.IMatchArg} message MatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MatchArg} MatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Camp = reader.int32();
                    break;
                case 2:
                    message.Type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MatchArg} MatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchArg message.
         * @function verify
         * @memberof pb.MatchArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * MatchType enum.
         * @name pb.MatchArg.MatchType
         * @enum {string}
         * @property {number} Ladder=0 Ladder value
         * @property {number} Training=1 Training value
         */
        MatchArg.MatchType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Ladder"] = 0;
            values[valuesById[1] = "Training"] = 1;
            return values;
        })();

        return MatchArg;
    })();

    pb.MatchReply = (function() {

        /**
         * Properties of a MatchReply.
         * @memberof pb
         * @interface IMatchReply
         * @property {boolean|null} [NeedChooseCamp] MatchReply NeedChooseCamp
         * @property {number|null} [LastCamp] MatchReply LastCamp
         * @property {pb.ISeasonPvpChooseCardData|null} [ChooseCardData] MatchReply ChooseCardData
         */

        /**
         * Constructs a new MatchReply.
         * @memberof pb
         * @classdesc Represents a MatchReply.
         * @implements IMatchReply
         * @constructor
         * @param {pb.IMatchReply=} [properties] Properties to set
         */
        function MatchReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchReply NeedChooseCamp.
         * @member {boolean} NeedChooseCamp
         * @memberof pb.MatchReply
         * @instance
         */
        MatchReply.prototype.NeedChooseCamp = false;

        /**
         * MatchReply LastCamp.
         * @member {number} LastCamp
         * @memberof pb.MatchReply
         * @instance
         */
        MatchReply.prototype.LastCamp = 0;

        /**
         * MatchReply ChooseCardData.
         * @member {pb.ISeasonPvpChooseCardData|null|undefined} ChooseCardData
         * @memberof pb.MatchReply
         * @instance
         */
        MatchReply.prototype.ChooseCardData = null;

        /**
         * Creates a new MatchReply instance using the specified properties.
         * @function create
         * @memberof pb.MatchReply
         * @static
         * @param {pb.IMatchReply=} [properties] Properties to set
         * @returns {pb.MatchReply} MatchReply instance
         */
        MatchReply.create = function create(properties) {
            return new MatchReply(properties);
        };

        /**
         * Encodes the specified MatchReply message. Does not implicitly {@link pb.MatchReply.verify|verify} messages.
         * @function encode
         * @memberof pb.MatchReply
         * @static
         * @param {pb.IMatchReply} message MatchReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.NeedChooseCamp != null && message.hasOwnProperty("NeedChooseCamp"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.NeedChooseCamp);
            if (message.LastCamp != null && message.hasOwnProperty("LastCamp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LastCamp);
            if (message.ChooseCardData != null && message.hasOwnProperty("ChooseCardData"))
                $root.pb.SeasonPvpChooseCardData.encode(message.ChooseCardData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MatchReply message, length delimited. Does not implicitly {@link pb.MatchReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MatchReply
         * @static
         * @param {pb.IMatchReply} message MatchReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MatchReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MatchReply} MatchReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.NeedChooseCamp = reader.bool();
                    break;
                case 2:
                    message.LastCamp = reader.int32();
                    break;
                case 3:
                    message.ChooseCardData = $root.pb.SeasonPvpChooseCardData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MatchReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MatchReply} MatchReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchReply message.
         * @function verify
         * @memberof pb.MatchReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.NeedChooseCamp != null && message.hasOwnProperty("NeedChooseCamp"))
                if (typeof message.NeedChooseCamp !== "boolean")
                    return "NeedChooseCamp: boolean expected";
            if (message.LastCamp != null && message.hasOwnProperty("LastCamp"))
                if (!$util.isInteger(message.LastCamp))
                    return "LastCamp: integer expected";
            if (message.ChooseCardData != null && message.hasOwnProperty("ChooseCardData")) {
                var error = $root.pb.SeasonPvpChooseCardData.verify(message.ChooseCardData);
                if (error)
                    return "ChooseCardData." + error;
            }
            return null;
        };

        return MatchReply;
    })();

    pb.MatchInfo = (function() {

        /**
         * Properties of a MatchInfo.
         * @memberof pb
         * @interface IMatchInfo
         * @property {number|null} [RoomId] MatchInfo RoomId
         * @property {pb.IMatchPlayer|null} [Player1] MatchInfo Player1
         * @property {pb.IMatchPlayer|null} [Player2] MatchInfo Player2
         */

        /**
         * Constructs a new MatchInfo.
         * @memberof pb
         * @classdesc Represents a MatchInfo.
         * @implements IMatchInfo
         * @constructor
         * @param {pb.IMatchInfo=} [properties] Properties to set
         */
        function MatchInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchInfo RoomId.
         * @member {number} RoomId
         * @memberof pb.MatchInfo
         * @instance
         */
        MatchInfo.prototype.RoomId = 0;

        /**
         * MatchInfo Player1.
         * @member {pb.IMatchPlayer|null|undefined} Player1
         * @memberof pb.MatchInfo
         * @instance
         */
        MatchInfo.prototype.Player1 = null;

        /**
         * MatchInfo Player2.
         * @member {pb.IMatchPlayer|null|undefined} Player2
         * @memberof pb.MatchInfo
         * @instance
         */
        MatchInfo.prototype.Player2 = null;

        /**
         * Creates a new MatchInfo instance using the specified properties.
         * @function create
         * @memberof pb.MatchInfo
         * @static
         * @param {pb.IMatchInfo=} [properties] Properties to set
         * @returns {pb.MatchInfo} MatchInfo instance
         */
        MatchInfo.create = function create(properties) {
            return new MatchInfo(properties);
        };

        /**
         * Encodes the specified MatchInfo message. Does not implicitly {@link pb.MatchInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.MatchInfo
         * @static
         * @param {pb.IMatchInfo} message MatchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RoomId != null && message.hasOwnProperty("RoomId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RoomId);
            if (message.Player1 != null && message.hasOwnProperty("Player1"))
                $root.pb.MatchPlayer.encode(message.Player1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Player2 != null && message.hasOwnProperty("Player2"))
                $root.pb.MatchPlayer.encode(message.Player2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MatchInfo message, length delimited. Does not implicitly {@link pb.MatchInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MatchInfo
         * @static
         * @param {pb.IMatchInfo} message MatchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MatchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MatchInfo} MatchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RoomId = reader.int32();
                    break;
                case 2:
                    message.Player1 = $root.pb.MatchPlayer.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Player2 = $root.pb.MatchPlayer.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MatchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MatchInfo} MatchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchInfo message.
         * @function verify
         * @memberof pb.MatchInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RoomId != null && message.hasOwnProperty("RoomId"))
                if (!$util.isInteger(message.RoomId))
                    return "RoomId: integer expected";
            if (message.Player1 != null && message.hasOwnProperty("Player1")) {
                var error = $root.pb.MatchPlayer.verify(message.Player1);
                if (error)
                    return "Player1." + error;
            }
            if (message.Player2 != null && message.hasOwnProperty("Player2")) {
                var error = $root.pb.MatchPlayer.verify(message.Player2);
                if (error)
                    return "Player2." + error;
            }
            return null;
        };

        return MatchInfo;
    })();

    pb.MatchDoneArg = (function() {

        /**
         * Properties of a MatchDoneArg.
         * @memberof pb
         * @interface IMatchDoneArg
         * @property {number|null} [RoomId] MatchDoneArg RoomId
         */

        /**
         * Constructs a new MatchDoneArg.
         * @memberof pb
         * @classdesc Represents a MatchDoneArg.
         * @implements IMatchDoneArg
         * @constructor
         * @param {pb.IMatchDoneArg=} [properties] Properties to set
         */
        function MatchDoneArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchDoneArg RoomId.
         * @member {number} RoomId
         * @memberof pb.MatchDoneArg
         * @instance
         */
        MatchDoneArg.prototype.RoomId = 0;

        /**
         * Creates a new MatchDoneArg instance using the specified properties.
         * @function create
         * @memberof pb.MatchDoneArg
         * @static
         * @param {pb.IMatchDoneArg=} [properties] Properties to set
         * @returns {pb.MatchDoneArg} MatchDoneArg instance
         */
        MatchDoneArg.create = function create(properties) {
            return new MatchDoneArg(properties);
        };

        /**
         * Encodes the specified MatchDoneArg message. Does not implicitly {@link pb.MatchDoneArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MatchDoneArg
         * @static
         * @param {pb.IMatchDoneArg} message MatchDoneArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchDoneArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RoomId != null && message.hasOwnProperty("RoomId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RoomId);
            return writer;
        };

        /**
         * Encodes the specified MatchDoneArg message, length delimited. Does not implicitly {@link pb.MatchDoneArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MatchDoneArg
         * @static
         * @param {pb.IMatchDoneArg} message MatchDoneArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchDoneArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchDoneArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MatchDoneArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MatchDoneArg} MatchDoneArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchDoneArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MatchDoneArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RoomId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchDoneArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MatchDoneArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MatchDoneArg} MatchDoneArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchDoneArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchDoneArg message.
         * @function verify
         * @memberof pb.MatchDoneArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchDoneArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RoomId != null && message.hasOwnProperty("RoomId"))
                if (!$util.isInteger(message.RoomId))
                    return "RoomId: integer expected";
            return null;
        };

        return MatchDoneArg;
    })();

    pb.BeginMatchArg = (function() {

        /**
         * Properties of a BeginMatchArg.
         * @memberof pb
         * @interface IBeginMatchArg
         * @property {string|null} [Name] BeginMatchArg Name
         * @property {number|null} [Camp] BeginMatchArg Camp
         * @property {number|null} [PvpScore] BeginMatchArg PvpScore
         * @property {number|null} [Mmr] BeginMatchArg Mmr
         * @property {number|null} [StreakLoseCnt] BeginMatchArg StreakLoseCnt
         * @property {Array.<pb.ISkinGCard>|null} [HandCards] BeginMatchArg HandCards
         * @property {Array.<pb.ISkinGCard>|null} [DrawCards] BeginMatchArg DrawCards
         * @property {number|null} [CardStrength] BeginMatchArg CardStrength
         * @property {string|null} [HeadImgUrl] BeginMatchArg HeadImgUrl
         * @property {string|null} [HeadFrame] BeginMatchArg HeadFrame
         * @property {number|null} [SeasonPvpSession] BeginMatchArg SeasonPvpSession
         * @property {number|null} [RebornRemainDay] BeginMatchArg RebornRemainDay
         */

        /**
         * Constructs a new BeginMatchArg.
         * @memberof pb
         * @classdesc Represents a BeginMatchArg.
         * @implements IBeginMatchArg
         * @constructor
         * @param {pb.IBeginMatchArg=} [properties] Properties to set
         */
        function BeginMatchArg(properties) {
            this.HandCards = [];
            this.DrawCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginMatchArg Name.
         * @member {string} Name
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.Name = "";

        /**
         * BeginMatchArg Camp.
         * @member {number} Camp
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.Camp = 0;

        /**
         * BeginMatchArg PvpScore.
         * @member {number} PvpScore
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.PvpScore = 0;

        /**
         * BeginMatchArg Mmr.
         * @member {number} Mmr
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.Mmr = 0;

        /**
         * BeginMatchArg StreakLoseCnt.
         * @member {number} StreakLoseCnt
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.StreakLoseCnt = 0;

        /**
         * BeginMatchArg HandCards.
         * @member {Array.<pb.ISkinGCard>} HandCards
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.HandCards = $util.emptyArray;

        /**
         * BeginMatchArg DrawCards.
         * @member {Array.<pb.ISkinGCard>} DrawCards
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.DrawCards = $util.emptyArray;

        /**
         * BeginMatchArg CardStrength.
         * @member {number} CardStrength
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.CardStrength = 0;

        /**
         * BeginMatchArg HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.HeadImgUrl = "";

        /**
         * BeginMatchArg HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.HeadFrame = "";

        /**
         * BeginMatchArg SeasonPvpSession.
         * @member {number} SeasonPvpSession
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.SeasonPvpSession = 0;

        /**
         * BeginMatchArg RebornRemainDay.
         * @member {number} RebornRemainDay
         * @memberof pb.BeginMatchArg
         * @instance
         */
        BeginMatchArg.prototype.RebornRemainDay = 0;

        /**
         * Creates a new BeginMatchArg instance using the specified properties.
         * @function create
         * @memberof pb.BeginMatchArg
         * @static
         * @param {pb.IBeginMatchArg=} [properties] Properties to set
         * @returns {pb.BeginMatchArg} BeginMatchArg instance
         */
        BeginMatchArg.create = function create(properties) {
            return new BeginMatchArg(properties);
        };

        /**
         * Encodes the specified BeginMatchArg message. Does not implicitly {@link pb.BeginMatchArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeginMatchArg
         * @static
         * @param {pb.IBeginMatchArg} message BeginMatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatchArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Camp);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Mmr);
            if (message.StreakLoseCnt != null && message.hasOwnProperty("StreakLoseCnt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.StreakLoseCnt);
            if (message.HandCards != null && message.HandCards.length)
                for (var i = 0; i < message.HandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.HandCards[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.DrawCards != null && message.DrawCards.length)
                for (var i = 0; i < message.DrawCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.DrawCards[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.CardStrength != null && message.hasOwnProperty("CardStrength"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.CardStrength);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.HeadImgUrl);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.HeadFrame);
            if (message.SeasonPvpSession != null && message.hasOwnProperty("SeasonPvpSession"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.SeasonPvpSession);
            if (message.RebornRemainDay != null && message.hasOwnProperty("RebornRemainDay"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.RebornRemainDay);
            return writer;
        };

        /**
         * Encodes the specified BeginMatchArg message, length delimited. Does not implicitly {@link pb.BeginMatchArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeginMatchArg
         * @static
         * @param {pb.IBeginMatchArg} message BeginMatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatchArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginMatchArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeginMatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeginMatchArg} BeginMatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatchArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeginMatchArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.Camp = reader.int32();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.Mmr = reader.int32();
                    break;
                case 5:
                    message.StreakLoseCnt = reader.int32();
                    break;
                case 6:
                    if (!(message.HandCards && message.HandCards.length))
                        message.HandCards = [];
                    message.HandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.DrawCards && message.DrawCards.length))
                        message.DrawCards = [];
                    message.DrawCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.CardStrength = reader.int32();
                    break;
                case 9:
                    message.HeadImgUrl = reader.string();
                    break;
                case 10:
                    message.HeadFrame = reader.string();
                    break;
                case 11:
                    message.SeasonPvpSession = reader.int32();
                    break;
                case 12:
                    message.RebornRemainDay = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginMatchArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeginMatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeginMatchArg} BeginMatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatchArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginMatchArg message.
         * @function verify
         * @memberof pb.BeginMatchArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginMatchArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                if (!$util.isInteger(message.Mmr))
                    return "Mmr: integer expected";
            if (message.StreakLoseCnt != null && message.hasOwnProperty("StreakLoseCnt"))
                if (!$util.isInteger(message.StreakLoseCnt))
                    return "StreakLoseCnt: integer expected";
            if (message.HandCards != null && message.hasOwnProperty("HandCards")) {
                if (!Array.isArray(message.HandCards))
                    return "HandCards: array expected";
                for (var i = 0; i < message.HandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.HandCards[i]);
                    if (error)
                        return "HandCards." + error;
                }
            }
            if (message.DrawCards != null && message.hasOwnProperty("DrawCards")) {
                if (!Array.isArray(message.DrawCards))
                    return "DrawCards: array expected";
                for (var i = 0; i < message.DrawCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.DrawCards[i]);
                    if (error)
                        return "DrawCards." + error;
                }
            }
            if (message.CardStrength != null && message.hasOwnProperty("CardStrength"))
                if (!$util.isInteger(message.CardStrength))
                    return "CardStrength: integer expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.SeasonPvpSession != null && message.hasOwnProperty("SeasonPvpSession"))
                if (!$util.isInteger(message.SeasonPvpSession))
                    return "SeasonPvpSession: integer expected";
            if (message.RebornRemainDay != null && message.hasOwnProperty("RebornRemainDay"))
                if (!$util.isInteger(message.RebornRemainDay))
                    return "RebornRemainDay: integer expected";
            return null;
        };

        return BeginMatchArg;
    })();

    pb.BeginNewbiePvpMatchArg = (function() {

        /**
         * Properties of a BeginNewbiePvpMatchArg.
         * @memberof pb
         * @interface IBeginNewbiePvpMatchArg
         * @property {string|null} [Name] BeginNewbiePvpMatchArg Name
         * @property {number|null} [Camp] BeginNewbiePvpMatchArg Camp
         * @property {number|null} [PvpScore] BeginNewbiePvpMatchArg PvpScore
         * @property {number|null} [Mmr] BeginNewbiePvpMatchArg Mmr
         * @property {number|null} [EnemyCamp] BeginNewbiePvpMatchArg EnemyCamp
         * @property {Array.<pb.ISkinGCard>|null} [HandCards] BeginNewbiePvpMatchArg HandCards
         * @property {Array.<pb.ISkinGCard>|null} [DrawCards] BeginNewbiePvpMatchArg DrawCards
         * @property {boolean|null} [IsFirstBattle] BeginNewbiePvpMatchArg IsFirstBattle
         * @property {string|null} [HeadImgUrl] BeginNewbiePvpMatchArg HeadImgUrl
         * @property {string|null} [HeadFrame] BeginNewbiePvpMatchArg HeadFrame
         */

        /**
         * Constructs a new BeginNewbiePvpMatchArg.
         * @memberof pb
         * @classdesc Represents a BeginNewbiePvpMatchArg.
         * @implements IBeginNewbiePvpMatchArg
         * @constructor
         * @param {pb.IBeginNewbiePvpMatchArg=} [properties] Properties to set
         */
        function BeginNewbiePvpMatchArg(properties) {
            this.HandCards = [];
            this.DrawCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginNewbiePvpMatchArg Name.
         * @member {string} Name
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.Name = "";

        /**
         * BeginNewbiePvpMatchArg Camp.
         * @member {number} Camp
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.Camp = 0;

        /**
         * BeginNewbiePvpMatchArg PvpScore.
         * @member {number} PvpScore
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.PvpScore = 0;

        /**
         * BeginNewbiePvpMatchArg Mmr.
         * @member {number} Mmr
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.Mmr = 0;

        /**
         * BeginNewbiePvpMatchArg EnemyCamp.
         * @member {number} EnemyCamp
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.EnemyCamp = 0;

        /**
         * BeginNewbiePvpMatchArg HandCards.
         * @member {Array.<pb.ISkinGCard>} HandCards
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.HandCards = $util.emptyArray;

        /**
         * BeginNewbiePvpMatchArg DrawCards.
         * @member {Array.<pb.ISkinGCard>} DrawCards
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.DrawCards = $util.emptyArray;

        /**
         * BeginNewbiePvpMatchArg IsFirstBattle.
         * @member {boolean} IsFirstBattle
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.IsFirstBattle = false;

        /**
         * BeginNewbiePvpMatchArg HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.HeadImgUrl = "";

        /**
         * BeginNewbiePvpMatchArg HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.BeginNewbiePvpMatchArg
         * @instance
         */
        BeginNewbiePvpMatchArg.prototype.HeadFrame = "";

        /**
         * Creates a new BeginNewbiePvpMatchArg instance using the specified properties.
         * @function create
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {pb.IBeginNewbiePvpMatchArg=} [properties] Properties to set
         * @returns {pb.BeginNewbiePvpMatchArg} BeginNewbiePvpMatchArg instance
         */
        BeginNewbiePvpMatchArg.create = function create(properties) {
            return new BeginNewbiePvpMatchArg(properties);
        };

        /**
         * Encodes the specified BeginNewbiePvpMatchArg message. Does not implicitly {@link pb.BeginNewbiePvpMatchArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {pb.IBeginNewbiePvpMatchArg} message BeginNewbiePvpMatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginNewbiePvpMatchArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Camp);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Mmr);
            if (message.EnemyCamp != null && message.hasOwnProperty("EnemyCamp"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.EnemyCamp);
            if (message.HandCards != null && message.HandCards.length)
                for (var i = 0; i < message.HandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.HandCards[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.DrawCards != null && message.DrawCards.length)
                for (var i = 0; i < message.DrawCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.DrawCards[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.IsFirstBattle != null && message.hasOwnProperty("IsFirstBattle"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsFirstBattle);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 9, wireType 2 =*/74).string(message.HeadImgUrl);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified BeginNewbiePvpMatchArg message, length delimited. Does not implicitly {@link pb.BeginNewbiePvpMatchArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {pb.IBeginNewbiePvpMatchArg} message BeginNewbiePvpMatchArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginNewbiePvpMatchArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginNewbiePvpMatchArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeginNewbiePvpMatchArg} BeginNewbiePvpMatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginNewbiePvpMatchArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeginNewbiePvpMatchArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.Camp = reader.int32();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.Mmr = reader.int32();
                    break;
                case 5:
                    message.EnemyCamp = reader.int32();
                    break;
                case 6:
                    if (!(message.HandCards && message.HandCards.length))
                        message.HandCards = [];
                    message.HandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 7:
                    if (!(message.DrawCards && message.DrawCards.length))
                        message.DrawCards = [];
                    message.DrawCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 8:
                    message.IsFirstBattle = reader.bool();
                    break;
                case 9:
                    message.HeadImgUrl = reader.string();
                    break;
                case 10:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginNewbiePvpMatchArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeginNewbiePvpMatchArg} BeginNewbiePvpMatchArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginNewbiePvpMatchArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginNewbiePvpMatchArg message.
         * @function verify
         * @memberof pb.BeginNewbiePvpMatchArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginNewbiePvpMatchArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                if (!$util.isInteger(message.Mmr))
                    return "Mmr: integer expected";
            if (message.EnemyCamp != null && message.hasOwnProperty("EnemyCamp"))
                if (!$util.isInteger(message.EnemyCamp))
                    return "EnemyCamp: integer expected";
            if (message.HandCards != null && message.hasOwnProperty("HandCards")) {
                if (!Array.isArray(message.HandCards))
                    return "HandCards: array expected";
                for (var i = 0; i < message.HandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.HandCards[i]);
                    if (error)
                        return "HandCards." + error;
                }
            }
            if (message.DrawCards != null && message.hasOwnProperty("DrawCards")) {
                if (!Array.isArray(message.DrawCards))
                    return "DrawCards: array expected";
                for (var i = 0; i < message.DrawCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.DrawCards[i]);
                    if (error)
                        return "DrawCards." + error;
                }
            }
            if (message.IsFirstBattle != null && message.hasOwnProperty("IsFirstBattle"))
                if (typeof message.IsFirstBattle !== "boolean")
                    return "IsFirstBattle: boolean expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return BeginNewbiePvpMatchArg;
    })();

    pb.SeasonPvpLimitTime = (function() {

        /**
         * Properties of a SeasonPvpLimitTime.
         * @memberof pb
         * @interface ISeasonPvpLimitTime
         * @property {number|null} [LimitTime] SeasonPvpLimitTime LimitTime
         */

        /**
         * Constructs a new SeasonPvpLimitTime.
         * @memberof pb
         * @classdesc Represents a SeasonPvpLimitTime.
         * @implements ISeasonPvpLimitTime
         * @constructor
         * @param {pb.ISeasonPvpLimitTime=} [properties] Properties to set
         */
        function SeasonPvpLimitTime(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpLimitTime LimitTime.
         * @member {number} LimitTime
         * @memberof pb.SeasonPvpLimitTime
         * @instance
         */
        SeasonPvpLimitTime.prototype.LimitTime = 0;

        /**
         * Creates a new SeasonPvpLimitTime instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {pb.ISeasonPvpLimitTime=} [properties] Properties to set
         * @returns {pb.SeasonPvpLimitTime} SeasonPvpLimitTime instance
         */
        SeasonPvpLimitTime.create = function create(properties) {
            return new SeasonPvpLimitTime(properties);
        };

        /**
         * Encodes the specified SeasonPvpLimitTime message. Does not implicitly {@link pb.SeasonPvpLimitTime.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {pb.ISeasonPvpLimitTime} message SeasonPvpLimitTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpLimitTime.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LimitTime != null && message.hasOwnProperty("LimitTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LimitTime);
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpLimitTime message, length delimited. Does not implicitly {@link pb.SeasonPvpLimitTime.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {pb.ISeasonPvpLimitTime} message SeasonPvpLimitTime message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpLimitTime.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpLimitTime message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpLimitTime} SeasonPvpLimitTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpLimitTime.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpLimitTime();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LimitTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpLimitTime message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpLimitTime} SeasonPvpLimitTime
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpLimitTime.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpLimitTime message.
         * @function verify
         * @memberof pb.SeasonPvpLimitTime
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpLimitTime.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LimitTime != null && message.hasOwnProperty("LimitTime"))
                if (!$util.isInteger(message.LimitTime))
                    return "LimitTime: integer expected";
            return null;
        };

        return SeasonPvpLimitTime;
    })();

    pb.SeasonPvpInfo = (function() {

        /**
         * Properties of a SeasonPvpInfo.
         * @memberof pb
         * @interface ISeasonPvpInfo
         * @property {number|null} [LimitTime] SeasonPvpInfo LimitTime
         * @property {number|null} [FirstHandAmount] SeasonPvpInfo FirstHandAmount
         * @property {number|null} [BackHandAmount] SeasonPvpInfo BackHandAmount
         * @property {number|null} [FirstHandWinAmount] SeasonPvpInfo FirstHandWinAmount
         * @property {number|null} [BackHandWinAmount] SeasonPvpInfo BackHandWinAmount
         */

        /**
         * Constructs a new SeasonPvpInfo.
         * @memberof pb
         * @classdesc Represents a SeasonPvpInfo.
         * @implements ISeasonPvpInfo
         * @constructor
         * @param {pb.ISeasonPvpInfo=} [properties] Properties to set
         */
        function SeasonPvpInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpInfo LimitTime.
         * @member {number} LimitTime
         * @memberof pb.SeasonPvpInfo
         * @instance
         */
        SeasonPvpInfo.prototype.LimitTime = 0;

        /**
         * SeasonPvpInfo FirstHandAmount.
         * @member {number} FirstHandAmount
         * @memberof pb.SeasonPvpInfo
         * @instance
         */
        SeasonPvpInfo.prototype.FirstHandAmount = 0;

        /**
         * SeasonPvpInfo BackHandAmount.
         * @member {number} BackHandAmount
         * @memberof pb.SeasonPvpInfo
         * @instance
         */
        SeasonPvpInfo.prototype.BackHandAmount = 0;

        /**
         * SeasonPvpInfo FirstHandWinAmount.
         * @member {number} FirstHandWinAmount
         * @memberof pb.SeasonPvpInfo
         * @instance
         */
        SeasonPvpInfo.prototype.FirstHandWinAmount = 0;

        /**
         * SeasonPvpInfo BackHandWinAmount.
         * @member {number} BackHandWinAmount
         * @memberof pb.SeasonPvpInfo
         * @instance
         */
        SeasonPvpInfo.prototype.BackHandWinAmount = 0;

        /**
         * Creates a new SeasonPvpInfo instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {pb.ISeasonPvpInfo=} [properties] Properties to set
         * @returns {pb.SeasonPvpInfo} SeasonPvpInfo instance
         */
        SeasonPvpInfo.create = function create(properties) {
            return new SeasonPvpInfo(properties);
        };

        /**
         * Encodes the specified SeasonPvpInfo message. Does not implicitly {@link pb.SeasonPvpInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {pb.ISeasonPvpInfo} message SeasonPvpInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LimitTime != null && message.hasOwnProperty("LimitTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LimitTime);
            if (message.FirstHandAmount != null && message.hasOwnProperty("FirstHandAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.FirstHandAmount);
            if (message.BackHandAmount != null && message.hasOwnProperty("BackHandAmount"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.BackHandAmount);
            if (message.FirstHandWinAmount != null && message.hasOwnProperty("FirstHandWinAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.FirstHandWinAmount);
            if (message.BackHandWinAmount != null && message.hasOwnProperty("BackHandWinAmount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.BackHandWinAmount);
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpInfo message, length delimited. Does not implicitly {@link pb.SeasonPvpInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {pb.ISeasonPvpInfo} message SeasonPvpInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpInfo} SeasonPvpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LimitTime = reader.int32();
                    break;
                case 2:
                    message.FirstHandAmount = reader.int32();
                    break;
                case 3:
                    message.BackHandAmount = reader.int32();
                    break;
                case 4:
                    message.FirstHandWinAmount = reader.int32();
                    break;
                case 5:
                    message.BackHandWinAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpInfo} SeasonPvpInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpInfo message.
         * @function verify
         * @memberof pb.SeasonPvpInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LimitTime != null && message.hasOwnProperty("LimitTime"))
                if (!$util.isInteger(message.LimitTime))
                    return "LimitTime: integer expected";
            if (message.FirstHandAmount != null && message.hasOwnProperty("FirstHandAmount"))
                if (!$util.isInteger(message.FirstHandAmount))
                    return "FirstHandAmount: integer expected";
            if (message.BackHandAmount != null && message.hasOwnProperty("BackHandAmount"))
                if (!$util.isInteger(message.BackHandAmount))
                    return "BackHandAmount: integer expected";
            if (message.FirstHandWinAmount != null && message.hasOwnProperty("FirstHandWinAmount"))
                if (!$util.isInteger(message.FirstHandWinAmount))
                    return "FirstHandWinAmount: integer expected";
            if (message.BackHandWinAmount != null && message.hasOwnProperty("BackHandWinAmount"))
                if (!$util.isInteger(message.BackHandWinAmount))
                    return "BackHandWinAmount: integer expected";
            return null;
        };

        return SeasonPvpInfo;
    })();

    pb.SeasonPvpChooseCampArg = (function() {

        /**
         * Properties of a SeasonPvpChooseCampArg.
         * @memberof pb
         * @interface ISeasonPvpChooseCampArg
         * @property {number|null} [Camp] SeasonPvpChooseCampArg Camp
         */

        /**
         * Constructs a new SeasonPvpChooseCampArg.
         * @memberof pb
         * @classdesc Represents a SeasonPvpChooseCampArg.
         * @implements ISeasonPvpChooseCampArg
         * @constructor
         * @param {pb.ISeasonPvpChooseCampArg=} [properties] Properties to set
         */
        function SeasonPvpChooseCampArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpChooseCampArg Camp.
         * @member {number} Camp
         * @memberof pb.SeasonPvpChooseCampArg
         * @instance
         */
        SeasonPvpChooseCampArg.prototype.Camp = 0;

        /**
         * Creates a new SeasonPvpChooseCampArg instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {pb.ISeasonPvpChooseCampArg=} [properties] Properties to set
         * @returns {pb.SeasonPvpChooseCampArg} SeasonPvpChooseCampArg instance
         */
        SeasonPvpChooseCampArg.create = function create(properties) {
            return new SeasonPvpChooseCampArg(properties);
        };

        /**
         * Encodes the specified SeasonPvpChooseCampArg message. Does not implicitly {@link pb.SeasonPvpChooseCampArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {pb.ISeasonPvpChooseCampArg} message SeasonPvpChooseCampArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCampArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Camp);
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpChooseCampArg message, length delimited. Does not implicitly {@link pb.SeasonPvpChooseCampArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {pb.ISeasonPvpChooseCampArg} message SeasonPvpChooseCampArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCampArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpChooseCampArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpChooseCampArg} SeasonPvpChooseCampArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCampArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpChooseCampArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Camp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpChooseCampArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpChooseCampArg} SeasonPvpChooseCampArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCampArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpChooseCampArg message.
         * @function verify
         * @memberof pb.SeasonPvpChooseCampArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpChooseCampArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            return null;
        };

        return SeasonPvpChooseCampArg;
    })();

    pb.SeasonPvpChooseCardData = (function() {

        /**
         * Properties of a SeasonPvpChooseCardData.
         * @memberof pb
         * @interface ISeasonPvpChooseCardData
         * @property {Array.<number>|null} [CardIDs] SeasonPvpChooseCardData CardIDs
         * @property {number|null} [NeedChooseAmount] SeasonPvpChooseCardData NeedChooseAmount
         * @property {number|null} [FreeRefreshCnt] SeasonPvpChooseCardData FreeRefreshCnt
         * @property {number|null} [JadeRefreshCnt] SeasonPvpChooseCardData JadeRefreshCnt
         */

        /**
         * Constructs a new SeasonPvpChooseCardData.
         * @memberof pb
         * @classdesc Represents a SeasonPvpChooseCardData.
         * @implements ISeasonPvpChooseCardData
         * @constructor
         * @param {pb.ISeasonPvpChooseCardData=} [properties] Properties to set
         */
        function SeasonPvpChooseCardData(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpChooseCardData CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.SeasonPvpChooseCardData
         * @instance
         */
        SeasonPvpChooseCardData.prototype.CardIDs = $util.emptyArray;

        /**
         * SeasonPvpChooseCardData NeedChooseAmount.
         * @member {number} NeedChooseAmount
         * @memberof pb.SeasonPvpChooseCardData
         * @instance
         */
        SeasonPvpChooseCardData.prototype.NeedChooseAmount = 0;

        /**
         * SeasonPvpChooseCardData FreeRefreshCnt.
         * @member {number} FreeRefreshCnt
         * @memberof pb.SeasonPvpChooseCardData
         * @instance
         */
        SeasonPvpChooseCardData.prototype.FreeRefreshCnt = 0;

        /**
         * SeasonPvpChooseCardData JadeRefreshCnt.
         * @member {number} JadeRefreshCnt
         * @memberof pb.SeasonPvpChooseCardData
         * @instance
         */
        SeasonPvpChooseCardData.prototype.JadeRefreshCnt = 0;

        /**
         * Creates a new SeasonPvpChooseCardData instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {pb.ISeasonPvpChooseCardData=} [properties] Properties to set
         * @returns {pb.SeasonPvpChooseCardData} SeasonPvpChooseCardData instance
         */
        SeasonPvpChooseCardData.create = function create(properties) {
            return new SeasonPvpChooseCardData(properties);
        };

        /**
         * Encodes the specified SeasonPvpChooseCardData message. Does not implicitly {@link pb.SeasonPvpChooseCardData.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {pb.ISeasonPvpChooseCardData} message SeasonPvpChooseCardData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            if (message.NeedChooseAmount != null && message.hasOwnProperty("NeedChooseAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NeedChooseAmount);
            if (message.FreeRefreshCnt != null && message.hasOwnProperty("FreeRefreshCnt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.FreeRefreshCnt);
            if (message.JadeRefreshCnt != null && message.hasOwnProperty("JadeRefreshCnt"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.JadeRefreshCnt);
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpChooseCardData message, length delimited. Does not implicitly {@link pb.SeasonPvpChooseCardData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {pb.ISeasonPvpChooseCardData} message SeasonPvpChooseCardData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpChooseCardData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpChooseCardData} SeasonPvpChooseCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpChooseCardData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                case 2:
                    message.NeedChooseAmount = reader.int32();
                    break;
                case 3:
                    message.FreeRefreshCnt = reader.int32();
                    break;
                case 4:
                    message.JadeRefreshCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpChooseCardData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpChooseCardData} SeasonPvpChooseCardData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpChooseCardData message.
         * @function verify
         * @memberof pb.SeasonPvpChooseCardData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpChooseCardData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            if (message.NeedChooseAmount != null && message.hasOwnProperty("NeedChooseAmount"))
                if (!$util.isInteger(message.NeedChooseAmount))
                    return "NeedChooseAmount: integer expected";
            if (message.FreeRefreshCnt != null && message.hasOwnProperty("FreeRefreshCnt"))
                if (!$util.isInteger(message.FreeRefreshCnt))
                    return "FreeRefreshCnt: integer expected";
            if (message.JadeRefreshCnt != null && message.hasOwnProperty("JadeRefreshCnt"))
                if (!$util.isInteger(message.JadeRefreshCnt))
                    return "JadeRefreshCnt: integer expected";
            return null;
        };

        return SeasonPvpChooseCardData;
    })();

    pb.SeasonPvpChooseCardArg = (function() {

        /**
         * Properties of a SeasonPvpChooseCardArg.
         * @memberof pb
         * @interface ISeasonPvpChooseCardArg
         * @property {Array.<number>|null} [CardIDs] SeasonPvpChooseCardArg CardIDs
         */

        /**
         * Constructs a new SeasonPvpChooseCardArg.
         * @memberof pb
         * @classdesc Represents a SeasonPvpChooseCardArg.
         * @implements ISeasonPvpChooseCardArg
         * @constructor
         * @param {pb.ISeasonPvpChooseCardArg=} [properties] Properties to set
         */
        function SeasonPvpChooseCardArg(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpChooseCardArg CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.SeasonPvpChooseCardArg
         * @instance
         */
        SeasonPvpChooseCardArg.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new SeasonPvpChooseCardArg instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {pb.ISeasonPvpChooseCardArg=} [properties] Properties to set
         * @returns {pb.SeasonPvpChooseCardArg} SeasonPvpChooseCardArg instance
         */
        SeasonPvpChooseCardArg.create = function create(properties) {
            return new SeasonPvpChooseCardArg(properties);
        };

        /**
         * Encodes the specified SeasonPvpChooseCardArg message. Does not implicitly {@link pb.SeasonPvpChooseCardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {pb.ISeasonPvpChooseCardArg} message SeasonPvpChooseCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpChooseCardArg message, length delimited. Does not implicitly {@link pb.SeasonPvpChooseCardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {pb.ISeasonPvpChooseCardArg} message SeasonPvpChooseCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpChooseCardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpChooseCardArg} SeasonPvpChooseCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpChooseCardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpChooseCardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpChooseCardArg} SeasonPvpChooseCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpChooseCardArg message.
         * @function verify
         * @memberof pb.SeasonPvpChooseCardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpChooseCardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return SeasonPvpChooseCardArg;
    })();

    pb.SeasonPvpChooseCardReply = (function() {

        /**
         * Properties of a SeasonPvpChooseCardReply.
         * @memberof pb
         * @interface ISeasonPvpChooseCardReply
         * @property {Array.<number>|null} [CardIDs] SeasonPvpChooseCardReply CardIDs
         */

        /**
         * Constructs a new SeasonPvpChooseCardReply.
         * @memberof pb
         * @classdesc Represents a SeasonPvpChooseCardReply.
         * @implements ISeasonPvpChooseCardReply
         * @constructor
         * @param {pb.ISeasonPvpChooseCardReply=} [properties] Properties to set
         */
        function SeasonPvpChooseCardReply(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SeasonPvpChooseCardReply CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.SeasonPvpChooseCardReply
         * @instance
         */
        SeasonPvpChooseCardReply.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new SeasonPvpChooseCardReply instance using the specified properties.
         * @function create
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {pb.ISeasonPvpChooseCardReply=} [properties] Properties to set
         * @returns {pb.SeasonPvpChooseCardReply} SeasonPvpChooseCardReply instance
         */
        SeasonPvpChooseCardReply.create = function create(properties) {
            return new SeasonPvpChooseCardReply(properties);
        };

        /**
         * Encodes the specified SeasonPvpChooseCardReply message. Does not implicitly {@link pb.SeasonPvpChooseCardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {pb.ISeasonPvpChooseCardReply} message SeasonPvpChooseCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SeasonPvpChooseCardReply message, length delimited. Does not implicitly {@link pb.SeasonPvpChooseCardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {pb.ISeasonPvpChooseCardReply} message SeasonPvpChooseCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SeasonPvpChooseCardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SeasonPvpChooseCardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SeasonPvpChooseCardReply} SeasonPvpChooseCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SeasonPvpChooseCardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SeasonPvpChooseCardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SeasonPvpChooseCardReply} SeasonPvpChooseCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SeasonPvpChooseCardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SeasonPvpChooseCardReply message.
         * @function verify
         * @memberof pb.SeasonPvpChooseCardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SeasonPvpChooseCardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return SeasonPvpChooseCardReply;
    })();

    pb.FetchSeasonHandCardReply = (function() {

        /**
         * Properties of a FetchSeasonHandCardReply.
         * @memberof pb
         * @interface IFetchSeasonHandCardReply
         * @property {Array.<number>|null} [CardIDs] FetchSeasonHandCardReply CardIDs
         * @property {pb.FetchSeasonHandCardReply.ChangeTypeEnum|null} [ChangeType] FetchSeasonHandCardReply ChangeType
         * @property {number|null} [ChangeMaxPro] FetchSeasonHandCardReply ChangeMaxPro
         * @property {number|null} [ChangeCurPro] FetchSeasonHandCardReply ChangeCurPro
         * @property {number|null} [WinCnt] FetchSeasonHandCardReply WinCnt
         */

        /**
         * Constructs a new FetchSeasonHandCardReply.
         * @memberof pb
         * @classdesc Represents a FetchSeasonHandCardReply.
         * @implements IFetchSeasonHandCardReply
         * @constructor
         * @param {pb.IFetchSeasonHandCardReply=} [properties] Properties to set
         */
        function FetchSeasonHandCardReply(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchSeasonHandCardReply CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.FetchSeasonHandCardReply
         * @instance
         */
        FetchSeasonHandCardReply.prototype.CardIDs = $util.emptyArray;

        /**
         * FetchSeasonHandCardReply ChangeType.
         * @member {pb.FetchSeasonHandCardReply.ChangeTypeEnum} ChangeType
         * @memberof pb.FetchSeasonHandCardReply
         * @instance
         */
        FetchSeasonHandCardReply.prototype.ChangeType = 0;

        /**
         * FetchSeasonHandCardReply ChangeMaxPro.
         * @member {number} ChangeMaxPro
         * @memberof pb.FetchSeasonHandCardReply
         * @instance
         */
        FetchSeasonHandCardReply.prototype.ChangeMaxPro = 0;

        /**
         * FetchSeasonHandCardReply ChangeCurPro.
         * @member {number} ChangeCurPro
         * @memberof pb.FetchSeasonHandCardReply
         * @instance
         */
        FetchSeasonHandCardReply.prototype.ChangeCurPro = 0;

        /**
         * FetchSeasonHandCardReply WinCnt.
         * @member {number} WinCnt
         * @memberof pb.FetchSeasonHandCardReply
         * @instance
         */
        FetchSeasonHandCardReply.prototype.WinCnt = 0;

        /**
         * Creates a new FetchSeasonHandCardReply instance using the specified properties.
         * @function create
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {pb.IFetchSeasonHandCardReply=} [properties] Properties to set
         * @returns {pb.FetchSeasonHandCardReply} FetchSeasonHandCardReply instance
         */
        FetchSeasonHandCardReply.create = function create(properties) {
            return new FetchSeasonHandCardReply(properties);
        };

        /**
         * Encodes the specified FetchSeasonHandCardReply message. Does not implicitly {@link pb.FetchSeasonHandCardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {pb.IFetchSeasonHandCardReply} message FetchSeasonHandCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchSeasonHandCardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            if (message.ChangeType != null && message.hasOwnProperty("ChangeType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ChangeType);
            if (message.ChangeMaxPro != null && message.hasOwnProperty("ChangeMaxPro"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ChangeMaxPro);
            if (message.ChangeCurPro != null && message.hasOwnProperty("ChangeCurPro"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ChangeCurPro);
            if (message.WinCnt != null && message.hasOwnProperty("WinCnt"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.WinCnt);
            return writer;
        };

        /**
         * Encodes the specified FetchSeasonHandCardReply message, length delimited. Does not implicitly {@link pb.FetchSeasonHandCardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {pb.IFetchSeasonHandCardReply} message FetchSeasonHandCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchSeasonHandCardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchSeasonHandCardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchSeasonHandCardReply} FetchSeasonHandCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchSeasonHandCardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchSeasonHandCardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                case 2:
                    message.ChangeType = reader.int32();
                    break;
                case 3:
                    message.ChangeMaxPro = reader.int32();
                    break;
                case 4:
                    message.ChangeCurPro = reader.int32();
                    break;
                case 5:
                    message.WinCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchSeasonHandCardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchSeasonHandCardReply} FetchSeasonHandCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchSeasonHandCardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchSeasonHandCardReply message.
         * @function verify
         * @memberof pb.FetchSeasonHandCardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchSeasonHandCardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            if (message.ChangeType != null && message.hasOwnProperty("ChangeType"))
                switch (message.ChangeType) {
                default:
                    return "ChangeType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                    break;
                }
            if (message.ChangeMaxPro != null && message.hasOwnProperty("ChangeMaxPro"))
                if (!$util.isInteger(message.ChangeMaxPro))
                    return "ChangeMaxPro: integer expected";
            if (message.ChangeCurPro != null && message.hasOwnProperty("ChangeCurPro"))
                if (!$util.isInteger(message.ChangeCurPro))
                    return "ChangeCurPro: integer expected";
            if (message.WinCnt != null && message.hasOwnProperty("WinCnt"))
                if (!$util.isInteger(message.WinCnt))
                    return "WinCnt: integer expected";
            return null;
        };

        /**
         * ChangeTypeEnum enum.
         * @name pb.FetchSeasonHandCardReply.ChangeTypeEnum
         * @enum {string}
         * @property {number} Unknow=0 Unknow value
         * @property {number} Fight=1 Fight value
         * @property {number} Win=2 Win value
         * @property {number} Lose=3 Lose value
         */
        FetchSeasonHandCardReply.ChangeTypeEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknow"] = 0;
            values[valuesById[1] = "Fight"] = 1;
            values[valuesById[2] = "Win"] = 2;
            values[valuesById[3] = "Lose"] = 3;
            return values;
        })();

        return FetchSeasonHandCardReply;
    })();

    pb.GetFighterDataArg = (function() {

        /**
         * Properties of a GetFighterDataArg.
         * @memberof pb
         * @interface IGetFighterDataArg
         * @property {Array.<number>|null} [CardIDs] GetFighterDataArg CardIDs
         */

        /**
         * Constructs a new GetFighterDataArg.
         * @memberof pb
         * @classdesc Represents a GetFighterDataArg.
         * @implements IGetFighterDataArg
         * @constructor
         * @param {pb.IGetFighterDataArg=} [properties] Properties to set
         */
        function GetFighterDataArg(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetFighterDataArg CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.GetFighterDataArg
         * @instance
         */
        GetFighterDataArg.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new GetFighterDataArg instance using the specified properties.
         * @function create
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {pb.IGetFighterDataArg=} [properties] Properties to set
         * @returns {pb.GetFighterDataArg} GetFighterDataArg instance
         */
        GetFighterDataArg.create = function create(properties) {
            return new GetFighterDataArg(properties);
        };

        /**
         * Encodes the specified GetFighterDataArg message. Does not implicitly {@link pb.GetFighterDataArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {pb.IGetFighterDataArg} message GetFighterDataArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFighterDataArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetFighterDataArg message, length delimited. Does not implicitly {@link pb.GetFighterDataArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {pb.IGetFighterDataArg} message GetFighterDataArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFighterDataArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFighterDataArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetFighterDataArg} GetFighterDataArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFighterDataArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetFighterDataArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFighterDataArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetFighterDataArg} GetFighterDataArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFighterDataArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFighterDataArg message.
         * @function verify
         * @memberof pb.GetFighterDataArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFighterDataArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return GetFighterDataArg;
    })();

    /**
     * HuodongTypeEnum enum.
     * @name pb.HuodongTypeEnum
     * @enum {string}
     * @property {number} HUnknow=0 HUnknow value
     * @property {number} HSeasonPvp=1 HSeasonPvp value
     * @property {number} HSpringExchange=2 HSpringExchange value
     */
    pb.HuodongTypeEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "HUnknow"] = 0;
        values[valuesById[1] = "HSeasonPvp"] = 1;
        values[valuesById[2] = "HSpringExchange"] = 2;
        return values;
    })();

    pb.HuodongData = (function() {

        /**
         * Properties of a HuodongData.
         * @memberof pb
         * @interface IHuodongData
         * @property {pb.HuodongTypeEnum|null} [Type] HuodongData Type
         * @property {number|null} [RemainTime] HuodongData RemainTime
         * @property {number|null} [RemainExchangeTime] HuodongData RemainExchangeTime
         */

        /**
         * Constructs a new HuodongData.
         * @memberof pb
         * @classdesc Represents a HuodongData.
         * @implements IHuodongData
         * @constructor
         * @param {pb.IHuodongData=} [properties] Properties to set
         */
        function HuodongData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HuodongData Type.
         * @member {pb.HuodongTypeEnum} Type
         * @memberof pb.HuodongData
         * @instance
         */
        HuodongData.prototype.Type = 0;

        /**
         * HuodongData RemainTime.
         * @member {number} RemainTime
         * @memberof pb.HuodongData
         * @instance
         */
        HuodongData.prototype.RemainTime = 0;

        /**
         * HuodongData RemainExchangeTime.
         * @member {number} RemainExchangeTime
         * @memberof pb.HuodongData
         * @instance
         */
        HuodongData.prototype.RemainExchangeTime = 0;

        /**
         * Creates a new HuodongData instance using the specified properties.
         * @function create
         * @memberof pb.HuodongData
         * @static
         * @param {pb.IHuodongData=} [properties] Properties to set
         * @returns {pb.HuodongData} HuodongData instance
         */
        HuodongData.create = function create(properties) {
            return new HuodongData(properties);
        };

        /**
         * Encodes the specified HuodongData message. Does not implicitly {@link pb.HuodongData.verify|verify} messages.
         * @function encode
         * @memberof pb.HuodongData
         * @static
         * @param {pb.IHuodongData} message HuodongData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RemainTime);
            if (message.RemainExchangeTime != null && message.hasOwnProperty("RemainExchangeTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RemainExchangeTime);
            return writer;
        };

        /**
         * Encodes the specified HuodongData message, length delimited. Does not implicitly {@link pb.HuodongData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HuodongData
         * @static
         * @param {pb.IHuodongData} message HuodongData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HuodongData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HuodongData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HuodongData} HuodongData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HuodongData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.RemainTime = reader.int32();
                    break;
                case 3:
                    message.RemainExchangeTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HuodongData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HuodongData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HuodongData} HuodongData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HuodongData message.
         * @function verify
         * @memberof pb.HuodongData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HuodongData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.RemainExchangeTime != null && message.hasOwnProperty("RemainExchangeTime"))
                if (!$util.isInteger(message.RemainExchangeTime))
                    return "RemainExchangeTime: integer expected";
            return null;
        };

        return HuodongData;
    })();

    pb.TargetHuodong = (function() {

        /**
         * Properties of a TargetHuodong.
         * @memberof pb
         * @interface ITargetHuodong
         * @property {pb.HuodongTypeEnum|null} [Type] TargetHuodong Type
         */

        /**
         * Constructs a new TargetHuodong.
         * @memberof pb
         * @classdesc Represents a TargetHuodong.
         * @implements ITargetHuodong
         * @constructor
         * @param {pb.ITargetHuodong=} [properties] Properties to set
         */
        function TargetHuodong(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetHuodong Type.
         * @member {pb.HuodongTypeEnum} Type
         * @memberof pb.TargetHuodong
         * @instance
         */
        TargetHuodong.prototype.Type = 0;

        /**
         * Creates a new TargetHuodong instance using the specified properties.
         * @function create
         * @memberof pb.TargetHuodong
         * @static
         * @param {pb.ITargetHuodong=} [properties] Properties to set
         * @returns {pb.TargetHuodong} TargetHuodong instance
         */
        TargetHuodong.create = function create(properties) {
            return new TargetHuodong(properties);
        };

        /**
         * Encodes the specified TargetHuodong message. Does not implicitly {@link pb.TargetHuodong.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetHuodong
         * @static
         * @param {pb.ITargetHuodong} message TargetHuodong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetHuodong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            return writer;
        };

        /**
         * Encodes the specified TargetHuodong message, length delimited. Does not implicitly {@link pb.TargetHuodong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetHuodong
         * @static
         * @param {pb.ITargetHuodong} message TargetHuodong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetHuodong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetHuodong message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetHuodong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetHuodong} TargetHuodong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetHuodong.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetHuodong();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetHuodong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetHuodong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetHuodong} TargetHuodong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetHuodong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetHuodong message.
         * @function verify
         * @memberof pb.TargetHuodong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetHuodong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        return TargetHuodong;
    })();

    pb.HuodongDetail = (function() {

        /**
         * Properties of a HuodongDetail.
         * @memberof pb
         * @interface IHuodongDetail
         * @property {Uint8Array|null} [Data] HuodongDetail Data
         */

        /**
         * Constructs a new HuodongDetail.
         * @memberof pb
         * @classdesc Represents a HuodongDetail.
         * @implements IHuodongDetail
         * @constructor
         * @param {pb.IHuodongDetail=} [properties] Properties to set
         */
        function HuodongDetail(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HuodongDetail Data.
         * @member {Uint8Array} Data
         * @memberof pb.HuodongDetail
         * @instance
         */
        HuodongDetail.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new HuodongDetail instance using the specified properties.
         * @function create
         * @memberof pb.HuodongDetail
         * @static
         * @param {pb.IHuodongDetail=} [properties] Properties to set
         * @returns {pb.HuodongDetail} HuodongDetail instance
         */
        HuodongDetail.create = function create(properties) {
            return new HuodongDetail(properties);
        };

        /**
         * Encodes the specified HuodongDetail message. Does not implicitly {@link pb.HuodongDetail.verify|verify} messages.
         * @function encode
         * @memberof pb.HuodongDetail
         * @static
         * @param {pb.IHuodongDetail} message HuodongDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongDetail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified HuodongDetail message, length delimited. Does not implicitly {@link pb.HuodongDetail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HuodongDetail
         * @static
         * @param {pb.IHuodongDetail} message HuodongDetail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongDetail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HuodongDetail message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HuodongDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HuodongDetail} HuodongDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongDetail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HuodongDetail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HuodongDetail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HuodongDetail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HuodongDetail} HuodongDetail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongDetail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HuodongDetail message.
         * @function verify
         * @memberof pb.HuodongDetail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HuodongDetail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        return HuodongDetail;
    })();

    pb.SpringExchangeData = (function() {

        /**
         * Properties of a SpringExchangeData.
         * @memberof pb
         * @interface ISpringExchangeData
         * @property {number|null} [GoodsID] SpringExchangeData GoodsID
         * @property {number|null} [ExchangeCnt] SpringExchangeData ExchangeCnt
         */

        /**
         * Constructs a new SpringExchangeData.
         * @memberof pb
         * @classdesc Represents a SpringExchangeData.
         * @implements ISpringExchangeData
         * @constructor
         * @param {pb.ISpringExchangeData=} [properties] Properties to set
         */
        function SpringExchangeData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpringExchangeData GoodsID.
         * @member {number} GoodsID
         * @memberof pb.SpringExchangeData
         * @instance
         */
        SpringExchangeData.prototype.GoodsID = 0;

        /**
         * SpringExchangeData ExchangeCnt.
         * @member {number} ExchangeCnt
         * @memberof pb.SpringExchangeData
         * @instance
         */
        SpringExchangeData.prototype.ExchangeCnt = 0;

        /**
         * Creates a new SpringExchangeData instance using the specified properties.
         * @function create
         * @memberof pb.SpringExchangeData
         * @static
         * @param {pb.ISpringExchangeData=} [properties] Properties to set
         * @returns {pb.SpringExchangeData} SpringExchangeData instance
         */
        SpringExchangeData.create = function create(properties) {
            return new SpringExchangeData(properties);
        };

        /**
         * Encodes the specified SpringExchangeData message. Does not implicitly {@link pb.SpringExchangeData.verify|verify} messages.
         * @function encode
         * @memberof pb.SpringExchangeData
         * @static
         * @param {pb.ISpringExchangeData} message SpringExchangeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpringExchangeData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.GoodsID);
            if (message.ExchangeCnt != null && message.hasOwnProperty("ExchangeCnt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ExchangeCnt);
            return writer;
        };

        /**
         * Encodes the specified SpringExchangeData message, length delimited. Does not implicitly {@link pb.SpringExchangeData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SpringExchangeData
         * @static
         * @param {pb.ISpringExchangeData} message SpringExchangeData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpringExchangeData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpringExchangeData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SpringExchangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SpringExchangeData} SpringExchangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpringExchangeData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SpringExchangeData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.int32();
                    break;
                case 2:
                    message.ExchangeCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpringExchangeData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SpringExchangeData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SpringExchangeData} SpringExchangeData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpringExchangeData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpringExchangeData message.
         * @function verify
         * @memberof pb.SpringExchangeData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpringExchangeData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isInteger(message.GoodsID))
                    return "GoodsID: integer expected";
            if (message.ExchangeCnt != null && message.hasOwnProperty("ExchangeCnt"))
                if (!$util.isInteger(message.ExchangeCnt))
                    return "ExchangeCnt: integer expected";
            return null;
        };

        return SpringExchangeData;
    })();

    pb.SpringHuodong = (function() {

        /**
         * Properties of a SpringHuodong.
         * @memberof pb
         * @interface ISpringHuodong
         * @property {Array.<pb.ISpringExchangeData>|null} [ExchangeDatas] SpringHuodong ExchangeDatas
         */

        /**
         * Constructs a new SpringHuodong.
         * @memberof pb
         * @classdesc Represents a SpringHuodong.
         * @implements ISpringHuodong
         * @constructor
         * @param {pb.ISpringHuodong=} [properties] Properties to set
         */
        function SpringHuodong(properties) {
            this.ExchangeDatas = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SpringHuodong ExchangeDatas.
         * @member {Array.<pb.ISpringExchangeData>} ExchangeDatas
         * @memberof pb.SpringHuodong
         * @instance
         */
        SpringHuodong.prototype.ExchangeDatas = $util.emptyArray;

        /**
         * Creates a new SpringHuodong instance using the specified properties.
         * @function create
         * @memberof pb.SpringHuodong
         * @static
         * @param {pb.ISpringHuodong=} [properties] Properties to set
         * @returns {pb.SpringHuodong} SpringHuodong instance
         */
        SpringHuodong.create = function create(properties) {
            return new SpringHuodong(properties);
        };

        /**
         * Encodes the specified SpringHuodong message. Does not implicitly {@link pb.SpringHuodong.verify|verify} messages.
         * @function encode
         * @memberof pb.SpringHuodong
         * @static
         * @param {pb.ISpringHuodong} message SpringHuodong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpringHuodong.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ExchangeDatas != null && message.ExchangeDatas.length)
                for (var i = 0; i < message.ExchangeDatas.length; ++i)
                    $root.pb.SpringExchangeData.encode(message.ExchangeDatas[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SpringHuodong message, length delimited. Does not implicitly {@link pb.SpringHuodong.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SpringHuodong
         * @static
         * @param {pb.ISpringHuodong} message SpringHuodong message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SpringHuodong.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SpringHuodong message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SpringHuodong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SpringHuodong} SpringHuodong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpringHuodong.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SpringHuodong();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ExchangeDatas && message.ExchangeDatas.length))
                        message.ExchangeDatas = [];
                    message.ExchangeDatas.push($root.pb.SpringExchangeData.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SpringHuodong message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SpringHuodong
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SpringHuodong} SpringHuodong
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SpringHuodong.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SpringHuodong message.
         * @function verify
         * @memberof pb.SpringHuodong
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SpringHuodong.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ExchangeDatas != null && message.hasOwnProperty("ExchangeDatas")) {
                if (!Array.isArray(message.ExchangeDatas))
                    return "ExchangeDatas: array expected";
                for (var i = 0; i < message.ExchangeDatas.length; ++i) {
                    var error = $root.pb.SpringExchangeData.verify(message.ExchangeDatas[i]);
                    if (error)
                        return "ExchangeDatas." + error;
                }
            }
            return null;
        };

        return SpringHuodong;
    })();

    pb.HuodongExchangeArg = (function() {

        /**
         * Properties of a HuodongExchangeArg.
         * @memberof pb
         * @interface IHuodongExchangeArg
         * @property {pb.HuodongTypeEnum|null} [Type] HuodongExchangeArg Type
         * @property {number|null} [GoodsID] HuodongExchangeArg GoodsID
         */

        /**
         * Constructs a new HuodongExchangeArg.
         * @memberof pb
         * @classdesc Represents a HuodongExchangeArg.
         * @implements IHuodongExchangeArg
         * @constructor
         * @param {pb.IHuodongExchangeArg=} [properties] Properties to set
         */
        function HuodongExchangeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HuodongExchangeArg Type.
         * @member {pb.HuodongTypeEnum} Type
         * @memberof pb.HuodongExchangeArg
         * @instance
         */
        HuodongExchangeArg.prototype.Type = 0;

        /**
         * HuodongExchangeArg GoodsID.
         * @member {number} GoodsID
         * @memberof pb.HuodongExchangeArg
         * @instance
         */
        HuodongExchangeArg.prototype.GoodsID = 0;

        /**
         * Creates a new HuodongExchangeArg instance using the specified properties.
         * @function create
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {pb.IHuodongExchangeArg=} [properties] Properties to set
         * @returns {pb.HuodongExchangeArg} HuodongExchangeArg instance
         */
        HuodongExchangeArg.create = function create(properties) {
            return new HuodongExchangeArg(properties);
        };

        /**
         * Encodes the specified HuodongExchangeArg message. Does not implicitly {@link pb.HuodongExchangeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {pb.IHuodongExchangeArg} message HuodongExchangeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongExchangeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified HuodongExchangeArg message, length delimited. Does not implicitly {@link pb.HuodongExchangeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {pb.IHuodongExchangeArg} message HuodongExchangeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongExchangeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HuodongExchangeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HuodongExchangeArg} HuodongExchangeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongExchangeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HuodongExchangeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.GoodsID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HuodongExchangeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HuodongExchangeArg} HuodongExchangeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongExchangeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HuodongExchangeArg message.
         * @function verify
         * @memberof pb.HuodongExchangeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HuodongExchangeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isInteger(message.GoodsID))
                    return "GoodsID: integer expected";
            return null;
        };

        return HuodongExchangeArg;
    })();

    pb.HuodongExchangeReply = (function() {

        /**
         * Properties of a HuodongExchangeReply.
         * @memberof pb
         * @interface IHuodongExchangeReply
         * @property {pb.IOpenTreasureReply|null} [Treasure] HuodongExchangeReply Treasure
         */

        /**
         * Constructs a new HuodongExchangeReply.
         * @memberof pb
         * @classdesc Represents a HuodongExchangeReply.
         * @implements IHuodongExchangeReply
         * @constructor
         * @param {pb.IHuodongExchangeReply=} [properties] Properties to set
         */
        function HuodongExchangeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HuodongExchangeReply Treasure.
         * @member {pb.IOpenTreasureReply|null|undefined} Treasure
         * @memberof pb.HuodongExchangeReply
         * @instance
         */
        HuodongExchangeReply.prototype.Treasure = null;

        /**
         * Creates a new HuodongExchangeReply instance using the specified properties.
         * @function create
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {pb.IHuodongExchangeReply=} [properties] Properties to set
         * @returns {pb.HuodongExchangeReply} HuodongExchangeReply instance
         */
        HuodongExchangeReply.create = function create(properties) {
            return new HuodongExchangeReply(properties);
        };

        /**
         * Encodes the specified HuodongExchangeReply message. Does not implicitly {@link pb.HuodongExchangeReply.verify|verify} messages.
         * @function encode
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {pb.IHuodongExchangeReply} message HuodongExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongExchangeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Treasure != null && message.hasOwnProperty("Treasure"))
                $root.pb.OpenTreasureReply.encode(message.Treasure, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified HuodongExchangeReply message, length delimited. Does not implicitly {@link pb.HuodongExchangeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {pb.IHuodongExchangeReply} message HuodongExchangeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HuodongExchangeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HuodongExchangeReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HuodongExchangeReply} HuodongExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongExchangeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HuodongExchangeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Treasure = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HuodongExchangeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HuodongExchangeReply} HuodongExchangeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HuodongExchangeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HuodongExchangeReply message.
         * @function verify
         * @memberof pb.HuodongExchangeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HuodongExchangeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Treasure != null && message.hasOwnProperty("Treasure")) {
                var error = $root.pb.OpenTreasureReply.verify(message.Treasure);
                if (error)
                    return "Treasure." + error;
            }
            return null;
        };

        return HuodongExchangeReply;
    })();

    pb.LevelInfo = (function() {

        /**
         * Properties of a LevelInfo.
         * @memberof pb
         * @interface ILevelInfo
         * @property {number|null} [CurLevel] LevelInfo CurLevel
         * @property {Array.<number>|null} [OpenedTreasureChapters] LevelInfo OpenedTreasureChapters
         * @property {Array.<number>|null} [AskHelpLevels] LevelInfo AskHelpLevels
         */

        /**
         * Constructs a new LevelInfo.
         * @memberof pb
         * @classdesc Represents a LevelInfo.
         * @implements ILevelInfo
         * @constructor
         * @param {pb.ILevelInfo=} [properties] Properties to set
         */
        function LevelInfo(properties) {
            this.OpenedTreasureChapters = [];
            this.AskHelpLevels = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelInfo CurLevel.
         * @member {number} CurLevel
         * @memberof pb.LevelInfo
         * @instance
         */
        LevelInfo.prototype.CurLevel = 0;

        /**
         * LevelInfo OpenedTreasureChapters.
         * @member {Array.<number>} OpenedTreasureChapters
         * @memberof pb.LevelInfo
         * @instance
         */
        LevelInfo.prototype.OpenedTreasureChapters = $util.emptyArray;

        /**
         * LevelInfo AskHelpLevels.
         * @member {Array.<number>} AskHelpLevels
         * @memberof pb.LevelInfo
         * @instance
         */
        LevelInfo.prototype.AskHelpLevels = $util.emptyArray;

        /**
         * Creates a new LevelInfo instance using the specified properties.
         * @function create
         * @memberof pb.LevelInfo
         * @static
         * @param {pb.ILevelInfo=} [properties] Properties to set
         * @returns {pb.LevelInfo} LevelInfo instance
         */
        LevelInfo.create = function create(properties) {
            return new LevelInfo(properties);
        };

        /**
         * Encodes the specified LevelInfo message. Does not implicitly {@link pb.LevelInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelInfo
         * @static
         * @param {pb.ILevelInfo} message LevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CurLevel != null && message.hasOwnProperty("CurLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurLevel);
            if (message.OpenedTreasureChapters != null && message.OpenedTreasureChapters.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.OpenedTreasureChapters.length; ++i)
                    writer.int32(message.OpenedTreasureChapters[i]);
                writer.ldelim();
            }
            if (message.AskHelpLevels != null && message.AskHelpLevels.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.AskHelpLevels.length; ++i)
                    writer.int32(message.AskHelpLevels[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LevelInfo message, length delimited. Does not implicitly {@link pb.LevelInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelInfo
         * @static
         * @param {pb.ILevelInfo} message LevelInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelInfo} LevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CurLevel = reader.int32();
                    break;
                case 2:
                    if (!(message.OpenedTreasureChapters && message.OpenedTreasureChapters.length))
                        message.OpenedTreasureChapters = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.OpenedTreasureChapters.push(reader.int32());
                    } else
                        message.OpenedTreasureChapters.push(reader.int32());
                    break;
                case 3:
                    if (!(message.AskHelpLevels && message.AskHelpLevels.length))
                        message.AskHelpLevels = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.AskHelpLevels.push(reader.int32());
                    } else
                        message.AskHelpLevels.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelInfo} LevelInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelInfo message.
         * @function verify
         * @memberof pb.LevelInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CurLevel != null && message.hasOwnProperty("CurLevel"))
                if (!$util.isInteger(message.CurLevel))
                    return "CurLevel: integer expected";
            if (message.OpenedTreasureChapters != null && message.hasOwnProperty("OpenedTreasureChapters")) {
                if (!Array.isArray(message.OpenedTreasureChapters))
                    return "OpenedTreasureChapters: array expected";
                for (var i = 0; i < message.OpenedTreasureChapters.length; ++i)
                    if (!$util.isInteger(message.OpenedTreasureChapters[i]))
                        return "OpenedTreasureChapters: integer[] expected";
            }
            if (message.AskHelpLevels != null && message.hasOwnProperty("AskHelpLevels")) {
                if (!Array.isArray(message.AskHelpLevels))
                    return "AskHelpLevels: array expected";
                for (var i = 0; i < message.AskHelpLevels.length; ++i)
                    if (!$util.isInteger(message.AskHelpLevels[i]))
                        return "AskHelpLevels: integer[] expected";
            }
            return null;
        };

        return LevelInfo;
    })();

    pb.LevelHelpRecordItem = (function() {

        /**
         * Properties of a LevelHelpRecordItem.
         * @memberof pb
         * @interface ILevelHelpRecordItem
         * @property {string|null} [HelperHeadImgUrl] LevelHelpRecordItem HelperHeadImgUrl
         * @property {string|null} [HelperName] LevelHelpRecordItem HelperName
         * @property {number|null} [HelpCnt] LevelHelpRecordItem HelpCnt
         * @property {boolean|null} [IsWin] LevelHelpRecordItem IsWin
         * @property {number|Long|null} [VideoID] LevelHelpRecordItem VideoID
         * @property {string|null} [HelperHeadFrame] LevelHelpRecordItem HelperHeadFrame
         */

        /**
         * Constructs a new LevelHelpRecordItem.
         * @memberof pb
         * @classdesc Represents a LevelHelpRecordItem.
         * @implements ILevelHelpRecordItem
         * @constructor
         * @param {pb.ILevelHelpRecordItem=} [properties] Properties to set
         */
        function LevelHelpRecordItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelHelpRecordItem HelperHeadImgUrl.
         * @member {string} HelperHeadImgUrl
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.HelperHeadImgUrl = "";

        /**
         * LevelHelpRecordItem HelperName.
         * @member {string} HelperName
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.HelperName = "";

        /**
         * LevelHelpRecordItem HelpCnt.
         * @member {number} HelpCnt
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.HelpCnt = 0;

        /**
         * LevelHelpRecordItem IsWin.
         * @member {boolean} IsWin
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.IsWin = false;

        /**
         * LevelHelpRecordItem VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LevelHelpRecordItem HelperHeadFrame.
         * @member {string} HelperHeadFrame
         * @memberof pb.LevelHelpRecordItem
         * @instance
         */
        LevelHelpRecordItem.prototype.HelperHeadFrame = "";

        /**
         * Creates a new LevelHelpRecordItem instance using the specified properties.
         * @function create
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {pb.ILevelHelpRecordItem=} [properties] Properties to set
         * @returns {pb.LevelHelpRecordItem} LevelHelpRecordItem instance
         */
        LevelHelpRecordItem.create = function create(properties) {
            return new LevelHelpRecordItem(properties);
        };

        /**
         * Encodes the specified LevelHelpRecordItem message. Does not implicitly {@link pb.LevelHelpRecordItem.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {pb.ILevelHelpRecordItem} message LevelHelpRecordItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpRecordItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HelperHeadImgUrl != null && message.hasOwnProperty("HelperHeadImgUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HelperHeadImgUrl);
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.HelperName);
            if (message.HelpCnt != null && message.hasOwnProperty("HelpCnt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.HelpCnt);
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsWin);
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.VideoID);
            if (message.HelperHeadFrame != null && message.hasOwnProperty("HelperHeadFrame"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.HelperHeadFrame);
            return writer;
        };

        /**
         * Encodes the specified LevelHelpRecordItem message, length delimited. Does not implicitly {@link pb.LevelHelpRecordItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {pb.ILevelHelpRecordItem} message LevelHelpRecordItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpRecordItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelHelpRecordItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelHelpRecordItem} LevelHelpRecordItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpRecordItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelHelpRecordItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HelperHeadImgUrl = reader.string();
                    break;
                case 2:
                    message.HelperName = reader.string();
                    break;
                case 3:
                    message.HelpCnt = reader.int32();
                    break;
                case 4:
                    message.IsWin = reader.bool();
                    break;
                case 5:
                    message.VideoID = reader.uint64();
                    break;
                case 6:
                    message.HelperHeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelHelpRecordItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelHelpRecordItem} LevelHelpRecordItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpRecordItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelHelpRecordItem message.
         * @function verify
         * @memberof pb.LevelHelpRecordItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelHelpRecordItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HelperHeadImgUrl != null && message.hasOwnProperty("HelperHeadImgUrl"))
                if (!$util.isString(message.HelperHeadImgUrl))
                    return "HelperHeadImgUrl: string expected";
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                if (!$util.isString(message.HelperName))
                    return "HelperName: string expected";
            if (message.HelpCnt != null && message.hasOwnProperty("HelpCnt"))
                if (!$util.isInteger(message.HelpCnt))
                    return "HelpCnt: integer expected";
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                if (typeof message.IsWin !== "boolean")
                    return "IsWin: boolean expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.HelperHeadFrame != null && message.hasOwnProperty("HelperHeadFrame"))
                if (!$util.isString(message.HelperHeadFrame))
                    return "HelperHeadFrame: string expected";
            return null;
        };

        return LevelHelpRecordItem;
    })();

    pb.LevelHelpRecord = (function() {

        /**
         * Properties of a LevelHelpRecord.
         * @memberof pb
         * @interface ILevelHelpRecord
         * @property {Array.<pb.ILevelHelpRecordItem>|null} [Records] LevelHelpRecord Records
         */

        /**
         * Constructs a new LevelHelpRecord.
         * @memberof pb
         * @classdesc Represents a LevelHelpRecord.
         * @implements ILevelHelpRecord
         * @constructor
         * @param {pb.ILevelHelpRecord=} [properties] Properties to set
         */
        function LevelHelpRecord(properties) {
            this.Records = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelHelpRecord Records.
         * @member {Array.<pb.ILevelHelpRecordItem>} Records
         * @memberof pb.LevelHelpRecord
         * @instance
         */
        LevelHelpRecord.prototype.Records = $util.emptyArray;

        /**
         * Creates a new LevelHelpRecord instance using the specified properties.
         * @function create
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {pb.ILevelHelpRecord=} [properties] Properties to set
         * @returns {pb.LevelHelpRecord} LevelHelpRecord instance
         */
        LevelHelpRecord.create = function create(properties) {
            return new LevelHelpRecord(properties);
        };

        /**
         * Encodes the specified LevelHelpRecord message. Does not implicitly {@link pb.LevelHelpRecord.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {pb.ILevelHelpRecord} message LevelHelpRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Records != null && message.Records.length)
                for (var i = 0; i < message.Records.length; ++i)
                    $root.pb.LevelHelpRecordItem.encode(message.Records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LevelHelpRecord message, length delimited. Does not implicitly {@link pb.LevelHelpRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {pb.ILevelHelpRecord} message LevelHelpRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelHelpRecord message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelHelpRecord} LevelHelpRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelHelpRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Records && message.Records.length))
                        message.Records = [];
                    message.Records.push($root.pb.LevelHelpRecordItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelHelpRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelHelpRecord} LevelHelpRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelHelpRecord message.
         * @function verify
         * @memberof pb.LevelHelpRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelHelpRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Records != null && message.hasOwnProperty("Records")) {
                if (!Array.isArray(message.Records))
                    return "Records: array expected";
                for (var i = 0; i < message.Records.length; ++i) {
                    var error = $root.pb.LevelHelpRecordItem.verify(message.Records[i]);
                    if (error)
                        return "Records." + error;
                }
            }
            return null;
        };

        return LevelHelpRecord;
    })();

    pb.OpenLevelTreasureArg = (function() {

        /**
         * Properties of an OpenLevelTreasureArg.
         * @memberof pb
         * @interface IOpenLevelTreasureArg
         * @property {number|null} [ChapterID] OpenLevelTreasureArg ChapterID
         */

        /**
         * Constructs a new OpenLevelTreasureArg.
         * @memberof pb
         * @classdesc Represents an OpenLevelTreasureArg.
         * @implements IOpenLevelTreasureArg
         * @constructor
         * @param {pb.IOpenLevelTreasureArg=} [properties] Properties to set
         */
        function OpenLevelTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenLevelTreasureArg ChapterID.
         * @member {number} ChapterID
         * @memberof pb.OpenLevelTreasureArg
         * @instance
         */
        OpenLevelTreasureArg.prototype.ChapterID = 0;

        /**
         * Creates a new OpenLevelTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {pb.IOpenLevelTreasureArg=} [properties] Properties to set
         * @returns {pb.OpenLevelTreasureArg} OpenLevelTreasureArg instance
         */
        OpenLevelTreasureArg.create = function create(properties) {
            return new OpenLevelTreasureArg(properties);
        };

        /**
         * Encodes the specified OpenLevelTreasureArg message. Does not implicitly {@link pb.OpenLevelTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {pb.IOpenLevelTreasureArg} message OpenLevelTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenLevelTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChapterID != null && message.hasOwnProperty("ChapterID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ChapterID);
            return writer;
        };

        /**
         * Encodes the specified OpenLevelTreasureArg message, length delimited. Does not implicitly {@link pb.OpenLevelTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {pb.IOpenLevelTreasureArg} message OpenLevelTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenLevelTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenLevelTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OpenLevelTreasureArg} OpenLevelTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenLevelTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OpenLevelTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ChapterID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenLevelTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OpenLevelTreasureArg} OpenLevelTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenLevelTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenLevelTreasureArg message.
         * @function verify
         * @memberof pb.OpenLevelTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenLevelTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChapterID != null && message.hasOwnProperty("ChapterID"))
                if (!$util.isInteger(message.ChapterID))
                    return "ChapterID: integer expected";
            return null;
        };

        return OpenLevelTreasureArg;
    })();

    pb.BeginLevelBattle = (function() {

        /**
         * Properties of a BeginLevelBattle.
         * @memberof pb
         * @interface IBeginLevelBattle
         * @property {number|null} [LevelId] BeginLevelBattle LevelId
         */

        /**
         * Constructs a new BeginLevelBattle.
         * @memberof pb
         * @classdesc Represents a BeginLevelBattle.
         * @implements IBeginLevelBattle
         * @constructor
         * @param {pb.IBeginLevelBattle=} [properties] Properties to set
         */
        function BeginLevelBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginLevelBattle LevelId.
         * @member {number} LevelId
         * @memberof pb.BeginLevelBattle
         * @instance
         */
        BeginLevelBattle.prototype.LevelId = 0;

        /**
         * Creates a new BeginLevelBattle instance using the specified properties.
         * @function create
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {pb.IBeginLevelBattle=} [properties] Properties to set
         * @returns {pb.BeginLevelBattle} BeginLevelBattle instance
         */
        BeginLevelBattle.create = function create(properties) {
            return new BeginLevelBattle(properties);
        };

        /**
         * Encodes the specified BeginLevelBattle message. Does not implicitly {@link pb.BeginLevelBattle.verify|verify} messages.
         * @function encode
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {pb.IBeginLevelBattle} message BeginLevelBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLevelBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LevelId != null && message.hasOwnProperty("LevelId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LevelId);
            return writer;
        };

        /**
         * Encodes the specified BeginLevelBattle message, length delimited. Does not implicitly {@link pb.BeginLevelBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {pb.IBeginLevelBattle} message BeginLevelBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginLevelBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginLevelBattle message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeginLevelBattle} BeginLevelBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLevelBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeginLevelBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LevelId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginLevelBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeginLevelBattle} BeginLevelBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginLevelBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginLevelBattle message.
         * @function verify
         * @memberof pb.BeginLevelBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginLevelBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LevelId != null && message.hasOwnProperty("LevelId"))
                if (!$util.isInteger(message.LevelId))
                    return "LevelId: integer expected";
            return null;
        };

        return BeginLevelBattle;
    })();

    pb.LevelFightResult = (function() {

        /**
         * Properties of a LevelFightResult.
         * @memberof pb
         * @interface ILevelFightResult
         * @property {boolean|null} [IsWin] LevelFightResult IsWin
         * @property {number|null} [UnlockLevel] LevelFightResult UnlockLevel
         * @property {Array.<pb.IChangeCardInfo>|null} [ChangeCards] LevelFightResult ChangeCards
         * @property {number|null} [Gold] LevelFightResult Gold
         */

        /**
         * Constructs a new LevelFightResult.
         * @memberof pb
         * @classdesc Represents a LevelFightResult.
         * @implements ILevelFightResult
         * @constructor
         * @param {pb.ILevelFightResult=} [properties] Properties to set
         */
        function LevelFightResult(properties) {
            this.ChangeCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelFightResult IsWin.
         * @member {boolean} IsWin
         * @memberof pb.LevelFightResult
         * @instance
         */
        LevelFightResult.prototype.IsWin = false;

        /**
         * LevelFightResult UnlockLevel.
         * @member {number} UnlockLevel
         * @memberof pb.LevelFightResult
         * @instance
         */
        LevelFightResult.prototype.UnlockLevel = 0;

        /**
         * LevelFightResult ChangeCards.
         * @member {Array.<pb.IChangeCardInfo>} ChangeCards
         * @memberof pb.LevelFightResult
         * @instance
         */
        LevelFightResult.prototype.ChangeCards = $util.emptyArray;

        /**
         * LevelFightResult Gold.
         * @member {number} Gold
         * @memberof pb.LevelFightResult
         * @instance
         */
        LevelFightResult.prototype.Gold = 0;

        /**
         * Creates a new LevelFightResult instance using the specified properties.
         * @function create
         * @memberof pb.LevelFightResult
         * @static
         * @param {pb.ILevelFightResult=} [properties] Properties to set
         * @returns {pb.LevelFightResult} LevelFightResult instance
         */
        LevelFightResult.create = function create(properties) {
            return new LevelFightResult(properties);
        };

        /**
         * Encodes the specified LevelFightResult message. Does not implicitly {@link pb.LevelFightResult.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelFightResult
         * @static
         * @param {pb.ILevelFightResult} message LevelFightResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelFightResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsWin);
            if (message.UnlockLevel != null && message.hasOwnProperty("UnlockLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.UnlockLevel);
            if (message.ChangeCards != null && message.ChangeCards.length)
                for (var i = 0; i < message.ChangeCards.length; ++i)
                    $root.pb.ChangeCardInfo.encode(message.ChangeCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Gold);
            return writer;
        };

        /**
         * Encodes the specified LevelFightResult message, length delimited. Does not implicitly {@link pb.LevelFightResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelFightResult
         * @static
         * @param {pb.ILevelFightResult} message LevelFightResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelFightResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelFightResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelFightResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelFightResult} LevelFightResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelFightResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelFightResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsWin = reader.bool();
                    break;
                case 2:
                    message.UnlockLevel = reader.int32();
                    break;
                case 3:
                    if (!(message.ChangeCards && message.ChangeCards.length))
                        message.ChangeCards = [];
                    message.ChangeCards.push($root.pb.ChangeCardInfo.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.Gold = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelFightResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelFightResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelFightResult} LevelFightResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelFightResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelFightResult message.
         * @function verify
         * @memberof pb.LevelFightResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelFightResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsWin != null && message.hasOwnProperty("IsWin"))
                if (typeof message.IsWin !== "boolean")
                    return "IsWin: boolean expected";
            if (message.UnlockLevel != null && message.hasOwnProperty("UnlockLevel"))
                if (!$util.isInteger(message.UnlockLevel))
                    return "UnlockLevel: integer expected";
            if (message.ChangeCards != null && message.hasOwnProperty("ChangeCards")) {
                if (!Array.isArray(message.ChangeCards))
                    return "ChangeCards: array expected";
                for (var i = 0; i < message.ChangeCards.length; ++i) {
                    var error = $root.pb.ChangeCardInfo.verify(message.ChangeCards[i]);
                    if (error)
                        return "ChangeCards." + error;
                }
            }
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            return null;
        };

        return LevelFightResult;
    })();

    pb.LevelChooseCard = (function() {

        /**
         * Properties of a LevelChooseCard.
         * @memberof pb
         * @interface ILevelChooseCard
         * @property {Array.<number>|null} [Cards] LevelChooseCard Cards
         */

        /**
         * Constructs a new LevelChooseCard.
         * @memberof pb
         * @classdesc Represents a LevelChooseCard.
         * @implements ILevelChooseCard
         * @constructor
         * @param {pb.ILevelChooseCard=} [properties] Properties to set
         */
        function LevelChooseCard(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelChooseCard Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.LevelChooseCard
         * @instance
         */
        LevelChooseCard.prototype.Cards = $util.emptyArray;

        /**
         * Creates a new LevelChooseCard instance using the specified properties.
         * @function create
         * @memberof pb.LevelChooseCard
         * @static
         * @param {pb.ILevelChooseCard=} [properties] Properties to set
         * @returns {pb.LevelChooseCard} LevelChooseCard instance
         */
        LevelChooseCard.create = function create(properties) {
            return new LevelChooseCard(properties);
        };

        /**
         * Encodes the specified LevelChooseCard message. Does not implicitly {@link pb.LevelChooseCard.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelChooseCard
         * @static
         * @param {pb.ILevelChooseCard} message LevelChooseCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelChooseCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LevelChooseCard message, length delimited. Does not implicitly {@link pb.LevelChooseCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelChooseCard
         * @static
         * @param {pb.ILevelChooseCard} message LevelChooseCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelChooseCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelChooseCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelChooseCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelChooseCard} LevelChooseCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelChooseCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelChooseCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelChooseCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelChooseCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelChooseCard} LevelChooseCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelChooseCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelChooseCard message.
         * @function verify
         * @memberof pb.LevelChooseCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelChooseCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            return null;
        };

        return LevelChooseCard;
    })();

    pb.LevelBattle = (function() {

        /**
         * Properties of a LevelBattle.
         * @memberof pb
         * @interface ILevelBattle
         * @property {pb.IFightDesk|null} [Desk] LevelBattle Desk
         * @property {Array.<pb.ICard>|null} [ChoiceCards] LevelBattle ChoiceCards
         * @property {number|null} [NeedChooseNum] LevelBattle NeedChooseNum
         * @property {number|null} [LevelID] LevelBattle LevelID
         */

        /**
         * Constructs a new LevelBattle.
         * @memberof pb
         * @classdesc Represents a LevelBattle.
         * @implements ILevelBattle
         * @constructor
         * @param {pb.ILevelBattle=} [properties] Properties to set
         */
        function LevelBattle(properties) {
            this.ChoiceCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelBattle Desk.
         * @member {pb.IFightDesk|null|undefined} Desk
         * @memberof pb.LevelBattle
         * @instance
         */
        LevelBattle.prototype.Desk = null;

        /**
         * LevelBattle ChoiceCards.
         * @member {Array.<pb.ICard>} ChoiceCards
         * @memberof pb.LevelBattle
         * @instance
         */
        LevelBattle.prototype.ChoiceCards = $util.emptyArray;

        /**
         * LevelBattle NeedChooseNum.
         * @member {number} NeedChooseNum
         * @memberof pb.LevelBattle
         * @instance
         */
        LevelBattle.prototype.NeedChooseNum = 0;

        /**
         * LevelBattle LevelID.
         * @member {number} LevelID
         * @memberof pb.LevelBattle
         * @instance
         */
        LevelBattle.prototype.LevelID = 0;

        /**
         * Creates a new LevelBattle instance using the specified properties.
         * @function create
         * @memberof pb.LevelBattle
         * @static
         * @param {pb.ILevelBattle=} [properties] Properties to set
         * @returns {pb.LevelBattle} LevelBattle instance
         */
        LevelBattle.create = function create(properties) {
            return new LevelBattle(properties);
        };

        /**
         * Encodes the specified LevelBattle message. Does not implicitly {@link pb.LevelBattle.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelBattle
         * @static
         * @param {pb.ILevelBattle} message LevelBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Desk != null && message.hasOwnProperty("Desk"))
                $root.pb.FightDesk.encode(message.Desk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ChoiceCards != null && message.ChoiceCards.length)
                for (var i = 0; i < message.ChoiceCards.length; ++i)
                    $root.pb.Card.encode(message.ChoiceCards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.NeedChooseNum != null && message.hasOwnProperty("NeedChooseNum"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.NeedChooseNum);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified LevelBattle message, length delimited. Does not implicitly {@link pb.LevelBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelBattle
         * @static
         * @param {pb.ILevelBattle} message LevelBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelBattle message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelBattle} LevelBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Desk = $root.pb.FightDesk.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.ChoiceCards && message.ChoiceCards.length))
                        message.ChoiceCards = [];
                    message.ChoiceCards.push($root.pb.Card.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.NeedChooseNum = reader.int32();
                    break;
                case 4:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelBattle} LevelBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelBattle message.
         * @function verify
         * @memberof pb.LevelBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Desk != null && message.hasOwnProperty("Desk")) {
                var error = $root.pb.FightDesk.verify(message.Desk);
                if (error)
                    return "Desk." + error;
            }
            if (message.ChoiceCards != null && message.hasOwnProperty("ChoiceCards")) {
                if (!Array.isArray(message.ChoiceCards))
                    return "ChoiceCards: array expected";
                for (var i = 0; i < message.ChoiceCards.length; ++i) {
                    var error = $root.pb.Card.verify(message.ChoiceCards[i]);
                    if (error)
                        return "ChoiceCards." + error;
                }
            }
            if (message.NeedChooseNum != null && message.hasOwnProperty("NeedChooseNum"))
                if (!$util.isInteger(message.NeedChooseNum))
                    return "NeedChooseNum: integer expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return LevelBattle;
    })();

    pb.ChapterUnlock = (function() {

        /**
         * Properties of a ChapterUnlock.
         * @memberof pb
         * @interface IChapterUnlock
         * @property {number|null} [Chapter] ChapterUnlock Chapter
         */

        /**
         * Constructs a new ChapterUnlock.
         * @memberof pb
         * @classdesc Represents a ChapterUnlock.
         * @implements IChapterUnlock
         * @constructor
         * @param {pb.IChapterUnlock=} [properties] Properties to set
         */
        function ChapterUnlock(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChapterUnlock Chapter.
         * @member {number} Chapter
         * @memberof pb.ChapterUnlock
         * @instance
         */
        ChapterUnlock.prototype.Chapter = 0;

        /**
         * Creates a new ChapterUnlock instance using the specified properties.
         * @function create
         * @memberof pb.ChapterUnlock
         * @static
         * @param {pb.IChapterUnlock=} [properties] Properties to set
         * @returns {pb.ChapterUnlock} ChapterUnlock instance
         */
        ChapterUnlock.create = function create(properties) {
            return new ChapterUnlock(properties);
        };

        /**
         * Encodes the specified ChapterUnlock message. Does not implicitly {@link pb.ChapterUnlock.verify|verify} messages.
         * @function encode
         * @memberof pb.ChapterUnlock
         * @static
         * @param {pb.IChapterUnlock} message ChapterUnlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChapterUnlock.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Chapter != null && message.hasOwnProperty("Chapter"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Chapter);
            return writer;
        };

        /**
         * Encodes the specified ChapterUnlock message, length delimited. Does not implicitly {@link pb.ChapterUnlock.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChapterUnlock
         * @static
         * @param {pb.IChapterUnlock} message ChapterUnlock message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChapterUnlock.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChapterUnlock message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChapterUnlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChapterUnlock} ChapterUnlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChapterUnlock.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChapterUnlock();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Chapter = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChapterUnlock message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChapterUnlock
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChapterUnlock} ChapterUnlock
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChapterUnlock.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChapterUnlock message.
         * @function verify
         * @memberof pb.ChapterUnlock
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChapterUnlock.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Chapter != null && message.hasOwnProperty("Chapter"))
                if (!$util.isInteger(message.Chapter))
                    return "Chapter: integer expected";
            return null;
        };

        return ChapterUnlock;
    })();

    pb.LevelHelpArg = (function() {

        /**
         * Properties of a LevelHelpArg.
         * @memberof pb
         * @interface ILevelHelpArg
         * @property {number|Long|null} [HelpUid] LevelHelpArg HelpUid
         * @property {number|null} [LevelID] LevelHelpArg LevelID
         */

        /**
         * Constructs a new LevelHelpArg.
         * @memberof pb
         * @classdesc Represents a LevelHelpArg.
         * @implements ILevelHelpArg
         * @constructor
         * @param {pb.ILevelHelpArg=} [properties] Properties to set
         */
        function LevelHelpArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelHelpArg HelpUid.
         * @member {number|Long} HelpUid
         * @memberof pb.LevelHelpArg
         * @instance
         */
        LevelHelpArg.prototype.HelpUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LevelHelpArg LevelID.
         * @member {number} LevelID
         * @memberof pb.LevelHelpArg
         * @instance
         */
        LevelHelpArg.prototype.LevelID = 0;

        /**
         * Creates a new LevelHelpArg instance using the specified properties.
         * @function create
         * @memberof pb.LevelHelpArg
         * @static
         * @param {pb.ILevelHelpArg=} [properties] Properties to set
         * @returns {pb.LevelHelpArg} LevelHelpArg instance
         */
        LevelHelpArg.create = function create(properties) {
            return new LevelHelpArg(properties);
        };

        /**
         * Encodes the specified LevelHelpArg message. Does not implicitly {@link pb.LevelHelpArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelHelpArg
         * @static
         * @param {pb.ILevelHelpArg} message LevelHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HelpUid != null && message.hasOwnProperty("HelpUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.HelpUid);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified LevelHelpArg message, length delimited. Does not implicitly {@link pb.LevelHelpArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelHelpArg
         * @static
         * @param {pb.ILevelHelpArg} message LevelHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelHelpArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelHelpArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelHelpArg} LevelHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelHelpArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HelpUid = reader.uint64();
                    break;
                case 2:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelHelpArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelHelpArg} LevelHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelHelpArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelHelpArg message.
         * @function verify
         * @memberof pb.LevelHelpArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelHelpArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HelpUid != null && message.hasOwnProperty("HelpUid"))
                if (!$util.isInteger(message.HelpUid) && !(message.HelpUid && $util.isInteger(message.HelpUid.low) && $util.isInteger(message.HelpUid.high)))
                    return "HelpUid: integer|Long expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return LevelHelpArg;
    })();

    pb.LevelBeHelpArg = (function() {

        /**
         * Properties of a LevelBeHelpArg.
         * @memberof pb
         * @interface ILevelBeHelpArg
         * @property {string|null} [HelperName] LevelBeHelpArg HelperName
         * @property {number|null} [LevelID] LevelBeHelpArg LevelID
         */

        /**
         * Constructs a new LevelBeHelpArg.
         * @memberof pb
         * @classdesc Represents a LevelBeHelpArg.
         * @implements ILevelBeHelpArg
         * @constructor
         * @param {pb.ILevelBeHelpArg=} [properties] Properties to set
         */
        function LevelBeHelpArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LevelBeHelpArg HelperName.
         * @member {string} HelperName
         * @memberof pb.LevelBeHelpArg
         * @instance
         */
        LevelBeHelpArg.prototype.HelperName = "";

        /**
         * LevelBeHelpArg LevelID.
         * @member {number} LevelID
         * @memberof pb.LevelBeHelpArg
         * @instance
         */
        LevelBeHelpArg.prototype.LevelID = 0;

        /**
         * Creates a new LevelBeHelpArg instance using the specified properties.
         * @function create
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {pb.ILevelBeHelpArg=} [properties] Properties to set
         * @returns {pb.LevelBeHelpArg} LevelBeHelpArg instance
         */
        LevelBeHelpArg.create = function create(properties) {
            return new LevelBeHelpArg(properties);
        };

        /**
         * Encodes the specified LevelBeHelpArg message. Does not implicitly {@link pb.LevelBeHelpArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {pb.ILevelBeHelpArg} message LevelBeHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelBeHelpArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HelperName);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified LevelBeHelpArg message, length delimited. Does not implicitly {@link pb.LevelBeHelpArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {pb.ILevelBeHelpArg} message LevelBeHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LevelBeHelpArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LevelBeHelpArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LevelBeHelpArg} LevelBeHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelBeHelpArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LevelBeHelpArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HelperName = reader.string();
                    break;
                case 2:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LevelBeHelpArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LevelBeHelpArg} LevelBeHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LevelBeHelpArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LevelBeHelpArg message.
         * @function verify
         * @memberof pb.LevelBeHelpArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LevelBeHelpArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                if (!$util.isString(message.HelperName))
                    return "HelperName: string expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return LevelBeHelpArg;
    })();

    pb.TargetLevel = (function() {

        /**
         * Properties of a TargetLevel.
         * @memberof pb
         * @interface ITargetLevel
         * @property {number|null} [LevelID] TargetLevel LevelID
         */

        /**
         * Constructs a new TargetLevel.
         * @memberof pb
         * @classdesc Represents a TargetLevel.
         * @implements ITargetLevel
         * @constructor
         * @param {pb.ITargetLevel=} [properties] Properties to set
         */
        function TargetLevel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetLevel LevelID.
         * @member {number} LevelID
         * @memberof pb.TargetLevel
         * @instance
         */
        TargetLevel.prototype.LevelID = 0;

        /**
         * Creates a new TargetLevel instance using the specified properties.
         * @function create
         * @memberof pb.TargetLevel
         * @static
         * @param {pb.ITargetLevel=} [properties] Properties to set
         * @returns {pb.TargetLevel} TargetLevel instance
         */
        TargetLevel.create = function create(properties) {
            return new TargetLevel(properties);
        };

        /**
         * Encodes the specified TargetLevel message. Does not implicitly {@link pb.TargetLevel.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetLevel
         * @static
         * @param {pb.ITargetLevel} message TargetLevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetLevel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified TargetLevel message, length delimited. Does not implicitly {@link pb.TargetLevel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetLevel
         * @static
         * @param {pb.ITargetLevel} message TargetLevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetLevel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetLevel message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetLevel} TargetLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetLevel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetLevel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetLevel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetLevel} TargetLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetLevel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetLevel message.
         * @function verify
         * @memberof pb.TargetLevel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetLevel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return TargetLevel;
    })();

    pb.WatchHelpVideoArg = (function() {

        /**
         * Properties of a WatchHelpVideoArg.
         * @memberof pb
         * @interface IWatchHelpVideoArg
         * @property {number|Long|null} [VideoID] WatchHelpVideoArg VideoID
         */

        /**
         * Constructs a new WatchHelpVideoArg.
         * @memberof pb
         * @classdesc Represents a WatchHelpVideoArg.
         * @implements IWatchHelpVideoArg
         * @constructor
         * @param {pb.IWatchHelpVideoArg=} [properties] Properties to set
         */
        function WatchHelpVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchHelpVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.WatchHelpVideoArg
         * @instance
         */
        WatchHelpVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new WatchHelpVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {pb.IWatchHelpVideoArg=} [properties] Properties to set
         * @returns {pb.WatchHelpVideoArg} WatchHelpVideoArg instance
         */
        WatchHelpVideoArg.create = function create(properties) {
            return new WatchHelpVideoArg(properties);
        };

        /**
         * Encodes the specified WatchHelpVideoArg message. Does not implicitly {@link pb.WatchHelpVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {pb.IWatchHelpVideoArg} message WatchHelpVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchHelpVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            return writer;
        };

        /**
         * Encodes the specified WatchHelpVideoArg message, length delimited. Does not implicitly {@link pb.WatchHelpVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {pb.IWatchHelpVideoArg} message WatchHelpVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchHelpVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchHelpVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchHelpVideoArg} WatchHelpVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchHelpVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchHelpVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchHelpVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchHelpVideoArg} WatchHelpVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchHelpVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchHelpVideoArg message.
         * @function verify
         * @memberof pb.WatchHelpVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchHelpVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            return null;
        };

        return WatchHelpVideoArg;
    })();

    pb.FetchLevelVideoIDArg = (function() {

        /**
         * Properties of a FetchLevelVideoIDArg.
         * @memberof pb
         * @interface IFetchLevelVideoIDArg
         * @property {number|null} [LevelID] FetchLevelVideoIDArg LevelID
         */

        /**
         * Constructs a new FetchLevelVideoIDArg.
         * @memberof pb
         * @classdesc Represents a FetchLevelVideoIDArg.
         * @implements IFetchLevelVideoIDArg
         * @constructor
         * @param {pb.IFetchLevelVideoIDArg=} [properties] Properties to set
         */
        function FetchLevelVideoIDArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchLevelVideoIDArg LevelID.
         * @member {number} LevelID
         * @memberof pb.FetchLevelVideoIDArg
         * @instance
         */
        FetchLevelVideoIDArg.prototype.LevelID = 0;

        /**
         * Creates a new FetchLevelVideoIDArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {pb.IFetchLevelVideoIDArg=} [properties] Properties to set
         * @returns {pb.FetchLevelVideoIDArg} FetchLevelVideoIDArg instance
         */
        FetchLevelVideoIDArg.create = function create(properties) {
            return new FetchLevelVideoIDArg(properties);
        };

        /**
         * Encodes the specified FetchLevelVideoIDArg message. Does not implicitly {@link pb.FetchLevelVideoIDArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {pb.IFetchLevelVideoIDArg} message FetchLevelVideoIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchLevelVideoIDArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.LevelID);
            return writer;
        };

        /**
         * Encodes the specified FetchLevelVideoIDArg message, length delimited. Does not implicitly {@link pb.FetchLevelVideoIDArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {pb.IFetchLevelVideoIDArg} message FetchLevelVideoIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchLevelVideoIDArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchLevelVideoIDArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchLevelVideoIDArg} FetchLevelVideoIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchLevelVideoIDArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchLevelVideoIDArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LevelID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchLevelVideoIDArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchLevelVideoIDArg} FetchLevelVideoIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchLevelVideoIDArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchLevelVideoIDArg message.
         * @function verify
         * @memberof pb.FetchLevelVideoIDArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchLevelVideoIDArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            return null;
        };

        return FetchLevelVideoIDArg;
    })();

    pb.FetchLevelVideoIDRely = (function() {

        /**
         * Properties of a FetchLevelVideoIDRely.
         * @memberof pb
         * @interface IFetchLevelVideoIDRely
         * @property {number|Long|null} [VideoID] FetchLevelVideoIDRely VideoID
         */

        /**
         * Constructs a new FetchLevelVideoIDRely.
         * @memberof pb
         * @classdesc Represents a FetchLevelVideoIDRely.
         * @implements IFetchLevelVideoIDRely
         * @constructor
         * @param {pb.IFetchLevelVideoIDRely=} [properties] Properties to set
         */
        function FetchLevelVideoIDRely(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchLevelVideoIDRely VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.FetchLevelVideoIDRely
         * @instance
         */
        FetchLevelVideoIDRely.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FetchLevelVideoIDRely instance using the specified properties.
         * @function create
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {pb.IFetchLevelVideoIDRely=} [properties] Properties to set
         * @returns {pb.FetchLevelVideoIDRely} FetchLevelVideoIDRely instance
         */
        FetchLevelVideoIDRely.create = function create(properties) {
            return new FetchLevelVideoIDRely(properties);
        };

        /**
         * Encodes the specified FetchLevelVideoIDRely message. Does not implicitly {@link pb.FetchLevelVideoIDRely.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {pb.IFetchLevelVideoIDRely} message FetchLevelVideoIDRely message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchLevelVideoIDRely.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            return writer;
        };

        /**
         * Encodes the specified FetchLevelVideoIDRely message, length delimited. Does not implicitly {@link pb.FetchLevelVideoIDRely.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {pb.IFetchLevelVideoIDRely} message FetchLevelVideoIDRely message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchLevelVideoIDRely.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchLevelVideoIDRely message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchLevelVideoIDRely} FetchLevelVideoIDRely
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchLevelVideoIDRely.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchLevelVideoIDRely();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchLevelVideoIDRely message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchLevelVideoIDRely} FetchLevelVideoIDRely
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchLevelVideoIDRely.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchLevelVideoIDRely message.
         * @function verify
         * @memberof pb.FetchLevelVideoIDRely
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchLevelVideoIDRely.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            return null;
        };

        return FetchLevelVideoIDRely;
    })();

    pb.FetchMailListArg = (function() {

        /**
         * Properties of a FetchMailListArg.
         * @memberof pb
         * @interface IFetchMailListArg
         * @property {number|null} [MinMailID] FetchMailListArg MinMailID
         */

        /**
         * Constructs a new FetchMailListArg.
         * @memberof pb
         * @classdesc Represents a FetchMailListArg.
         * @implements IFetchMailListArg
         * @constructor
         * @param {pb.IFetchMailListArg=} [properties] Properties to set
         */
        function FetchMailListArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchMailListArg MinMailID.
         * @member {number} MinMailID
         * @memberof pb.FetchMailListArg
         * @instance
         */
        FetchMailListArg.prototype.MinMailID = 0;

        /**
         * Creates a new FetchMailListArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchMailListArg
         * @static
         * @param {pb.IFetchMailListArg=} [properties] Properties to set
         * @returns {pb.FetchMailListArg} FetchMailListArg instance
         */
        FetchMailListArg.create = function create(properties) {
            return new FetchMailListArg(properties);
        };

        /**
         * Encodes the specified FetchMailListArg message. Does not implicitly {@link pb.FetchMailListArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchMailListArg
         * @static
         * @param {pb.IFetchMailListArg} message FetchMailListArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchMailListArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MinMailID != null && message.hasOwnProperty("MinMailID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MinMailID);
            return writer;
        };

        /**
         * Encodes the specified FetchMailListArg message, length delimited. Does not implicitly {@link pb.FetchMailListArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchMailListArg
         * @static
         * @param {pb.IFetchMailListArg} message FetchMailListArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchMailListArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchMailListArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchMailListArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchMailListArg} FetchMailListArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchMailListArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchMailListArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MinMailID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchMailListArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchMailListArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchMailListArg} FetchMailListArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchMailListArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchMailListArg message.
         * @function verify
         * @memberof pb.FetchMailListArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchMailListArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MinMailID != null && message.hasOwnProperty("MinMailID"))
                if (!$util.isInteger(message.MinMailID))
                    return "MinMailID: integer expected";
            return null;
        };

        return FetchMailListArg;
    })();

    /**
     * MailRewardType enum.
     * @name pb.MailRewardType
     * @enum {string}
     * @property {number} MrtGold=0 MrtGold value
     * @property {number} MrtJade=1 MrtJade value
     * @property {number} MrtCard=2 MrtCard value
     * @property {number} MrtTreasure=3 MrtTreasure value
     * @property {number} MrtCardSkin=4 MrtCardSkin value
     * @property {number} MrtHeadFrame=5 MrtHeadFrame value
     * @property {number} MrtFeats=6 MrtFeats value
     * @property {number} MrtPrestige=7 MrtPrestige value
     * @property {number} MrtEquip=8 MrtEquip value
     * @property {number} MrtEmoji=9 MrtEmoji value
     * @property {number} MrtContribution=10 MrtContribution value
     * @property {number} MrtBowlder=11 MrtBowlder value
     */
    pb.MailRewardType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "MrtGold"] = 0;
        values[valuesById[1] = "MrtJade"] = 1;
        values[valuesById[2] = "MrtCard"] = 2;
        values[valuesById[3] = "MrtTreasure"] = 3;
        values[valuesById[4] = "MrtCardSkin"] = 4;
        values[valuesById[5] = "MrtHeadFrame"] = 5;
        values[valuesById[6] = "MrtFeats"] = 6;
        values[valuesById[7] = "MrtPrestige"] = 7;
        values[valuesById[8] = "MrtEquip"] = 8;
        values[valuesById[9] = "MrtEmoji"] = 9;
        values[valuesById[10] = "MrtContribution"] = 10;
        values[valuesById[11] = "MrtBowlder"] = 11;
        return values;
    })();

    pb.MailReward = (function() {

        /**
         * Properties of a MailReward.
         * @memberof pb
         * @interface IMailReward
         * @property {pb.MailRewardType|null} [Type] MailReward Type
         * @property {number|null} [Amount] MailReward Amount
         * @property {number|null} [CardID] MailReward CardID
         * @property {string|null} [ItemID] MailReward ItemID
         * @property {number|null} [EmojiTeam] MailReward EmojiTeam
         */

        /**
         * Constructs a new MailReward.
         * @memberof pb
         * @classdesc Represents a MailReward.
         * @implements IMailReward
         * @constructor
         * @param {pb.IMailReward=} [properties] Properties to set
         */
        function MailReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailReward Type.
         * @member {pb.MailRewardType} Type
         * @memberof pb.MailReward
         * @instance
         */
        MailReward.prototype.Type = 0;

        /**
         * MailReward Amount.
         * @member {number} Amount
         * @memberof pb.MailReward
         * @instance
         */
        MailReward.prototype.Amount = 0;

        /**
         * MailReward CardID.
         * @member {number} CardID
         * @memberof pb.MailReward
         * @instance
         */
        MailReward.prototype.CardID = 0;

        /**
         * MailReward ItemID.
         * @member {string} ItemID
         * @memberof pb.MailReward
         * @instance
         */
        MailReward.prototype.ItemID = "";

        /**
         * MailReward EmojiTeam.
         * @member {number} EmojiTeam
         * @memberof pb.MailReward
         * @instance
         */
        MailReward.prototype.EmojiTeam = 0;

        /**
         * Creates a new MailReward instance using the specified properties.
         * @function create
         * @memberof pb.MailReward
         * @static
         * @param {pb.IMailReward=} [properties] Properties to set
         * @returns {pb.MailReward} MailReward instance
         */
        MailReward.create = function create(properties) {
            return new MailReward(properties);
        };

        /**
         * Encodes the specified MailReward message. Does not implicitly {@link pb.MailReward.verify|verify} messages.
         * @function encode
         * @memberof pb.MailReward
         * @static
         * @param {pb.IMailReward} message MailReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.CardID);
            if (message.ItemID != null && message.hasOwnProperty("ItemID"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.ItemID);
            if (message.EmojiTeam != null && message.hasOwnProperty("EmojiTeam"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.EmojiTeam);
            return writer;
        };

        /**
         * Encodes the specified MailReward message, length delimited. Does not implicitly {@link pb.MailReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailReward
         * @static
         * @param {pb.IMailReward} message MailReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailReward} MailReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                case 3:
                    message.CardID = reader.uint32();
                    break;
                case 4:
                    message.ItemID = reader.string();
                    break;
                case 5:
                    message.EmojiTeam = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailReward} MailReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailReward message.
         * @function verify
         * @memberof pb.MailReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            if (message.ItemID != null && message.hasOwnProperty("ItemID"))
                if (!$util.isString(message.ItemID))
                    return "ItemID: string expected";
            if (message.EmojiTeam != null && message.hasOwnProperty("EmojiTeam"))
                if (!$util.isInteger(message.EmojiTeam))
                    return "EmojiTeam: integer expected";
            return null;
        };

        return MailReward;
    })();

    /**
     * MailTypeEnum enum.
     * @name pb.MailTypeEnum
     * @enum {string}
     * @property {number} CUSTOM=0 CUSTOM value
     * @property {number} SeasonPvpBegin=1 SeasonPvpBegin value
     * @property {number} SeasonPvpEnd=2 SeasonPvpEnd value
     * @property {number} FbAdvert=3 FbAdvert value
     * @property {number} KingReward=4 KingReward value
     * @property {number} ChristmasReward=5 ChristmasReward value
     * @property {number} YuandanReward=6 YuandanReward value
     * @property {number} CampaignUnified=7 CampaignUnified value
     */
    pb.MailTypeEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CUSTOM"] = 0;
        values[valuesById[1] = "SeasonPvpBegin"] = 1;
        values[valuesById[2] = "SeasonPvpEnd"] = 2;
        values[valuesById[3] = "FbAdvert"] = 3;
        values[valuesById[4] = "KingReward"] = 4;
        values[valuesById[5] = "ChristmasReward"] = 5;
        values[valuesById[6] = "YuandanReward"] = 6;
        values[valuesById[7] = "CampaignUnified"] = 7;
        return values;
    })();

    pb.MailSeasonPvpBeginArg = (function() {

        /**
         * Properties of a MailSeasonPvpBeginArg.
         * @memberof pb
         * @interface IMailSeasonPvpBeginArg
         * @property {number|null} [PvpLevel] MailSeasonPvpBeginArg PvpLevel
         */

        /**
         * Constructs a new MailSeasonPvpBeginArg.
         * @memberof pb
         * @classdesc Represents a MailSeasonPvpBeginArg.
         * @implements IMailSeasonPvpBeginArg
         * @constructor
         * @param {pb.IMailSeasonPvpBeginArg=} [properties] Properties to set
         */
        function MailSeasonPvpBeginArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailSeasonPvpBeginArg PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.MailSeasonPvpBeginArg
         * @instance
         */
        MailSeasonPvpBeginArg.prototype.PvpLevel = 0;

        /**
         * Creates a new MailSeasonPvpBeginArg instance using the specified properties.
         * @function create
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {pb.IMailSeasonPvpBeginArg=} [properties] Properties to set
         * @returns {pb.MailSeasonPvpBeginArg} MailSeasonPvpBeginArg instance
         */
        MailSeasonPvpBeginArg.create = function create(properties) {
            return new MailSeasonPvpBeginArg(properties);
        };

        /**
         * Encodes the specified MailSeasonPvpBeginArg message. Does not implicitly {@link pb.MailSeasonPvpBeginArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {pb.IMailSeasonPvpBeginArg} message MailSeasonPvpBeginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSeasonPvpBeginArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.PvpLevel);
            return writer;
        };

        /**
         * Encodes the specified MailSeasonPvpBeginArg message, length delimited. Does not implicitly {@link pb.MailSeasonPvpBeginArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {pb.IMailSeasonPvpBeginArg} message MailSeasonPvpBeginArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSeasonPvpBeginArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailSeasonPvpBeginArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailSeasonPvpBeginArg} MailSeasonPvpBeginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSeasonPvpBeginArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailSeasonPvpBeginArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.PvpLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailSeasonPvpBeginArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailSeasonPvpBeginArg} MailSeasonPvpBeginArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSeasonPvpBeginArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailSeasonPvpBeginArg message.
         * @function verify
         * @memberof pb.MailSeasonPvpBeginArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailSeasonPvpBeginArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            return null;
        };

        return MailSeasonPvpBeginArg;
    })();

    pb.MailSeasonPvpEndArg = (function() {

        /**
         * Properties of a MailSeasonPvpEndArg.
         * @memberof pb
         * @interface IMailSeasonPvpEndArg
         * @property {number|null} [WinDiff] MailSeasonPvpEndArg WinDiff
         */

        /**
         * Constructs a new MailSeasonPvpEndArg.
         * @memberof pb
         * @classdesc Represents a MailSeasonPvpEndArg.
         * @implements IMailSeasonPvpEndArg
         * @constructor
         * @param {pb.IMailSeasonPvpEndArg=} [properties] Properties to set
         */
        function MailSeasonPvpEndArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailSeasonPvpEndArg WinDiff.
         * @member {number} WinDiff
         * @memberof pb.MailSeasonPvpEndArg
         * @instance
         */
        MailSeasonPvpEndArg.prototype.WinDiff = 0;

        /**
         * Creates a new MailSeasonPvpEndArg instance using the specified properties.
         * @function create
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {pb.IMailSeasonPvpEndArg=} [properties] Properties to set
         * @returns {pb.MailSeasonPvpEndArg} MailSeasonPvpEndArg instance
         */
        MailSeasonPvpEndArg.create = function create(properties) {
            return new MailSeasonPvpEndArg(properties);
        };

        /**
         * Encodes the specified MailSeasonPvpEndArg message. Does not implicitly {@link pb.MailSeasonPvpEndArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {pb.IMailSeasonPvpEndArg} message MailSeasonPvpEndArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSeasonPvpEndArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.WinDiff);
            return writer;
        };

        /**
         * Encodes the specified MailSeasonPvpEndArg message, length delimited. Does not implicitly {@link pb.MailSeasonPvpEndArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {pb.IMailSeasonPvpEndArg} message MailSeasonPvpEndArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailSeasonPvpEndArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailSeasonPvpEndArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailSeasonPvpEndArg} MailSeasonPvpEndArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSeasonPvpEndArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailSeasonPvpEndArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.WinDiff = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailSeasonPvpEndArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailSeasonPvpEndArg} MailSeasonPvpEndArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailSeasonPvpEndArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailSeasonPvpEndArg message.
         * @function verify
         * @memberof pb.MailSeasonPvpEndArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailSeasonPvpEndArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                if (!$util.isInteger(message.WinDiff))
                    return "WinDiff: integer expected";
            return null;
        };

        return MailSeasonPvpEndArg;
    })();

    pb.MailCampaignUnifiedArg = (function() {

        /**
         * Properties of a MailCampaignUnifiedArg.
         * @memberof pb
         * @interface IMailCampaignUnifiedArg
         * @property {string|null} [YourMajestyName] MailCampaignUnifiedArg YourMajestyName
         * @property {string|null} [CountryName] MailCampaignUnifiedArg CountryName
         */

        /**
         * Constructs a new MailCampaignUnifiedArg.
         * @memberof pb
         * @classdesc Represents a MailCampaignUnifiedArg.
         * @implements IMailCampaignUnifiedArg
         * @constructor
         * @param {pb.IMailCampaignUnifiedArg=} [properties] Properties to set
         */
        function MailCampaignUnifiedArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailCampaignUnifiedArg YourMajestyName.
         * @member {string} YourMajestyName
         * @memberof pb.MailCampaignUnifiedArg
         * @instance
         */
        MailCampaignUnifiedArg.prototype.YourMajestyName = "";

        /**
         * MailCampaignUnifiedArg CountryName.
         * @member {string} CountryName
         * @memberof pb.MailCampaignUnifiedArg
         * @instance
         */
        MailCampaignUnifiedArg.prototype.CountryName = "";

        /**
         * Creates a new MailCampaignUnifiedArg instance using the specified properties.
         * @function create
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {pb.IMailCampaignUnifiedArg=} [properties] Properties to set
         * @returns {pb.MailCampaignUnifiedArg} MailCampaignUnifiedArg instance
         */
        MailCampaignUnifiedArg.create = function create(properties) {
            return new MailCampaignUnifiedArg(properties);
        };

        /**
         * Encodes the specified MailCampaignUnifiedArg message. Does not implicitly {@link pb.MailCampaignUnifiedArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {pb.IMailCampaignUnifiedArg} message MailCampaignUnifiedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailCampaignUnifiedArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.YourMajestyName);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.CountryName);
            return writer;
        };

        /**
         * Encodes the specified MailCampaignUnifiedArg message, length delimited. Does not implicitly {@link pb.MailCampaignUnifiedArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {pb.IMailCampaignUnifiedArg} message MailCampaignUnifiedArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailCampaignUnifiedArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailCampaignUnifiedArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailCampaignUnifiedArg} MailCampaignUnifiedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailCampaignUnifiedArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailCampaignUnifiedArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.YourMajestyName = reader.string();
                    break;
                case 2:
                    message.CountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailCampaignUnifiedArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailCampaignUnifiedArg} MailCampaignUnifiedArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailCampaignUnifiedArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailCampaignUnifiedArg message.
         * @function verify
         * @memberof pb.MailCampaignUnifiedArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailCampaignUnifiedArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                if (!$util.isString(message.YourMajestyName))
                    return "YourMajestyName: string expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            return null;
        };

        return MailCampaignUnifiedArg;
    })();

    pb.Mail = (function() {

        /**
         * Properties of a Mail.
         * @memberof pb
         * @interface IMail
         * @property {number|null} [ID] Mail ID
         * @property {string|null} [Title] Mail Title
         * @property {string|null} [Content] Mail Content
         * @property {number|null} [Time] Mail Time
         * @property {boolean|null} [IsReward] Mail IsReward
         * @property {string|null} [SenderName] Mail SenderName
         * @property {Array.<pb.IMailReward>|null} [Rewards] Mail Rewards
         * @property {boolean|null} [IsRead] Mail IsRead
         * @property {pb.MailTypeEnum|null} [MailType] Mail MailType
         * @property {Uint8Array|null} [Arg] Mail Arg
         */

        /**
         * Constructs a new Mail.
         * @memberof pb
         * @classdesc Represents a Mail.
         * @implements IMail
         * @constructor
         * @param {pb.IMail=} [properties] Properties to set
         */
        function Mail(properties) {
            this.Rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mail ID.
         * @member {number} ID
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.ID = 0;

        /**
         * Mail Title.
         * @member {string} Title
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.Title = "";

        /**
         * Mail Content.
         * @member {string} Content
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.Content = "";

        /**
         * Mail Time.
         * @member {number} Time
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.Time = 0;

        /**
         * Mail IsReward.
         * @member {boolean} IsReward
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.IsReward = false;

        /**
         * Mail SenderName.
         * @member {string} SenderName
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.SenderName = "";

        /**
         * Mail Rewards.
         * @member {Array.<pb.IMailReward>} Rewards
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.Rewards = $util.emptyArray;

        /**
         * Mail IsRead.
         * @member {boolean} IsRead
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.IsRead = false;

        /**
         * Mail MailType.
         * @member {pb.MailTypeEnum} MailType
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.MailType = 0;

        /**
         * Mail Arg.
         * @member {Uint8Array} Arg
         * @memberof pb.Mail
         * @instance
         */
        Mail.prototype.Arg = $util.newBuffer([]);

        /**
         * Creates a new Mail instance using the specified properties.
         * @function create
         * @memberof pb.Mail
         * @static
         * @param {pb.IMail=} [properties] Properties to set
         * @returns {pb.Mail} Mail instance
         */
        Mail.create = function create(properties) {
            return new Mail(properties);
        };

        /**
         * Encodes the specified Mail message. Does not implicitly {@link pb.Mail.verify|verify} messages.
         * @function encode
         * @memberof pb.Mail
         * @static
         * @param {pb.IMail} message Mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Title != null && message.hasOwnProperty("Title"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Title);
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Content);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Time);
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsReward);
            if (message.SenderName != null && message.hasOwnProperty("SenderName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.SenderName);
            if (message.Rewards != null && message.Rewards.length)
                for (var i = 0; i < message.Rewards.length; ++i)
                    $root.pb.MailReward.encode(message.Rewards[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.IsRead != null && message.hasOwnProperty("IsRead"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.IsRead);
            if (message.MailType != null && message.hasOwnProperty("MailType"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.MailType);
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.Arg);
            return writer;
        };

        /**
         * Encodes the specified Mail message, length delimited. Does not implicitly {@link pb.Mail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Mail
         * @static
         * @param {pb.IMail} message Mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mail message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Mail} Mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Mail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Title = reader.string();
                    break;
                case 3:
                    message.Content = reader.string();
                    break;
                case 4:
                    message.Time = reader.int32();
                    break;
                case 6:
                    message.IsReward = reader.bool();
                    break;
                case 7:
                    message.SenderName = reader.string();
                    break;
                case 8:
                    if (!(message.Rewards && message.Rewards.length))
                        message.Rewards = [];
                    message.Rewards.push($root.pb.MailReward.decode(reader, reader.uint32()));
                    break;
                case 9:
                    message.IsRead = reader.bool();
                    break;
                case 10:
                    message.MailType = reader.int32();
                    break;
                case 11:
                    message.Arg = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Mail} Mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mail message.
         * @function verify
         * @memberof pb.Mail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.Title != null && message.hasOwnProperty("Title"))
                if (!$util.isString(message.Title))
                    return "Title: string expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                if (typeof message.IsReward !== "boolean")
                    return "IsReward: boolean expected";
            if (message.SenderName != null && message.hasOwnProperty("SenderName"))
                if (!$util.isString(message.SenderName))
                    return "SenderName: string expected";
            if (message.Rewards != null && message.hasOwnProperty("Rewards")) {
                if (!Array.isArray(message.Rewards))
                    return "Rewards: array expected";
                for (var i = 0; i < message.Rewards.length; ++i) {
                    var error = $root.pb.MailReward.verify(message.Rewards[i]);
                    if (error)
                        return "Rewards." + error;
                }
            }
            if (message.IsRead != null && message.hasOwnProperty("IsRead"))
                if (typeof message.IsRead !== "boolean")
                    return "IsRead: boolean expected";
            if (message.MailType != null && message.hasOwnProperty("MailType"))
                switch (message.MailType) {
                default:
                    return "MailType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                    break;
                }
            if (message.Arg != null && message.hasOwnProperty("Arg"))
                if (!(message.Arg && typeof message.Arg.length === "number" || $util.isString(message.Arg)))
                    return "Arg: buffer expected";
            return null;
        };

        return Mail;
    })();

    pb.MailList = (function() {

        /**
         * Properties of a MailList.
         * @memberof pb
         * @interface IMailList
         * @property {Array.<pb.IMail>|null} [Mails] MailList Mails
         * @property {boolean|null} [HasMore] MailList HasMore
         */

        /**
         * Constructs a new MailList.
         * @memberof pb
         * @classdesc Represents a MailList.
         * @implements IMailList
         * @constructor
         * @param {pb.IMailList=} [properties] Properties to set
         */
        function MailList(properties) {
            this.Mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailList Mails.
         * @member {Array.<pb.IMail>} Mails
         * @memberof pb.MailList
         * @instance
         */
        MailList.prototype.Mails = $util.emptyArray;

        /**
         * MailList HasMore.
         * @member {boolean} HasMore
         * @memberof pb.MailList
         * @instance
         */
        MailList.prototype.HasMore = false;

        /**
         * Creates a new MailList instance using the specified properties.
         * @function create
         * @memberof pb.MailList
         * @static
         * @param {pb.IMailList=} [properties] Properties to set
         * @returns {pb.MailList} MailList instance
         */
        MailList.create = function create(properties) {
            return new MailList(properties);
        };

        /**
         * Encodes the specified MailList message. Does not implicitly {@link pb.MailList.verify|verify} messages.
         * @function encode
         * @memberof pb.MailList
         * @static
         * @param {pb.IMailList} message MailList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Mails != null && message.Mails.length)
                for (var i = 0; i < message.Mails.length; ++i)
                    $root.pb.Mail.encode(message.Mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.HasMore != null && message.hasOwnProperty("HasMore"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.HasMore);
            return writer;
        };

        /**
         * Encodes the specified MailList message, length delimited. Does not implicitly {@link pb.MailList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailList
         * @static
         * @param {pb.IMailList} message MailList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailList} MailList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Mails && message.Mails.length))
                        message.Mails = [];
                    message.Mails.push($root.pb.Mail.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.HasMore = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailList} MailList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailList message.
         * @function verify
         * @memberof pb.MailList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Mails != null && message.hasOwnProperty("Mails")) {
                if (!Array.isArray(message.Mails))
                    return "Mails: array expected";
                for (var i = 0; i < message.Mails.length; ++i) {
                    var error = $root.pb.Mail.verify(message.Mails[i]);
                    if (error)
                        return "Mails." + error;
                }
            }
            if (message.HasMore != null && message.hasOwnProperty("HasMore"))
                if (typeof message.HasMore !== "boolean")
                    return "HasMore: boolean expected";
            return null;
        };

        return MailList;
    })();

    pb.GetMailRewardArg = (function() {

        /**
         * Properties of a GetMailRewardArg.
         * @memberof pb
         * @interface IGetMailRewardArg
         * @property {number|null} [ID] GetMailRewardArg ID
         */

        /**
         * Constructs a new GetMailRewardArg.
         * @memberof pb
         * @classdesc Represents a GetMailRewardArg.
         * @implements IGetMailRewardArg
         * @constructor
         * @param {pb.IGetMailRewardArg=} [properties] Properties to set
         */
        function GetMailRewardArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMailRewardArg ID.
         * @member {number} ID
         * @memberof pb.GetMailRewardArg
         * @instance
         */
        GetMailRewardArg.prototype.ID = 0;

        /**
         * Creates a new GetMailRewardArg instance using the specified properties.
         * @function create
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {pb.IGetMailRewardArg=} [properties] Properties to set
         * @returns {pb.GetMailRewardArg} GetMailRewardArg instance
         */
        GetMailRewardArg.create = function create(properties) {
            return new GetMailRewardArg(properties);
        };

        /**
         * Encodes the specified GetMailRewardArg message. Does not implicitly {@link pb.GetMailRewardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {pb.IGetMailRewardArg} message GetMailRewardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMailRewardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            return writer;
        };

        /**
         * Encodes the specified GetMailRewardArg message, length delimited. Does not implicitly {@link pb.GetMailRewardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {pb.IGetMailRewardArg} message GetMailRewardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMailRewardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMailRewardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetMailRewardArg} GetMailRewardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMailRewardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetMailRewardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMailRewardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetMailRewardArg} GetMailRewardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMailRewardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMailRewardArg message.
         * @function verify
         * @memberof pb.GetMailRewardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMailRewardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            return null;
        };

        return GetMailRewardArg;
    })();

    pb.ReadMailArg = (function() {

        /**
         * Properties of a ReadMailArg.
         * @memberof pb
         * @interface IReadMailArg
         * @property {number|null} [ID] ReadMailArg ID
         */

        /**
         * Constructs a new ReadMailArg.
         * @memberof pb
         * @classdesc Represents a ReadMailArg.
         * @implements IReadMailArg
         * @constructor
         * @param {pb.IReadMailArg=} [properties] Properties to set
         */
        function ReadMailArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadMailArg ID.
         * @member {number} ID
         * @memberof pb.ReadMailArg
         * @instance
         */
        ReadMailArg.prototype.ID = 0;

        /**
         * Creates a new ReadMailArg instance using the specified properties.
         * @function create
         * @memberof pb.ReadMailArg
         * @static
         * @param {pb.IReadMailArg=} [properties] Properties to set
         * @returns {pb.ReadMailArg} ReadMailArg instance
         */
        ReadMailArg.create = function create(properties) {
            return new ReadMailArg(properties);
        };

        /**
         * Encodes the specified ReadMailArg message. Does not implicitly {@link pb.ReadMailArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ReadMailArg
         * @static
         * @param {pb.IReadMailArg} message ReadMailArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMailArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            return writer;
        };

        /**
         * Encodes the specified ReadMailArg message, length delimited. Does not implicitly {@link pb.ReadMailArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ReadMailArg
         * @static
         * @param {pb.IReadMailArg} message ReadMailArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMailArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadMailArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ReadMailArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ReadMailArg} ReadMailArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMailArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReadMailArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadMailArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ReadMailArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ReadMailArg} ReadMailArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMailArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadMailArg message.
         * @function verify
         * @memberof pb.ReadMailArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadMailArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            return null;
        };

        return ReadMailArg;
    })();

    pb.MailRewardCard = (function() {

        /**
         * Properties of a MailRewardCard.
         * @memberof pb
         * @interface IMailRewardCard
         * @property {number|null} [CardID] MailRewardCard CardID
         * @property {number|null} [Amount] MailRewardCard Amount
         */

        /**
         * Constructs a new MailRewardCard.
         * @memberof pb
         * @classdesc Represents a MailRewardCard.
         * @implements IMailRewardCard
         * @constructor
         * @param {pb.IMailRewardCard=} [properties] Properties to set
         */
        function MailRewardCard(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRewardCard CardID.
         * @member {number} CardID
         * @memberof pb.MailRewardCard
         * @instance
         */
        MailRewardCard.prototype.CardID = 0;

        /**
         * MailRewardCard Amount.
         * @member {number} Amount
         * @memberof pb.MailRewardCard
         * @instance
         */
        MailRewardCard.prototype.Amount = 0;

        /**
         * Creates a new MailRewardCard instance using the specified properties.
         * @function create
         * @memberof pb.MailRewardCard
         * @static
         * @param {pb.IMailRewardCard=} [properties] Properties to set
         * @returns {pb.MailRewardCard} MailRewardCard instance
         */
        MailRewardCard.create = function create(properties) {
            return new MailRewardCard(properties);
        };

        /**
         * Encodes the specified MailRewardCard message. Does not implicitly {@link pb.MailRewardCard.verify|verify} messages.
         * @function encode
         * @memberof pb.MailRewardCard
         * @static
         * @param {pb.IMailRewardCard} message MailRewardCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardCard.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.CardID);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified MailRewardCard message, length delimited. Does not implicitly {@link pb.MailRewardCard.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailRewardCard
         * @static
         * @param {pb.IMailRewardCard} message MailRewardCard message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardCard.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRewardCard message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailRewardCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailRewardCard} MailRewardCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardCard.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailRewardCard();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CardID = reader.uint32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRewardCard message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailRewardCard
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailRewardCard} MailRewardCard
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardCard.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRewardCard message.
         * @function verify
         * @memberof pb.MailRewardCard
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRewardCard.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardID != null && message.hasOwnProperty("CardID"))
                if (!$util.isInteger(message.CardID))
                    return "CardID: integer expected";
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return MailRewardCard;
    })();

    pb.MailRewardAmountArg = (function() {

        /**
         * Properties of a MailRewardAmountArg.
         * @memberof pb
         * @interface IMailRewardAmountArg
         * @property {pb.MailRewardType|null} [Type] MailRewardAmountArg Type
         * @property {number|null} [Amount] MailRewardAmountArg Amount
         */

        /**
         * Constructs a new MailRewardAmountArg.
         * @memberof pb
         * @classdesc Represents a MailRewardAmountArg.
         * @implements IMailRewardAmountArg
         * @constructor
         * @param {pb.IMailRewardAmountArg=} [properties] Properties to set
         */
        function MailRewardAmountArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRewardAmountArg Type.
         * @member {pb.MailRewardType} Type
         * @memberof pb.MailRewardAmountArg
         * @instance
         */
        MailRewardAmountArg.prototype.Type = 0;

        /**
         * MailRewardAmountArg Amount.
         * @member {number} Amount
         * @memberof pb.MailRewardAmountArg
         * @instance
         */
        MailRewardAmountArg.prototype.Amount = 0;

        /**
         * Creates a new MailRewardAmountArg instance using the specified properties.
         * @function create
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {pb.IMailRewardAmountArg=} [properties] Properties to set
         * @returns {pb.MailRewardAmountArg} MailRewardAmountArg instance
         */
        MailRewardAmountArg.create = function create(properties) {
            return new MailRewardAmountArg(properties);
        };

        /**
         * Encodes the specified MailRewardAmountArg message. Does not implicitly {@link pb.MailRewardAmountArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {pb.IMailRewardAmountArg} message MailRewardAmountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardAmountArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Amount);
            return writer;
        };

        /**
         * Encodes the specified MailRewardAmountArg message, length delimited. Does not implicitly {@link pb.MailRewardAmountArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {pb.IMailRewardAmountArg} message MailRewardAmountArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardAmountArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRewardAmountArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailRewardAmountArg} MailRewardAmountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardAmountArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailRewardAmountArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Amount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRewardAmountArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailRewardAmountArg} MailRewardAmountArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardAmountArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRewardAmountArg message.
         * @function verify
         * @memberof pb.MailRewardAmountArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRewardAmountArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.Amount != null && message.hasOwnProperty("Amount"))
                if (!$util.isInteger(message.Amount))
                    return "Amount: integer expected";
            return null;
        };

        return MailRewardAmountArg;
    })();

    pb.MailRewardItemArg = (function() {

        /**
         * Properties of a MailRewardItemArg.
         * @memberof pb
         * @interface IMailRewardItemArg
         * @property {pb.MailRewardType|null} [Type] MailRewardItemArg Type
         * @property {string|null} [ItemID] MailRewardItemArg ItemID
         */

        /**
         * Constructs a new MailRewardItemArg.
         * @memberof pb
         * @classdesc Represents a MailRewardItemArg.
         * @implements IMailRewardItemArg
         * @constructor
         * @param {pb.IMailRewardItemArg=} [properties] Properties to set
         */
        function MailRewardItemArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRewardItemArg Type.
         * @member {pb.MailRewardType} Type
         * @memberof pb.MailRewardItemArg
         * @instance
         */
        MailRewardItemArg.prototype.Type = 0;

        /**
         * MailRewardItemArg ItemID.
         * @member {string} ItemID
         * @memberof pb.MailRewardItemArg
         * @instance
         */
        MailRewardItemArg.prototype.ItemID = "";

        /**
         * Creates a new MailRewardItemArg instance using the specified properties.
         * @function create
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {pb.IMailRewardItemArg=} [properties] Properties to set
         * @returns {pb.MailRewardItemArg} MailRewardItemArg instance
         */
        MailRewardItemArg.create = function create(properties) {
            return new MailRewardItemArg(properties);
        };

        /**
         * Encodes the specified MailRewardItemArg message. Does not implicitly {@link pb.MailRewardItemArg.verify|verify} messages.
         * @function encode
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {pb.IMailRewardItemArg} message MailRewardItemArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardItemArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.ItemID != null && message.hasOwnProperty("ItemID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.ItemID);
            return writer;
        };

        /**
         * Encodes the specified MailRewardItemArg message, length delimited. Does not implicitly {@link pb.MailRewardItemArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {pb.IMailRewardItemArg} message MailRewardItemArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardItemArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRewardItemArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailRewardItemArg} MailRewardItemArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardItemArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailRewardItemArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.ItemID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRewardItemArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailRewardItemArg} MailRewardItemArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardItemArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRewardItemArg message.
         * @function verify
         * @memberof pb.MailRewardItemArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRewardItemArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.ItemID != null && message.hasOwnProperty("ItemID"))
                if (!$util.isString(message.ItemID))
                    return "ItemID: string expected";
            return null;
        };

        return MailRewardItemArg;
    })();

    pb.MailRewardReply = (function() {

        /**
         * Properties of a MailRewardReply.
         * @memberof pb
         * @interface IMailRewardReply
         * @property {Array.<pb.IMailRewardAmountArg>|null} [AmountRewards] MailRewardReply AmountRewards
         * @property {Array.<pb.IOpenTreasureReply>|null} [TreasureRewards] MailRewardReply TreasureRewards
         * @property {Array.<pb.IMailRewardCard>|null} [Cards] MailRewardReply Cards
         * @property {Array.<pb.IMailRewardItemArg>|null} [ItemRewards] MailRewardReply ItemRewards
         * @property {Array.<number>|null} [EmojiTeams] MailRewardReply EmojiTeams
         */

        /**
         * Constructs a new MailRewardReply.
         * @memberof pb
         * @classdesc Represents a MailRewardReply.
         * @implements IMailRewardReply
         * @constructor
         * @param {pb.IMailRewardReply=} [properties] Properties to set
         */
        function MailRewardReply(properties) {
            this.AmountRewards = [];
            this.TreasureRewards = [];
            this.Cards = [];
            this.ItemRewards = [];
            this.EmojiTeams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MailRewardReply AmountRewards.
         * @member {Array.<pb.IMailRewardAmountArg>} AmountRewards
         * @memberof pb.MailRewardReply
         * @instance
         */
        MailRewardReply.prototype.AmountRewards = $util.emptyArray;

        /**
         * MailRewardReply TreasureRewards.
         * @member {Array.<pb.IOpenTreasureReply>} TreasureRewards
         * @memberof pb.MailRewardReply
         * @instance
         */
        MailRewardReply.prototype.TreasureRewards = $util.emptyArray;

        /**
         * MailRewardReply Cards.
         * @member {Array.<pb.IMailRewardCard>} Cards
         * @memberof pb.MailRewardReply
         * @instance
         */
        MailRewardReply.prototype.Cards = $util.emptyArray;

        /**
         * MailRewardReply ItemRewards.
         * @member {Array.<pb.IMailRewardItemArg>} ItemRewards
         * @memberof pb.MailRewardReply
         * @instance
         */
        MailRewardReply.prototype.ItemRewards = $util.emptyArray;

        /**
         * MailRewardReply EmojiTeams.
         * @member {Array.<number>} EmojiTeams
         * @memberof pb.MailRewardReply
         * @instance
         */
        MailRewardReply.prototype.EmojiTeams = $util.emptyArray;

        /**
         * Creates a new MailRewardReply instance using the specified properties.
         * @function create
         * @memberof pb.MailRewardReply
         * @static
         * @param {pb.IMailRewardReply=} [properties] Properties to set
         * @returns {pb.MailRewardReply} MailRewardReply instance
         */
        MailRewardReply.create = function create(properties) {
            return new MailRewardReply(properties);
        };

        /**
         * Encodes the specified MailRewardReply message. Does not implicitly {@link pb.MailRewardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.MailRewardReply
         * @static
         * @param {pb.IMailRewardReply} message MailRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AmountRewards != null && message.AmountRewards.length)
                for (var i = 0; i < message.AmountRewards.length; ++i)
                    $root.pb.MailRewardAmountArg.encode(message.AmountRewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.TreasureRewards != null && message.TreasureRewards.length)
                for (var i = 0; i < message.TreasureRewards.length; ++i)
                    $root.pb.OpenTreasureReply.encode(message.TreasureRewards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Cards != null && message.Cards.length)
                for (var i = 0; i < message.Cards.length; ++i)
                    $root.pb.MailRewardCard.encode(message.Cards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.ItemRewards != null && message.ItemRewards.length)
                for (var i = 0; i < message.ItemRewards.length; ++i)
                    $root.pb.MailRewardItemArg.encode(message.ItemRewards[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.EmojiTeams != null && message.EmojiTeams.length) {
                writer.uint32(/* id 5, wireType 2 =*/42).fork();
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    writer.int32(message.EmojiTeams[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified MailRewardReply message, length delimited. Does not implicitly {@link pb.MailRewardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MailRewardReply
         * @static
         * @param {pb.IMailRewardReply} message MailRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MailRewardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MailRewardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MailRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MailRewardReply} MailRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MailRewardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.AmountRewards && message.AmountRewards.length))
                        message.AmountRewards = [];
                    message.AmountRewards.push($root.pb.MailRewardAmountArg.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.TreasureRewards && message.TreasureRewards.length))
                        message.TreasureRewards = [];
                    message.TreasureRewards.push($root.pb.OpenTreasureReply.decode(reader, reader.uint32()));
                    break;
                case 3:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    message.Cards.push($root.pb.MailRewardCard.decode(reader, reader.uint32()));
                    break;
                case 4:
                    if (!(message.ItemRewards && message.ItemRewards.length))
                        message.ItemRewards = [];
                    message.ItemRewards.push($root.pb.MailRewardItemArg.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.EmojiTeams && message.EmojiTeams.length))
                        message.EmojiTeams = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.EmojiTeams.push(reader.int32());
                    } else
                        message.EmojiTeams.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MailRewardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MailRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MailRewardReply} MailRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MailRewardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MailRewardReply message.
         * @function verify
         * @memberof pb.MailRewardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MailRewardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AmountRewards != null && message.hasOwnProperty("AmountRewards")) {
                if (!Array.isArray(message.AmountRewards))
                    return "AmountRewards: array expected";
                for (var i = 0; i < message.AmountRewards.length; ++i) {
                    var error = $root.pb.MailRewardAmountArg.verify(message.AmountRewards[i]);
                    if (error)
                        return "AmountRewards." + error;
                }
            }
            if (message.TreasureRewards != null && message.hasOwnProperty("TreasureRewards")) {
                if (!Array.isArray(message.TreasureRewards))
                    return "TreasureRewards: array expected";
                for (var i = 0; i < message.TreasureRewards.length; ++i) {
                    var error = $root.pb.OpenTreasureReply.verify(message.TreasureRewards[i]);
                    if (error)
                        return "TreasureRewards." + error;
                }
            }
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i) {
                    var error = $root.pb.MailRewardCard.verify(message.Cards[i]);
                    if (error)
                        return "Cards." + error;
                }
            }
            if (message.ItemRewards != null && message.hasOwnProperty("ItemRewards")) {
                if (!Array.isArray(message.ItemRewards))
                    return "ItemRewards: array expected";
                for (var i = 0; i < message.ItemRewards.length; ++i) {
                    var error = $root.pb.MailRewardItemArg.verify(message.ItemRewards[i]);
                    if (error)
                        return "ItemRewards." + error;
                }
            }
            if (message.EmojiTeams != null && message.hasOwnProperty("EmojiTeams")) {
                if (!Array.isArray(message.EmojiTeams))
                    return "EmojiTeams: array expected";
                for (var i = 0; i < message.EmojiTeams.length; ++i)
                    if (!$util.isInteger(message.EmojiTeams[i]))
                        return "EmojiTeams: integer[] expected";
            }
            return null;
        };

        return MailRewardReply;
    })();

    pb.Mission = (function() {

        /**
         * Properties of a Mission.
         * @memberof pb
         * @interface IMission
         * @property {number|null} [MissionID] Mission MissionID
         * @property {number|null} [CurCnt] Mission CurCnt
         * @property {boolean|null} [IsReward] Mission IsReward
         * @property {number|null} [ID] Mission ID
         */

        /**
         * Constructs a new Mission.
         * @memberof pb
         * @classdesc Represents a Mission.
         * @implements IMission
         * @constructor
         * @param {pb.IMission=} [properties] Properties to set
         */
        function Mission(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mission MissionID.
         * @member {number} MissionID
         * @memberof pb.Mission
         * @instance
         */
        Mission.prototype.MissionID = 0;

        /**
         * Mission CurCnt.
         * @member {number} CurCnt
         * @memberof pb.Mission
         * @instance
         */
        Mission.prototype.CurCnt = 0;

        /**
         * Mission IsReward.
         * @member {boolean} IsReward
         * @memberof pb.Mission
         * @instance
         */
        Mission.prototype.IsReward = false;

        /**
         * Mission ID.
         * @member {number} ID
         * @memberof pb.Mission
         * @instance
         */
        Mission.prototype.ID = 0;

        /**
         * Creates a new Mission instance using the specified properties.
         * @function create
         * @memberof pb.Mission
         * @static
         * @param {pb.IMission=} [properties] Properties to set
         * @returns {pb.Mission} Mission instance
         */
        Mission.create = function create(properties) {
            return new Mission(properties);
        };

        /**
         * Encodes the specified Mission message. Does not implicitly {@link pb.Mission.verify|verify} messages.
         * @function encode
         * @memberof pb.Mission
         * @static
         * @param {pb.IMission} message Mission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MissionID != null && message.hasOwnProperty("MissionID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MissionID);
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurCnt);
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsReward);
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ID);
            return writer;
        };

        /**
         * Encodes the specified Mission message, length delimited. Does not implicitly {@link pb.Mission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Mission
         * @static
         * @param {pb.IMission} message Mission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mission message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Mission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Mission} Mission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Mission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MissionID = reader.int32();
                    break;
                case 2:
                    message.CurCnt = reader.int32();
                    break;
                case 3:
                    message.IsReward = reader.bool();
                    break;
                case 4:
                    message.ID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Mission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Mission} Mission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mission message.
         * @function verify
         * @memberof pb.Mission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MissionID != null && message.hasOwnProperty("MissionID"))
                if (!$util.isInteger(message.MissionID))
                    return "MissionID: integer expected";
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                if (!$util.isInteger(message.CurCnt))
                    return "CurCnt: integer expected";
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                if (typeof message.IsReward !== "boolean")
                    return "IsReward: boolean expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            return null;
        };

        return Mission;
    })();

    pb.MissionTreasure = (function() {

        /**
         * Properties of a MissionTreasure.
         * @memberof pb
         * @interface IMissionTreasure
         * @property {string|null} [TreasureModelID] MissionTreasure TreasureModelID
         * @property {number|null} [CurCnt] MissionTreasure CurCnt
         */

        /**
         * Constructs a new MissionTreasure.
         * @memberof pb
         * @classdesc Represents a MissionTreasure.
         * @implements IMissionTreasure
         * @constructor
         * @param {pb.IMissionTreasure=} [properties] Properties to set
         */
        function MissionTreasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MissionTreasure TreasureModelID.
         * @member {string} TreasureModelID
         * @memberof pb.MissionTreasure
         * @instance
         */
        MissionTreasure.prototype.TreasureModelID = "";

        /**
         * MissionTreasure CurCnt.
         * @member {number} CurCnt
         * @memberof pb.MissionTreasure
         * @instance
         */
        MissionTreasure.prototype.CurCnt = 0;

        /**
         * Creates a new MissionTreasure instance using the specified properties.
         * @function create
         * @memberof pb.MissionTreasure
         * @static
         * @param {pb.IMissionTreasure=} [properties] Properties to set
         * @returns {pb.MissionTreasure} MissionTreasure instance
         */
        MissionTreasure.create = function create(properties) {
            return new MissionTreasure(properties);
        };

        /**
         * Encodes the specified MissionTreasure message. Does not implicitly {@link pb.MissionTreasure.verify|verify} messages.
         * @function encode
         * @memberof pb.MissionTreasure
         * @static
         * @param {pb.IMissionTreasure} message MissionTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionTreasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.TreasureModelID);
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurCnt);
            return writer;
        };

        /**
         * Encodes the specified MissionTreasure message, length delimited. Does not implicitly {@link pb.MissionTreasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MissionTreasure
         * @static
         * @param {pb.IMissionTreasure} message MissionTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionTreasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissionTreasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MissionTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MissionTreasure} MissionTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionTreasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MissionTreasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureModelID = reader.string();
                    break;
                case 2:
                    message.CurCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissionTreasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MissionTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MissionTreasure} MissionTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionTreasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissionTreasure message.
         * @function verify
         * @memberof pb.MissionTreasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissionTreasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                if (!$util.isString(message.TreasureModelID))
                    return "TreasureModelID: string expected";
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                if (!$util.isInteger(message.CurCnt))
                    return "CurCnt: integer expected";
            return null;
        };

        return MissionTreasure;
    })();

    pb.MissionInfo = (function() {

        /**
         * Properties of a MissionInfo.
         * @memberof pb
         * @interface IMissionInfo
         * @property {Array.<pb.IMission>|null} [Missions] MissionInfo Missions
         * @property {pb.IMissionTreasure|null} [Treasure] MissionInfo Treasure
         * @property {boolean|null} [CanRefresh] MissionInfo CanRefresh
         * @property {number|null} [RefreshRemainTime] MissionInfo RefreshRemainTime
         */

        /**
         * Constructs a new MissionInfo.
         * @memberof pb
         * @classdesc Represents a MissionInfo.
         * @implements IMissionInfo
         * @constructor
         * @param {pb.IMissionInfo=} [properties] Properties to set
         */
        function MissionInfo(properties) {
            this.Missions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MissionInfo Missions.
         * @member {Array.<pb.IMission>} Missions
         * @memberof pb.MissionInfo
         * @instance
         */
        MissionInfo.prototype.Missions = $util.emptyArray;

        /**
         * MissionInfo Treasure.
         * @member {pb.IMissionTreasure|null|undefined} Treasure
         * @memberof pb.MissionInfo
         * @instance
         */
        MissionInfo.prototype.Treasure = null;

        /**
         * MissionInfo CanRefresh.
         * @member {boolean} CanRefresh
         * @memberof pb.MissionInfo
         * @instance
         */
        MissionInfo.prototype.CanRefresh = false;

        /**
         * MissionInfo RefreshRemainTime.
         * @member {number} RefreshRemainTime
         * @memberof pb.MissionInfo
         * @instance
         */
        MissionInfo.prototype.RefreshRemainTime = 0;

        /**
         * Creates a new MissionInfo instance using the specified properties.
         * @function create
         * @memberof pb.MissionInfo
         * @static
         * @param {pb.IMissionInfo=} [properties] Properties to set
         * @returns {pb.MissionInfo} MissionInfo instance
         */
        MissionInfo.create = function create(properties) {
            return new MissionInfo(properties);
        };

        /**
         * Encodes the specified MissionInfo message. Does not implicitly {@link pb.MissionInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.MissionInfo
         * @static
         * @param {pb.IMissionInfo} message MissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Missions != null && message.Missions.length)
                for (var i = 0; i < message.Missions.length; ++i)
                    $root.pb.Mission.encode(message.Missions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Treasure != null && message.hasOwnProperty("Treasure"))
                $root.pb.MissionTreasure.encode(message.Treasure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.CanRefresh != null && message.hasOwnProperty("CanRefresh"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.CanRefresh);
            if (message.RefreshRemainTime != null && message.hasOwnProperty("RefreshRemainTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.RefreshRemainTime);
            return writer;
        };

        /**
         * Encodes the specified MissionInfo message, length delimited. Does not implicitly {@link pb.MissionInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MissionInfo
         * @static
         * @param {pb.IMissionInfo} message MissionInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissionInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MissionInfo} MissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MissionInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Missions && message.Missions.length))
                        message.Missions = [];
                    message.Missions.push($root.pb.Mission.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.Treasure = $root.pb.MissionTreasure.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.CanRefresh = reader.bool();
                    break;
                case 4:
                    message.RefreshRemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissionInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MissionInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MissionInfo} MissionInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissionInfo message.
         * @function verify
         * @memberof pb.MissionInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissionInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Missions != null && message.hasOwnProperty("Missions")) {
                if (!Array.isArray(message.Missions))
                    return "Missions: array expected";
                for (var i = 0; i < message.Missions.length; ++i) {
                    var error = $root.pb.Mission.verify(message.Missions[i]);
                    if (error)
                        return "Missions." + error;
                }
            }
            if (message.Treasure != null && message.hasOwnProperty("Treasure")) {
                var error = $root.pb.MissionTreasure.verify(message.Treasure);
                if (error)
                    return "Treasure." + error;
            }
            if (message.CanRefresh != null && message.hasOwnProperty("CanRefresh"))
                if (typeof message.CanRefresh !== "boolean")
                    return "CanRefresh: boolean expected";
            if (message.RefreshRemainTime != null && message.hasOwnProperty("RefreshRemainTime"))
                if (!$util.isInteger(message.RefreshRemainTime))
                    return "RefreshRemainTime: integer expected";
            return null;
        };

        return MissionInfo;
    })();

    pb.TargetMission = (function() {

        /**
         * Properties of a TargetMission.
         * @memberof pb
         * @interface ITargetMission
         * @property {number|null} [ID] TargetMission ID
         */

        /**
         * Constructs a new TargetMission.
         * @memberof pb
         * @classdesc Represents a TargetMission.
         * @implements ITargetMission
         * @constructor
         * @param {pb.ITargetMission=} [properties] Properties to set
         */
        function TargetMission(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetMission ID.
         * @member {number} ID
         * @memberof pb.TargetMission
         * @instance
         */
        TargetMission.prototype.ID = 0;

        /**
         * Creates a new TargetMission instance using the specified properties.
         * @function create
         * @memberof pb.TargetMission
         * @static
         * @param {pb.ITargetMission=} [properties] Properties to set
         * @returns {pb.TargetMission} TargetMission instance
         */
        TargetMission.create = function create(properties) {
            return new TargetMission(properties);
        };

        /**
         * Encodes the specified TargetMission message. Does not implicitly {@link pb.TargetMission.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetMission
         * @static
         * @param {pb.ITargetMission} message TargetMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetMission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            return writer;
        };

        /**
         * Encodes the specified TargetMission message, length delimited. Does not implicitly {@link pb.TargetMission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetMission
         * @static
         * @param {pb.ITargetMission} message TargetMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetMission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetMission message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetMission} TargetMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetMission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetMission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetMission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetMission} TargetMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetMission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetMission message.
         * @function verify
         * @memberof pb.TargetMission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetMission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            return null;
        };

        return TargetMission;
    })();

    pb.MissionReward = (function() {

        /**
         * Properties of a MissionReward.
         * @memberof pb
         * @interface IMissionReward
         * @property {number|null} [Jade] MissionReward Jade
         * @property {number|null} [Gold] MissionReward Gold
         * @property {number|null} [Bowlder] MissionReward Bowlder
         */

        /**
         * Constructs a new MissionReward.
         * @memberof pb
         * @classdesc Represents a MissionReward.
         * @implements IMissionReward
         * @constructor
         * @param {pb.IMissionReward=} [properties] Properties to set
         */
        function MissionReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MissionReward Jade.
         * @member {number} Jade
         * @memberof pb.MissionReward
         * @instance
         */
        MissionReward.prototype.Jade = 0;

        /**
         * MissionReward Gold.
         * @member {number} Gold
         * @memberof pb.MissionReward
         * @instance
         */
        MissionReward.prototype.Gold = 0;

        /**
         * MissionReward Bowlder.
         * @member {number} Bowlder
         * @memberof pb.MissionReward
         * @instance
         */
        MissionReward.prototype.Bowlder = 0;

        /**
         * Creates a new MissionReward instance using the specified properties.
         * @function create
         * @memberof pb.MissionReward
         * @static
         * @param {pb.IMissionReward=} [properties] Properties to set
         * @returns {pb.MissionReward} MissionReward instance
         */
        MissionReward.create = function create(properties) {
            return new MissionReward(properties);
        };

        /**
         * Encodes the specified MissionReward message. Does not implicitly {@link pb.MissionReward.verify|verify} messages.
         * @function encode
         * @memberof pb.MissionReward
         * @static
         * @param {pb.IMissionReward} message MissionReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Jade);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Bowlder);
            return writer;
        };

        /**
         * Encodes the specified MissionReward message, length delimited. Does not implicitly {@link pb.MissionReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.MissionReward
         * @static
         * @param {pb.IMissionReward} message MissionReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MissionReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MissionReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.MissionReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.MissionReward} MissionReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.MissionReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Jade = reader.int32();
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                case 3:
                    message.Bowlder = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MissionReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.MissionReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.MissionReward} MissionReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MissionReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MissionReward message.
         * @function verify
         * @memberof pb.MissionReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MissionReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                if (!$util.isInteger(message.Bowlder))
                    return "Bowlder: integer expected";
            return null;
        };

        return MissionReward;
    })();

    pb.OpenMissionTreasureReply = (function() {

        /**
         * Properties of an OpenMissionTreasureReply.
         * @memberof pb
         * @interface IOpenMissionTreasureReply
         * @property {pb.IOpenTreasureReply|null} [TreasureReward] OpenMissionTreasureReply TreasureReward
         * @property {pb.IMissionTreasure|null} [NextTreasure] OpenMissionTreasureReply NextTreasure
         */

        /**
         * Constructs a new OpenMissionTreasureReply.
         * @memberof pb
         * @classdesc Represents an OpenMissionTreasureReply.
         * @implements IOpenMissionTreasureReply
         * @constructor
         * @param {pb.IOpenMissionTreasureReply=} [properties] Properties to set
         */
        function OpenMissionTreasureReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenMissionTreasureReply TreasureReward.
         * @member {pb.IOpenTreasureReply|null|undefined} TreasureReward
         * @memberof pb.OpenMissionTreasureReply
         * @instance
         */
        OpenMissionTreasureReply.prototype.TreasureReward = null;

        /**
         * OpenMissionTreasureReply NextTreasure.
         * @member {pb.IMissionTreasure|null|undefined} NextTreasure
         * @memberof pb.OpenMissionTreasureReply
         * @instance
         */
        OpenMissionTreasureReply.prototype.NextTreasure = null;

        /**
         * Creates a new OpenMissionTreasureReply instance using the specified properties.
         * @function create
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {pb.IOpenMissionTreasureReply=} [properties] Properties to set
         * @returns {pb.OpenMissionTreasureReply} OpenMissionTreasureReply instance
         */
        OpenMissionTreasureReply.create = function create(properties) {
            return new OpenMissionTreasureReply(properties);
        };

        /**
         * Encodes the specified OpenMissionTreasureReply message. Does not implicitly {@link pb.OpenMissionTreasureReply.verify|verify} messages.
         * @function encode
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {pb.IOpenMissionTreasureReply} message OpenMissionTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenMissionTreasureReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward"))
                $root.pb.OpenTreasureReply.encode(message.TreasureReward, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.NextTreasure != null && message.hasOwnProperty("NextTreasure"))
                $root.pb.MissionTreasure.encode(message.NextTreasure, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified OpenMissionTreasureReply message, length delimited. Does not implicitly {@link pb.OpenMissionTreasureReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {pb.IOpenMissionTreasureReply} message OpenMissionTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenMissionTreasureReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenMissionTreasureReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.OpenMissionTreasureReply} OpenMissionTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenMissionTreasureReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.OpenMissionTreasureReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureReward = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.NextTreasure = $root.pb.MissionTreasure.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenMissionTreasureReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.OpenMissionTreasureReply} OpenMissionTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenMissionTreasureReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenMissionTreasureReply message.
         * @function verify
         * @memberof pb.OpenMissionTreasureReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenMissionTreasureReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward")) {
                var error = $root.pb.OpenTreasureReply.verify(message.TreasureReward);
                if (error)
                    return "TreasureReward." + error;
            }
            if (message.NextTreasure != null && message.hasOwnProperty("NextTreasure")) {
                var error = $root.pb.MissionTreasure.verify(message.NextTreasure);
                if (error)
                    return "NextTreasure." + error;
            }
            return null;
        };

        return OpenMissionTreasureReply;
    })();

    pb.UpdateMissionProcessArg = (function() {

        /**
         * Properties of an UpdateMissionProcessArg.
         * @memberof pb
         * @interface IUpdateMissionProcessArg
         * @property {Array.<pb.IMission>|null} [Missions] UpdateMissionProcessArg Missions
         */

        /**
         * Constructs a new UpdateMissionProcessArg.
         * @memberof pb
         * @classdesc Represents an UpdateMissionProcessArg.
         * @implements IUpdateMissionProcessArg
         * @constructor
         * @param {pb.IUpdateMissionProcessArg=} [properties] Properties to set
         */
        function UpdateMissionProcessArg(properties) {
            this.Missions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdateMissionProcessArg Missions.
         * @member {Array.<pb.IMission>} Missions
         * @memberof pb.UpdateMissionProcessArg
         * @instance
         */
        UpdateMissionProcessArg.prototype.Missions = $util.emptyArray;

        /**
         * Creates a new UpdateMissionProcessArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {pb.IUpdateMissionProcessArg=} [properties] Properties to set
         * @returns {pb.UpdateMissionProcessArg} UpdateMissionProcessArg instance
         */
        UpdateMissionProcessArg.create = function create(properties) {
            return new UpdateMissionProcessArg(properties);
        };

        /**
         * Encodes the specified UpdateMissionProcessArg message. Does not implicitly {@link pb.UpdateMissionProcessArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {pb.IUpdateMissionProcessArg} message UpdateMissionProcessArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMissionProcessArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Missions != null && message.Missions.length)
                for (var i = 0; i < message.Missions.length; ++i)
                    $root.pb.Mission.encode(message.Missions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified UpdateMissionProcessArg message, length delimited. Does not implicitly {@link pb.UpdateMissionProcessArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {pb.IUpdateMissionProcessArg} message UpdateMissionProcessArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdateMissionProcessArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdateMissionProcessArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdateMissionProcessArg} UpdateMissionProcessArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMissionProcessArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdateMissionProcessArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Missions && message.Missions.length))
                        message.Missions = [];
                    message.Missions.push($root.pb.Mission.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdateMissionProcessArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdateMissionProcessArg} UpdateMissionProcessArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdateMissionProcessArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdateMissionProcessArg message.
         * @function verify
         * @memberof pb.UpdateMissionProcessArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdateMissionProcessArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Missions != null && message.hasOwnProperty("Missions")) {
                if (!Array.isArray(message.Missions))
                    return "Missions: array expected";
                for (var i = 0; i < message.Missions.length; ++i) {
                    var error = $root.pb.Mission.verify(message.Missions[i]);
                    if (error)
                        return "Missions." + error;
                }
            }
            return null;
        };

        return UpdateMissionProcessArg;
    })();

    /**
     * MessageID enum.
     * @name pb.MessageID
     * @enum {string}
     * @property {number} UNKNOW_MessageID=0 UNKNOW_MessageID value
     * @property {number} C2S_LOGIN=100 C2S_LOGIN value
     * @property {number} C2S_BEGIN_MATCH=101 C2S_BEGIN_MATCH value
     * @property {number} C2S_STOP_MATCH=102 C2S_STOP_MATCH value
     * @property {number} C2S_FIGHT_BOUT_READY_DONE=103 C2S_FIGHT_BOUT_READY_DONE value
     * @property {number} C2S_FIGHT_BOUT_CMD=104 C2S_FIGHT_BOUT_CMD value
     * @property {number} C2S_FETCH_CARD_DATA=105 C2S_FETCH_CARD_DATA value
     * @property {number} C2S_MATCH_ADD_ROBOT=106 C2S_MATCH_ADD_ROBOT value
     * @property {number} C2S_POOL_ADD_CARD=107 C2S_POOL_ADD_CARD value
     * @property {number} C2S_UPDATE_CARD_POOL=108 C2S_UPDATE_CARD_POOL value
     * @property {number} C2S_UPLEVEL_CARD=109 C2S_UPLEVEL_CARD value
     * @property {number} C2S_FETCH_LEVEL_INFO=110 C2S_FETCH_LEVEL_INFO value
     * @property {number} C2S_BEGIN_LEVEL_BATTLE=111 C2S_BEGIN_LEVEL_BATTLE value
     * @property {number} C2S_LEVEL_READY_DONE=112 C2S_LEVEL_READY_DONE value
     * @property {number} C2S_FIGHT_SURRENDER=113 C2S_FIGHT_SURRENDER value
     * @property {number} C2S_GM_COMMAND=114 C2S_GM_COMMAND value
     * @property {number} C2S_FETCH_CAMPAIGN_INFO=115 C2S_FETCH_CAMPAIGN_INFO value
     * @property {number} C2S_BEGIN_CAMPAIGN_FIGHT=116 C2S_BEGIN_CAMPAIGN_FIGHT value
     * @property {number} C2S_UPDATE_CAMPAIGN_GUARD=118 C2S_UPDATE_CAMPAIGN_GUARD value
     * @property {number} C2S_CAMPAIGN_FETCH_VIDEO=119 C2S_CAMPAIGN_FETCH_VIDEO value
     * @property {number} C2S_CAMPAIGN_MARCH=120 C2S_CAMPAIGN_MARCH value
     * @property {number} C2S_CAMPAIGN_DISMISS=121 C2S_CAMPAIGN_DISMISS value
     * @property {number} C2S_CARD_RELIVE=122 C2S_CARD_RELIVE value
     * @property {number} C2S_FIGHT_GM_WIN=123 C2S_FIGHT_GM_WIN value
     * @property {number} C2S_CARD_TREAT=124 C2S_CARD_TREAT value
     * @property {number} C2S_DIY_CARD=125 C2S_DIY_CARD value
     * @property {number} C2S_FETCH_DIY_CARD_IMG=126 C2S_FETCH_DIY_CARD_IMG value
     * @property {number} C2S_EXCHANGE_RESOURCE=127 C2S_EXCHANGE_RESOURCE value
     * @property {number} C2S_DIY_CARD_AGAIN=128 C2S_DIY_CARD_AGAIN value
     * @property {number} C2S_DECOMPOSE_DIY_CARD=129 C2S_DECOMPOSE_DIY_CARD value
     * @property {number} C2S_POOL_UPDATE_CARD=130 C2S_POOL_UPDATE_CARD value
     * @property {number} C2S_LOAD_FIGHT=131 C2S_LOAD_FIGHT value
     * @property {number} C2S_ACCOUNT_LOGIN=132 C2S_ACCOUNT_LOGIN value
     * @property {number} C2S_DEL_ARCHIVES=133 C2S_DEL_ARCHIVES value
     * @property {number} C2S_PLAYER_LOGOUT=134 C2S_PLAYER_LOGOUT value
     * @property {number} C2S_EXCHANGE_EXPED_CARD=135 C2S_EXCHANGE_EXPED_CARD value
     * @property {number} C2S_FINISH_GUIDE=136 C2S_FINISH_GUIDE value
     * @property {number} C2S_FETCH_GUIDE=137 C2S_FETCH_GUIDE value
     * @property {number} C2S_CAMPAIGN_DEF_ENEMY=138 C2S_CAMPAIGN_DEF_ENEMY value
     * @property {number} C2S_PING=139 C2S_PING value
     * @property {number} C2S_GET_TREASURES=140 C2S_GET_TREASURES value
     * @property {number} C2S_OPEN_TREASURE=141 C2S_OPEN_TREASURE value
     * @property {number} C2S_ACTIVATE_REWARD_TREASURE=142 C2S_ACTIVATE_REWARD_TREASURE value
     * @property {number} C2S_GET_CAMP_ID=143 C2S_GET_CAMP_ID value
     * @property {number} C2S_SET_CAMP_ID=144 C2S_SET_CAMP_ID value
     * @property {number} C2S_START_TUTORIAL_BATTLE=145 C2S_START_TUTORIAL_BATTLE value
     * @property {number} C2S_MATCH_READY_DONE=146 C2S_MATCH_READY_DONE value
     * @property {number} C2S_FETCH_RANK=147 C2S_FETCH_RANK value
     * @property {number} C2S_FETCH_RANK_USER=148 C2S_FETCH_RANK_USER value
     * @property {number} C2S_OPEN_LEVEL_TREASURE=149 C2S_OPEN_LEVEL_TREASURE value
     * @property {number} C2S_GET_BATTLE_VIDEO=150 C2S_GET_BATTLE_VIDEO value
     * @property {number} C2S_SEND_EMOJI=151 C2S_SEND_EMOJI value
     * @property {number} C2S_REGISTER_ACCOUNT=152 C2S_REGISTER_ACCOUNT value
     * @property {number} C2S_FETCH_VIDEO_LIST=153 C2S_FETCH_VIDEO_LIST value
     * @property {number} C2S_WATCH_VIDEO=154 C2S_WATCH_VIDEO value
     * @property {number} C2S_FETCH_SELF_VIDEO_LIST=155 C2S_FETCH_SELF_VIDEO_LIST value
     * @property {number} C2S_LIKE_VIDEO=156 C2S_LIKE_VIDEO value
     * @property {number} C2S_SHARE_VIDEO=157 C2S_SHARE_VIDEO value
     * @property {number} C2S_FETCH_SURVEY_INFO=158 C2S_FETCH_SURVEY_INFO value
     * @property {number} C2S_COMPLETE_SURVEY=159 C2S_COMPLETE_SURVEY value
     * @property {number} C2S_GET_SURVEY_REWARD=160 C2S_GET_SURVEY_REWARD value
     * @property {number} C2S_MODIFY_NAME=161 C2S_MODIFY_NAME value
     * @property {number} C2S_SDK_ACCOUNT_LOGIN=162 C2S_SDK_ACCOUNT_LOGIN value
     * @property {number} C2S_EXCHANGE_GIFT_CODE=163 C2S_EXCHANGE_GIFT_CODE value
     * @property {number} C2S_FETCH_VERSION=164 C2S_FETCH_VERSION value
     * @property {number} C2S_FETCH_FRIEND_LIST=165 C2S_FETCH_FRIEND_LIST value
     * @property {number} C2S_FETCH_PLAYER_INFO=166 C2S_FETCH_PLAYER_INFO value
     * @property {number} C2S_ADD_FRIEND_APPLY=167 C2S_ADD_FRIEND_APPLY value
     * @property {number} C2S_FETCH_FRIEND_APPLY_LIST=168 C2S_FETCH_FRIEND_APPLY_LIST value
     * @property {number} C2S_REPLY_AFRIEND_APPLY=169 C2S_REPLY_AFRIEND_APPLY value
     * @property {number} C2S_DEL_FRIEND=170 C2S_DEL_FRIEND value
     * @property {number} C2S_FETCH_PRIVATE_CHAT=171 C2S_FETCH_PRIVATE_CHAT value
     * @property {number} C2S_SEND_PRIVATE_CHAT=172 C2S_SEND_PRIVATE_CHAT value
     * @property {number} C2S_SUBSCRIBE_CHAT=173 C2S_SUBSCRIBE_CHAT value
     * @property {number} C2S_UNSUBSCRIBE_CHAT=174 C2S_UNSUBSCRIBE_CHAT value
     * @property {number} C2S_SEND_CHAT=175 C2S_SEND_CHAT value
     * @property {number} C2S_INVITE_BATTLE=176 C2S_INVITE_BATTLE value
     * @property {number} C2S_CANCEL_INVITE_BATTLE=177 C2S_CANCEL_INVITE_BATTLE value
     * @property {number} C2S_REPLY_INVITE_BATTLE=178 C2S_REPLY_INVITE_BATTLE value
     * @property {number} C2S_UPDATE_SDK_USER_INFO=179 C2S_UPDATE_SDK_USER_INFO value
     * @property {number} C2S_WX_INVITE_BATTLE=180 C2S_WX_INVITE_BATTLE value
     * @property {number} C2S_WX_CANCEL_INVITE_BATTLE=181 C2S_WX_CANCEL_INVITE_BATTLE value
     * @property {number} C2S_WX_REPLY_INVITE_BATTLE=182 C2S_WX_REPLY_INVITE_BATTLE value
     * @property {number} C2S_GET_SHARE_TREASURE_REWARD=183 C2S_GET_SHARE_TREASURE_REWARD value
     * @property {number} C2S_HELP_SHARE_TREASURE=184 C2S_HELP_SHARE_TREASURE value
     * @property {number} C2S_SHARE_TREASURE=185 C2S_SHARE_TREASURE value
     * @property {number} C2S_SHARE_BATTLE_LOSE=186 C2S_SHARE_BATTLE_LOSE value
     * @property {number} C2S_END_SHARE_BATTLE_LOSE=187 C2S_END_SHARE_BATTLE_LOSE value
     * @property {number} C2S_JADE_ACC_TREASURE=188 C2S_JADE_ACC_TREASURE value
     * @property {number} C2S_FETCH_SHOP_DATA=189 C2S_FETCH_SHOP_DATA value
     * @property {number} C2S_BUY_LIMIT_GITF=190 C2S_BUY_LIMIT_GITF value
     * @property {number} C2S_BUY_JADE=191 C2S_BUY_JADE value
     * @property {number} C2S_BUY_SOLDTREASURE=192 C2S_BUY_SOLDTREASURE value
     * @property {number} C2S_BUY_GOLD=193 C2S_BUY_GOLD value
     * @property {number} C2S_DAILY_TREASURE_READ_ADS=194 C2S_DAILY_TREASURE_READ_ADS value
     * @property {number} C2S_TREASURE_READ_ADS=195 C2S_TREASURE_READ_ADS value
     * @property {number} C2S_BATTLE_LOSE_READ_ADS=196 C2S_BATTLE_LOSE_READ_ADS value
     * @property {number} C2S_RECORD_CUR_GUIDE_GROUP=197 C2S_RECORD_CUR_GUIDE_GROUP value
     * @property {number} C2S_FETCH_CUR_GUIDE_GROUP=198 C2S_FETCH_CUR_GUIDE_GROUP value
     * @property {number} C2S_UPDATE_HEADIMG=199 C2S_UPDATE_HEADIMG value
     * @property {number} C2S_FETCH_LEVEL_HELP_RECORD=200 C2S_FETCH_LEVEL_HELP_RECORD value
     * @property {number} C2S_LEVEL_HELP_OTHER=201 C2S_LEVEL_HELP_OTHER value
     * @property {number} C2S_HELP_SHARE_BATTLE_LOSE=202 C2S_HELP_SHARE_BATTLE_LOSE value
     * @property {number} C2S_WATCH_UP_TREASURE_RARE_ADS=203 C2S_WATCH_UP_TREASURE_RARE_ADS value
     * @property {number} C2S_WATCH_SHOP_FREE_ADS=204 C2S_WATCH_SHOP_FREE_ADS value
     * @property {number} C2S_WATCH_TREASURE_ADD_CARD_ADS=205 C2S_WATCH_TREASURE_ADD_CARD_ADS value
     * @property {number} C2S_WATCH_HELP_VIDEO=206 C2S_WATCH_HELP_VIDEO value
     * @property {number} C2S_FETCH_MISSION_INFO=207 C2S_FETCH_MISSION_INFO value
     * @property {number} C2S_REFRESH_MISSION=208 C2S_REFRESH_MISSION value
     * @property {number} C2S_GET_MISSION_REWARD=209 C2S_GET_MISSION_REWARD value
     * @property {number} C2S_OPEN_MISSION_TREASURE=210 C2S_OPEN_MISSION_TREASURE value
     * @property {number} C2S_WXGAME_SHARE=211 C2S_WXGAME_SHARE value
     * @property {number} C2S_WATCH_OUT_VIDEO=212 C2S_WATCH_OUT_VIDEO value
     * @property {number} C2S_FETCH_VIDEO_COMMENTS=213 C2S_FETCH_VIDEO_COMMENTS value
     * @property {number} C2S_LIKE_VIDEO_COMMENTS=214 C2S_LIKE_VIDEO_COMMENTS value
     * @property {number} C2S_COMMENTS_VIDEO=215 C2S_COMMENTS_VIDEO value
     * @property {number} C2S_FETCH_WX_INVITE_FRIENDS=216 C2S_FETCH_WX_INVITE_FRIENDS value
     * @property {number} C2S_GET_WX_INVITE_REWARD=217 C2S_GET_WX_INVITE_REWARD value
     * @property {number} C2S_CLICK_WXGAME_SHARE=218 C2S_CLICK_WXGAME_SHARE value
     * @property {number} C2S_WATCH_ADS_BEGIN=219 C2S_WATCH_ADS_BEGIN value
     * @property {number} C2S_WATCH_ADS_END=220 C2S_WATCH_ADS_END value
     * @property {number} C2S_CANCEL_WX_SHARE=221 C2S_CANCEL_WX_SHARE value
     * @property {number} C2S_FETCH_MAIL_LIST=222 C2S_FETCH_MAIL_LIST value
     * @property {number} C2S_GET_MAIL_REWARD=223 C2S_GET_MAIL_REWARD value
     * @property {number} C2S_READ_MAIL=224 C2S_READ_MAIL value
     * @property {number} C2S_GET_ALL_MAIL_REWARD=225 C2S_GET_ALL_MAIL_REWARD value
     * @property {number} C2S_SDK_CREATE_ORDER=226 C2S_SDK_CREATE_ORDER value
     * @property {number} C2S_UPDATE_NAME=227 C2S_UPDATE_NAME value
     * @property {number} C2S_IOS_PRE_PAY=228 C2S_IOS_PRE_PAY value
     * @property {number} C2S_IOS_SHARE=229 C2S_IOS_SHARE value
     * @property {number} C2S_FETCH_LEVEL_VIDEO_ID=230 C2S_FETCH_LEVEL_VIDEO_ID value
     * @property {number} C2S_BUY_LIMIT_GITF_BY_JADE=231 C2S_BUY_LIMIT_GITF_BY_JADE value
     * @property {number} C2S_TOURIST_REGISTER_ACCOUNT=232 C2S_TOURIST_REGISTER_ACCOUNT value
     * @property {number} C2S_GOOGLE_PLAY_RECHARGE=233 C2S_GOOGLE_PLAY_RECHARGE value
     * @property {number} C2S_TOURIST_BIND_ACCOUNT=234 C2S_TOURIST_BIND_ACCOUNT value
     * @property {number} C2S_FETCH_SEASON_PVP_LIMIT_TIME=235 C2S_FETCH_SEASON_PVP_LIMIT_TIME value
     * @property {number} C2S_FETCH_SEASON_PVP_INFO=236 C2S_FETCH_SEASON_PVP_INFO value
     * @property {number} C2S_BUY_VIP_CARD=237 C2S_BUY_VIP_CARD value
     * @property {number} C2S_UPDATE_CARD_SKIN=238 C2S_UPDATE_CARD_SKIN value
     * @property {number} C2S_FETCH_HEAD_FRAME=239 C2S_FETCH_HEAD_FRAME value
     * @property {number} C2S_UPDATE_HEAD_FRAME=240 C2S_UPDATE_HEAD_FRAME value
     * @property {number} C2S_GET_FBADVERT_REWARD=241 C2S_GET_FBADVERT_REWARD value
     * @property {number} C2S_REFINE_CARD=242 C2S_REFINE_CARD value
     * @property {number} C2S_REBORN=243 C2S_REBORN value
     * @property {number} C2S_BUY_REBORN_GOODS=244 C2S_BUY_REBORN_GOODS value
     * @property {number} C2S_FETCH_REBORN_DATA=245 C2S_FETCH_REBORN_DATA value
     * @property {number} C2S_FETCH_VIDEO_ITEM=246 C2S_FETCH_VIDEO_ITEM value
     * @property {number} C2S_SEASON_BATTLE_READY_DONE=247 C2S_SEASON_BATTLE_READY_DONE value
     * @property {number} C2S_FETCH_HEAD=248 C2S_FETCH_HEAD value
     * @property {number} C2S_SEASON_PVP_CHOOSE_CAMP=249 C2S_SEASON_PVP_CHOOSE_CAMP value
     * @property {number} C2S_SEASON_PVP_CHOOSE_CARD=250 C2S_SEASON_PVP_CHOOSE_CARD value
     * @property {number} C2S_FETCH_SEASON_HAND_CARD=251 C2S_FETCH_SEASON_HAND_CARD value
     * @property {number} C2S_FETCH_EQUIP=252 C2S_FETCH_EQUIP value
     * @property {number} C2S_WEAR_EQUIP=253 C2S_WEAR_EQUIP value
     * @property {number} C2S_DE_EQUIP=254 C2S_DE_EQUIP value
     * @property {number} C2S_REFRESH_SEASON_PVP_CHOOSE_CARD=255 C2S_REFRESH_SEASON_PVP_CHOOSE_CARD value
     * @property {number} C2S_FETCH_EMOJI=256 C2S_FETCH_EMOJI value
     * @property {number} C2S_FETCH_VIP_REMAIN_TIME=257 C2S_FETCH_VIP_REMAIN_TIME value
     * @property {number} C2S_SETTLE_CITY=258 C2S_SETTLE_CITY value
     * @property {number} C2S_CREATE_COUNTRY=259 C2S_CREATE_COUNTRY value
     * @property {number} C2S_FETCH_CITY_DATA=260 C2S_FETCH_CITY_DATA value
     * @property {number} C2S_FETCH_APPLY_CREATE_COUNTRY_INFO=261 C2S_FETCH_APPLY_CREATE_COUNTRY_INFO value
     * @property {number} C2S_FETCH_APPLY_CREATE_COUNTRY_PLAYERS=262 C2S_FETCH_APPLY_CREATE_COUNTRY_PLAYERS value
     * @property {number} C2S_FETCH_CAMPAIGN_MISSION_INFO=263 C2S_FETCH_CAMPAIGN_MISSION_INFO value
     * @property {number} C2S_ACCEPT_CAMPAIGN_MISSION=264 C2S_ACCEPT_CAMPAIGN_MISSION value
     * @property {number} C2S_CANCEL_CAMPAIGN_MISSION=265 C2S_CANCEL_CAMPAIGN_MISSION value
     * @property {number} C2S_GET_CAMPAIGN_MISSION_REWARD=266 C2S_GET_CAMPAIGN_MISSION_REWARD value
     * @property {number} C2S_FETCH_PERSONAL_INFO=267 C2S_FETCH_PERSONAL_INFO value
     * @property {number} C2S_FETCH_CITY_PLAYERS=268 C2S_FETCH_CITY_PLAYERS value
     * @property {number} C2S_SET_FORAGE_PRICE=270 C2S_SET_FORAGE_PRICE value
     * @property {number} C2S_FETCH_FORAGE_PRICE=271 C2S_FETCH_FORAGE_PRICE value
     * @property {number} C2S_FETCH_CAMPAIGN_NOTICE=273 C2S_FETCH_CAMPAIGN_NOTICE value
     * @property {number} C2S_FETCH_COUNTRY_PLAYERS=274 C2S_FETCH_COUNTRY_PLAYERS value
     * @property {number} C2S_APPOINT_JOB=275 C2S_APPOINT_JOB value
     * @property {number} C2S_CAMPAIGN_PUBLISH_MISSION=276 C2S_CAMPAIGN_PUBLISH_MISSION value
     * @property {number} C2S_LEAVE_CAMPAIGN_SCENE=278 C2S_LEAVE_CAMPAIGN_SCENE value
     * @property {number} C2S_FETCH_ALL_CITY_PLAYER_AMOUNT=279 C2S_FETCH_ALL_CITY_PLAYER_AMOUNT value
     * @property {number} C2S_FETCH_COUNTRY_JOB_PLAYERS=280 C2S_FETCH_COUNTRY_JOB_PLAYERS value
     * @property {number} C2S_PATROL_CITY=281 C2S_PATROL_CITY value
     * @property {number} C2S_CITY_CAPITAL_INJECTION=282 C2S_CITY_CAPITAL_INJECTION value
     * @property {number} C2S_BEGIN_ATTACK_CITY=284 C2S_BEGIN_ATTACK_CITY value
     * @property {number} C2S_MOVE_CITY=285 C2S_MOVE_CITY value
     * @property {number} C2S_QUIT_COUNTRY=286 C2S_QUIT_COUNTRY value
     * @property {number} C2S_KICK_OUT_CITY_PLAYER=287 C2S_KICK_OUT_CITY_PLAYER value
     * @property {number} C2S_CANCEL_KICK_OUT_CITY_PLAYER=288 C2S_CANCEL_KICK_OUT_CITY_PLAYER value
     * @property {number} C2S_FETCH_AUTOCEPHALY_INFO=289 C2S_FETCH_AUTOCEPHALY_INFO value
     * @property {number} C2S_AUTOCEPHALY=290 C2S_AUTOCEPHALY value
     * @property {number} C2S_VOTE_AUTOCEPHALY=291 C2S_VOTE_AUTOCEPHALY value
     * @property {number} C2S_MY_TEAM_RETREAT=293 C2S_MY_TEAM_RETREAT value
     * @property {number} C2S_ACC_DEF_CITY_LOSE_LOADING=294 C2S_ACC_DEF_CITY_LOSE_LOADING value
     * @property {number} C2S_DEF_CITY=295 C2S_DEF_CITY value
     * @property {number} C2S_ESCAPED_FROM_JAIL=296 C2S_ESCAPED_FROM_JAIL value
     * @property {number} C2S_CAMPAIGN_SURRENDER=297 C2S_CAMPAIGN_SURRENDER value
     * @property {number} C2S_CAMPAIGN_RETIRE=298 C2S_CAMPAIGN_RETIRE value
     * @property {number} C2S_COUNTRY_MODIFY_NAME=299 C2S_COUNTRY_MODIFY_NAME value
     * @property {number} C2S_CANCEL_PUBLISH_MISSION=300 C2S_CANCEL_PUBLISH_MISSION value
     * @property {number} C2S_RECALL_JOB=301 C2S_RECALL_JOB value
     * @property {number} C2S_FETCH_SEASON_RANK=302 C2S_FETCH_SEASON_RANK value
     * @property {number} C2S_COUNTRY_MODIFY_FLAG=303 C2S_COUNTRY_MODIFY_FLAG value
     * @property {number} C2S_FETCH_CITY_CAPITAL_INJECTION_HISTORY=304 C2S_FETCH_CITY_CAPITAL_INJECTION_HISTORY value
     * @property {number} C2S_UPDATE_CITY_NOTICE=305 C2S_UPDATE_CITY_NOTICE value
     * @property {number} C2S_FETCH_CITY_NOTICE=306 C2S_FETCH_CITY_NOTICE value
     * @property {number} C2S_PUBLISH_MILITARY_ORDERS=307 C2S_PUBLISH_MILITARY_ORDERS value
     * @property {number} C2S_FETCH_MILITARY_ORDERS=308 C2S_FETCH_MILITARY_ORDERS value
     * @property {number} C2S_ACCEPT_MILITARY_ORDER=309 C2S_ACCEPT_MILITARY_ORDER value
     * @property {number} C2S_CANCEL_MILITARY_ORDER=310 C2S_CANCEL_MILITARY_ORDER value
     * @property {number} C2S_CANCEL_DEF_CITY=311 C2S_CANCEL_DEF_CITY value
     * @property {number} C2S_MY_TEAM_MARCH=312 C2S_MY_TEAM_MARCH value
     * @property {number} C2S_CAMPAIGN_BACK_CITY=313 C2S_CAMPAIGN_BACK_CITY value
     * @property {number} C2S_FETCH_IN_CITY_PLAYERS=314 C2S_FETCH_IN_CITY_PLAYERS value
     * @property {number} C2S_FETCH_CITY_CAPTIVES=315 C2S_FETCH_CITY_CAPTIVES value
     * @property {number} C2S_SURRENDER_CITY=316 C2S_SURRENDER_CITY value
     * @property {number} C2S_CAMPAIGN_BUY_GOODS=317 C2S_CAMPAIGN_BUY_GOODS value
     * @property {number} C2S_FIRE233_BIND_ACCOUNT=318 C2S_FIRE233_BIND_ACCOUNT value
     * @property {number} C2S_FETCH_FIRE233_BIND_ACCOUNT=319 C2S_FETCH_FIRE233_BIND_ACCOUNT value
     * @property {number} C2S_FETCH_HUODONG_DETAIL=320 C2S_FETCH_HUODONG_DETAIL value
     * @property {number} C2S_HUODONG_EXCHANGE=321 C2S_HUODONG_EXCHANGE value
     * @property {number} M2B_BEGIN_BATTLE=1000 M2B_BEGIN_BATTLE value
     * @property {number} L2B_BEGIN_LEVEL_BATTLE=1001 L2B_BEGIN_LEVEL_BATTLE value
     * @property {number} G2M_BEGIN_MATCH=1002 G2M_BEGIN_MATCH value
     * @property {number} G2M_BEGIN_GUIDE_MATCH=1003 G2M_BEGIN_GUIDE_MATCH value
     * @property {number} L2CA_SEND_CHAT=1004 L2CA_SEND_CHAT value
     * @property {number} G2G_LOAD_PLAYER=1005 G2G_LOAD_PLAYER value
     * @property {number} G2R_UPDATE_PVP_SCORE=1006 G2R_UPDATE_PVP_SCORE value
     * @property {number} B2V_SAVE_VIDEO=1007 B2V_SAVE_VIDEO value
     * @property {number} G2B_LOAD_BATTLE=1008 G2B_LOAD_BATTLE value
     * @property {number} G2G_WX_REPLY_INVITE_BATTLE=1009 G2G_WX_REPLY_INVITE_BATTLE value
     * @property {number} G2G_REPLY_INVITE_BATTLE=1011 G2G_REPLY_INVITE_BATTLE value
     * @property {number} L2B_BEGIN_LEVEL_HELP_BATTLE=1012 L2B_BEGIN_LEVEL_HELP_BATTLE value
     * @property {number} G2V_SHARE_VIDEO=1013 G2V_SHARE_VIDEO value
     * @property {number} G2M_BEGIN_NEWBIE_PVP_MATCH=1014 G2M_BEGIN_NEWBIE_PVP_MATCH value
     * @property {number} G2V_COMMENTS_VIDEO=1015 G2V_COMMENTS_VIDEO value
     * @property {number} G2G_INVITE_BATTLE=1016 G2G_INVITE_BATTLE value
     * @property {number} G2R_SEASON_PVP_BEGIN=1017 G2R_SEASON_PVP_BEGIN value
     * @property {number} G2R_FETCH_CUR_RANK=1018 G2R_FETCH_CUR_RANK value
     * @property {number} G2CA_SETTLE_CITY=1019 G2CA_SETTLE_CITY value
     * @property {number} G2CA_CREATE_COUNTRY=1020 G2CA_CREATE_COUNTRY value
     * @property {number} G2CA_ACCEPT_CAMPAIGN_MISSION=1021 G2CA_ACCEPT_CAMPAIGN_MISSION value
     * @property {number} G2CA_CANCEL_CAMPAIGN_MISSION=1022 G2CA_CANCEL_CAMPAIGN_MISSION value
     * @property {number} G2CA_GET_CAMPAIGN_MISSION_REWARD=1023 G2CA_GET_CAMPAIGN_MISSION_REWARD value
     * @property {number} G2CA_FETCH_CAMPAIGN_INFO=1024 G2CA_FETCH_CAMPAIGN_INFO value
     * @property {number} G2CA_CITY_CAPITAL_INJECTION=1025 G2CA_CITY_CAPITAL_INJECTION value
     * @property {number} G2CA_GET_MY_COUNTRY=1026 G2CA_GET_MY_COUNTRY value
     * @property {number} G2CA_MOVE_CITY=1027 G2CA_MOVE_CITY value
     * @property {number} G2CA_COUNTRY_MODIFY_NAME=1028 G2CA_COUNTRY_MODIFY_NAME value
     * @property {number} G2CA_CAMPAIGN_EXPEDITION=1029 G2CA_CAMPAIGN_EXPEDITION value
     * @property {number} L2G_GET_PVP_FIGHTER_DATA=1030 L2G_GET_PVP_FIGHTER_DATA value
     * @property {number} G2CA_CAMPAIGN_ON_BATTLE_END=1031 G2CA_CAMPAIGN_ON_BATTLE_END value
     * @property {number} G2CA_DEF_CITY=1032 G2CA_DEF_CITY value
     * @property {number} G2CA_FETCH_CAMPAIGN_PLAYER_INFO=1033 G2CA_FETCH_CAMPAIGN_PLAYER_INFO value
     * @property {number} CA2G_UPDATE_CAMPAIGN_PLAYER_INFO=1034 CA2G_UPDATE_CAMPAIGN_PLAYER_INFO value
     * @property {number} L2CA_SUBSCRIBE_CHAT=1035 L2CA_SUBSCRIBE_CHAT value
     * @property {number} G2R_SEASON_PVP_END=1036 G2R_SEASON_PVP_END value
     * @property {number} CA2G_CAMPAIGN_NOTICE_NOTIFY=1037 CA2G_CAMPAIGN_NOTICE_NOTIFY value
     * @property {number} G2CA_ACCEPT_MILITARY_ORDER=1038 G2CA_ACCEPT_MILITARY_ORDER value
     * @property {number} G2CA_GM_COMMAND=1039 G2CA_GM_COMMAND value
     * @property {number} G2CA_ESCAPED_FROM_JAIL=1040 G2CA_ESCAPED_FROM_JAIL value
     * @property {number} G2CA_GET_CAMPAIGN_INFO=1041 G2CA_GET_CAMPAIGN_INFO value
     * @property {number} CA2G_UPDATE_CAMPAIGN_INFO=1042 CA2G_UPDATE_CAMPAIGN_INFO value
     * @property {number} G2CA_IS_IN_CAMPAIGN_MATCH=1043 G2CA_IS_IN_CAMPAIGN_MATCH value
     * @property {number} G2CA_FETCH_CAMPAIGN_TARGET_PLAYER_INFO=1044 G2CA_FETCH_CAMPAIGN_TARGET_PLAYER_INFO value
     * @property {number} G2CA_MODIFY_CONTRIBUTION=1045 G2CA_MODIFY_CONTRIBUTION value
     * @property {number} G2G_GET_ONLINE_INFO=1046 G2G_GET_ONLINE_INFO value
     * @property {number} G2G_GET_CARD_AMOUNT_LOG=1047 G2G_GET_CARD_AMOUNT_LOG value
     * @property {number} G2G_GET_CARD_LEVEL_LOG=1048 G2G_GET_CARD_LEVEL_LOG value
     * @property {number} G2G_GET_CARD_POOL_LOG=1049 G2G_GET_CARD_POOL_LOG value
     * @property {number} S2C_UPDATE_MATCH_INFO=5000 S2C_UPDATE_MATCH_INFO value
     * @property {number} S2C_READY_FIGHT=5001 S2C_READY_FIGHT value
     * @property {number} S2C_FIGHT_BOUT_BEGIN=5002 S2C_FIGHT_BOUT_BEGIN value
     * @property {number} S2C_FIGHT_BOUT_RESULT=5003 S2C_FIGHT_BOUT_RESULT value
     * @property {number} S2C_FIGHT_BOUT_TIMEOUT=5004 S2C_FIGHT_BOUT_TIMEOUT value
     * @property {number} S2C_BATTLE_END=5005 S2C_BATTLE_END value
     * @property {number} S2C_LEVEL_FIGHT_END=5006 S2C_LEVEL_FIGHT_END value
     * @property {number} S2C_SYNC_CARD_INFO=5007 S2C_SYNC_CARD_INFO value
     * @property {number} S2C_CAMPAIGN_FIGHT_END=5008 S2C_CAMPAIGN_FIGHT_END value
     * @property {number} S2C_CAMPAIGN_BE_ATTACK=5009 S2C_CAMPAIGN_BE_ATTACK value
     * @property {number} S2C_SYNC_RESOURCE=5010 S2C_SYNC_RESOURCE value
     * @property {number} S2C_CHAPTER_UNLOCK=5011 S2C_CHAPTER_UNLOCK value
     * @property {number} S2C_UPDATE_FIGHT_CARD=5012 S2C_UPDATE_FIGHT_CARD value
     * @property {number} S2C_KICK_OUT=5013 S2C_KICK_OUT value
     * @property {number} S2C_GAIN_TREASURE=5014 S2C_GAIN_TREASURE value
     * @property {number} S2C_TUTORIAL_FIGHT_END=5015 S2C_TUTORIAL_FIGHT_END value
     * @property {number} S2C_MATCH_TIMEOUT=5016 S2C_MATCH_TIMEOUT value
     * @property {number} S2C_REFRESH_RANK=5017 S2C_REFRESH_RANK value
     * @property {number} S2C_UPDATE_DAILY_TREASURE=5020 S2C_UPDATE_DAILY_TREASURE value
     * @property {number} S2C_SYNC_EMOJI=5021 S2C_SYNC_EMOJI value
     * @property {number} S2C_UPDATE_VERSION=5022 S2C_UPDATE_VERSION value
     * @property {number} S2C_FRIEND_APPLY_NOTIFY=5023 S2C_FRIEND_APPLY_NOTIFY value
     * @property {number} S2C_FRIEND_APPLY_RESULT=5024 S2C_FRIEND_APPLY_RESULT value
     * @property {number} S2C_PRIVATE_CHAT_NOTIFY=5025 S2C_PRIVATE_CHAT_NOTIFY value
     * @property {number} S2C_CHAT_NOTIFY=5026 S2C_CHAT_NOTIFY value
     * @property {number} S2C_BE_INVITE_BATTLE=5027 S2C_BE_INVITE_BATTLE value
     * @property {number} S2C_INVITE_BATTLE_RESULT=5028 S2C_INVITE_BATTLE_RESULT value
     * @property {number} S2C_BE_DEL_FRIEND=5029 S2C_BE_DEL_FRIEND value
     * @property {number} S2C_WX_INVITE_BATTLE_RESULT=5030 S2C_WX_INVITE_BATTLE_RESULT value
     * @property {number} S2C_DAILY_TREASURE_BE_HELP=5031 S2C_DAILY_TREASURE_BE_HELP value
     * @property {number} S2C_TREASURE_BE_HELP=5032 S2C_TREASURE_BE_HELP value
     * @property {number} S2C_BATTLE_LOSE_BE_HELP=5033 S2C_BATTLE_LOSE_BE_HELP value
     * @property {number} S2C_UPDATE_WX_EXAMINE_STATE=5034 S2C_UPDATE_WX_EXAMINE_STATE value
     * @property {number} S2C_LEVEL_BE_HELP=5035 S2C_LEVEL_BE_HELP value
     * @property {number} S2C_READY_LEVEL_FIGHT=5036 S2C_READY_LEVEL_FIGHT value
     * @property {number} S2C_TRIGGER_SHOP_ADD_GOLD_ADS=5037 S2C_TRIGGER_SHOP_ADD_GOLD_ADS value
     * @property {number} S2C_MISSION_SHOW_RED_DOT=5038 S2C_MISSION_SHOW_RED_DOT value
     * @property {number} S2C_UPDATE_MISSION_INFO=5039 S2C_UPDATE_MISSION_INFO value
     * @property {number} S2C_UPDATE_MISSION_PROCESS=5040 S2C_UPDATE_MISSION_PROCESS value
     * @property {number} S2C_UPDATE_MISSION_TREASURE_PROCESS=5041 S2C_UPDATE_MISSION_TREASURE_PROCESS value
     * @property {number} S2C_WX_INVITE_SHOW_RED_DOT=5042 S2C_WX_INVITE_SHOW_RED_DOT value
     * @property {number} S2C_WX_SHARE_BE_HELP=5043 S2C_WX_SHARE_BE_HELP value
     * @property {number} S2C_NOTIFY_NEW_MAIL=5044 S2C_NOTIFY_NEW_MAIL value
     * @property {number} S2C_NOTIFY_SDK_RECHARGE_RESULT=5045 S2C_NOTIFY_SDK_RECHARGE_RESULT value
     * @property {number} S2C_ON_CROSS_DAY=5046 S2C_ON_CROSS_DAY value
     * @property {number} S2C_SEASON_PVP_BEGIN=5047 S2C_SEASON_PVP_BEGIN value
     * @property {number} S2C_SEASON_PVP_STOP=5048 S2C_SEASON_PVP_STOP value
     * @property {number} S2C_ADD_CARD_SKIN=5049 S2C_ADD_CARD_SKIN value
     * @property {number} S2C_BEGIN_SEASON_BATTLE=5050 S2C_BEGIN_SEASON_BATTLE value
     * @property {number} S2C_SEASON_BATTLE_BEGIN=5051 S2C_SEASON_BATTLE_BEGIN value
     * @property {number} S2C_SEASON_PVP_CHANGE_HAND_CARD=5052 S2C_SEASON_PVP_CHANGE_HAND_CARD value
     * @property {number} S2C_ADD_EQUIP=5053 S2C_ADD_EQUIP value
     * @property {number} S2C_TELL_ME=5054 S2C_TELL_ME value
     * @property {number} S2C_UNLOCK_EMOJI=5055 S2C_UNLOCK_EMOJI value
     * @property {number} S2C_ADD_VIP=5056 S2C_ADD_VIP value
     * @property {number} S2C_VIP_TIMEOUT=5057 S2C_VIP_TIMEOUT value
     * @property {number} S2C_COUNTRY_CREATED=5058 S2C_COUNTRY_CREATED value
     * @property {number} S2C_CITY_BE_OCCUPY=5059 S2C_CITY_BE_OCCUPY value
     * @property {number} S2C_UPDATE_FORAGE=5060 S2C_UPDATE_FORAGE value
     * @property {number} S2C_CAMPAIGN_NOTIFY_RED_DOT=5061 S2C_CAMPAIGN_NOTIFY_RED_DOT value
     * @property {number} S2C_SYNC_CITY_DEFENSE=5062 S2C_SYNC_CITY_DEFENSE value
     * @property {number} S2C_UPDATE_CAMPAIGN_STATE=5063 S2C_UPDATE_CAMPAIGN_STATE value
     * @property {number} S2C_UPDATE_CITY_BE_ATTACK_STATE=5064 S2C_UPDATE_CITY_BE_ATTACK_STATE value
     * @property {number} S2C_CAMPAIGN_UPDATE_JOB=5065 S2C_CAMPAIGN_UPDATE_JOB value
     * @property {number} S2C_MY_TEAM_CAN_ATTACK_CITY=5066 S2C_MY_TEAM_CAN_ATTACK_CITY value
     * @property {number} S2C_TO_BE_CAPTIVE=5067 S2C_TO_BE_CAPTIVE value
     * @property {number} S2C_UPDATE_MY_CITY=5068 S2C_UPDATE_MY_CITY value
     * @property {number} S2C_UPDATE_MY_COUNTRY=5069 S2C_UPDATE_MY_COUNTRY value
     * @property {number} S2C_COUNTRY_WAR_END=5072 S2C_COUNTRY_WAR_END value
     * @property {number} S2C_UPDATE_COUNTRY_NAME=5073 S2C_UPDATE_COUNTRY_NAME value
     * @property {number} S2C_TO_BE_UN_CAPTIVE=5074 S2C_TO_BE_UN_CAPTIVE value
     * @property {number} S2C_UNIFIED_WORLD=5075 S2C_UNIFIED_WORLD value
     * @property {number} S2C_UPDATE_CAMPAIGN_TEAMS=5076 S2C_UPDATE_CAMPAIGN_TEAMS value
     * @property {number} S2C_COUNTRY_DESTORYED=5077 S2C_COUNTRY_DESTORYED value
     * @property {number} S2C_UPDATE_COUNTRY_FLAG=5078 S2C_UPDATE_COUNTRY_FLAG value
     * @property {number} S2C_UPDATE_CONTRIBUTION=5079 S2C_UPDATE_CONTRIBUTION value
     * @property {number} S2C_ON_UNSUBSCRIBE_CHAT=5080 S2C_ON_UNSUBSCRIBE_CHAT value
     * @property {number} S2C_SYNC_CITY_PLYAER_AMOUNT=5081 S2C_SYNC_CITY_PLYAER_AMOUNT value
     * @property {number} S2C_UPDATE_CITY_STATE=5082 S2C_UPDATE_CITY_STATE value
     * @property {number} S2C_UPDATE_CAMPAIGN_PLAYER_STATE=5083 S2C_UPDATE_CAMPAIGN_PLAYER_STATE value
     * @property {number} S2C_UPDATE_MY_TEAM_STATE=5084 S2C_UPDATE_MY_TEAM_STATE value
     * @property {number} S2C_UPDATE_CAMPAIGN_SUPPORT_CARDS=5085 S2C_UPDATE_CAMPAIGN_SUPPORT_CARDS value
     * @property {number} S2C_UPDATE_CITY_COUNTRY=5086 S2C_UPDATE_CITY_COUNTRY value
     * @property {number} S2C_ADD_MIN_VIP=5087 S2C_ADD_MIN_VIP value
     * @property {number} S2C_MIN_VIP_TIMEOUT=5088 S2C_MIN_VIP_TIMEOUT value
     * @property {number} S2C_SYNC_DEF_CITY_PLAYER_AMOUNT=5089 S2C_SYNC_DEF_CITY_PLAYER_AMOUNT value
     * @property {number} S2C_ADD_NEWBIE_VIP=5090 S2C_ADD_NEWBIE_VIP value
     * @property {number} S2C_NEWBIE_VIP_TIMEOUT=5091 S2C_NEWBIE_VIP_TIMEOUT value
     * @property {number} S2C_HUODONG_BEGIN=5092 S2C_HUODONG_BEGIN value
     * @property {number} S2C_HUODONG_END=5093 S2C_HUODONG_END value
     */
    pb.MessageID = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOW_MessageID"] = 0;
        values[valuesById[100] = "C2S_LOGIN"] = 100;
        values[valuesById[101] = "C2S_BEGIN_MATCH"] = 101;
        values[valuesById[102] = "C2S_STOP_MATCH"] = 102;
        values[valuesById[103] = "C2S_FIGHT_BOUT_READY_DONE"] = 103;
        values[valuesById[104] = "C2S_FIGHT_BOUT_CMD"] = 104;
        values[valuesById[105] = "C2S_FETCH_CARD_DATA"] = 105;
        values[valuesById[106] = "C2S_MATCH_ADD_ROBOT"] = 106;
        values[valuesById[107] = "C2S_POOL_ADD_CARD"] = 107;
        values[valuesById[108] = "C2S_UPDATE_CARD_POOL"] = 108;
        values[valuesById[109] = "C2S_UPLEVEL_CARD"] = 109;
        values[valuesById[110] = "C2S_FETCH_LEVEL_INFO"] = 110;
        values[valuesById[111] = "C2S_BEGIN_LEVEL_BATTLE"] = 111;
        values[valuesById[112] = "C2S_LEVEL_READY_DONE"] = 112;
        values[valuesById[113] = "C2S_FIGHT_SURRENDER"] = 113;
        values[valuesById[114] = "C2S_GM_COMMAND"] = 114;
        values[valuesById[115] = "C2S_FETCH_CAMPAIGN_INFO"] = 115;
        values[valuesById[116] = "C2S_BEGIN_CAMPAIGN_FIGHT"] = 116;
        values[valuesById[118] = "C2S_UPDATE_CAMPAIGN_GUARD"] = 118;
        values[valuesById[119] = "C2S_CAMPAIGN_FETCH_VIDEO"] = 119;
        values[valuesById[120] = "C2S_CAMPAIGN_MARCH"] = 120;
        values[valuesById[121] = "C2S_CAMPAIGN_DISMISS"] = 121;
        values[valuesById[122] = "C2S_CARD_RELIVE"] = 122;
        values[valuesById[123] = "C2S_FIGHT_GM_WIN"] = 123;
        values[valuesById[124] = "C2S_CARD_TREAT"] = 124;
        values[valuesById[125] = "C2S_DIY_CARD"] = 125;
        values[valuesById[126] = "C2S_FETCH_DIY_CARD_IMG"] = 126;
        values[valuesById[127] = "C2S_EXCHANGE_RESOURCE"] = 127;
        values[valuesById[128] = "C2S_DIY_CARD_AGAIN"] = 128;
        values[valuesById[129] = "C2S_DECOMPOSE_DIY_CARD"] = 129;
        values[valuesById[130] = "C2S_POOL_UPDATE_CARD"] = 130;
        values[valuesById[131] = "C2S_LOAD_FIGHT"] = 131;
        values[valuesById[132] = "C2S_ACCOUNT_LOGIN"] = 132;
        values[valuesById[133] = "C2S_DEL_ARCHIVES"] = 133;
        values[valuesById[134] = "C2S_PLAYER_LOGOUT"] = 134;
        values[valuesById[135] = "C2S_EXCHANGE_EXPED_CARD"] = 135;
        values[valuesById[136] = "C2S_FINISH_GUIDE"] = 136;
        values[valuesById[137] = "C2S_FETCH_GUIDE"] = 137;
        values[valuesById[138] = "C2S_CAMPAIGN_DEF_ENEMY"] = 138;
        values[valuesById[139] = "C2S_PING"] = 139;
        values[valuesById[140] = "C2S_GET_TREASURES"] = 140;
        values[valuesById[141] = "C2S_OPEN_TREASURE"] = 141;
        values[valuesById[142] = "C2S_ACTIVATE_REWARD_TREASURE"] = 142;
        values[valuesById[143] = "C2S_GET_CAMP_ID"] = 143;
        values[valuesById[144] = "C2S_SET_CAMP_ID"] = 144;
        values[valuesById[145] = "C2S_START_TUTORIAL_BATTLE"] = 145;
        values[valuesById[146] = "C2S_MATCH_READY_DONE"] = 146;
        values[valuesById[147] = "C2S_FETCH_RANK"] = 147;
        values[valuesById[148] = "C2S_FETCH_RANK_USER"] = 148;
        values[valuesById[149] = "C2S_OPEN_LEVEL_TREASURE"] = 149;
        values[valuesById[150] = "C2S_GET_BATTLE_VIDEO"] = 150;
        values[valuesById[151] = "C2S_SEND_EMOJI"] = 151;
        values[valuesById[152] = "C2S_REGISTER_ACCOUNT"] = 152;
        values[valuesById[153] = "C2S_FETCH_VIDEO_LIST"] = 153;
        values[valuesById[154] = "C2S_WATCH_VIDEO"] = 154;
        values[valuesById[155] = "C2S_FETCH_SELF_VIDEO_LIST"] = 155;
        values[valuesById[156] = "C2S_LIKE_VIDEO"] = 156;
        values[valuesById[157] = "C2S_SHARE_VIDEO"] = 157;
        values[valuesById[158] = "C2S_FETCH_SURVEY_INFO"] = 158;
        values[valuesById[159] = "C2S_COMPLETE_SURVEY"] = 159;
        values[valuesById[160] = "C2S_GET_SURVEY_REWARD"] = 160;
        values[valuesById[161] = "C2S_MODIFY_NAME"] = 161;
        values[valuesById[162] = "C2S_SDK_ACCOUNT_LOGIN"] = 162;
        values[valuesById[163] = "C2S_EXCHANGE_GIFT_CODE"] = 163;
        values[valuesById[164] = "C2S_FETCH_VERSION"] = 164;
        values[valuesById[165] = "C2S_FETCH_FRIEND_LIST"] = 165;
        values[valuesById[166] = "C2S_FETCH_PLAYER_INFO"] = 166;
        values[valuesById[167] = "C2S_ADD_FRIEND_APPLY"] = 167;
        values[valuesById[168] = "C2S_FETCH_FRIEND_APPLY_LIST"] = 168;
        values[valuesById[169] = "C2S_REPLY_AFRIEND_APPLY"] = 169;
        values[valuesById[170] = "C2S_DEL_FRIEND"] = 170;
        values[valuesById[171] = "C2S_FETCH_PRIVATE_CHAT"] = 171;
        values[valuesById[172] = "C2S_SEND_PRIVATE_CHAT"] = 172;
        values[valuesById[173] = "C2S_SUBSCRIBE_CHAT"] = 173;
        values[valuesById[174] = "C2S_UNSUBSCRIBE_CHAT"] = 174;
        values[valuesById[175] = "C2S_SEND_CHAT"] = 175;
        values[valuesById[176] = "C2S_INVITE_BATTLE"] = 176;
        values[valuesById[177] = "C2S_CANCEL_INVITE_BATTLE"] = 177;
        values[valuesById[178] = "C2S_REPLY_INVITE_BATTLE"] = 178;
        values[valuesById[179] = "C2S_UPDATE_SDK_USER_INFO"] = 179;
        values[valuesById[180] = "C2S_WX_INVITE_BATTLE"] = 180;
        values[valuesById[181] = "C2S_WX_CANCEL_INVITE_BATTLE"] = 181;
        values[valuesById[182] = "C2S_WX_REPLY_INVITE_BATTLE"] = 182;
        values[valuesById[183] = "C2S_GET_SHARE_TREASURE_REWARD"] = 183;
        values[valuesById[184] = "C2S_HELP_SHARE_TREASURE"] = 184;
        values[valuesById[185] = "C2S_SHARE_TREASURE"] = 185;
        values[valuesById[186] = "C2S_SHARE_BATTLE_LOSE"] = 186;
        values[valuesById[187] = "C2S_END_SHARE_BATTLE_LOSE"] = 187;
        values[valuesById[188] = "C2S_JADE_ACC_TREASURE"] = 188;
        values[valuesById[189] = "C2S_FETCH_SHOP_DATA"] = 189;
        values[valuesById[190] = "C2S_BUY_LIMIT_GITF"] = 190;
        values[valuesById[191] = "C2S_BUY_JADE"] = 191;
        values[valuesById[192] = "C2S_BUY_SOLDTREASURE"] = 192;
        values[valuesById[193] = "C2S_BUY_GOLD"] = 193;
        values[valuesById[194] = "C2S_DAILY_TREASURE_READ_ADS"] = 194;
        values[valuesById[195] = "C2S_TREASURE_READ_ADS"] = 195;
        values[valuesById[196] = "C2S_BATTLE_LOSE_READ_ADS"] = 196;
        values[valuesById[197] = "C2S_RECORD_CUR_GUIDE_GROUP"] = 197;
        values[valuesById[198] = "C2S_FETCH_CUR_GUIDE_GROUP"] = 198;
        values[valuesById[199] = "C2S_UPDATE_HEADIMG"] = 199;
        values[valuesById[200] = "C2S_FETCH_LEVEL_HELP_RECORD"] = 200;
        values[valuesById[201] = "C2S_LEVEL_HELP_OTHER"] = 201;
        values[valuesById[202] = "C2S_HELP_SHARE_BATTLE_LOSE"] = 202;
        values[valuesById[203] = "C2S_WATCH_UP_TREASURE_RARE_ADS"] = 203;
        values[valuesById[204] = "C2S_WATCH_SHOP_FREE_ADS"] = 204;
        values[valuesById[205] = "C2S_WATCH_TREASURE_ADD_CARD_ADS"] = 205;
        values[valuesById[206] = "C2S_WATCH_HELP_VIDEO"] = 206;
        values[valuesById[207] = "C2S_FETCH_MISSION_INFO"] = 207;
        values[valuesById[208] = "C2S_REFRESH_MISSION"] = 208;
        values[valuesById[209] = "C2S_GET_MISSION_REWARD"] = 209;
        values[valuesById[210] = "C2S_OPEN_MISSION_TREASURE"] = 210;
        values[valuesById[211] = "C2S_WXGAME_SHARE"] = 211;
        values[valuesById[212] = "C2S_WATCH_OUT_VIDEO"] = 212;
        values[valuesById[213] = "C2S_FETCH_VIDEO_COMMENTS"] = 213;
        values[valuesById[214] = "C2S_LIKE_VIDEO_COMMENTS"] = 214;
        values[valuesById[215] = "C2S_COMMENTS_VIDEO"] = 215;
        values[valuesById[216] = "C2S_FETCH_WX_INVITE_FRIENDS"] = 216;
        values[valuesById[217] = "C2S_GET_WX_INVITE_REWARD"] = 217;
        values[valuesById[218] = "C2S_CLICK_WXGAME_SHARE"] = 218;
        values[valuesById[219] = "C2S_WATCH_ADS_BEGIN"] = 219;
        values[valuesById[220] = "C2S_WATCH_ADS_END"] = 220;
        values[valuesById[221] = "C2S_CANCEL_WX_SHARE"] = 221;
        values[valuesById[222] = "C2S_FETCH_MAIL_LIST"] = 222;
        values[valuesById[223] = "C2S_GET_MAIL_REWARD"] = 223;
        values[valuesById[224] = "C2S_READ_MAIL"] = 224;
        values[valuesById[225] = "C2S_GET_ALL_MAIL_REWARD"] = 225;
        values[valuesById[226] = "C2S_SDK_CREATE_ORDER"] = 226;
        values[valuesById[227] = "C2S_UPDATE_NAME"] = 227;
        values[valuesById[228] = "C2S_IOS_PRE_PAY"] = 228;
        values[valuesById[229] = "C2S_IOS_SHARE"] = 229;
        values[valuesById[230] = "C2S_FETCH_LEVEL_VIDEO_ID"] = 230;
        values[valuesById[231] = "C2S_BUY_LIMIT_GITF_BY_JADE"] = 231;
        values[valuesById[232] = "C2S_TOURIST_REGISTER_ACCOUNT"] = 232;
        values[valuesById[233] = "C2S_GOOGLE_PLAY_RECHARGE"] = 233;
        values[valuesById[234] = "C2S_TOURIST_BIND_ACCOUNT"] = 234;
        values[valuesById[235] = "C2S_FETCH_SEASON_PVP_LIMIT_TIME"] = 235;
        values[valuesById[236] = "C2S_FETCH_SEASON_PVP_INFO"] = 236;
        values[valuesById[237] = "C2S_BUY_VIP_CARD"] = 237;
        values[valuesById[238] = "C2S_UPDATE_CARD_SKIN"] = 238;
        values[valuesById[239] = "C2S_FETCH_HEAD_FRAME"] = 239;
        values[valuesById[240] = "C2S_UPDATE_HEAD_FRAME"] = 240;
        values[valuesById[241] = "C2S_GET_FBADVERT_REWARD"] = 241;
        values[valuesById[242] = "C2S_REFINE_CARD"] = 242;
        values[valuesById[243] = "C2S_REBORN"] = 243;
        values[valuesById[244] = "C2S_BUY_REBORN_GOODS"] = 244;
        values[valuesById[245] = "C2S_FETCH_REBORN_DATA"] = 245;
        values[valuesById[246] = "C2S_FETCH_VIDEO_ITEM"] = 246;
        values[valuesById[247] = "C2S_SEASON_BATTLE_READY_DONE"] = 247;
        values[valuesById[248] = "C2S_FETCH_HEAD"] = 248;
        values[valuesById[249] = "C2S_SEASON_PVP_CHOOSE_CAMP"] = 249;
        values[valuesById[250] = "C2S_SEASON_PVP_CHOOSE_CARD"] = 250;
        values[valuesById[251] = "C2S_FETCH_SEASON_HAND_CARD"] = 251;
        values[valuesById[252] = "C2S_FETCH_EQUIP"] = 252;
        values[valuesById[253] = "C2S_WEAR_EQUIP"] = 253;
        values[valuesById[254] = "C2S_DE_EQUIP"] = 254;
        values[valuesById[255] = "C2S_REFRESH_SEASON_PVP_CHOOSE_CARD"] = 255;
        values[valuesById[256] = "C2S_FETCH_EMOJI"] = 256;
        values[valuesById[257] = "C2S_FETCH_VIP_REMAIN_TIME"] = 257;
        values[valuesById[258] = "C2S_SETTLE_CITY"] = 258;
        values[valuesById[259] = "C2S_CREATE_COUNTRY"] = 259;
        values[valuesById[260] = "C2S_FETCH_CITY_DATA"] = 260;
        values[valuesById[261] = "C2S_FETCH_APPLY_CREATE_COUNTRY_INFO"] = 261;
        values[valuesById[262] = "C2S_FETCH_APPLY_CREATE_COUNTRY_PLAYERS"] = 262;
        values[valuesById[263] = "C2S_FETCH_CAMPAIGN_MISSION_INFO"] = 263;
        values[valuesById[264] = "C2S_ACCEPT_CAMPAIGN_MISSION"] = 264;
        values[valuesById[265] = "C2S_CANCEL_CAMPAIGN_MISSION"] = 265;
        values[valuesById[266] = "C2S_GET_CAMPAIGN_MISSION_REWARD"] = 266;
        values[valuesById[267] = "C2S_FETCH_PERSONAL_INFO"] = 267;
        values[valuesById[268] = "C2S_FETCH_CITY_PLAYERS"] = 268;
        values[valuesById[270] = "C2S_SET_FORAGE_PRICE"] = 270;
        values[valuesById[271] = "C2S_FETCH_FORAGE_PRICE"] = 271;
        values[valuesById[273] = "C2S_FETCH_CAMPAIGN_NOTICE"] = 273;
        values[valuesById[274] = "C2S_FETCH_COUNTRY_PLAYERS"] = 274;
        values[valuesById[275] = "C2S_APPOINT_JOB"] = 275;
        values[valuesById[276] = "C2S_CAMPAIGN_PUBLISH_MISSION"] = 276;
        values[valuesById[278] = "C2S_LEAVE_CAMPAIGN_SCENE"] = 278;
        values[valuesById[279] = "C2S_FETCH_ALL_CITY_PLAYER_AMOUNT"] = 279;
        values[valuesById[280] = "C2S_FETCH_COUNTRY_JOB_PLAYERS"] = 280;
        values[valuesById[281] = "C2S_PATROL_CITY"] = 281;
        values[valuesById[282] = "C2S_CITY_CAPITAL_INJECTION"] = 282;
        values[valuesById[284] = "C2S_BEGIN_ATTACK_CITY"] = 284;
        values[valuesById[285] = "C2S_MOVE_CITY"] = 285;
        values[valuesById[286] = "C2S_QUIT_COUNTRY"] = 286;
        values[valuesById[287] = "C2S_KICK_OUT_CITY_PLAYER"] = 287;
        values[valuesById[288] = "C2S_CANCEL_KICK_OUT_CITY_PLAYER"] = 288;
        values[valuesById[289] = "C2S_FETCH_AUTOCEPHALY_INFO"] = 289;
        values[valuesById[290] = "C2S_AUTOCEPHALY"] = 290;
        values[valuesById[291] = "C2S_VOTE_AUTOCEPHALY"] = 291;
        values[valuesById[293] = "C2S_MY_TEAM_RETREAT"] = 293;
        values[valuesById[294] = "C2S_ACC_DEF_CITY_LOSE_LOADING"] = 294;
        values[valuesById[295] = "C2S_DEF_CITY"] = 295;
        values[valuesById[296] = "C2S_ESCAPED_FROM_JAIL"] = 296;
        values[valuesById[297] = "C2S_CAMPAIGN_SURRENDER"] = 297;
        values[valuesById[298] = "C2S_CAMPAIGN_RETIRE"] = 298;
        values[valuesById[299] = "C2S_COUNTRY_MODIFY_NAME"] = 299;
        values[valuesById[300] = "C2S_CANCEL_PUBLISH_MISSION"] = 300;
        values[valuesById[301] = "C2S_RECALL_JOB"] = 301;
        values[valuesById[302] = "C2S_FETCH_SEASON_RANK"] = 302;
        values[valuesById[303] = "C2S_COUNTRY_MODIFY_FLAG"] = 303;
        values[valuesById[304] = "C2S_FETCH_CITY_CAPITAL_INJECTION_HISTORY"] = 304;
        values[valuesById[305] = "C2S_UPDATE_CITY_NOTICE"] = 305;
        values[valuesById[306] = "C2S_FETCH_CITY_NOTICE"] = 306;
        values[valuesById[307] = "C2S_PUBLISH_MILITARY_ORDERS"] = 307;
        values[valuesById[308] = "C2S_FETCH_MILITARY_ORDERS"] = 308;
        values[valuesById[309] = "C2S_ACCEPT_MILITARY_ORDER"] = 309;
        values[valuesById[310] = "C2S_CANCEL_MILITARY_ORDER"] = 310;
        values[valuesById[311] = "C2S_CANCEL_DEF_CITY"] = 311;
        values[valuesById[312] = "C2S_MY_TEAM_MARCH"] = 312;
        values[valuesById[313] = "C2S_CAMPAIGN_BACK_CITY"] = 313;
        values[valuesById[314] = "C2S_FETCH_IN_CITY_PLAYERS"] = 314;
        values[valuesById[315] = "C2S_FETCH_CITY_CAPTIVES"] = 315;
        values[valuesById[316] = "C2S_SURRENDER_CITY"] = 316;
        values[valuesById[317] = "C2S_CAMPAIGN_BUY_GOODS"] = 317;
        values[valuesById[318] = "C2S_FIRE233_BIND_ACCOUNT"] = 318;
        values[valuesById[319] = "C2S_FETCH_FIRE233_BIND_ACCOUNT"] = 319;
        values[valuesById[320] = "C2S_FETCH_HUODONG_DETAIL"] = 320;
        values[valuesById[321] = "C2S_HUODONG_EXCHANGE"] = 321;
        values[valuesById[1000] = "M2B_BEGIN_BATTLE"] = 1000;
        values[valuesById[1001] = "L2B_BEGIN_LEVEL_BATTLE"] = 1001;
        values[valuesById[1002] = "G2M_BEGIN_MATCH"] = 1002;
        values[valuesById[1003] = "G2M_BEGIN_GUIDE_MATCH"] = 1003;
        values[valuesById[1004] = "L2CA_SEND_CHAT"] = 1004;
        values[valuesById[1005] = "G2G_LOAD_PLAYER"] = 1005;
        values[valuesById[1006] = "G2R_UPDATE_PVP_SCORE"] = 1006;
        values[valuesById[1007] = "B2V_SAVE_VIDEO"] = 1007;
        values[valuesById[1008] = "G2B_LOAD_BATTLE"] = 1008;
        values[valuesById[1009] = "G2G_WX_REPLY_INVITE_BATTLE"] = 1009;
        values[valuesById[1011] = "G2G_REPLY_INVITE_BATTLE"] = 1011;
        values[valuesById[1012] = "L2B_BEGIN_LEVEL_HELP_BATTLE"] = 1012;
        values[valuesById[1013] = "G2V_SHARE_VIDEO"] = 1013;
        values[valuesById[1014] = "G2M_BEGIN_NEWBIE_PVP_MATCH"] = 1014;
        values[valuesById[1015] = "G2V_COMMENTS_VIDEO"] = 1015;
        values[valuesById[1016] = "G2G_INVITE_BATTLE"] = 1016;
        values[valuesById[1017] = "G2R_SEASON_PVP_BEGIN"] = 1017;
        values[valuesById[1018] = "G2R_FETCH_CUR_RANK"] = 1018;
        values[valuesById[1019] = "G2CA_SETTLE_CITY"] = 1019;
        values[valuesById[1020] = "G2CA_CREATE_COUNTRY"] = 1020;
        values[valuesById[1021] = "G2CA_ACCEPT_CAMPAIGN_MISSION"] = 1021;
        values[valuesById[1022] = "G2CA_CANCEL_CAMPAIGN_MISSION"] = 1022;
        values[valuesById[1023] = "G2CA_GET_CAMPAIGN_MISSION_REWARD"] = 1023;
        values[valuesById[1024] = "G2CA_FETCH_CAMPAIGN_INFO"] = 1024;
        values[valuesById[1025] = "G2CA_CITY_CAPITAL_INJECTION"] = 1025;
        values[valuesById[1026] = "G2CA_GET_MY_COUNTRY"] = 1026;
        values[valuesById[1027] = "G2CA_MOVE_CITY"] = 1027;
        values[valuesById[1028] = "G2CA_COUNTRY_MODIFY_NAME"] = 1028;
        values[valuesById[1029] = "G2CA_CAMPAIGN_EXPEDITION"] = 1029;
        values[valuesById[1030] = "L2G_GET_PVP_FIGHTER_DATA"] = 1030;
        values[valuesById[1031] = "G2CA_CAMPAIGN_ON_BATTLE_END"] = 1031;
        values[valuesById[1032] = "G2CA_DEF_CITY"] = 1032;
        values[valuesById[1033] = "G2CA_FETCH_CAMPAIGN_PLAYER_INFO"] = 1033;
        values[valuesById[1034] = "CA2G_UPDATE_CAMPAIGN_PLAYER_INFO"] = 1034;
        values[valuesById[1035] = "L2CA_SUBSCRIBE_CHAT"] = 1035;
        values[valuesById[1036] = "G2R_SEASON_PVP_END"] = 1036;
        values[valuesById[1037] = "CA2G_CAMPAIGN_NOTICE_NOTIFY"] = 1037;
        values[valuesById[1038] = "G2CA_ACCEPT_MILITARY_ORDER"] = 1038;
        values[valuesById[1039] = "G2CA_GM_COMMAND"] = 1039;
        values[valuesById[1040] = "G2CA_ESCAPED_FROM_JAIL"] = 1040;
        values[valuesById[1041] = "G2CA_GET_CAMPAIGN_INFO"] = 1041;
        values[valuesById[1042] = "CA2G_UPDATE_CAMPAIGN_INFO"] = 1042;
        values[valuesById[1043] = "G2CA_IS_IN_CAMPAIGN_MATCH"] = 1043;
        values[valuesById[1044] = "G2CA_FETCH_CAMPAIGN_TARGET_PLAYER_INFO"] = 1044;
        values[valuesById[1045] = "G2CA_MODIFY_CONTRIBUTION"] = 1045;
        values[valuesById[1046] = "G2G_GET_ONLINE_INFO"] = 1046;
        values[valuesById[1047] = "G2G_GET_CARD_AMOUNT_LOG"] = 1047;
        values[valuesById[1048] = "G2G_GET_CARD_LEVEL_LOG"] = 1048;
        values[valuesById[1049] = "G2G_GET_CARD_POOL_LOG"] = 1049;
        values[valuesById[5000] = "S2C_UPDATE_MATCH_INFO"] = 5000;
        values[valuesById[5001] = "S2C_READY_FIGHT"] = 5001;
        values[valuesById[5002] = "S2C_FIGHT_BOUT_BEGIN"] = 5002;
        values[valuesById[5003] = "S2C_FIGHT_BOUT_RESULT"] = 5003;
        values[valuesById[5004] = "S2C_FIGHT_BOUT_TIMEOUT"] = 5004;
        values[valuesById[5005] = "S2C_BATTLE_END"] = 5005;
        values[valuesById[5006] = "S2C_LEVEL_FIGHT_END"] = 5006;
        values[valuesById[5007] = "S2C_SYNC_CARD_INFO"] = 5007;
        values[valuesById[5008] = "S2C_CAMPAIGN_FIGHT_END"] = 5008;
        values[valuesById[5009] = "S2C_CAMPAIGN_BE_ATTACK"] = 5009;
        values[valuesById[5010] = "S2C_SYNC_RESOURCE"] = 5010;
        values[valuesById[5011] = "S2C_CHAPTER_UNLOCK"] = 5011;
        values[valuesById[5012] = "S2C_UPDATE_FIGHT_CARD"] = 5012;
        values[valuesById[5013] = "S2C_KICK_OUT"] = 5013;
        values[valuesById[5014] = "S2C_GAIN_TREASURE"] = 5014;
        values[valuesById[5015] = "S2C_TUTORIAL_FIGHT_END"] = 5015;
        values[valuesById[5016] = "S2C_MATCH_TIMEOUT"] = 5016;
        values[valuesById[5017] = "S2C_REFRESH_RANK"] = 5017;
        values[valuesById[5020] = "S2C_UPDATE_DAILY_TREASURE"] = 5020;
        values[valuesById[5021] = "S2C_SYNC_EMOJI"] = 5021;
        values[valuesById[5022] = "S2C_UPDATE_VERSION"] = 5022;
        values[valuesById[5023] = "S2C_FRIEND_APPLY_NOTIFY"] = 5023;
        values[valuesById[5024] = "S2C_FRIEND_APPLY_RESULT"] = 5024;
        values[valuesById[5025] = "S2C_PRIVATE_CHAT_NOTIFY"] = 5025;
        values[valuesById[5026] = "S2C_CHAT_NOTIFY"] = 5026;
        values[valuesById[5027] = "S2C_BE_INVITE_BATTLE"] = 5027;
        values[valuesById[5028] = "S2C_INVITE_BATTLE_RESULT"] = 5028;
        values[valuesById[5029] = "S2C_BE_DEL_FRIEND"] = 5029;
        values[valuesById[5030] = "S2C_WX_INVITE_BATTLE_RESULT"] = 5030;
        values[valuesById[5031] = "S2C_DAILY_TREASURE_BE_HELP"] = 5031;
        values[valuesById[5032] = "S2C_TREASURE_BE_HELP"] = 5032;
        values[valuesById[5033] = "S2C_BATTLE_LOSE_BE_HELP"] = 5033;
        values[valuesById[5034] = "S2C_UPDATE_WX_EXAMINE_STATE"] = 5034;
        values[valuesById[5035] = "S2C_LEVEL_BE_HELP"] = 5035;
        values[valuesById[5036] = "S2C_READY_LEVEL_FIGHT"] = 5036;
        values[valuesById[5037] = "S2C_TRIGGER_SHOP_ADD_GOLD_ADS"] = 5037;
        values[valuesById[5038] = "S2C_MISSION_SHOW_RED_DOT"] = 5038;
        values[valuesById[5039] = "S2C_UPDATE_MISSION_INFO"] = 5039;
        values[valuesById[5040] = "S2C_UPDATE_MISSION_PROCESS"] = 5040;
        values[valuesById[5041] = "S2C_UPDATE_MISSION_TREASURE_PROCESS"] = 5041;
        values[valuesById[5042] = "S2C_WX_INVITE_SHOW_RED_DOT"] = 5042;
        values[valuesById[5043] = "S2C_WX_SHARE_BE_HELP"] = 5043;
        values[valuesById[5044] = "S2C_NOTIFY_NEW_MAIL"] = 5044;
        values[valuesById[5045] = "S2C_NOTIFY_SDK_RECHARGE_RESULT"] = 5045;
        values[valuesById[5046] = "S2C_ON_CROSS_DAY"] = 5046;
        values[valuesById[5047] = "S2C_SEASON_PVP_BEGIN"] = 5047;
        values[valuesById[5048] = "S2C_SEASON_PVP_STOP"] = 5048;
        values[valuesById[5049] = "S2C_ADD_CARD_SKIN"] = 5049;
        values[valuesById[5050] = "S2C_BEGIN_SEASON_BATTLE"] = 5050;
        values[valuesById[5051] = "S2C_SEASON_BATTLE_BEGIN"] = 5051;
        values[valuesById[5052] = "S2C_SEASON_PVP_CHANGE_HAND_CARD"] = 5052;
        values[valuesById[5053] = "S2C_ADD_EQUIP"] = 5053;
        values[valuesById[5054] = "S2C_TELL_ME"] = 5054;
        values[valuesById[5055] = "S2C_UNLOCK_EMOJI"] = 5055;
        values[valuesById[5056] = "S2C_ADD_VIP"] = 5056;
        values[valuesById[5057] = "S2C_VIP_TIMEOUT"] = 5057;
        values[valuesById[5058] = "S2C_COUNTRY_CREATED"] = 5058;
        values[valuesById[5059] = "S2C_CITY_BE_OCCUPY"] = 5059;
        values[valuesById[5060] = "S2C_UPDATE_FORAGE"] = 5060;
        values[valuesById[5061] = "S2C_CAMPAIGN_NOTIFY_RED_DOT"] = 5061;
        values[valuesById[5062] = "S2C_SYNC_CITY_DEFENSE"] = 5062;
        values[valuesById[5063] = "S2C_UPDATE_CAMPAIGN_STATE"] = 5063;
        values[valuesById[5064] = "S2C_UPDATE_CITY_BE_ATTACK_STATE"] = 5064;
        values[valuesById[5065] = "S2C_CAMPAIGN_UPDATE_JOB"] = 5065;
        values[valuesById[5066] = "S2C_MY_TEAM_CAN_ATTACK_CITY"] = 5066;
        values[valuesById[5067] = "S2C_TO_BE_CAPTIVE"] = 5067;
        values[valuesById[5068] = "S2C_UPDATE_MY_CITY"] = 5068;
        values[valuesById[5069] = "S2C_UPDATE_MY_COUNTRY"] = 5069;
        values[valuesById[5072] = "S2C_COUNTRY_WAR_END"] = 5072;
        values[valuesById[5073] = "S2C_UPDATE_COUNTRY_NAME"] = 5073;
        values[valuesById[5074] = "S2C_TO_BE_UN_CAPTIVE"] = 5074;
        values[valuesById[5075] = "S2C_UNIFIED_WORLD"] = 5075;
        values[valuesById[5076] = "S2C_UPDATE_CAMPAIGN_TEAMS"] = 5076;
        values[valuesById[5077] = "S2C_COUNTRY_DESTORYED"] = 5077;
        values[valuesById[5078] = "S2C_UPDATE_COUNTRY_FLAG"] = 5078;
        values[valuesById[5079] = "S2C_UPDATE_CONTRIBUTION"] = 5079;
        values[valuesById[5080] = "S2C_ON_UNSUBSCRIBE_CHAT"] = 5080;
        values[valuesById[5081] = "S2C_SYNC_CITY_PLYAER_AMOUNT"] = 5081;
        values[valuesById[5082] = "S2C_UPDATE_CITY_STATE"] = 5082;
        values[valuesById[5083] = "S2C_UPDATE_CAMPAIGN_PLAYER_STATE"] = 5083;
        values[valuesById[5084] = "S2C_UPDATE_MY_TEAM_STATE"] = 5084;
        values[valuesById[5085] = "S2C_UPDATE_CAMPAIGN_SUPPORT_CARDS"] = 5085;
        values[valuesById[5086] = "S2C_UPDATE_CITY_COUNTRY"] = 5086;
        values[valuesById[5087] = "S2C_ADD_MIN_VIP"] = 5087;
        values[valuesById[5088] = "S2C_MIN_VIP_TIMEOUT"] = 5088;
        values[valuesById[5089] = "S2C_SYNC_DEF_CITY_PLAYER_AMOUNT"] = 5089;
        values[valuesById[5090] = "S2C_ADD_NEWBIE_VIP"] = 5090;
        values[valuesById[5091] = "S2C_NEWBIE_VIP_TIMEOUT"] = 5091;
        values[valuesById[5092] = "S2C_HUODONG_BEGIN"] = 5092;
        values[valuesById[5093] = "S2C_HUODONG_END"] = 5093;
        return values;
    })();

    pb.RankItem = (function() {

        /**
         * Properties of a RankItem.
         * @memberof pb
         * @interface IRankItem
         * @property {number|Long|null} [Uid] RankItem Uid
         * @property {string|null} [Name] RankItem Name
         * @property {number|null} [PvpScore] RankItem PvpScore
         * @property {number|null} [Rank] RankItem Rank
         * @property {number|null} [LastRank] RankItem LastRank
         * @property {number|null} [Camp] RankItem Camp
         * @property {number|null} [WinDiff] RankItem WinDiff
         */

        /**
         * Constructs a new RankItem.
         * @memberof pb
         * @classdesc Represents a RankItem.
         * @implements IRankItem
         * @constructor
         * @param {pb.IRankItem=} [properties] Properties to set
         */
        function RankItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankItem Uid.
         * @member {number|Long} Uid
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RankItem Name.
         * @member {string} Name
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.Name = "";

        /**
         * RankItem PvpScore.
         * @member {number} PvpScore
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.PvpScore = 0;

        /**
         * RankItem Rank.
         * @member {number} Rank
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.Rank = 0;

        /**
         * RankItem LastRank.
         * @member {number} LastRank
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.LastRank = 0;

        /**
         * RankItem Camp.
         * @member {number} Camp
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.Camp = 0;

        /**
         * RankItem WinDiff.
         * @member {number} WinDiff
         * @memberof pb.RankItem
         * @instance
         */
        RankItem.prototype.WinDiff = 0;

        /**
         * Creates a new RankItem instance using the specified properties.
         * @function create
         * @memberof pb.RankItem
         * @static
         * @param {pb.IRankItem=} [properties] Properties to set
         * @returns {pb.RankItem} RankItem instance
         */
        RankItem.create = function create(properties) {
            return new RankItem(properties);
        };

        /**
         * Encodes the specified RankItem message. Does not implicitly {@link pb.RankItem.verify|verify} messages.
         * @function encode
         * @memberof pb.RankItem
         * @static
         * @param {pb.IRankItem} message RankItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.Rank != null && message.hasOwnProperty("Rank"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Rank);
            if (message.LastRank != null && message.hasOwnProperty("LastRank"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.LastRank);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Camp);
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.WinDiff);
            return writer;
        };

        /**
         * Encodes the specified RankItem message, length delimited. Does not implicitly {@link pb.RankItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RankItem
         * @static
         * @param {pb.IRankItem} message RankItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RankItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RankItem} RankItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RankItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.Rank = reader.int32();
                    break;
                case 5:
                    message.LastRank = reader.int32();
                    break;
                case 6:
                    message.Camp = reader.int32();
                    break;
                case 7:
                    message.WinDiff = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RankItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RankItem} RankItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankItem message.
         * @function verify
         * @memberof pb.RankItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.Rank != null && message.hasOwnProperty("Rank"))
                if (!$util.isInteger(message.Rank))
                    return "Rank: integer expected";
            if (message.LastRank != null && message.hasOwnProperty("LastRank"))
                if (!$util.isInteger(message.LastRank))
                    return "LastRank: integer expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                if (!$util.isInteger(message.WinDiff))
                    return "WinDiff: integer expected";
            return null;
        };

        return RankItem;
    })();

    pb.RankInfo = (function() {

        /**
         * Properties of a RankInfo.
         * @memberof pb
         * @interface IRankInfo
         * @property {number|null} [UpdateTime] RankInfo UpdateTime
         * @property {Array.<pb.IRankItem>|null} [Items] RankInfo Items
         */

        /**
         * Constructs a new RankInfo.
         * @memberof pb
         * @classdesc Represents a RankInfo.
         * @implements IRankInfo
         * @constructor
         * @param {pb.IRankInfo=} [properties] Properties to set
         */
        function RankInfo(properties) {
            this.Items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankInfo UpdateTime.
         * @member {number} UpdateTime
         * @memberof pb.RankInfo
         * @instance
         */
        RankInfo.prototype.UpdateTime = 0;

        /**
         * RankInfo Items.
         * @member {Array.<pb.IRankItem>} Items
         * @memberof pb.RankInfo
         * @instance
         */
        RankInfo.prototype.Items = $util.emptyArray;

        /**
         * Creates a new RankInfo instance using the specified properties.
         * @function create
         * @memberof pb.RankInfo
         * @static
         * @param {pb.IRankInfo=} [properties] Properties to set
         * @returns {pb.RankInfo} RankInfo instance
         */
        RankInfo.create = function create(properties) {
            return new RankInfo(properties);
        };

        /**
         * Encodes the specified RankInfo message. Does not implicitly {@link pb.RankInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.RankInfo
         * @static
         * @param {pb.IRankInfo} message RankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.UpdateTime != null && message.hasOwnProperty("UpdateTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.UpdateTime);
            if (message.Items != null && message.Items.length)
                for (var i = 0; i < message.Items.length; ++i)
                    $root.pb.RankItem.encode(message.Items[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RankInfo message, length delimited. Does not implicitly {@link pb.RankInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RankInfo
         * @static
         * @param {pb.IRankInfo} message RankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RankInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.UpdateTime = reader.int32();
                    break;
                case 2:
                    if (!(message.Items && message.Items.length))
                        message.Items = [];
                    message.Items.push($root.pb.RankItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankInfo message.
         * @function verify
         * @memberof pb.RankInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.UpdateTime != null && message.hasOwnProperty("UpdateTime"))
                if (!$util.isInteger(message.UpdateTime))
                    return "UpdateTime: integer expected";
            if (message.Items != null && message.hasOwnProperty("Items")) {
                if (!Array.isArray(message.Items))
                    return "Items: array expected";
                for (var i = 0; i < message.Items.length; ++i) {
                    var error = $root.pb.RankItem.verify(message.Items[i]);
                    if (error)
                        return "Items." + error;
                }
            }
            return null;
        };

        return RankInfo;
    })();

    pb.FetchRankUserArg = (function() {

        /**
         * Properties of a FetchRankUserArg.
         * @memberof pb
         * @interface IFetchRankUserArg
         * @property {number|Long|null} [Uid] FetchRankUserArg Uid
         */

        /**
         * Constructs a new FetchRankUserArg.
         * @memberof pb
         * @classdesc Represents a FetchRankUserArg.
         * @implements IFetchRankUserArg
         * @constructor
         * @param {pb.IFetchRankUserArg=} [properties] Properties to set
         */
        function FetchRankUserArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchRankUserArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.FetchRankUserArg
         * @instance
         */
        FetchRankUserArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FetchRankUserArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {pb.IFetchRankUserArg=} [properties] Properties to set
         * @returns {pb.FetchRankUserArg} FetchRankUserArg instance
         */
        FetchRankUserArg.create = function create(properties) {
            return new FetchRankUserArg(properties);
        };

        /**
         * Encodes the specified FetchRankUserArg message. Does not implicitly {@link pb.FetchRankUserArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {pb.IFetchRankUserArg} message FetchRankUserArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchRankUserArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified FetchRankUserArg message, length delimited. Does not implicitly {@link pb.FetchRankUserArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {pb.IFetchRankUserArg} message FetchRankUserArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchRankUserArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchRankUserArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchRankUserArg} FetchRankUserArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchRankUserArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchRankUserArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchRankUserArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchRankUserArg} FetchRankUserArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchRankUserArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchRankUserArg message.
         * @function verify
         * @memberof pb.FetchRankUserArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchRankUserArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return FetchRankUserArg;
    })();

    pb.RankUser = (function() {

        /**
         * Properties of a RankUser.
         * @memberof pb
         * @interface IRankUser
         * @property {Array.<pb.ISkinGCard>|null} [FightCards] RankUser FightCards
         */

        /**
         * Constructs a new RankUser.
         * @memberof pb
         * @classdesc Represents a RankUser.
         * @implements IRankUser
         * @constructor
         * @param {pb.IRankUser=} [properties] Properties to set
         */
        function RankUser(properties) {
            this.FightCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankUser FightCards.
         * @member {Array.<pb.ISkinGCard>} FightCards
         * @memberof pb.RankUser
         * @instance
         */
        RankUser.prototype.FightCards = $util.emptyArray;

        /**
         * Creates a new RankUser instance using the specified properties.
         * @function create
         * @memberof pb.RankUser
         * @static
         * @param {pb.IRankUser=} [properties] Properties to set
         * @returns {pb.RankUser} RankUser instance
         */
        RankUser.create = function create(properties) {
            return new RankUser(properties);
        };

        /**
         * Encodes the specified RankUser message. Does not implicitly {@link pb.RankUser.verify|verify} messages.
         * @function encode
         * @memberof pb.RankUser
         * @static
         * @param {pb.IRankUser} message RankUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankUser.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FightCards != null && message.FightCards.length)
                for (var i = 0; i < message.FightCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FightCards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RankUser message, length delimited. Does not implicitly {@link pb.RankUser.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RankUser
         * @static
         * @param {pb.IRankUser} message RankUser message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankUser.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankUser message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RankUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RankUser} RankUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankUser.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RankUser();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.FightCards && message.FightCards.length))
                        message.FightCards = [];
                    message.FightCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankUser message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RankUser
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RankUser} RankUser
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankUser.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankUser message.
         * @function verify
         * @memberof pb.RankUser
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankUser.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FightCards != null && message.hasOwnProperty("FightCards")) {
                if (!Array.isArray(message.FightCards))
                    return "FightCards: array expected";
                for (var i = 0; i < message.FightCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FightCards[i]);
                    if (error)
                        return "FightCards." + error;
                }
            }
            return null;
        };

        return RankUser;
    })();

    pb.UpdatePvpScoreArg = (function() {

        /**
         * Properties of an UpdatePvpScoreArg.
         * @memberof pb
         * @interface IUpdatePvpScoreArg
         * @property {number|Long|null} [Uid] UpdatePvpScoreArg Uid
         * @property {string|null} [Name] UpdatePvpScoreArg Name
         * @property {Array.<pb.ISkinGCard>|null} [HandCards] UpdatePvpScoreArg HandCards
         * @property {number|null} [Camp] UpdatePvpScoreArg Camp
         * @property {number|null} [PvpScore] UpdatePvpScoreArg PvpScore
         * @property {number|null} [WinDiff] UpdatePvpScoreArg WinDiff
         * @property {number|null} [WinCnt] UpdatePvpScoreArg WinCnt
         * @property {number|null} [RebornCnt] UpdatePvpScoreArg RebornCnt
         */

        /**
         * Constructs a new UpdatePvpScoreArg.
         * @memberof pb
         * @classdesc Represents an UpdatePvpScoreArg.
         * @implements IUpdatePvpScoreArg
         * @constructor
         * @param {pb.IUpdatePvpScoreArg=} [properties] Properties to set
         */
        function UpdatePvpScoreArg(properties) {
            this.HandCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UpdatePvpScoreArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UpdatePvpScoreArg Name.
         * @member {string} Name
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.Name = "";

        /**
         * UpdatePvpScoreArg HandCards.
         * @member {Array.<pb.ISkinGCard>} HandCards
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.HandCards = $util.emptyArray;

        /**
         * UpdatePvpScoreArg Camp.
         * @member {number} Camp
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.Camp = 0;

        /**
         * UpdatePvpScoreArg PvpScore.
         * @member {number} PvpScore
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.PvpScore = 0;

        /**
         * UpdatePvpScoreArg WinDiff.
         * @member {number} WinDiff
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.WinDiff = 0;

        /**
         * UpdatePvpScoreArg WinCnt.
         * @member {number} WinCnt
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.WinCnt = 0;

        /**
         * UpdatePvpScoreArg RebornCnt.
         * @member {number} RebornCnt
         * @memberof pb.UpdatePvpScoreArg
         * @instance
         */
        UpdatePvpScoreArg.prototype.RebornCnt = 0;

        /**
         * Creates a new UpdatePvpScoreArg instance using the specified properties.
         * @function create
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {pb.IUpdatePvpScoreArg=} [properties] Properties to set
         * @returns {pb.UpdatePvpScoreArg} UpdatePvpScoreArg instance
         */
        UpdatePvpScoreArg.create = function create(properties) {
            return new UpdatePvpScoreArg(properties);
        };

        /**
         * Encodes the specified UpdatePvpScoreArg message. Does not implicitly {@link pb.UpdatePvpScoreArg.verify|verify} messages.
         * @function encode
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {pb.IUpdatePvpScoreArg} message UpdatePvpScoreArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePvpScoreArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.HandCards != null && message.HandCards.length)
                for (var i = 0; i < message.HandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.HandCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Camp);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.PvpScore);
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.WinDiff);
            if (message.WinCnt != null && message.hasOwnProperty("WinCnt"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.WinCnt);
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.RebornCnt);
            return writer;
        };

        /**
         * Encodes the specified UpdatePvpScoreArg message, length delimited. Does not implicitly {@link pb.UpdatePvpScoreArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {pb.IUpdatePvpScoreArg} message UpdatePvpScoreArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UpdatePvpScoreArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an UpdatePvpScoreArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.UpdatePvpScoreArg} UpdatePvpScoreArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePvpScoreArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.UpdatePvpScoreArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    if (!(message.HandCards && message.HandCards.length))
                        message.HandCards = [];
                    message.HandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.Camp = reader.int32();
                    break;
                case 5:
                    message.PvpScore = reader.int32();
                    break;
                case 6:
                    message.WinDiff = reader.int32();
                    break;
                case 7:
                    message.WinCnt = reader.int32();
                    break;
                case 8:
                    message.RebornCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an UpdatePvpScoreArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.UpdatePvpScoreArg} UpdatePvpScoreArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UpdatePvpScoreArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an UpdatePvpScoreArg message.
         * @function verify
         * @memberof pb.UpdatePvpScoreArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UpdatePvpScoreArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HandCards != null && message.hasOwnProperty("HandCards")) {
                if (!Array.isArray(message.HandCards))
                    return "HandCards: array expected";
                for (var i = 0; i < message.HandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.HandCards[i]);
                    if (error)
                        return "HandCards." + error;
                }
            }
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.WinDiff != null && message.hasOwnProperty("WinDiff"))
                if (!$util.isInteger(message.WinDiff))
                    return "WinDiff: integer expected";
            if (message.WinCnt != null && message.hasOwnProperty("WinCnt"))
                if (!$util.isInteger(message.WinCnt))
                    return "WinCnt: integer expected";
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                if (!$util.isInteger(message.RebornCnt))
                    return "RebornCnt: integer expected";
            return null;
        };

        return UpdatePvpScoreArg;
    })();

    pb.G2RSeasonPvpEndReply = (function() {

        /**
         * Properties of a G2RSeasonPvpEndReply.
         * @memberof pb
         * @interface IG2RSeasonPvpEndReply
         * @property {Array.<number|Long>|null} [RankUids] G2RSeasonPvpEndReply RankUids
         */

        /**
         * Constructs a new G2RSeasonPvpEndReply.
         * @memberof pb
         * @classdesc Represents a G2RSeasonPvpEndReply.
         * @implements IG2RSeasonPvpEndReply
         * @constructor
         * @param {pb.IG2RSeasonPvpEndReply=} [properties] Properties to set
         */
        function G2RSeasonPvpEndReply(properties) {
            this.RankUids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2RSeasonPvpEndReply RankUids.
         * @member {Array.<number|Long>} RankUids
         * @memberof pb.G2RSeasonPvpEndReply
         * @instance
         */
        G2RSeasonPvpEndReply.prototype.RankUids = $util.emptyArray;

        /**
         * Creates a new G2RSeasonPvpEndReply instance using the specified properties.
         * @function create
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {pb.IG2RSeasonPvpEndReply=} [properties] Properties to set
         * @returns {pb.G2RSeasonPvpEndReply} G2RSeasonPvpEndReply instance
         */
        G2RSeasonPvpEndReply.create = function create(properties) {
            return new G2RSeasonPvpEndReply(properties);
        };

        /**
         * Encodes the specified G2RSeasonPvpEndReply message. Does not implicitly {@link pb.G2RSeasonPvpEndReply.verify|verify} messages.
         * @function encode
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {pb.IG2RSeasonPvpEndReply} message G2RSeasonPvpEndReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2RSeasonPvpEndReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RankUids != null && message.RankUids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.RankUids.length; ++i)
                    writer.uint64(message.RankUids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified G2RSeasonPvpEndReply message, length delimited. Does not implicitly {@link pb.G2RSeasonPvpEndReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {pb.IG2RSeasonPvpEndReply} message G2RSeasonPvpEndReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2RSeasonPvpEndReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2RSeasonPvpEndReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.G2RSeasonPvpEndReply} G2RSeasonPvpEndReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2RSeasonPvpEndReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.G2RSeasonPvpEndReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.RankUids && message.RankUids.length))
                        message.RankUids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.RankUids.push(reader.uint64());
                    } else
                        message.RankUids.push(reader.uint64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2RSeasonPvpEndReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.G2RSeasonPvpEndReply} G2RSeasonPvpEndReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2RSeasonPvpEndReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2RSeasonPvpEndReply message.
         * @function verify
         * @memberof pb.G2RSeasonPvpEndReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2RSeasonPvpEndReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RankUids != null && message.hasOwnProperty("RankUids")) {
                if (!Array.isArray(message.RankUids))
                    return "RankUids: array expected";
                for (var i = 0; i < message.RankUids.length; ++i)
                    if (!$util.isInteger(message.RankUids[i]) && !(message.RankUids[i] && $util.isInteger(message.RankUids[i].low) && $util.isInteger(message.RankUids[i].high)))
                        return "RankUids: integer|Long[] expected";
            }
            return null;
        };

        return G2RSeasonPvpEndReply;
    })();

    pb.RefineCardArg = (function() {

        /**
         * Properties of a RefineCardArg.
         * @memberof pb
         * @interface IRefineCardArg
         * @property {Array.<number>|null} [CardIDs] RefineCardArg CardIDs
         */

        /**
         * Constructs a new RefineCardArg.
         * @memberof pb
         * @classdesc Represents a RefineCardArg.
         * @implements IRefineCardArg
         * @constructor
         * @param {pb.IRefineCardArg=} [properties] Properties to set
         */
        function RefineCardArg(properties) {
            this.CardIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RefineCardArg CardIDs.
         * @member {Array.<number>} CardIDs
         * @memberof pb.RefineCardArg
         * @instance
         */
        RefineCardArg.prototype.CardIDs = $util.emptyArray;

        /**
         * Creates a new RefineCardArg instance using the specified properties.
         * @function create
         * @memberof pb.RefineCardArg
         * @static
         * @param {pb.IRefineCardArg=} [properties] Properties to set
         * @returns {pb.RefineCardArg} RefineCardArg instance
         */
        RefineCardArg.create = function create(properties) {
            return new RefineCardArg(properties);
        };

        /**
         * Encodes the specified RefineCardArg message. Does not implicitly {@link pb.RefineCardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.RefineCardArg
         * @static
         * @param {pb.IRefineCardArg} message RefineCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefineCardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CardIDs != null && message.CardIDs.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.CardIDs.length; ++i)
                    writer.uint32(message.CardIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RefineCardArg message, length delimited. Does not implicitly {@link pb.RefineCardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RefineCardArg
         * @static
         * @param {pb.IRefineCardArg} message RefineCardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefineCardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefineCardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RefineCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RefineCardArg} RefineCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefineCardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RefineCardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CardIDs && message.CardIDs.length))
                        message.CardIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.CardIDs.push(reader.uint32());
                    } else
                        message.CardIDs.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefineCardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RefineCardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RefineCardArg} RefineCardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefineCardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefineCardArg message.
         * @function verify
         * @memberof pb.RefineCardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefineCardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CardIDs != null && message.hasOwnProperty("CardIDs")) {
                if (!Array.isArray(message.CardIDs))
                    return "CardIDs: array expected";
                for (var i = 0; i < message.CardIDs.length; ++i)
                    if (!$util.isInteger(message.CardIDs[i]))
                        return "CardIDs: integer[] expected";
            }
            return null;
        };

        return RefineCardArg;
    })();

    pb.RefineCardReply = (function() {

        /**
         * Properties of a RefineCardReply.
         * @memberof pb
         * @interface IRefineCardReply
         * @property {number|null} [Feats] RefineCardReply Feats
         */

        /**
         * Constructs a new RefineCardReply.
         * @memberof pb
         * @classdesc Represents a RefineCardReply.
         * @implements IRefineCardReply
         * @constructor
         * @param {pb.IRefineCardReply=} [properties] Properties to set
         */
        function RefineCardReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RefineCardReply Feats.
         * @member {number} Feats
         * @memberof pb.RefineCardReply
         * @instance
         */
        RefineCardReply.prototype.Feats = 0;

        /**
         * Creates a new RefineCardReply instance using the specified properties.
         * @function create
         * @memberof pb.RefineCardReply
         * @static
         * @param {pb.IRefineCardReply=} [properties] Properties to set
         * @returns {pb.RefineCardReply} RefineCardReply instance
         */
        RefineCardReply.create = function create(properties) {
            return new RefineCardReply(properties);
        };

        /**
         * Encodes the specified RefineCardReply message. Does not implicitly {@link pb.RefineCardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.RefineCardReply
         * @static
         * @param {pb.IRefineCardReply} message RefineCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefineCardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Feats != null && message.hasOwnProperty("Feats"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Feats);
            return writer;
        };

        /**
         * Encodes the specified RefineCardReply message, length delimited. Does not implicitly {@link pb.RefineCardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RefineCardReply
         * @static
         * @param {pb.IRefineCardReply} message RefineCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefineCardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefineCardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RefineCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RefineCardReply} RefineCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefineCardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RefineCardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Feats = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefineCardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RefineCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RefineCardReply} RefineCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefineCardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefineCardReply message.
         * @function verify
         * @memberof pb.RefineCardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefineCardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Feats != null && message.hasOwnProperty("Feats"))
                if (!$util.isInteger(message.Feats))
                    return "Feats: integer expected";
            return null;
        };

        return RefineCardReply;
    })();

    pb.RebornReply = (function() {

        /**
         * Properties of a RebornReply.
         * @memberof pb
         * @interface IRebornReply
         * @property {pb.IOpenTreasureReply|null} [TreasureReward] RebornReply TreasureReward
         * @property {number|null} [Feats] RebornReply Feats
         * @property {string|null} [NewName] RebornReply NewName
         * @property {number|null} [Prestige] RebornReply Prestige
         */

        /**
         * Constructs a new RebornReply.
         * @memberof pb
         * @classdesc Represents a RebornReply.
         * @implements IRebornReply
         * @constructor
         * @param {pb.IRebornReply=} [properties] Properties to set
         */
        function RebornReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RebornReply TreasureReward.
         * @member {pb.IOpenTreasureReply|null|undefined} TreasureReward
         * @memberof pb.RebornReply
         * @instance
         */
        RebornReply.prototype.TreasureReward = null;

        /**
         * RebornReply Feats.
         * @member {number} Feats
         * @memberof pb.RebornReply
         * @instance
         */
        RebornReply.prototype.Feats = 0;

        /**
         * RebornReply NewName.
         * @member {string} NewName
         * @memberof pb.RebornReply
         * @instance
         */
        RebornReply.prototype.NewName = "";

        /**
         * RebornReply Prestige.
         * @member {number} Prestige
         * @memberof pb.RebornReply
         * @instance
         */
        RebornReply.prototype.Prestige = 0;

        /**
         * Creates a new RebornReply instance using the specified properties.
         * @function create
         * @memberof pb.RebornReply
         * @static
         * @param {pb.IRebornReply=} [properties] Properties to set
         * @returns {pb.RebornReply} RebornReply instance
         */
        RebornReply.create = function create(properties) {
            return new RebornReply(properties);
        };

        /**
         * Encodes the specified RebornReply message. Does not implicitly {@link pb.RebornReply.verify|verify} messages.
         * @function encode
         * @memberof pb.RebornReply
         * @static
         * @param {pb.IRebornReply} message RebornReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebornReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward"))
                $root.pb.OpenTreasureReply.encode(message.TreasureReward, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Feats != null && message.hasOwnProperty("Feats"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Feats);
            if (message.NewName != null && message.hasOwnProperty("NewName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.NewName);
            if (message.Prestige != null && message.hasOwnProperty("Prestige"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Prestige);
            return writer;
        };

        /**
         * Encodes the specified RebornReply message, length delimited. Does not implicitly {@link pb.RebornReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RebornReply
         * @static
         * @param {pb.IRebornReply} message RebornReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebornReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RebornReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RebornReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RebornReply} RebornReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebornReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RebornReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureReward = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.Feats = reader.int32();
                    break;
                case 3:
                    message.NewName = reader.string();
                    break;
                case 4:
                    message.Prestige = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RebornReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RebornReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RebornReply} RebornReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebornReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RebornReply message.
         * @function verify
         * @memberof pb.RebornReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RebornReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward")) {
                var error = $root.pb.OpenTreasureReply.verify(message.TreasureReward);
                if (error)
                    return "TreasureReward." + error;
            }
            if (message.Feats != null && message.hasOwnProperty("Feats"))
                if (!$util.isInteger(message.Feats))
                    return "Feats: integer expected";
            if (message.NewName != null && message.hasOwnProperty("NewName"))
                if (!$util.isString(message.NewName))
                    return "NewName: string expected";
            if (message.Prestige != null && message.hasOwnProperty("Prestige"))
                if (!$util.isInteger(message.Prestige))
                    return "Prestige: integer expected";
            return null;
        };

        return RebornReply;
    })();

    pb.BuyRebornGoodsArg = (function() {

        /**
         * Properties of a BuyRebornGoodsArg.
         * @memberof pb
         * @interface IBuyRebornGoodsArg
         * @property {pb.BuyRebornGoodsArg.GoodsType|null} [Type] BuyRebornGoodsArg Type
         * @property {number|null} [GoodsID] BuyRebornGoodsArg GoodsID
         */

        /**
         * Constructs a new BuyRebornGoodsArg.
         * @memberof pb
         * @classdesc Represents a BuyRebornGoodsArg.
         * @implements IBuyRebornGoodsArg
         * @constructor
         * @param {pb.IBuyRebornGoodsArg=} [properties] Properties to set
         */
        function BuyRebornGoodsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyRebornGoodsArg Type.
         * @member {pb.BuyRebornGoodsArg.GoodsType} Type
         * @memberof pb.BuyRebornGoodsArg
         * @instance
         */
        BuyRebornGoodsArg.prototype.Type = 0;

        /**
         * BuyRebornGoodsArg GoodsID.
         * @member {number} GoodsID
         * @memberof pb.BuyRebornGoodsArg
         * @instance
         */
        BuyRebornGoodsArg.prototype.GoodsID = 0;

        /**
         * Creates a new BuyRebornGoodsArg instance using the specified properties.
         * @function create
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {pb.IBuyRebornGoodsArg=} [properties] Properties to set
         * @returns {pb.BuyRebornGoodsArg} BuyRebornGoodsArg instance
         */
        BuyRebornGoodsArg.create = function create(properties) {
            return new BuyRebornGoodsArg(properties);
        };

        /**
         * Encodes the specified BuyRebornGoodsArg message. Does not implicitly {@link pb.BuyRebornGoodsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {pb.IBuyRebornGoodsArg} message BuyRebornGoodsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyRebornGoodsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified BuyRebornGoodsArg message, length delimited. Does not implicitly {@link pb.BuyRebornGoodsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {pb.IBuyRebornGoodsArg} message BuyRebornGoodsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyRebornGoodsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyRebornGoodsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyRebornGoodsArg} BuyRebornGoodsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyRebornGoodsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyRebornGoodsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.GoodsID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyRebornGoodsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyRebornGoodsArg} BuyRebornGoodsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyRebornGoodsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyRebornGoodsArg message.
         * @function verify
         * @memberof pb.BuyRebornGoodsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyRebornGoodsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                    break;
                }
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isInteger(message.GoodsID))
                    return "GoodsID: integer expected";
            return null;
        };

        /**
         * GoodsType enum.
         * @name pb.BuyRebornGoodsArg.GoodsType
         * @enum {string}
         * @property {number} Unknow=0 Unknow value
         * @property {number} Card=1 Card value
         * @property {number} Privilege=2 Privilege value
         * @property {number} CardSkin=3 CardSkin value
         * @property {number} Equip=4 Equip value
         */
        BuyRebornGoodsArg.GoodsType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Unknow"] = 0;
            values[valuesById[1] = "Card"] = 1;
            values[valuesById[2] = "Privilege"] = 2;
            values[valuesById[3] = "CardSkin"] = 3;
            values[valuesById[4] = "Equip"] = 4;
            return values;
        })();

        return BuyRebornGoodsArg;
    })();

    pb.RebornData = (function() {

        /**
         * Properties of a RebornData.
         * @memberof pb
         * @interface IRebornData
         * @property {number|null} [RemainDay] RebornData RemainDay
         * @property {number|null} [Prestige] RebornData Prestige
         * @property {number|null} [Cnt] RebornData Cnt
         */

        /**
         * Constructs a new RebornData.
         * @memberof pb
         * @classdesc Represents a RebornData.
         * @implements IRebornData
         * @constructor
         * @param {pb.IRebornData=} [properties] Properties to set
         */
        function RebornData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RebornData RemainDay.
         * @member {number} RemainDay
         * @memberof pb.RebornData
         * @instance
         */
        RebornData.prototype.RemainDay = 0;

        /**
         * RebornData Prestige.
         * @member {number} Prestige
         * @memberof pb.RebornData
         * @instance
         */
        RebornData.prototype.Prestige = 0;

        /**
         * RebornData Cnt.
         * @member {number} Cnt
         * @memberof pb.RebornData
         * @instance
         */
        RebornData.prototype.Cnt = 0;

        /**
         * Creates a new RebornData instance using the specified properties.
         * @function create
         * @memberof pb.RebornData
         * @static
         * @param {pb.IRebornData=} [properties] Properties to set
         * @returns {pb.RebornData} RebornData instance
         */
        RebornData.create = function create(properties) {
            return new RebornData(properties);
        };

        /**
         * Encodes the specified RebornData message. Does not implicitly {@link pb.RebornData.verify|verify} messages.
         * @function encode
         * @memberof pb.RebornData
         * @static
         * @param {pb.IRebornData} message RebornData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebornData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.RemainDay != null && message.hasOwnProperty("RemainDay"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.RemainDay);
            if (message.Prestige != null && message.hasOwnProperty("Prestige"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Prestige);
            if (message.Cnt != null && message.hasOwnProperty("Cnt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Cnt);
            return writer;
        };

        /**
         * Encodes the specified RebornData message, length delimited. Does not implicitly {@link pb.RebornData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RebornData
         * @static
         * @param {pb.IRebornData} message RebornData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RebornData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RebornData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RebornData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RebornData} RebornData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebornData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RebornData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.RemainDay = reader.int32();
                    break;
                case 2:
                    message.Prestige = reader.int32();
                    break;
                case 3:
                    message.Cnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RebornData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RebornData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RebornData} RebornData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RebornData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RebornData message.
         * @function verify
         * @memberof pb.RebornData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RebornData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.RemainDay != null && message.hasOwnProperty("RemainDay"))
                if (!$util.isInteger(message.RemainDay))
                    return "RemainDay: integer expected";
            if (message.Prestige != null && message.hasOwnProperty("Prestige"))
                if (!$util.isInteger(message.Prestige))
                    return "Prestige: integer expected";
            if (message.Cnt != null && message.hasOwnProperty("Cnt"))
                if (!$util.isInteger(message.Cnt))
                    return "Cnt: integer expected";
            return null;
        };

        return RebornData;
    })();

    /**
     * RmqType enum.
     * @name pb.RmqType
     * @enum {string}
     * @property {number} Unknow_RmqType=0 Unknow_RmqType value
     * @property {number} BattleBegin=1 BattleBegin value
     * @property {number} BattleEnd=2 BattleEnd value
     * @property {number} Bonus=3 Bonus value
     * @property {number} AddFriendApply=4 AddFriendApply value
     * @property {number} ReplyFriendApply=5 ReplyFriendApply value
     * @property {number} BeDelFriend=6 BeDelFriend value
     * @property {number} PrivateChat=7 PrivateChat value
     * @property {number} HelpLevel=8 HelpLevel value
     * @property {number} WxInviteFriendTp=9 WxInviteFriendTp value
     * @property {number} ForbidLogin=10 ForbidLogin value
     * @property {number} ForbidChat=11 ForbidChat value
     * @property {number} SendMail=12 SendMail value
     * @property {number} WxShareBeHelp=13 WxShareBeHelp value
     * @property {number} SdkRecharge=14 SdkRecharge value
     * @property {number} CampaignMissionDone=15 CampaignMissionDone value
     * @property {number} CampaignAcceptMission=16 CampaignAcceptMission value
     * @property {number} UnifiedReward=17 UnifiedReward value
     */
    pb.RmqType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Unknow_RmqType"] = 0;
        values[valuesById[1] = "BattleBegin"] = 1;
        values[valuesById[2] = "BattleEnd"] = 2;
        values[valuesById[3] = "Bonus"] = 3;
        values[valuesById[4] = "AddFriendApply"] = 4;
        values[valuesById[5] = "ReplyFriendApply"] = 5;
        values[valuesById[6] = "BeDelFriend"] = 6;
        values[valuesById[7] = "PrivateChat"] = 7;
        values[valuesById[8] = "HelpLevel"] = 8;
        values[valuesById[9] = "WxInviteFriendTp"] = 9;
        values[valuesById[10] = "ForbidLogin"] = 10;
        values[valuesById[11] = "ForbidChat"] = 11;
        values[valuesById[12] = "SendMail"] = 12;
        values[valuesById[13] = "WxShareBeHelp"] = 13;
        values[valuesById[14] = "SdkRecharge"] = 14;
        values[valuesById[15] = "CampaignMissionDone"] = 15;
        values[valuesById[16] = "CampaignAcceptMission"] = 16;
        values[valuesById[17] = "UnifiedReward"] = 17;
        return values;
    })();

    pb.RmqMessage = (function() {

        /**
         * Properties of a RmqMessage.
         * @memberof pb
         * @interface IRmqMessage
         * @property {pb.RmqType|null} [Type] RmqMessage Type
         * @property {Uint8Array|null} [Payload] RmqMessage Payload
         */

        /**
         * Constructs a new RmqMessage.
         * @memberof pb
         * @classdesc Represents a RmqMessage.
         * @implements IRmqMessage
         * @constructor
         * @param {pb.IRmqMessage=} [properties] Properties to set
         */
        function RmqMessage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqMessage Type.
         * @member {pb.RmqType} Type
         * @memberof pb.RmqMessage
         * @instance
         */
        RmqMessage.prototype.Type = 0;

        /**
         * RmqMessage Payload.
         * @member {Uint8Array} Payload
         * @memberof pb.RmqMessage
         * @instance
         */
        RmqMessage.prototype.Payload = $util.newBuffer([]);

        /**
         * Creates a new RmqMessage instance using the specified properties.
         * @function create
         * @memberof pb.RmqMessage
         * @static
         * @param {pb.IRmqMessage=} [properties] Properties to set
         * @returns {pb.RmqMessage} RmqMessage instance
         */
        RmqMessage.create = function create(properties) {
            return new RmqMessage(properties);
        };

        /**
         * Encodes the specified RmqMessage message. Does not implicitly {@link pb.RmqMessage.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqMessage
         * @static
         * @param {pb.IRmqMessage} message RmqMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqMessage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Payload != null && message.hasOwnProperty("Payload"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Payload);
            return writer;
        };

        /**
         * Encodes the specified RmqMessage message, length delimited. Does not implicitly {@link pb.RmqMessage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqMessage
         * @static
         * @param {pb.IRmqMessage} message RmqMessage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqMessage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqMessage message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqMessage} RmqMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqMessage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqMessage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Payload = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqMessage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqMessage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqMessage} RmqMessage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqMessage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqMessage message.
         * @function verify
         * @memberof pb.RmqMessage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqMessage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                case 16:
                case 17:
                    break;
                }
            if (message.Payload != null && message.hasOwnProperty("Payload"))
                if (!(message.Payload && typeof message.Payload.length === "number" || $util.isString(message.Payload)))
                    return "Payload: buffer expected";
            return null;
        };

        return RmqMessage;
    })();

    pb.RmqBattleBegin = (function() {

        /**
         * Properties of a RmqBattleBegin.
         * @memberof pb
         * @interface IRmqBattleBegin
         * @property {number|Long|null} [BattleID] RmqBattleBegin BattleID
         * @property {number|null} [AppID] RmqBattleBegin AppID
         * @property {number|null} [BattleType] RmqBattleBegin BattleType
         */

        /**
         * Constructs a new RmqBattleBegin.
         * @memberof pb
         * @classdesc Represents a RmqBattleBegin.
         * @implements IRmqBattleBegin
         * @constructor
         * @param {pb.IRmqBattleBegin=} [properties] Properties to set
         */
        function RmqBattleBegin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqBattleBegin BattleID.
         * @member {number|Long} BattleID
         * @memberof pb.RmqBattleBegin
         * @instance
         */
        RmqBattleBegin.prototype.BattleID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqBattleBegin AppID.
         * @member {number} AppID
         * @memberof pb.RmqBattleBegin
         * @instance
         */
        RmqBattleBegin.prototype.AppID = 0;

        /**
         * RmqBattleBegin BattleType.
         * @member {number} BattleType
         * @memberof pb.RmqBattleBegin
         * @instance
         */
        RmqBattleBegin.prototype.BattleType = 0;

        /**
         * Creates a new RmqBattleBegin instance using the specified properties.
         * @function create
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {pb.IRmqBattleBegin=} [properties] Properties to set
         * @returns {pb.RmqBattleBegin} RmqBattleBegin instance
         */
        RmqBattleBegin.create = function create(properties) {
            return new RmqBattleBegin(properties);
        };

        /**
         * Encodes the specified RmqBattleBegin message. Does not implicitly {@link pb.RmqBattleBegin.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {pb.IRmqBattleBegin} message RmqBattleBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBattleBegin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.BattleID);
            if (message.AppID != null && message.hasOwnProperty("AppID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.AppID);
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.BattleType);
            return writer;
        };

        /**
         * Encodes the specified RmqBattleBegin message, length delimited. Does not implicitly {@link pb.RmqBattleBegin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {pb.IRmqBattleBegin} message RmqBattleBegin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBattleBegin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqBattleBegin message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqBattleBegin} RmqBattleBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBattleBegin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqBattleBegin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BattleID = reader.uint64();
                    break;
                case 2:
                    message.AppID = reader.uint32();
                    break;
                case 3:
                    message.BattleType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqBattleBegin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqBattleBegin} RmqBattleBegin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBattleBegin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqBattleBegin message.
         * @function verify
         * @memberof pb.RmqBattleBegin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqBattleBegin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                if (!$util.isInteger(message.BattleID) && !(message.BattleID && $util.isInteger(message.BattleID.low) && $util.isInteger(message.BattleID.high)))
                    return "BattleID: integer|Long expected";
            if (message.AppID != null && message.hasOwnProperty("AppID"))
                if (!$util.isInteger(message.AppID))
                    return "AppID: integer expected";
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                if (!$util.isInteger(message.BattleType))
                    return "BattleType: integer expected";
            return null;
        };

        return RmqBattleBegin;
    })();

    pb.RmqBonus = (function() {

        /**
         * Properties of a RmqBonus.
         * @memberof pb
         * @interface IRmqBonus
         * @property {Array.<pb.IResource>|null} [ChangeRes] RmqBonus ChangeRes
         */

        /**
         * Constructs a new RmqBonus.
         * @memberof pb
         * @classdesc Represents a RmqBonus.
         * @implements IRmqBonus
         * @constructor
         * @param {pb.IRmqBonus=} [properties] Properties to set
         */
        function RmqBonus(properties) {
            this.ChangeRes = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqBonus ChangeRes.
         * @member {Array.<pb.IResource>} ChangeRes
         * @memberof pb.RmqBonus
         * @instance
         */
        RmqBonus.prototype.ChangeRes = $util.emptyArray;

        /**
         * Creates a new RmqBonus instance using the specified properties.
         * @function create
         * @memberof pb.RmqBonus
         * @static
         * @param {pb.IRmqBonus=} [properties] Properties to set
         * @returns {pb.RmqBonus} RmqBonus instance
         */
        RmqBonus.create = function create(properties) {
            return new RmqBonus(properties);
        };

        /**
         * Encodes the specified RmqBonus message. Does not implicitly {@link pb.RmqBonus.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqBonus
         * @static
         * @param {pb.IRmqBonus} message RmqBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBonus.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChangeRes != null && message.ChangeRes.length)
                for (var i = 0; i < message.ChangeRes.length; ++i)
                    $root.pb.Resource.encode(message.ChangeRes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RmqBonus message, length delimited. Does not implicitly {@link pb.RmqBonus.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqBonus
         * @static
         * @param {pb.IRmqBonus} message RmqBonus message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBonus.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqBonus message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqBonus} RmqBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBonus.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqBonus();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ChangeRes && message.ChangeRes.length))
                        message.ChangeRes = [];
                    message.ChangeRes.push($root.pb.Resource.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqBonus message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqBonus
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqBonus} RmqBonus
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBonus.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqBonus message.
         * @function verify
         * @memberof pb.RmqBonus
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqBonus.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChangeRes != null && message.hasOwnProperty("ChangeRes")) {
                if (!Array.isArray(message.ChangeRes))
                    return "ChangeRes: array expected";
                for (var i = 0; i < message.ChangeRes.length; ++i) {
                    var error = $root.pb.Resource.verify(message.ChangeRes[i]);
                    if (error)
                        return "ChangeRes." + error;
                }
            }
            return null;
        };

        return RmqBonus;
    })();

    pb.EndFighterData = (function() {

        /**
         * Properties of an EndFighterData.
         * @memberof pb
         * @interface IEndFighterData
         * @property {number|Long|null} [Uid] EndFighterData Uid
         * @property {boolean|null} [IsRobot] EndFighterData IsRobot
         * @property {boolean|null} [IsSurrender] EndFighterData IsSurrender
         * @property {number|null} [Camp] EndFighterData Camp
         * @property {Array.<pb.ISkinGCard>|null} [InitHandCards] EndFighterData InitHandCards
         * @property {boolean|null} [IsFighter1] EndFighterData IsFighter1
         * @property {boolean|null} [IsFirstHand] EndFighterData IsFirstHand
         * @property {number|null} [Mmr] EndFighterData Mmr
         * @property {Array.<number>|null} [UseCards] EndFighterData UseCards
         */

        /**
         * Constructs a new EndFighterData.
         * @memberof pb
         * @classdesc Represents an EndFighterData.
         * @implements IEndFighterData
         * @constructor
         * @param {pb.IEndFighterData=} [properties] Properties to set
         */
        function EndFighterData(properties) {
            this.InitHandCards = [];
            this.UseCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EndFighterData Uid.
         * @member {number|Long} Uid
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * EndFighterData IsRobot.
         * @member {boolean} IsRobot
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.IsRobot = false;

        /**
         * EndFighterData IsSurrender.
         * @member {boolean} IsSurrender
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.IsSurrender = false;

        /**
         * EndFighterData Camp.
         * @member {number} Camp
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.Camp = 0;

        /**
         * EndFighterData InitHandCards.
         * @member {Array.<pb.ISkinGCard>} InitHandCards
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.InitHandCards = $util.emptyArray;

        /**
         * EndFighterData IsFighter1.
         * @member {boolean} IsFighter1
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.IsFighter1 = false;

        /**
         * EndFighterData IsFirstHand.
         * @member {boolean} IsFirstHand
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.IsFirstHand = false;

        /**
         * EndFighterData Mmr.
         * @member {number} Mmr
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.Mmr = 0;

        /**
         * EndFighterData UseCards.
         * @member {Array.<number>} UseCards
         * @memberof pb.EndFighterData
         * @instance
         */
        EndFighterData.prototype.UseCards = $util.emptyArray;

        /**
         * Creates a new EndFighterData instance using the specified properties.
         * @function create
         * @memberof pb.EndFighterData
         * @static
         * @param {pb.IEndFighterData=} [properties] Properties to set
         * @returns {pb.EndFighterData} EndFighterData instance
         */
        EndFighterData.create = function create(properties) {
            return new EndFighterData(properties);
        };

        /**
         * Encodes the specified EndFighterData message. Does not implicitly {@link pb.EndFighterData.verify|verify} messages.
         * @function encode
         * @memberof pb.EndFighterData
         * @static
         * @param {pb.IEndFighterData} message EndFighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndFighterData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsRobot);
            if (message.IsSurrender != null && message.hasOwnProperty("IsSurrender"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsSurrender);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Camp);
            if (message.InitHandCards != null && message.InitHandCards.length)
                for (var i = 0; i < message.InitHandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.InitHandCards[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.IsFighter1 != null && message.hasOwnProperty("IsFighter1"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsFighter1);
            if (message.IsFirstHand != null && message.hasOwnProperty("IsFirstHand"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.IsFirstHand);
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.Mmr);
            if (message.UseCards != null && message.UseCards.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (var i = 0; i < message.UseCards.length; ++i)
                    writer.uint32(message.UseCards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified EndFighterData message, length delimited. Does not implicitly {@link pb.EndFighterData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.EndFighterData
         * @static
         * @param {pb.IEndFighterData} message EndFighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EndFighterData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EndFighterData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.EndFighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.EndFighterData} EndFighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndFighterData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.EndFighterData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.IsRobot = reader.bool();
                    break;
                case 3:
                    message.IsSurrender = reader.bool();
                    break;
                case 4:
                    message.Camp = reader.int32();
                    break;
                case 5:
                    if (!(message.InitHandCards && message.InitHandCards.length))
                        message.InitHandCards = [];
                    message.InitHandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.IsFighter1 = reader.bool();
                    break;
                case 7:
                    message.IsFirstHand = reader.bool();
                    break;
                case 8:
                    message.Mmr = reader.int32();
                    break;
                case 9:
                    if (!(message.UseCards && message.UseCards.length))
                        message.UseCards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.UseCards.push(reader.uint32());
                    } else
                        message.UseCards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EndFighterData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.EndFighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.EndFighterData} EndFighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EndFighterData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EndFighterData message.
         * @function verify
         * @memberof pb.EndFighterData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EndFighterData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                if (typeof message.IsRobot !== "boolean")
                    return "IsRobot: boolean expected";
            if (message.IsSurrender != null && message.hasOwnProperty("IsSurrender"))
                if (typeof message.IsSurrender !== "boolean")
                    return "IsSurrender: boolean expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.InitHandCards != null && message.hasOwnProperty("InitHandCards")) {
                if (!Array.isArray(message.InitHandCards))
                    return "InitHandCards: array expected";
                for (var i = 0; i < message.InitHandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.InitHandCards[i]);
                    if (error)
                        return "InitHandCards." + error;
                }
            }
            if (message.IsFighter1 != null && message.hasOwnProperty("IsFighter1"))
                if (typeof message.IsFighter1 !== "boolean")
                    return "IsFighter1: boolean expected";
            if (message.IsFirstHand != null && message.hasOwnProperty("IsFirstHand"))
                if (typeof message.IsFirstHand !== "boolean")
                    return "IsFirstHand: boolean expected";
            if (message.Mmr != null && message.hasOwnProperty("Mmr"))
                if (!$util.isInteger(message.Mmr))
                    return "Mmr: integer expected";
            if (message.UseCards != null && message.hasOwnProperty("UseCards")) {
                if (!Array.isArray(message.UseCards))
                    return "UseCards: array expected";
                for (var i = 0; i < message.UseCards.length; ++i)
                    if (!$util.isInteger(message.UseCards[i]))
                        return "UseCards: integer[] expected";
            }
            return null;
        };

        return EndFighterData;
    })();

    pb.RmqBattleEnd = (function() {

        /**
         * Properties of a RmqBattleEnd.
         * @memberof pb
         * @interface IRmqBattleEnd
         * @property {number|Long|null} [BattleID] RmqBattleEnd BattleID
         * @property {number|null} [BattleType] RmqBattleEnd BattleType
         * @property {number|null} [LevelID] RmqBattleEnd LevelID
         * @property {boolean|null} [IsWonderful] RmqBattleEnd IsWonderful
         * @property {pb.IEndFighterData|null} [Winner] RmqBattleEnd Winner
         * @property {pb.IEndFighterData|null} [Loser] RmqBattleEnd Loser
         */

        /**
         * Constructs a new RmqBattleEnd.
         * @memberof pb
         * @classdesc Represents a RmqBattleEnd.
         * @implements IRmqBattleEnd
         * @constructor
         * @param {pb.IRmqBattleEnd=} [properties] Properties to set
         */
        function RmqBattleEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqBattleEnd BattleID.
         * @member {number|Long} BattleID
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.BattleID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqBattleEnd BattleType.
         * @member {number} BattleType
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.BattleType = 0;

        /**
         * RmqBattleEnd LevelID.
         * @member {number} LevelID
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.LevelID = 0;

        /**
         * RmqBattleEnd IsWonderful.
         * @member {boolean} IsWonderful
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.IsWonderful = false;

        /**
         * RmqBattleEnd Winner.
         * @member {pb.IEndFighterData|null|undefined} Winner
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.Winner = null;

        /**
         * RmqBattleEnd Loser.
         * @member {pb.IEndFighterData|null|undefined} Loser
         * @memberof pb.RmqBattleEnd
         * @instance
         */
        RmqBattleEnd.prototype.Loser = null;

        /**
         * Creates a new RmqBattleEnd instance using the specified properties.
         * @function create
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {pb.IRmqBattleEnd=} [properties] Properties to set
         * @returns {pb.RmqBattleEnd} RmqBattleEnd instance
         */
        RmqBattleEnd.create = function create(properties) {
            return new RmqBattleEnd(properties);
        };

        /**
         * Encodes the specified RmqBattleEnd message. Does not implicitly {@link pb.RmqBattleEnd.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {pb.IRmqBattleEnd} message RmqBattleEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBattleEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.BattleID);
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.BattleType);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.LevelID);
            if (message.IsWonderful != null && message.hasOwnProperty("IsWonderful"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsWonderful);
            if (message.Winner != null && message.hasOwnProperty("Winner"))
                $root.pb.EndFighterData.encode(message.Winner, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Loser != null && message.hasOwnProperty("Loser"))
                $root.pb.EndFighterData.encode(message.Loser, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified RmqBattleEnd message, length delimited. Does not implicitly {@link pb.RmqBattleEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {pb.IRmqBattleEnd} message RmqBattleEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBattleEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqBattleEnd message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqBattleEnd} RmqBattleEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBattleEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqBattleEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BattleID = reader.uint64();
                    break;
                case 2:
                    message.BattleType = reader.int32();
                    break;
                case 3:
                    message.LevelID = reader.int32();
                    break;
                case 4:
                    message.IsWonderful = reader.bool();
                    break;
                case 5:
                    message.Winner = $root.pb.EndFighterData.decode(reader, reader.uint32());
                    break;
                case 6:
                    message.Loser = $root.pb.EndFighterData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqBattleEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqBattleEnd} RmqBattleEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBattleEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqBattleEnd message.
         * @function verify
         * @memberof pb.RmqBattleEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqBattleEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                if (!$util.isInteger(message.BattleID) && !(message.BattleID && $util.isInteger(message.BattleID.low) && $util.isInteger(message.BattleID.high)))
                    return "BattleID: integer|Long expected";
            if (message.BattleType != null && message.hasOwnProperty("BattleType"))
                if (!$util.isInteger(message.BattleType))
                    return "BattleType: integer expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            if (message.IsWonderful != null && message.hasOwnProperty("IsWonderful"))
                if (typeof message.IsWonderful !== "boolean")
                    return "IsWonderful: boolean expected";
            if (message.Winner != null && message.hasOwnProperty("Winner")) {
                var error = $root.pb.EndFighterData.verify(message.Winner);
                if (error)
                    return "Winner." + error;
            }
            if (message.Loser != null && message.hasOwnProperty("Loser")) {
                var error = $root.pb.EndFighterData.verify(message.Loser);
                if (error)
                    return "Loser." + error;
            }
            return null;
        };

        return RmqBattleEnd;
    })();

    pb.RmqAddFriendApply = (function() {

        /**
         * Properties of a RmqAddFriendApply.
         * @memberof pb
         * @interface IRmqAddFriendApply
         * @property {number|Long|null} [FromUid] RmqAddFriendApply FromUid
         * @property {string|null} [FromName] RmqAddFriendApply FromName
         * @property {boolean|null} [IsInvite] RmqAddFriendApply IsInvite
         */

        /**
         * Constructs a new RmqAddFriendApply.
         * @memberof pb
         * @classdesc Represents a RmqAddFriendApply.
         * @implements IRmqAddFriendApply
         * @constructor
         * @param {pb.IRmqAddFriendApply=} [properties] Properties to set
         */
        function RmqAddFriendApply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqAddFriendApply FromUid.
         * @member {number|Long} FromUid
         * @memberof pb.RmqAddFriendApply
         * @instance
         */
        RmqAddFriendApply.prototype.FromUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqAddFriendApply FromName.
         * @member {string} FromName
         * @memberof pb.RmqAddFriendApply
         * @instance
         */
        RmqAddFriendApply.prototype.FromName = "";

        /**
         * RmqAddFriendApply IsInvite.
         * @member {boolean} IsInvite
         * @memberof pb.RmqAddFriendApply
         * @instance
         */
        RmqAddFriendApply.prototype.IsInvite = false;

        /**
         * Creates a new RmqAddFriendApply instance using the specified properties.
         * @function create
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {pb.IRmqAddFriendApply=} [properties] Properties to set
         * @returns {pb.RmqAddFriendApply} RmqAddFriendApply instance
         */
        RmqAddFriendApply.create = function create(properties) {
            return new RmqAddFriendApply(properties);
        };

        /**
         * Encodes the specified RmqAddFriendApply message. Does not implicitly {@link pb.RmqAddFriendApply.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {pb.IRmqAddFriendApply} message RmqAddFriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqAddFriendApply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.FromUid);
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.FromName);
            if (message.IsInvite != null && message.hasOwnProperty("IsInvite"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.IsInvite);
            return writer;
        };

        /**
         * Encodes the specified RmqAddFriendApply message, length delimited. Does not implicitly {@link pb.RmqAddFriendApply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {pb.IRmqAddFriendApply} message RmqAddFriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqAddFriendApply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqAddFriendApply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqAddFriendApply} RmqAddFriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqAddFriendApply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqAddFriendApply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromUid = reader.uint64();
                    break;
                case 2:
                    message.FromName = reader.string();
                    break;
                case 3:
                    message.IsInvite = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqAddFriendApply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqAddFriendApply} RmqAddFriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqAddFriendApply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqAddFriendApply message.
         * @function verify
         * @memberof pb.RmqAddFriendApply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqAddFriendApply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                if (!$util.isInteger(message.FromUid) && !(message.FromUid && $util.isInteger(message.FromUid.low) && $util.isInteger(message.FromUid.high)))
                    return "FromUid: integer|Long expected";
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                if (!$util.isString(message.FromName))
                    return "FromName: string expected";
            if (message.IsInvite != null && message.hasOwnProperty("IsInvite"))
                if (typeof message.IsInvite !== "boolean")
                    return "IsInvite: boolean expected";
            return null;
        };

        return RmqAddFriendApply;
    })();

    pb.RmqReplyFriendApply = (function() {

        /**
         * Properties of a RmqReplyFriendApply.
         * @memberof pb
         * @interface IRmqReplyFriendApply
         * @property {number|Long|null} [FromUid] RmqReplyFriendApply FromUid
         * @property {boolean|null} [IsAgree] RmqReplyFriendApply IsAgree
         * @property {string|null} [FromName] RmqReplyFriendApply FromName
         */

        /**
         * Constructs a new RmqReplyFriendApply.
         * @memberof pb
         * @classdesc Represents a RmqReplyFriendApply.
         * @implements IRmqReplyFriendApply
         * @constructor
         * @param {pb.IRmqReplyFriendApply=} [properties] Properties to set
         */
        function RmqReplyFriendApply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqReplyFriendApply FromUid.
         * @member {number|Long} FromUid
         * @memberof pb.RmqReplyFriendApply
         * @instance
         */
        RmqReplyFriendApply.prototype.FromUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqReplyFriendApply IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.RmqReplyFriendApply
         * @instance
         */
        RmqReplyFriendApply.prototype.IsAgree = false;

        /**
         * RmqReplyFriendApply FromName.
         * @member {string} FromName
         * @memberof pb.RmqReplyFriendApply
         * @instance
         */
        RmqReplyFriendApply.prototype.FromName = "";

        /**
         * Creates a new RmqReplyFriendApply instance using the specified properties.
         * @function create
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {pb.IRmqReplyFriendApply=} [properties] Properties to set
         * @returns {pb.RmqReplyFriendApply} RmqReplyFriendApply instance
         */
        RmqReplyFriendApply.create = function create(properties) {
            return new RmqReplyFriendApply(properties);
        };

        /**
         * Encodes the specified RmqReplyFriendApply message. Does not implicitly {@link pb.RmqReplyFriendApply.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {pb.IRmqReplyFriendApply} message RmqReplyFriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqReplyFriendApply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.FromUid);
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsAgree);
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.FromName);
            return writer;
        };

        /**
         * Encodes the specified RmqReplyFriendApply message, length delimited. Does not implicitly {@link pb.RmqReplyFriendApply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {pb.IRmqReplyFriendApply} message RmqReplyFriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqReplyFriendApply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqReplyFriendApply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqReplyFriendApply} RmqReplyFriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqReplyFriendApply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqReplyFriendApply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromUid = reader.uint64();
                    break;
                case 2:
                    message.IsAgree = reader.bool();
                    break;
                case 3:
                    message.FromName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqReplyFriendApply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqReplyFriendApply} RmqReplyFriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqReplyFriendApply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqReplyFriendApply message.
         * @function verify
         * @memberof pb.RmqReplyFriendApply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqReplyFriendApply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                if (!$util.isInteger(message.FromUid) && !(message.FromUid && $util.isInteger(message.FromUid.low) && $util.isInteger(message.FromUid.high)))
                    return "FromUid: integer|Long expected";
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                if (!$util.isString(message.FromName))
                    return "FromName: string expected";
            return null;
        };

        return RmqReplyFriendApply;
    })();

    pb.RmqBeDelFriend = (function() {

        /**
         * Properties of a RmqBeDelFriend.
         * @memberof pb
         * @interface IRmqBeDelFriend
         * @property {number|Long|null} [FromUid] RmqBeDelFriend FromUid
         */

        /**
         * Constructs a new RmqBeDelFriend.
         * @memberof pb
         * @classdesc Represents a RmqBeDelFriend.
         * @implements IRmqBeDelFriend
         * @constructor
         * @param {pb.IRmqBeDelFriend=} [properties] Properties to set
         */
        function RmqBeDelFriend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqBeDelFriend FromUid.
         * @member {number|Long} FromUid
         * @memberof pb.RmqBeDelFriend
         * @instance
         */
        RmqBeDelFriend.prototype.FromUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new RmqBeDelFriend instance using the specified properties.
         * @function create
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {pb.IRmqBeDelFriend=} [properties] Properties to set
         * @returns {pb.RmqBeDelFriend} RmqBeDelFriend instance
         */
        RmqBeDelFriend.create = function create(properties) {
            return new RmqBeDelFriend(properties);
        };

        /**
         * Encodes the specified RmqBeDelFriend message. Does not implicitly {@link pb.RmqBeDelFriend.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {pb.IRmqBeDelFriend} message RmqBeDelFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBeDelFriend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.FromUid);
            return writer;
        };

        /**
         * Encodes the specified RmqBeDelFriend message, length delimited. Does not implicitly {@link pb.RmqBeDelFriend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {pb.IRmqBeDelFriend} message RmqBeDelFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqBeDelFriend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqBeDelFriend message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqBeDelFriend} RmqBeDelFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBeDelFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqBeDelFriend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqBeDelFriend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqBeDelFriend} RmqBeDelFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqBeDelFriend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqBeDelFriend message.
         * @function verify
         * @memberof pb.RmqBeDelFriend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqBeDelFriend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                if (!$util.isInteger(message.FromUid) && !(message.FromUid && $util.isInteger(message.FromUid.low) && $util.isInteger(message.FromUid.high)))
                    return "FromUid: integer|Long expected";
            return null;
        };

        return RmqBeDelFriend;
    })();

    pb.RmqPrivateChat = (function() {

        /**
         * Properties of a RmqPrivateChat.
         * @memberof pb
         * @interface IRmqPrivateChat
         * @property {number|Long|null} [FromUid] RmqPrivateChat FromUid
         * @property {string|null} [FromName] RmqPrivateChat FromName
         * @property {string|null} [FromHeadImgUrl] RmqPrivateChat FromHeadImgUrl
         * @property {string|null} [Msg] RmqPrivateChat Msg
         * @property {number|null} [Time] RmqPrivateChat Time
         * @property {number|null} [FromPvpLevel] RmqPrivateChat FromPvpLevel
         * @property {string|null} [FromCountry] RmqPrivateChat FromCountry
         * @property {string|null} [FromHeadFrame] RmqPrivateChat FromHeadFrame
         */

        /**
         * Constructs a new RmqPrivateChat.
         * @memberof pb
         * @classdesc Represents a RmqPrivateChat.
         * @implements IRmqPrivateChat
         * @constructor
         * @param {pb.IRmqPrivateChat=} [properties] Properties to set
         */
        function RmqPrivateChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqPrivateChat FromUid.
         * @member {number|Long} FromUid
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqPrivateChat FromName.
         * @member {string} FromName
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromName = "";

        /**
         * RmqPrivateChat FromHeadImgUrl.
         * @member {string} FromHeadImgUrl
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromHeadImgUrl = "";

        /**
         * RmqPrivateChat Msg.
         * @member {string} Msg
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.Msg = "";

        /**
         * RmqPrivateChat Time.
         * @member {number} Time
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.Time = 0;

        /**
         * RmqPrivateChat FromPvpLevel.
         * @member {number} FromPvpLevel
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromPvpLevel = 0;

        /**
         * RmqPrivateChat FromCountry.
         * @member {string} FromCountry
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromCountry = "";

        /**
         * RmqPrivateChat FromHeadFrame.
         * @member {string} FromHeadFrame
         * @memberof pb.RmqPrivateChat
         * @instance
         */
        RmqPrivateChat.prototype.FromHeadFrame = "";

        /**
         * Creates a new RmqPrivateChat instance using the specified properties.
         * @function create
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {pb.IRmqPrivateChat=} [properties] Properties to set
         * @returns {pb.RmqPrivateChat} RmqPrivateChat instance
         */
        RmqPrivateChat.create = function create(properties) {
            return new RmqPrivateChat(properties);
        };

        /**
         * Encodes the specified RmqPrivateChat message. Does not implicitly {@link pb.RmqPrivateChat.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {pb.IRmqPrivateChat} message RmqPrivateChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqPrivateChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.FromUid);
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.FromName);
            if (message.FromHeadImgUrl != null && message.hasOwnProperty("FromHeadImgUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.FromHeadImgUrl);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.Msg);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.Time);
            if (message.FromPvpLevel != null && message.hasOwnProperty("FromPvpLevel"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.FromPvpLevel);
            if (message.FromCountry != null && message.hasOwnProperty("FromCountry"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.FromCountry);
            if (message.FromHeadFrame != null && message.hasOwnProperty("FromHeadFrame"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.FromHeadFrame);
            return writer;
        };

        /**
         * Encodes the specified RmqPrivateChat message, length delimited. Does not implicitly {@link pb.RmqPrivateChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {pb.IRmqPrivateChat} message RmqPrivateChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqPrivateChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqPrivateChat message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqPrivateChat} RmqPrivateChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqPrivateChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqPrivateChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromUid = reader.uint64();
                    break;
                case 2:
                    message.FromName = reader.string();
                    break;
                case 3:
                    message.FromHeadImgUrl = reader.string();
                    break;
                case 4:
                    message.Msg = reader.string();
                    break;
                case 5:
                    message.Time = reader.int32();
                    break;
                case 6:
                    message.FromPvpLevel = reader.int32();
                    break;
                case 7:
                    message.FromCountry = reader.string();
                    break;
                case 8:
                    message.FromHeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqPrivateChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqPrivateChat} RmqPrivateChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqPrivateChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqPrivateChat message.
         * @function verify
         * @memberof pb.RmqPrivateChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqPrivateChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromUid != null && message.hasOwnProperty("FromUid"))
                if (!$util.isInteger(message.FromUid) && !(message.FromUid && $util.isInteger(message.FromUid.low) && $util.isInteger(message.FromUid.high)))
                    return "FromUid: integer|Long expected";
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                if (!$util.isString(message.FromName))
                    return "FromName: string expected";
            if (message.FromHeadImgUrl != null && message.hasOwnProperty("FromHeadImgUrl"))
                if (!$util.isString(message.FromHeadImgUrl))
                    return "FromHeadImgUrl: string expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.FromPvpLevel != null && message.hasOwnProperty("FromPvpLevel"))
                if (!$util.isInteger(message.FromPvpLevel))
                    return "FromPvpLevel: integer expected";
            if (message.FromCountry != null && message.hasOwnProperty("FromCountry"))
                if (!$util.isString(message.FromCountry))
                    return "FromCountry: string expected";
            if (message.FromHeadFrame != null && message.hasOwnProperty("FromHeadFrame"))
                if (!$util.isString(message.FromHeadFrame))
                    return "FromHeadFrame: string expected";
            return null;
        };

        return RmqPrivateChat;
    })();

    pb.RmqHelpLevel = (function() {

        /**
         * Properties of a RmqHelpLevel.
         * @memberof pb
         * @interface IRmqHelpLevel
         * @property {number|Long|null} [HelperUid] RmqHelpLevel HelperUid
         * @property {string|null} [HelperName] RmqHelpLevel HelperName
         * @property {number|null} [LevelID] RmqHelpLevel LevelID
         * @property {number|Long|null} [BattleID] RmqHelpLevel BattleID
         */

        /**
         * Constructs a new RmqHelpLevel.
         * @memberof pb
         * @classdesc Represents a RmqHelpLevel.
         * @implements IRmqHelpLevel
         * @constructor
         * @param {pb.IRmqHelpLevel=} [properties] Properties to set
         */
        function RmqHelpLevel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqHelpLevel HelperUid.
         * @member {number|Long} HelperUid
         * @memberof pb.RmqHelpLevel
         * @instance
         */
        RmqHelpLevel.prototype.HelperUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqHelpLevel HelperName.
         * @member {string} HelperName
         * @memberof pb.RmqHelpLevel
         * @instance
         */
        RmqHelpLevel.prototype.HelperName = "";

        /**
         * RmqHelpLevel LevelID.
         * @member {number} LevelID
         * @memberof pb.RmqHelpLevel
         * @instance
         */
        RmqHelpLevel.prototype.LevelID = 0;

        /**
         * RmqHelpLevel BattleID.
         * @member {number|Long} BattleID
         * @memberof pb.RmqHelpLevel
         * @instance
         */
        RmqHelpLevel.prototype.BattleID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new RmqHelpLevel instance using the specified properties.
         * @function create
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {pb.IRmqHelpLevel=} [properties] Properties to set
         * @returns {pb.RmqHelpLevel} RmqHelpLevel instance
         */
        RmqHelpLevel.create = function create(properties) {
            return new RmqHelpLevel(properties);
        };

        /**
         * Encodes the specified RmqHelpLevel message. Does not implicitly {@link pb.RmqHelpLevel.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {pb.IRmqHelpLevel} message RmqHelpLevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqHelpLevel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HelperUid != null && message.hasOwnProperty("HelperUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.HelperUid);
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.HelperName);
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.LevelID);
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.BattleID);
            return writer;
        };

        /**
         * Encodes the specified RmqHelpLevel message, length delimited. Does not implicitly {@link pb.RmqHelpLevel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {pb.IRmqHelpLevel} message RmqHelpLevel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqHelpLevel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqHelpLevel message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqHelpLevel} RmqHelpLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqHelpLevel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqHelpLevel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HelperUid = reader.uint64();
                    break;
                case 2:
                    message.HelperName = reader.string();
                    break;
                case 3:
                    message.LevelID = reader.int32();
                    break;
                case 4:
                    message.BattleID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqHelpLevel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqHelpLevel} RmqHelpLevel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqHelpLevel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqHelpLevel message.
         * @function verify
         * @memberof pb.RmqHelpLevel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqHelpLevel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HelperUid != null && message.hasOwnProperty("HelperUid"))
                if (!$util.isInteger(message.HelperUid) && !(message.HelperUid && $util.isInteger(message.HelperUid.low) && $util.isInteger(message.HelperUid.high)))
                    return "HelperUid: integer|Long expected";
            if (message.HelperName != null && message.hasOwnProperty("HelperName"))
                if (!$util.isString(message.HelperName))
                    return "HelperName: string expected";
            if (message.LevelID != null && message.hasOwnProperty("LevelID"))
                if (!$util.isInteger(message.LevelID))
                    return "LevelID: integer expected";
            if (message.BattleID != null && message.hasOwnProperty("BattleID"))
                if (!$util.isInteger(message.BattleID) && !(message.BattleID && $util.isInteger(message.BattleID.low) && $util.isInteger(message.BattleID.high)))
                    return "BattleID: integer|Long expected";
            return null;
        };

        return RmqHelpLevel;
    })();

    pb.RmqWxInviteFriend = (function() {

        /**
         * Properties of a RmqWxInviteFriend.
         * @memberof pb
         * @interface IRmqWxInviteFriend
         * @property {number|Long|null} [Uid] RmqWxInviteFriend Uid
         * @property {string|null} [HeadImgUrl] RmqWxInviteFriend HeadImgUrl
         * @property {number|null} [MaxPvpLevel] RmqWxInviteFriend MaxPvpLevel
         */

        /**
         * Constructs a new RmqWxInviteFriend.
         * @memberof pb
         * @classdesc Represents a RmqWxInviteFriend.
         * @implements IRmqWxInviteFriend
         * @constructor
         * @param {pb.IRmqWxInviteFriend=} [properties] Properties to set
         */
        function RmqWxInviteFriend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqWxInviteFriend Uid.
         * @member {number|Long} Uid
         * @memberof pb.RmqWxInviteFriend
         * @instance
         */
        RmqWxInviteFriend.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RmqWxInviteFriend HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.RmqWxInviteFriend
         * @instance
         */
        RmqWxInviteFriend.prototype.HeadImgUrl = "";

        /**
         * RmqWxInviteFriend MaxPvpLevel.
         * @member {number} MaxPvpLevel
         * @memberof pb.RmqWxInviteFriend
         * @instance
         */
        RmqWxInviteFriend.prototype.MaxPvpLevel = 0;

        /**
         * Creates a new RmqWxInviteFriend instance using the specified properties.
         * @function create
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {pb.IRmqWxInviteFriend=} [properties] Properties to set
         * @returns {pb.RmqWxInviteFriend} RmqWxInviteFriend instance
         */
        RmqWxInviteFriend.create = function create(properties) {
            return new RmqWxInviteFriend(properties);
        };

        /**
         * Encodes the specified RmqWxInviteFriend message. Does not implicitly {@link pb.RmqWxInviteFriend.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {pb.IRmqWxInviteFriend} message RmqWxInviteFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqWxInviteFriend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.HeadImgUrl);
            if (message.MaxPvpLevel != null && message.hasOwnProperty("MaxPvpLevel"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.MaxPvpLevel);
            return writer;
        };

        /**
         * Encodes the specified RmqWxInviteFriend message, length delimited. Does not implicitly {@link pb.RmqWxInviteFriend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {pb.IRmqWxInviteFriend} message RmqWxInviteFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqWxInviteFriend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqWxInviteFriend message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqWxInviteFriend} RmqWxInviteFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqWxInviteFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqWxInviteFriend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.HeadImgUrl = reader.string();
                    break;
                case 3:
                    message.MaxPvpLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqWxInviteFriend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqWxInviteFriend} RmqWxInviteFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqWxInviteFriend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqWxInviteFriend message.
         * @function verify
         * @memberof pb.RmqWxInviteFriend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqWxInviteFriend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.MaxPvpLevel != null && message.hasOwnProperty("MaxPvpLevel"))
                if (!$util.isInteger(message.MaxPvpLevel))
                    return "MaxPvpLevel: integer expected";
            return null;
        };

        return RmqWxInviteFriend;
    })();

    pb.RmqForbidLogin = (function() {

        /**
         * Properties of a RmqForbidLogin.
         * @memberof pb
         * @interface IRmqForbidLogin
         * @property {boolean|null} [IsForbid] RmqForbidLogin IsForbid
         */

        /**
         * Constructs a new RmqForbidLogin.
         * @memberof pb
         * @classdesc Represents a RmqForbidLogin.
         * @implements IRmqForbidLogin
         * @constructor
         * @param {pb.IRmqForbidLogin=} [properties] Properties to set
         */
        function RmqForbidLogin(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqForbidLogin IsForbid.
         * @member {boolean} IsForbid
         * @memberof pb.RmqForbidLogin
         * @instance
         */
        RmqForbidLogin.prototype.IsForbid = false;

        /**
         * Creates a new RmqForbidLogin instance using the specified properties.
         * @function create
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {pb.IRmqForbidLogin=} [properties] Properties to set
         * @returns {pb.RmqForbidLogin} RmqForbidLogin instance
         */
        RmqForbidLogin.create = function create(properties) {
            return new RmqForbidLogin(properties);
        };

        /**
         * Encodes the specified RmqForbidLogin message. Does not implicitly {@link pb.RmqForbidLogin.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {pb.IRmqForbidLogin} message RmqForbidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqForbidLogin.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsForbid != null && message.hasOwnProperty("IsForbid"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsForbid);
            return writer;
        };

        /**
         * Encodes the specified RmqForbidLogin message, length delimited. Does not implicitly {@link pb.RmqForbidLogin.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {pb.IRmqForbidLogin} message RmqForbidLogin message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqForbidLogin.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqForbidLogin message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqForbidLogin} RmqForbidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqForbidLogin.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqForbidLogin();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsForbid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqForbidLogin message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqForbidLogin} RmqForbidLogin
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqForbidLogin.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqForbidLogin message.
         * @function verify
         * @memberof pb.RmqForbidLogin
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqForbidLogin.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsForbid != null && message.hasOwnProperty("IsForbid"))
                if (typeof message.IsForbid !== "boolean")
                    return "IsForbid: boolean expected";
            return null;
        };

        return RmqForbidLogin;
    })();

    pb.RmqForbidChat = (function() {

        /**
         * Properties of a RmqForbidChat.
         * @memberof pb
         * @interface IRmqForbidChat
         * @property {boolean|null} [IsForbid] RmqForbidChat IsForbid
         */

        /**
         * Constructs a new RmqForbidChat.
         * @memberof pb
         * @classdesc Represents a RmqForbidChat.
         * @implements IRmqForbidChat
         * @constructor
         * @param {pb.IRmqForbidChat=} [properties] Properties to set
         */
        function RmqForbidChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqForbidChat IsForbid.
         * @member {boolean} IsForbid
         * @memberof pb.RmqForbidChat
         * @instance
         */
        RmqForbidChat.prototype.IsForbid = false;

        /**
         * Creates a new RmqForbidChat instance using the specified properties.
         * @function create
         * @memberof pb.RmqForbidChat
         * @static
         * @param {pb.IRmqForbidChat=} [properties] Properties to set
         * @returns {pb.RmqForbidChat} RmqForbidChat instance
         */
        RmqForbidChat.create = function create(properties) {
            return new RmqForbidChat(properties);
        };

        /**
         * Encodes the specified RmqForbidChat message. Does not implicitly {@link pb.RmqForbidChat.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqForbidChat
         * @static
         * @param {pb.IRmqForbidChat} message RmqForbidChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqForbidChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsForbid != null && message.hasOwnProperty("IsForbid"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsForbid);
            return writer;
        };

        /**
         * Encodes the specified RmqForbidChat message, length delimited. Does not implicitly {@link pb.RmqForbidChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqForbidChat
         * @static
         * @param {pb.IRmqForbidChat} message RmqForbidChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqForbidChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqForbidChat message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqForbidChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqForbidChat} RmqForbidChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqForbidChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqForbidChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsForbid = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqForbidChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqForbidChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqForbidChat} RmqForbidChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqForbidChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqForbidChat message.
         * @function verify
         * @memberof pb.RmqForbidChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqForbidChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsForbid != null && message.hasOwnProperty("IsForbid"))
                if (typeof message.IsForbid !== "boolean")
                    return "IsForbid: boolean expected";
            return null;
        };

        return RmqForbidChat;
    })();

    pb.RmqWxShareBeHelp = (function() {

        /**
         * Properties of a RmqWxShareBeHelp.
         * @memberof pb
         * @interface IRmqWxShareBeHelp
         * @property {number|null} [ShareType] RmqWxShareBeHelp ShareType
         * @property {Uint8Array|null} [Data] RmqWxShareBeHelp Data
         */

        /**
         * Constructs a new RmqWxShareBeHelp.
         * @memberof pb
         * @classdesc Represents a RmqWxShareBeHelp.
         * @implements IRmqWxShareBeHelp
         * @constructor
         * @param {pb.IRmqWxShareBeHelp=} [properties] Properties to set
         */
        function RmqWxShareBeHelp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqWxShareBeHelp ShareType.
         * @member {number} ShareType
         * @memberof pb.RmqWxShareBeHelp
         * @instance
         */
        RmqWxShareBeHelp.prototype.ShareType = 0;

        /**
         * RmqWxShareBeHelp Data.
         * @member {Uint8Array} Data
         * @memberof pb.RmqWxShareBeHelp
         * @instance
         */
        RmqWxShareBeHelp.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new RmqWxShareBeHelp instance using the specified properties.
         * @function create
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {pb.IRmqWxShareBeHelp=} [properties] Properties to set
         * @returns {pb.RmqWxShareBeHelp} RmqWxShareBeHelp instance
         */
        RmqWxShareBeHelp.create = function create(properties) {
            return new RmqWxShareBeHelp(properties);
        };

        /**
         * Encodes the specified RmqWxShareBeHelp message. Does not implicitly {@link pb.RmqWxShareBeHelp.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {pb.IRmqWxShareBeHelp} message RmqWxShareBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqWxShareBeHelp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareType);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified RmqWxShareBeHelp message, length delimited. Does not implicitly {@link pb.RmqWxShareBeHelp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {pb.IRmqWxShareBeHelp} message RmqWxShareBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqWxShareBeHelp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqWxShareBeHelp message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqWxShareBeHelp} RmqWxShareBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqWxShareBeHelp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqWxShareBeHelp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareType = reader.int32();
                    break;
                case 2:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqWxShareBeHelp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqWxShareBeHelp} RmqWxShareBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqWxShareBeHelp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqWxShareBeHelp message.
         * @function verify
         * @memberof pb.RmqWxShareBeHelp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqWxShareBeHelp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                if (!$util.isInteger(message.ShareType))
                    return "ShareType: integer expected";
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        return RmqWxShareBeHelp;
    })();

    pb.RmqSdkRecharge = (function() {

        /**
         * Properties of a RmqSdkRecharge.
         * @memberof pb
         * @interface IRmqSdkRecharge
         * @property {string|null} [ChannelUid] RmqSdkRecharge ChannelUid
         * @property {string|null} [CpOrderID] RmqSdkRecharge CpOrderID
         * @property {string|null} [ChannelOrderID] RmqSdkRecharge ChannelOrderID
         * @property {number|null} [PaymentAmount] RmqSdkRecharge PaymentAmount
         */

        /**
         * Constructs a new RmqSdkRecharge.
         * @memberof pb
         * @classdesc Represents a RmqSdkRecharge.
         * @implements IRmqSdkRecharge
         * @constructor
         * @param {pb.IRmqSdkRecharge=} [properties] Properties to set
         */
        function RmqSdkRecharge(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqSdkRecharge ChannelUid.
         * @member {string} ChannelUid
         * @memberof pb.RmqSdkRecharge
         * @instance
         */
        RmqSdkRecharge.prototype.ChannelUid = "";

        /**
         * RmqSdkRecharge CpOrderID.
         * @member {string} CpOrderID
         * @memberof pb.RmqSdkRecharge
         * @instance
         */
        RmqSdkRecharge.prototype.CpOrderID = "";

        /**
         * RmqSdkRecharge ChannelOrderID.
         * @member {string} ChannelOrderID
         * @memberof pb.RmqSdkRecharge
         * @instance
         */
        RmqSdkRecharge.prototype.ChannelOrderID = "";

        /**
         * RmqSdkRecharge PaymentAmount.
         * @member {number} PaymentAmount
         * @memberof pb.RmqSdkRecharge
         * @instance
         */
        RmqSdkRecharge.prototype.PaymentAmount = 0;

        /**
         * Creates a new RmqSdkRecharge instance using the specified properties.
         * @function create
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {pb.IRmqSdkRecharge=} [properties] Properties to set
         * @returns {pb.RmqSdkRecharge} RmqSdkRecharge instance
         */
        RmqSdkRecharge.create = function create(properties) {
            return new RmqSdkRecharge(properties);
        };

        /**
         * Encodes the specified RmqSdkRecharge message. Does not implicitly {@link pb.RmqSdkRecharge.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {pb.IRmqSdkRecharge} message RmqSdkRecharge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqSdkRecharge.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChannelUid != null && message.hasOwnProperty("ChannelUid"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ChannelUid);
            if (message.CpOrderID != null && message.hasOwnProperty("CpOrderID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.CpOrderID);
            if (message.ChannelOrderID != null && message.hasOwnProperty("ChannelOrderID"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.ChannelOrderID);
            if (message.PaymentAmount != null && message.hasOwnProperty("PaymentAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.PaymentAmount);
            return writer;
        };

        /**
         * Encodes the specified RmqSdkRecharge message, length delimited. Does not implicitly {@link pb.RmqSdkRecharge.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {pb.IRmqSdkRecharge} message RmqSdkRecharge message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqSdkRecharge.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqSdkRecharge message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqSdkRecharge} RmqSdkRecharge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqSdkRecharge.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqSdkRecharge();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ChannelUid = reader.string();
                    break;
                case 2:
                    message.CpOrderID = reader.string();
                    break;
                case 3:
                    message.ChannelOrderID = reader.string();
                    break;
                case 4:
                    message.PaymentAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqSdkRecharge message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqSdkRecharge} RmqSdkRecharge
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqSdkRecharge.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqSdkRecharge message.
         * @function verify
         * @memberof pb.RmqSdkRecharge
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqSdkRecharge.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChannelUid != null && message.hasOwnProperty("ChannelUid"))
                if (!$util.isString(message.ChannelUid))
                    return "ChannelUid: string expected";
            if (message.CpOrderID != null && message.hasOwnProperty("CpOrderID"))
                if (!$util.isString(message.CpOrderID))
                    return "CpOrderID: string expected";
            if (message.ChannelOrderID != null && message.hasOwnProperty("ChannelOrderID"))
                if (!$util.isString(message.ChannelOrderID))
                    return "ChannelOrderID: string expected";
            if (message.PaymentAmount != null && message.hasOwnProperty("PaymentAmount"))
                if (!$util.isInteger(message.PaymentAmount))
                    return "PaymentAmount: integer expected";
            return null;
        };

        return RmqSdkRecharge;
    })();

    pb.RmqCampaignMissionDone = (function() {

        /**
         * Properties of a RmqCampaignMissionDone.
         * @memberof pb
         * @interface IRmqCampaignMissionDone
         * @property {Array.<number>|null} [Cards] RmqCampaignMissionDone Cards
         */

        /**
         * Constructs a new RmqCampaignMissionDone.
         * @memberof pb
         * @classdesc Represents a RmqCampaignMissionDone.
         * @implements IRmqCampaignMissionDone
         * @constructor
         * @param {pb.IRmqCampaignMissionDone=} [properties] Properties to set
         */
        function RmqCampaignMissionDone(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqCampaignMissionDone Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.RmqCampaignMissionDone
         * @instance
         */
        RmqCampaignMissionDone.prototype.Cards = $util.emptyArray;

        /**
         * Creates a new RmqCampaignMissionDone instance using the specified properties.
         * @function create
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {pb.IRmqCampaignMissionDone=} [properties] Properties to set
         * @returns {pb.RmqCampaignMissionDone} RmqCampaignMissionDone instance
         */
        RmqCampaignMissionDone.create = function create(properties) {
            return new RmqCampaignMissionDone(properties);
        };

        /**
         * Encodes the specified RmqCampaignMissionDone message. Does not implicitly {@link pb.RmqCampaignMissionDone.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {pb.IRmqCampaignMissionDone} message RmqCampaignMissionDone message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqCampaignMissionDone.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RmqCampaignMissionDone message, length delimited. Does not implicitly {@link pb.RmqCampaignMissionDone.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {pb.IRmqCampaignMissionDone} message RmqCampaignMissionDone message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqCampaignMissionDone.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqCampaignMissionDone message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqCampaignMissionDone} RmqCampaignMissionDone
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqCampaignMissionDone.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqCampaignMissionDone();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqCampaignMissionDone message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqCampaignMissionDone} RmqCampaignMissionDone
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqCampaignMissionDone.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqCampaignMissionDone message.
         * @function verify
         * @memberof pb.RmqCampaignMissionDone
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqCampaignMissionDone.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            return null;
        };

        return RmqCampaignMissionDone;
    })();

    pb.RmqCampaignAcceptMission = (function() {

        /**
         * Properties of a RmqCampaignAcceptMission.
         * @memberof pb
         * @interface IRmqCampaignAcceptMission
         * @property {Array.<number>|null} [Cards] RmqCampaignAcceptMission Cards
         */

        /**
         * Constructs a new RmqCampaignAcceptMission.
         * @memberof pb
         * @classdesc Represents a RmqCampaignAcceptMission.
         * @implements IRmqCampaignAcceptMission
         * @constructor
         * @param {pb.IRmqCampaignAcceptMission=} [properties] Properties to set
         */
        function RmqCampaignAcceptMission(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqCampaignAcceptMission Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.RmqCampaignAcceptMission
         * @instance
         */
        RmqCampaignAcceptMission.prototype.Cards = $util.emptyArray;

        /**
         * Creates a new RmqCampaignAcceptMission instance using the specified properties.
         * @function create
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {pb.IRmqCampaignAcceptMission=} [properties] Properties to set
         * @returns {pb.RmqCampaignAcceptMission} RmqCampaignAcceptMission instance
         */
        RmqCampaignAcceptMission.create = function create(properties) {
            return new RmqCampaignAcceptMission(properties);
        };

        /**
         * Encodes the specified RmqCampaignAcceptMission message. Does not implicitly {@link pb.RmqCampaignAcceptMission.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {pb.IRmqCampaignAcceptMission} message RmqCampaignAcceptMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqCampaignAcceptMission.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified RmqCampaignAcceptMission message, length delimited. Does not implicitly {@link pb.RmqCampaignAcceptMission.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {pb.IRmqCampaignAcceptMission} message RmqCampaignAcceptMission message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqCampaignAcceptMission.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqCampaignAcceptMission message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqCampaignAcceptMission} RmqCampaignAcceptMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqCampaignAcceptMission.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqCampaignAcceptMission();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqCampaignAcceptMission message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqCampaignAcceptMission} RmqCampaignAcceptMission
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqCampaignAcceptMission.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqCampaignAcceptMission message.
         * @function verify
         * @memberof pb.RmqCampaignAcceptMission
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqCampaignAcceptMission.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            return null;
        };

        return RmqCampaignAcceptMission;
    })();

    pb.RmqUnifiedReward = (function() {

        /**
         * Properties of a RmqUnifiedReward.
         * @memberof pb
         * @interface IRmqUnifiedReward
         * @property {number|null} [Rank] RmqUnifiedReward Rank
         * @property {number|null} [Contribution] RmqUnifiedReward Contribution
         * @property {string|null} [YourMajestyName] RmqUnifiedReward YourMajestyName
         * @property {string|null} [CountryName] RmqUnifiedReward CountryName
         */

        /**
         * Constructs a new RmqUnifiedReward.
         * @memberof pb
         * @classdesc Represents a RmqUnifiedReward.
         * @implements IRmqUnifiedReward
         * @constructor
         * @param {pb.IRmqUnifiedReward=} [properties] Properties to set
         */
        function RmqUnifiedReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RmqUnifiedReward Rank.
         * @member {number} Rank
         * @memberof pb.RmqUnifiedReward
         * @instance
         */
        RmqUnifiedReward.prototype.Rank = 0;

        /**
         * RmqUnifiedReward Contribution.
         * @member {number} Contribution
         * @memberof pb.RmqUnifiedReward
         * @instance
         */
        RmqUnifiedReward.prototype.Contribution = 0;

        /**
         * RmqUnifiedReward YourMajestyName.
         * @member {string} YourMajestyName
         * @memberof pb.RmqUnifiedReward
         * @instance
         */
        RmqUnifiedReward.prototype.YourMajestyName = "";

        /**
         * RmqUnifiedReward CountryName.
         * @member {string} CountryName
         * @memberof pb.RmqUnifiedReward
         * @instance
         */
        RmqUnifiedReward.prototype.CountryName = "";

        /**
         * Creates a new RmqUnifiedReward instance using the specified properties.
         * @function create
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {pb.IRmqUnifiedReward=} [properties] Properties to set
         * @returns {pb.RmqUnifiedReward} RmqUnifiedReward instance
         */
        RmqUnifiedReward.create = function create(properties) {
            return new RmqUnifiedReward(properties);
        };

        /**
         * Encodes the specified RmqUnifiedReward message. Does not implicitly {@link pb.RmqUnifiedReward.verify|verify} messages.
         * @function encode
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {pb.IRmqUnifiedReward} message RmqUnifiedReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqUnifiedReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Rank != null && message.hasOwnProperty("Rank"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Rank);
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Contribution);
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.YourMajestyName);
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.CountryName);
            return writer;
        };

        /**
         * Encodes the specified RmqUnifiedReward message, length delimited. Does not implicitly {@link pb.RmqUnifiedReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {pb.IRmqUnifiedReward} message RmqUnifiedReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RmqUnifiedReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RmqUnifiedReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.RmqUnifiedReward} RmqUnifiedReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqUnifiedReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.RmqUnifiedReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Rank = reader.int32();
                    break;
                case 2:
                    message.Contribution = reader.int32();
                    break;
                case 3:
                    message.YourMajestyName = reader.string();
                    break;
                case 4:
                    message.CountryName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RmqUnifiedReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.RmqUnifiedReward} RmqUnifiedReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RmqUnifiedReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RmqUnifiedReward message.
         * @function verify
         * @memberof pb.RmqUnifiedReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RmqUnifiedReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Rank != null && message.hasOwnProperty("Rank"))
                if (!$util.isInteger(message.Rank))
                    return "Rank: integer expected";
            if (message.Contribution != null && message.hasOwnProperty("Contribution"))
                if (!$util.isInteger(message.Contribution))
                    return "Contribution: integer expected";
            if (message.YourMajestyName != null && message.hasOwnProperty("YourMajestyName"))
                if (!$util.isString(message.YourMajestyName))
                    return "YourMajestyName: string expected";
            if (message.CountryName != null && message.hasOwnProperty("CountryName"))
                if (!$util.isString(message.CountryName))
                    return "CountryName: string expected";
            return null;
        };

        return RmqUnifiedReward;
    })();

    pb.LimitGift = (function() {

        /**
         * Properties of a LimitGift.
         * @memberof pb
         * @interface ILimitGift
         * @property {string|null} [GiftID] LimitGift GiftID
         * @property {number|null} [RemainTime] LimitGift RemainTime
         * @property {number|null} [Price] LimitGift Price
         */

        /**
         * Constructs a new LimitGift.
         * @memberof pb
         * @classdesc Represents a LimitGift.
         * @implements ILimitGift
         * @constructor
         * @param {pb.ILimitGift=} [properties] Properties to set
         */
        function LimitGift(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LimitGift GiftID.
         * @member {string} GiftID
         * @memberof pb.LimitGift
         * @instance
         */
        LimitGift.prototype.GiftID = "";

        /**
         * LimitGift RemainTime.
         * @member {number} RemainTime
         * @memberof pb.LimitGift
         * @instance
         */
        LimitGift.prototype.RemainTime = 0;

        /**
         * LimitGift Price.
         * @member {number} Price
         * @memberof pb.LimitGift
         * @instance
         */
        LimitGift.prototype.Price = 0;

        /**
         * Creates a new LimitGift instance using the specified properties.
         * @function create
         * @memberof pb.LimitGift
         * @static
         * @param {pb.ILimitGift=} [properties] Properties to set
         * @returns {pb.LimitGift} LimitGift instance
         */
        LimitGift.create = function create(properties) {
            return new LimitGift(properties);
        };

        /**
         * Encodes the specified LimitGift message. Does not implicitly {@link pb.LimitGift.verify|verify} messages.
         * @function encode
         * @memberof pb.LimitGift
         * @static
         * @param {pb.ILimitGift} message LimitGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LimitGift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GiftID);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RemainTime);
            if (message.Price != null && message.hasOwnProperty("Price"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Price);
            return writer;
        };

        /**
         * Encodes the specified LimitGift message, length delimited. Does not implicitly {@link pb.LimitGift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LimitGift
         * @static
         * @param {pb.ILimitGift} message LimitGift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LimitGift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LimitGift message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LimitGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LimitGift} LimitGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LimitGift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LimitGift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GiftID = reader.string();
                    break;
                case 2:
                    message.RemainTime = reader.int32();
                    break;
                case 3:
                    message.Price = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LimitGift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LimitGift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LimitGift} LimitGift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LimitGift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LimitGift message.
         * @function verify
         * @memberof pb.LimitGift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LimitGift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                if (!$util.isString(message.GiftID))
                    return "GiftID: string expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (!$util.isInteger(message.Price))
                    return "Price: integer expected";
            return null;
        };

        return LimitGift;
    })();

    pb.JadeGoods = (function() {

        /**
         * Properties of a JadeGoods.
         * @memberof pb
         * @interface IJadeGoods
         * @property {string|null} [GoodsID] JadeGoods GoodsID
         * @property {number|null} [Price] JadeGoods Price
         * @property {number|null} [Jade] JadeGoods Jade
         */

        /**
         * Constructs a new JadeGoods.
         * @memberof pb
         * @classdesc Represents a JadeGoods.
         * @implements IJadeGoods
         * @constructor
         * @param {pb.IJadeGoods=} [properties] Properties to set
         */
        function JadeGoods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JadeGoods GoodsID.
         * @member {string} GoodsID
         * @memberof pb.JadeGoods
         * @instance
         */
        JadeGoods.prototype.GoodsID = "";

        /**
         * JadeGoods Price.
         * @member {number} Price
         * @memberof pb.JadeGoods
         * @instance
         */
        JadeGoods.prototype.Price = 0;

        /**
         * JadeGoods Jade.
         * @member {number} Jade
         * @memberof pb.JadeGoods
         * @instance
         */
        JadeGoods.prototype.Jade = 0;

        /**
         * Creates a new JadeGoods instance using the specified properties.
         * @function create
         * @memberof pb.JadeGoods
         * @static
         * @param {pb.IJadeGoods=} [properties] Properties to set
         * @returns {pb.JadeGoods} JadeGoods instance
         */
        JadeGoods.create = function create(properties) {
            return new JadeGoods(properties);
        };

        /**
         * Encodes the specified JadeGoods message. Does not implicitly {@link pb.JadeGoods.verify|verify} messages.
         * @function encode
         * @memberof pb.JadeGoods
         * @static
         * @param {pb.IJadeGoods} message JadeGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JadeGoods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            if (message.Price != null && message.hasOwnProperty("Price"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Price);
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.Jade);
            return writer;
        };

        /**
         * Encodes the specified JadeGoods message, length delimited. Does not implicitly {@link pb.JadeGoods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.JadeGoods
         * @static
         * @param {pb.IJadeGoods} message JadeGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JadeGoods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JadeGoods message from the specified reader or buffer.
         * @function decode
         * @memberof pb.JadeGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.JadeGoods} JadeGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JadeGoods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.JadeGoods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                case 2:
                    message.Price = reader.int32();
                    break;
                case 3:
                    message.Jade = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JadeGoods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.JadeGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.JadeGoods} JadeGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JadeGoods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JadeGoods message.
         * @function verify
         * @memberof pb.JadeGoods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JadeGoods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            if (message.Price != null && message.hasOwnProperty("Price"))
                if (!$util.isInteger(message.Price))
                    return "Price: integer expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            return null;
        };

        return JadeGoods;
    })();

    pb.SoldTreasure = (function() {

        /**
         * Properties of a SoldTreasure.
         * @memberof pb
         * @interface ISoldTreasure
         * @property {string|null} [TreasureModelID] SoldTreasure TreasureModelID
         * @property {number|null} [NeedJade] SoldTreasure NeedJade
         */

        /**
         * Constructs a new SoldTreasure.
         * @memberof pb
         * @classdesc Represents a SoldTreasure.
         * @implements ISoldTreasure
         * @constructor
         * @param {pb.ISoldTreasure=} [properties] Properties to set
         */
        function SoldTreasure(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SoldTreasure TreasureModelID.
         * @member {string} TreasureModelID
         * @memberof pb.SoldTreasure
         * @instance
         */
        SoldTreasure.prototype.TreasureModelID = "";

        /**
         * SoldTreasure NeedJade.
         * @member {number} NeedJade
         * @memberof pb.SoldTreasure
         * @instance
         */
        SoldTreasure.prototype.NeedJade = 0;

        /**
         * Creates a new SoldTreasure instance using the specified properties.
         * @function create
         * @memberof pb.SoldTreasure
         * @static
         * @param {pb.ISoldTreasure=} [properties] Properties to set
         * @returns {pb.SoldTreasure} SoldTreasure instance
         */
        SoldTreasure.create = function create(properties) {
            return new SoldTreasure(properties);
        };

        /**
         * Encodes the specified SoldTreasure message. Does not implicitly {@link pb.SoldTreasure.verify|verify} messages.
         * @function encode
         * @memberof pb.SoldTreasure
         * @static
         * @param {pb.ISoldTreasure} message SoldTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SoldTreasure.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.TreasureModelID);
            if (message.NeedJade != null && message.hasOwnProperty("NeedJade"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NeedJade);
            return writer;
        };

        /**
         * Encodes the specified SoldTreasure message, length delimited. Does not implicitly {@link pb.SoldTreasure.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SoldTreasure
         * @static
         * @param {pb.ISoldTreasure} message SoldTreasure message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SoldTreasure.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SoldTreasure message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SoldTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SoldTreasure} SoldTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SoldTreasure.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SoldTreasure();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureModelID = reader.string();
                    break;
                case 2:
                    message.NeedJade = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SoldTreasure message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SoldTreasure
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SoldTreasure} SoldTreasure
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SoldTreasure.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SoldTreasure message.
         * @function verify
         * @memberof pb.SoldTreasure
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SoldTreasure.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                if (!$util.isString(message.TreasureModelID))
                    return "TreasureModelID: string expected";
            if (message.NeedJade != null && message.hasOwnProperty("NeedJade"))
                if (!$util.isInteger(message.NeedJade))
                    return "NeedJade: integer expected";
            return null;
        };

        return SoldTreasure;
    })();

    pb.GoldGoods = (function() {

        /**
         * Properties of a GoldGoods.
         * @memberof pb
         * @interface IGoldGoods
         * @property {string|null} [GoodsID] GoldGoods GoodsID
         * @property {number|null} [Gold] GoldGoods Gold
         * @property {number|null} [NeedJade] GoldGoods NeedJade
         */

        /**
         * Constructs a new GoldGoods.
         * @memberof pb
         * @classdesc Represents a GoldGoods.
         * @implements IGoldGoods
         * @constructor
         * @param {pb.IGoldGoods=} [properties] Properties to set
         */
        function GoldGoods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GoldGoods GoodsID.
         * @member {string} GoodsID
         * @memberof pb.GoldGoods
         * @instance
         */
        GoldGoods.prototype.GoodsID = "";

        /**
         * GoldGoods Gold.
         * @member {number} Gold
         * @memberof pb.GoldGoods
         * @instance
         */
        GoldGoods.prototype.Gold = 0;

        /**
         * GoldGoods NeedJade.
         * @member {number} NeedJade
         * @memberof pb.GoldGoods
         * @instance
         */
        GoldGoods.prototype.NeedJade = 0;

        /**
         * Creates a new GoldGoods instance using the specified properties.
         * @function create
         * @memberof pb.GoldGoods
         * @static
         * @param {pb.IGoldGoods=} [properties] Properties to set
         * @returns {pb.GoldGoods} GoldGoods instance
         */
        GoldGoods.create = function create(properties) {
            return new GoldGoods(properties);
        };

        /**
         * Encodes the specified GoldGoods message. Does not implicitly {@link pb.GoldGoods.verify|verify} messages.
         * @function encode
         * @memberof pb.GoldGoods
         * @static
         * @param {pb.IGoldGoods} message GoldGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GoldGoods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Gold);
            if (message.NeedJade != null && message.hasOwnProperty("NeedJade"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.NeedJade);
            return writer;
        };

        /**
         * Encodes the specified GoldGoods message, length delimited. Does not implicitly {@link pb.GoldGoods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GoldGoods
         * @static
         * @param {pb.IGoldGoods} message GoldGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GoldGoods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GoldGoods message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GoldGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GoldGoods} GoldGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoldGoods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GoldGoods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                case 2:
                    message.Gold = reader.int32();
                    break;
                case 3:
                    message.NeedJade = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GoldGoods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GoldGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GoldGoods} GoldGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GoldGoods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GoldGoods message.
         * @function verify
         * @memberof pb.GoldGoods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GoldGoods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.NeedJade != null && message.hasOwnProperty("NeedJade"))
                if (!$util.isInteger(message.NeedJade))
                    return "NeedJade: integer expected";
            return null;
        };

        return GoldGoods;
    })();

    pb.ShopData = (function() {

        /**
         * Properties of a ShopData.
         * @memberof pb
         * @interface IShopData
         * @property {Array.<pb.ILimitGift>|null} [Gift] ShopData Gift
         * @property {Array.<pb.ISoldTreasure>|null} [SoldTreasures] ShopData SoldTreasures
         * @property {number|null} [SoldTreasureRemainTime] ShopData SoldTreasureRemainTime
         * @property {Array.<pb.IJadeGoods>|null} [JadeGoodsList] ShopData JadeGoodsList
         * @property {Array.<pb.IGoldGoods>|null} [GoldGoodsList] ShopData GoldGoodsList
         * @property {Array.<pb.IShopFreeAds>|null} [Adses] ShopData Adses
         * @property {number|null} [BuyGoldRemainTime] ShopData BuyGoldRemainTime
         * @property {pb.IVipCardGoods|null} [VipCard] ShopData VipCard
         */

        /**
         * Constructs a new ShopData.
         * @memberof pb
         * @classdesc Represents a ShopData.
         * @implements IShopData
         * @constructor
         * @param {pb.IShopData=} [properties] Properties to set
         */
        function ShopData(properties) {
            this.Gift = [];
            this.SoldTreasures = [];
            this.JadeGoodsList = [];
            this.GoldGoodsList = [];
            this.Adses = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShopData Gift.
         * @member {Array.<pb.ILimitGift>} Gift
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.Gift = $util.emptyArray;

        /**
         * ShopData SoldTreasures.
         * @member {Array.<pb.ISoldTreasure>} SoldTreasures
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.SoldTreasures = $util.emptyArray;

        /**
         * ShopData SoldTreasureRemainTime.
         * @member {number} SoldTreasureRemainTime
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.SoldTreasureRemainTime = 0;

        /**
         * ShopData JadeGoodsList.
         * @member {Array.<pb.IJadeGoods>} JadeGoodsList
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.JadeGoodsList = $util.emptyArray;

        /**
         * ShopData GoldGoodsList.
         * @member {Array.<pb.IGoldGoods>} GoldGoodsList
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.GoldGoodsList = $util.emptyArray;

        /**
         * ShopData Adses.
         * @member {Array.<pb.IShopFreeAds>} Adses
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.Adses = $util.emptyArray;

        /**
         * ShopData BuyGoldRemainTime.
         * @member {number} BuyGoldRemainTime
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.BuyGoldRemainTime = 0;

        /**
         * ShopData VipCard.
         * @member {pb.IVipCardGoods|null|undefined} VipCard
         * @memberof pb.ShopData
         * @instance
         */
        ShopData.prototype.VipCard = null;

        /**
         * Creates a new ShopData instance using the specified properties.
         * @function create
         * @memberof pb.ShopData
         * @static
         * @param {pb.IShopData=} [properties] Properties to set
         * @returns {pb.ShopData} ShopData instance
         */
        ShopData.create = function create(properties) {
            return new ShopData(properties);
        };

        /**
         * Encodes the specified ShopData message. Does not implicitly {@link pb.ShopData.verify|verify} messages.
         * @function encode
         * @memberof pb.ShopData
         * @static
         * @param {pb.IShopData} message ShopData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gift != null && message.Gift.length)
                for (var i = 0; i < message.Gift.length; ++i)
                    $root.pb.LimitGift.encode(message.Gift[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.SoldTreasures != null && message.SoldTreasures.length)
                for (var i = 0; i < message.SoldTreasures.length; ++i)
                    $root.pb.SoldTreasure.encode(message.SoldTreasures[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.SoldTreasureRemainTime != null && message.hasOwnProperty("SoldTreasureRemainTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.SoldTreasureRemainTime);
            if (message.JadeGoodsList != null && message.JadeGoodsList.length)
                for (var i = 0; i < message.JadeGoodsList.length; ++i)
                    $root.pb.JadeGoods.encode(message.JadeGoodsList[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.GoldGoodsList != null && message.GoldGoodsList.length)
                for (var i = 0; i < message.GoldGoodsList.length; ++i)
                    $root.pb.GoldGoods.encode(message.GoldGoodsList[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.Adses != null && message.Adses.length)
                for (var i = 0; i < message.Adses.length; ++i)
                    $root.pb.ShopFreeAds.encode(message.Adses[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.BuyGoldRemainTime != null && message.hasOwnProperty("BuyGoldRemainTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.BuyGoldRemainTime);
            if (message.VipCard != null && message.hasOwnProperty("VipCard"))
                $root.pb.VipCardGoods.encode(message.VipCard, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ShopData message, length delimited. Does not implicitly {@link pb.ShopData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ShopData
         * @static
         * @param {pb.IShopData} message ShopData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShopData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShopData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ShopData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ShopData} ShopData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShopData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Gift && message.Gift.length))
                        message.Gift = [];
                    message.Gift.push($root.pb.LimitGift.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.SoldTreasures && message.SoldTreasures.length))
                        message.SoldTreasures = [];
                    message.SoldTreasures.push($root.pb.SoldTreasure.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.SoldTreasureRemainTime = reader.int32();
                    break;
                case 4:
                    if (!(message.JadeGoodsList && message.JadeGoodsList.length))
                        message.JadeGoodsList = [];
                    message.JadeGoodsList.push($root.pb.JadeGoods.decode(reader, reader.uint32()));
                    break;
                case 5:
                    if (!(message.GoldGoodsList && message.GoldGoodsList.length))
                        message.GoldGoodsList = [];
                    message.GoldGoodsList.push($root.pb.GoldGoods.decode(reader, reader.uint32()));
                    break;
                case 6:
                    if (!(message.Adses && message.Adses.length))
                        message.Adses = [];
                    message.Adses.push($root.pb.ShopFreeAds.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.BuyGoldRemainTime = reader.int32();
                    break;
                case 8:
                    message.VipCard = $root.pb.VipCardGoods.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShopData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ShopData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ShopData} ShopData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShopData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShopData message.
         * @function verify
         * @memberof pb.ShopData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShopData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gift != null && message.hasOwnProperty("Gift")) {
                if (!Array.isArray(message.Gift))
                    return "Gift: array expected";
                for (var i = 0; i < message.Gift.length; ++i) {
                    var error = $root.pb.LimitGift.verify(message.Gift[i]);
                    if (error)
                        return "Gift." + error;
                }
            }
            if (message.SoldTreasures != null && message.hasOwnProperty("SoldTreasures")) {
                if (!Array.isArray(message.SoldTreasures))
                    return "SoldTreasures: array expected";
                for (var i = 0; i < message.SoldTreasures.length; ++i) {
                    var error = $root.pb.SoldTreasure.verify(message.SoldTreasures[i]);
                    if (error)
                        return "SoldTreasures." + error;
                }
            }
            if (message.SoldTreasureRemainTime != null && message.hasOwnProperty("SoldTreasureRemainTime"))
                if (!$util.isInteger(message.SoldTreasureRemainTime))
                    return "SoldTreasureRemainTime: integer expected";
            if (message.JadeGoodsList != null && message.hasOwnProperty("JadeGoodsList")) {
                if (!Array.isArray(message.JadeGoodsList))
                    return "JadeGoodsList: array expected";
                for (var i = 0; i < message.JadeGoodsList.length; ++i) {
                    var error = $root.pb.JadeGoods.verify(message.JadeGoodsList[i]);
                    if (error)
                        return "JadeGoodsList." + error;
                }
            }
            if (message.GoldGoodsList != null && message.hasOwnProperty("GoldGoodsList")) {
                if (!Array.isArray(message.GoldGoodsList))
                    return "GoldGoodsList: array expected";
                for (var i = 0; i < message.GoldGoodsList.length; ++i) {
                    var error = $root.pb.GoldGoods.verify(message.GoldGoodsList[i]);
                    if (error)
                        return "GoldGoodsList." + error;
                }
            }
            if (message.Adses != null && message.hasOwnProperty("Adses")) {
                if (!Array.isArray(message.Adses))
                    return "Adses: array expected";
                for (var i = 0; i < message.Adses.length; ++i) {
                    var error = $root.pb.ShopFreeAds.verify(message.Adses[i]);
                    if (error)
                        return "Adses." + error;
                }
            }
            if (message.BuyGoldRemainTime != null && message.hasOwnProperty("BuyGoldRemainTime"))
                if (!$util.isInteger(message.BuyGoldRemainTime))
                    return "BuyGoldRemainTime: integer expected";
            if (message.VipCard != null && message.hasOwnProperty("VipCard")) {
                var error = $root.pb.VipCardGoods.verify(message.VipCard);
                if (error)
                    return "VipCard." + error;
            }
            return null;
        };

        return ShopData;
    })();

    pb.VipCardGoods = (function() {

        /**
         * Properties of a VipCardGoods.
         * @memberof pb
         * @interface IVipCardGoods
         * @property {string|null} [GoodsID] VipCardGoods GoodsID
         * @property {number|null} [JadePrice] VipCardGoods JadePrice
         */

        /**
         * Constructs a new VipCardGoods.
         * @memberof pb
         * @classdesc Represents a VipCardGoods.
         * @implements IVipCardGoods
         * @constructor
         * @param {pb.IVipCardGoods=} [properties] Properties to set
         */
        function VipCardGoods(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VipCardGoods GoodsID.
         * @member {string} GoodsID
         * @memberof pb.VipCardGoods
         * @instance
         */
        VipCardGoods.prototype.GoodsID = "";

        /**
         * VipCardGoods JadePrice.
         * @member {number} JadePrice
         * @memberof pb.VipCardGoods
         * @instance
         */
        VipCardGoods.prototype.JadePrice = 0;

        /**
         * Creates a new VipCardGoods instance using the specified properties.
         * @function create
         * @memberof pb.VipCardGoods
         * @static
         * @param {pb.IVipCardGoods=} [properties] Properties to set
         * @returns {pb.VipCardGoods} VipCardGoods instance
         */
        VipCardGoods.create = function create(properties) {
            return new VipCardGoods(properties);
        };

        /**
         * Encodes the specified VipCardGoods message. Does not implicitly {@link pb.VipCardGoods.verify|verify} messages.
         * @function encode
         * @memberof pb.VipCardGoods
         * @static
         * @param {pb.IVipCardGoods} message VipCardGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipCardGoods.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            if (message.JadePrice != null && message.hasOwnProperty("JadePrice"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.JadePrice);
            return writer;
        };

        /**
         * Encodes the specified VipCardGoods message, length delimited. Does not implicitly {@link pb.VipCardGoods.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VipCardGoods
         * @static
         * @param {pb.IVipCardGoods} message VipCardGoods message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VipCardGoods.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VipCardGoods message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VipCardGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VipCardGoods} VipCardGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipCardGoods.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VipCardGoods();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                case 2:
                    message.JadePrice = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VipCardGoods message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VipCardGoods
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VipCardGoods} VipCardGoods
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VipCardGoods.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VipCardGoods message.
         * @function verify
         * @memberof pb.VipCardGoods
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VipCardGoods.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            if (message.JadePrice != null && message.hasOwnProperty("JadePrice"))
                if (!$util.isInteger(message.JadePrice))
                    return "JadePrice: integer expected";
            return null;
        };

        return VipCardGoods;
    })();

    pb.BuyJadeArg = (function() {

        /**
         * Properties of a BuyJadeArg.
         * @memberof pb
         * @interface IBuyJadeArg
         * @property {string|null} [GoodsID] BuyJadeArg GoodsID
         * @property {string|null} [Receipt] BuyJadeArg Receipt
         */

        /**
         * Constructs a new BuyJadeArg.
         * @memberof pb
         * @classdesc Represents a BuyJadeArg.
         * @implements IBuyJadeArg
         * @constructor
         * @param {pb.IBuyJadeArg=} [properties] Properties to set
         */
        function BuyJadeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyJadeArg GoodsID.
         * @member {string} GoodsID
         * @memberof pb.BuyJadeArg
         * @instance
         */
        BuyJadeArg.prototype.GoodsID = "";

        /**
         * BuyJadeArg Receipt.
         * @member {string} Receipt
         * @memberof pb.BuyJadeArg
         * @instance
         */
        BuyJadeArg.prototype.Receipt = "";

        /**
         * Creates a new BuyJadeArg instance using the specified properties.
         * @function create
         * @memberof pb.BuyJadeArg
         * @static
         * @param {pb.IBuyJadeArg=} [properties] Properties to set
         * @returns {pb.BuyJadeArg} BuyJadeArg instance
         */
        BuyJadeArg.create = function create(properties) {
            return new BuyJadeArg(properties);
        };

        /**
         * Encodes the specified BuyJadeArg message. Does not implicitly {@link pb.BuyJadeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyJadeArg
         * @static
         * @param {pb.IBuyJadeArg} message BuyJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyJadeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            if (message.Receipt != null && message.hasOwnProperty("Receipt"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Receipt);
            return writer;
        };

        /**
         * Encodes the specified BuyJadeArg message, length delimited. Does not implicitly {@link pb.BuyJadeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyJadeArg
         * @static
         * @param {pb.IBuyJadeArg} message BuyJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyJadeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyJadeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyJadeArg} BuyJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyJadeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyJadeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                case 2:
                    message.Receipt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyJadeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyJadeArg} BuyJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyJadeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyJadeArg message.
         * @function verify
         * @memberof pb.BuyJadeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyJadeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            if (message.Receipt != null && message.hasOwnProperty("Receipt"))
                if (!$util.isString(message.Receipt))
                    return "Receipt: string expected";
            return null;
        };

        return BuyJadeArg;
    })();

    pb.BuyJadeReply = (function() {

        /**
         * Properties of a BuyJadeReply.
         * @memberof pb
         * @interface IBuyJadeReply
         * @property {number|null} [Jade] BuyJadeReply Jade
         * @property {number|null} [RewardJade] BuyJadeReply RewardJade
         */

        /**
         * Constructs a new BuyJadeReply.
         * @memberof pb
         * @classdesc Represents a BuyJadeReply.
         * @implements IBuyJadeReply
         * @constructor
         * @param {pb.IBuyJadeReply=} [properties] Properties to set
         */
        function BuyJadeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyJadeReply Jade.
         * @member {number} Jade
         * @memberof pb.BuyJadeReply
         * @instance
         */
        BuyJadeReply.prototype.Jade = 0;

        /**
         * BuyJadeReply RewardJade.
         * @member {number} RewardJade
         * @memberof pb.BuyJadeReply
         * @instance
         */
        BuyJadeReply.prototype.RewardJade = 0;

        /**
         * Creates a new BuyJadeReply instance using the specified properties.
         * @function create
         * @memberof pb.BuyJadeReply
         * @static
         * @param {pb.IBuyJadeReply=} [properties] Properties to set
         * @returns {pb.BuyJadeReply} BuyJadeReply instance
         */
        BuyJadeReply.create = function create(properties) {
            return new BuyJadeReply(properties);
        };

        /**
         * Encodes the specified BuyJadeReply message. Does not implicitly {@link pb.BuyJadeReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyJadeReply
         * @static
         * @param {pb.IBuyJadeReply} message BuyJadeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyJadeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Jade);
            if (message.RewardJade != null && message.hasOwnProperty("RewardJade"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RewardJade);
            return writer;
        };

        /**
         * Encodes the specified BuyJadeReply message, length delimited. Does not implicitly {@link pb.BuyJadeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyJadeReply
         * @static
         * @param {pb.IBuyJadeReply} message BuyJadeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyJadeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyJadeReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyJadeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyJadeReply} BuyJadeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyJadeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyJadeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Jade = reader.int32();
                    break;
                case 2:
                    message.RewardJade = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyJadeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyJadeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyJadeReply} BuyJadeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyJadeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyJadeReply message.
         * @function verify
         * @memberof pb.BuyJadeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyJadeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            if (message.RewardJade != null && message.hasOwnProperty("RewardJade"))
                if (!$util.isInteger(message.RewardJade))
                    return "RewardJade: integer expected";
            return null;
        };

        return BuyJadeReply;
    })();

    pb.BuyLimitGiftArg = (function() {

        /**
         * Properties of a BuyLimitGiftArg.
         * @memberof pb
         * @interface IBuyLimitGiftArg
         * @property {string|null} [GiftID] BuyLimitGiftArg GiftID
         * @property {string|null} [Receipt] BuyLimitGiftArg Receipt
         */

        /**
         * Constructs a new BuyLimitGiftArg.
         * @memberof pb
         * @classdesc Represents a BuyLimitGiftArg.
         * @implements IBuyLimitGiftArg
         * @constructor
         * @param {pb.IBuyLimitGiftArg=} [properties] Properties to set
         */
        function BuyLimitGiftArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyLimitGiftArg GiftID.
         * @member {string} GiftID
         * @memberof pb.BuyLimitGiftArg
         * @instance
         */
        BuyLimitGiftArg.prototype.GiftID = "";

        /**
         * BuyLimitGiftArg Receipt.
         * @member {string} Receipt
         * @memberof pb.BuyLimitGiftArg
         * @instance
         */
        BuyLimitGiftArg.prototype.Receipt = "";

        /**
         * Creates a new BuyLimitGiftArg instance using the specified properties.
         * @function create
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {pb.IBuyLimitGiftArg=} [properties] Properties to set
         * @returns {pb.BuyLimitGiftArg} BuyLimitGiftArg instance
         */
        BuyLimitGiftArg.create = function create(properties) {
            return new BuyLimitGiftArg(properties);
        };

        /**
         * Encodes the specified BuyLimitGiftArg message. Does not implicitly {@link pb.BuyLimitGiftArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {pb.IBuyLimitGiftArg} message BuyLimitGiftArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GiftID);
            if (message.Receipt != null && message.hasOwnProperty("Receipt"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Receipt);
            return writer;
        };

        /**
         * Encodes the specified BuyLimitGiftArg message, length delimited. Does not implicitly {@link pb.BuyLimitGiftArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {pb.IBuyLimitGiftArg} message BuyLimitGiftArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyLimitGiftArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyLimitGiftArg} BuyLimitGiftArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyLimitGiftArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GiftID = reader.string();
                    break;
                case 2:
                    message.Receipt = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyLimitGiftArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyLimitGiftArg} BuyLimitGiftArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyLimitGiftArg message.
         * @function verify
         * @memberof pb.BuyLimitGiftArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyLimitGiftArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                if (!$util.isString(message.GiftID))
                    return "GiftID: string expected";
            if (message.Receipt != null && message.hasOwnProperty("Receipt"))
                if (!$util.isString(message.Receipt))
                    return "Receipt: string expected";
            return null;
        };

        return BuyLimitGiftArg;
    })();

    pb.BuyLimitGiftReply = (function() {

        /**
         * Properties of a BuyLimitGiftReply.
         * @memberof pb
         * @interface IBuyLimitGiftReply
         * @property {pb.IOpenTreasureReply|null} [GiftReward] BuyLimitGiftReply GiftReward
         * @property {pb.ILimitGift|null} [NextGift] BuyLimitGiftReply NextGift
         */

        /**
         * Constructs a new BuyLimitGiftReply.
         * @memberof pb
         * @classdesc Represents a BuyLimitGiftReply.
         * @implements IBuyLimitGiftReply
         * @constructor
         * @param {pb.IBuyLimitGiftReply=} [properties] Properties to set
         */
        function BuyLimitGiftReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyLimitGiftReply GiftReward.
         * @member {pb.IOpenTreasureReply|null|undefined} GiftReward
         * @memberof pb.BuyLimitGiftReply
         * @instance
         */
        BuyLimitGiftReply.prototype.GiftReward = null;

        /**
         * BuyLimitGiftReply NextGift.
         * @member {pb.ILimitGift|null|undefined} NextGift
         * @memberof pb.BuyLimitGiftReply
         * @instance
         */
        BuyLimitGiftReply.prototype.NextGift = null;

        /**
         * Creates a new BuyLimitGiftReply instance using the specified properties.
         * @function create
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {pb.IBuyLimitGiftReply=} [properties] Properties to set
         * @returns {pb.BuyLimitGiftReply} BuyLimitGiftReply instance
         */
        BuyLimitGiftReply.create = function create(properties) {
            return new BuyLimitGiftReply(properties);
        };

        /**
         * Encodes the specified BuyLimitGiftReply message. Does not implicitly {@link pb.BuyLimitGiftReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {pb.IBuyLimitGiftReply} message BuyLimitGiftReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GiftReward != null && message.hasOwnProperty("GiftReward"))
                $root.pb.OpenTreasureReply.encode(message.GiftReward, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.NextGift != null && message.hasOwnProperty("NextGift"))
                $root.pb.LimitGift.encode(message.NextGift, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BuyLimitGiftReply message, length delimited. Does not implicitly {@link pb.BuyLimitGiftReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {pb.IBuyLimitGiftReply} message BuyLimitGiftReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyLimitGiftReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyLimitGiftReply} BuyLimitGiftReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyLimitGiftReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GiftReward = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.NextGift = $root.pb.LimitGift.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyLimitGiftReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyLimitGiftReply} BuyLimitGiftReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyLimitGiftReply message.
         * @function verify
         * @memberof pb.BuyLimitGiftReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyLimitGiftReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GiftReward != null && message.hasOwnProperty("GiftReward")) {
                var error = $root.pb.OpenTreasureReply.verify(message.GiftReward);
                if (error)
                    return "GiftReward." + error;
            }
            if (message.NextGift != null && message.hasOwnProperty("NextGift")) {
                var error = $root.pb.LimitGift.verify(message.NextGift);
                if (error)
                    return "NextGift." + error;
            }
            return null;
        };

        return BuyLimitGiftReply;
    })();

    pb.BuySoldTreasureArg = (function() {

        /**
         * Properties of a BuySoldTreasureArg.
         * @memberof pb
         * @interface IBuySoldTreasureArg
         * @property {string|null} [TreasureModelID] BuySoldTreasureArg TreasureModelID
         */

        /**
         * Constructs a new BuySoldTreasureArg.
         * @memberof pb
         * @classdesc Represents a BuySoldTreasureArg.
         * @implements IBuySoldTreasureArg
         * @constructor
         * @param {pb.IBuySoldTreasureArg=} [properties] Properties to set
         */
        function BuySoldTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuySoldTreasureArg TreasureModelID.
         * @member {string} TreasureModelID
         * @memberof pb.BuySoldTreasureArg
         * @instance
         */
        BuySoldTreasureArg.prototype.TreasureModelID = "";

        /**
         * Creates a new BuySoldTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {pb.IBuySoldTreasureArg=} [properties] Properties to set
         * @returns {pb.BuySoldTreasureArg} BuySoldTreasureArg instance
         */
        BuySoldTreasureArg.create = function create(properties) {
            return new BuySoldTreasureArg(properties);
        };

        /**
         * Encodes the specified BuySoldTreasureArg message. Does not implicitly {@link pb.BuySoldTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {pb.IBuySoldTreasureArg} message BuySoldTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySoldTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.TreasureModelID);
            return writer;
        };

        /**
         * Encodes the specified BuySoldTreasureArg message, length delimited. Does not implicitly {@link pb.BuySoldTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {pb.IBuySoldTreasureArg} message BuySoldTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySoldTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuySoldTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuySoldTreasureArg} BuySoldTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySoldTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySoldTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureModelID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuySoldTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuySoldTreasureArg} BuySoldTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySoldTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuySoldTreasureArg message.
         * @function verify
         * @memberof pb.BuySoldTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuySoldTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureModelID != null && message.hasOwnProperty("TreasureModelID"))
                if (!$util.isString(message.TreasureModelID))
                    return "TreasureModelID: string expected";
            return null;
        };

        return BuySoldTreasureArg;
    })();

    pb.BuySoldTreasureReply = (function() {

        /**
         * Properties of a BuySoldTreasureReply.
         * @memberof pb
         * @interface IBuySoldTreasureReply
         * @property {pb.IOpenTreasureReply|null} [TreasureReward] BuySoldTreasureReply TreasureReward
         * @property {number|null} [NextRemainTime] BuySoldTreasureReply NextRemainTime
         */

        /**
         * Constructs a new BuySoldTreasureReply.
         * @memberof pb
         * @classdesc Represents a BuySoldTreasureReply.
         * @implements IBuySoldTreasureReply
         * @constructor
         * @param {pb.IBuySoldTreasureReply=} [properties] Properties to set
         */
        function BuySoldTreasureReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuySoldTreasureReply TreasureReward.
         * @member {pb.IOpenTreasureReply|null|undefined} TreasureReward
         * @memberof pb.BuySoldTreasureReply
         * @instance
         */
        BuySoldTreasureReply.prototype.TreasureReward = null;

        /**
         * BuySoldTreasureReply NextRemainTime.
         * @member {number} NextRemainTime
         * @memberof pb.BuySoldTreasureReply
         * @instance
         */
        BuySoldTreasureReply.prototype.NextRemainTime = 0;

        /**
         * Creates a new BuySoldTreasureReply instance using the specified properties.
         * @function create
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {pb.IBuySoldTreasureReply=} [properties] Properties to set
         * @returns {pb.BuySoldTreasureReply} BuySoldTreasureReply instance
         */
        BuySoldTreasureReply.create = function create(properties) {
            return new BuySoldTreasureReply(properties);
        };

        /**
         * Encodes the specified BuySoldTreasureReply message. Does not implicitly {@link pb.BuySoldTreasureReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {pb.IBuySoldTreasureReply} message BuySoldTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySoldTreasureReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward"))
                $root.pb.OpenTreasureReply.encode(message.TreasureReward, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.NextRemainTime != null && message.hasOwnProperty("NextRemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NextRemainTime);
            return writer;
        };

        /**
         * Encodes the specified BuySoldTreasureReply message, length delimited. Does not implicitly {@link pb.BuySoldTreasureReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {pb.IBuySoldTreasureReply} message BuySoldTreasureReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuySoldTreasureReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuySoldTreasureReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuySoldTreasureReply} BuySoldTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySoldTreasureReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuySoldTreasureReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureReward = $root.pb.OpenTreasureReply.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.NextRemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuySoldTreasureReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuySoldTreasureReply} BuySoldTreasureReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuySoldTreasureReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuySoldTreasureReply message.
         * @function verify
         * @memberof pb.BuySoldTreasureReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuySoldTreasureReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureReward != null && message.hasOwnProperty("TreasureReward")) {
                var error = $root.pb.OpenTreasureReply.verify(message.TreasureReward);
                if (error)
                    return "TreasureReward." + error;
            }
            if (message.NextRemainTime != null && message.hasOwnProperty("NextRemainTime"))
                if (!$util.isInteger(message.NextRemainTime))
                    return "NextRemainTime: integer expected";
            return null;
        };

        return BuySoldTreasureReply;
    })();

    pb.BuyGoldArg = (function() {

        /**
         * Properties of a BuyGoldArg.
         * @memberof pb
         * @interface IBuyGoldArg
         * @property {string|null} [GoodsID] BuyGoldArg GoodsID
         */

        /**
         * Constructs a new BuyGoldArg.
         * @memberof pb
         * @classdesc Represents a BuyGoldArg.
         * @implements IBuyGoldArg
         * @constructor
         * @param {pb.IBuyGoldArg=} [properties] Properties to set
         */
        function BuyGoldArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyGoldArg GoodsID.
         * @member {string} GoodsID
         * @memberof pb.BuyGoldArg
         * @instance
         */
        BuyGoldArg.prototype.GoodsID = "";

        /**
         * Creates a new BuyGoldArg instance using the specified properties.
         * @function create
         * @memberof pb.BuyGoldArg
         * @static
         * @param {pb.IBuyGoldArg=} [properties] Properties to set
         * @returns {pb.BuyGoldArg} BuyGoldArg instance
         */
        BuyGoldArg.create = function create(properties) {
            return new BuyGoldArg(properties);
        };

        /**
         * Encodes the specified BuyGoldArg message. Does not implicitly {@link pb.BuyGoldArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyGoldArg
         * @static
         * @param {pb.IBuyGoldArg} message BuyGoldArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGoldArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified BuyGoldArg message, length delimited. Does not implicitly {@link pb.BuyGoldArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyGoldArg
         * @static
         * @param {pb.IBuyGoldArg} message BuyGoldArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGoldArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyGoldArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyGoldArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyGoldArg} BuyGoldArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGoldArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyGoldArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyGoldArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyGoldArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyGoldArg} BuyGoldArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGoldArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyGoldArg message.
         * @function verify
         * @memberof pb.BuyGoldArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyGoldArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            return null;
        };

        return BuyGoldArg;
    })();

    pb.BuyGoldReply = (function() {

        /**
         * Properties of a BuyGoldReply.
         * @memberof pb
         * @interface IBuyGoldReply
         * @property {number|null} [Gold] BuyGoldReply Gold
         * @property {number|null} [NextRemainTime] BuyGoldReply NextRemainTime
         */

        /**
         * Constructs a new BuyGoldReply.
         * @memberof pb
         * @classdesc Represents a BuyGoldReply.
         * @implements IBuyGoldReply
         * @constructor
         * @param {pb.IBuyGoldReply=} [properties] Properties to set
         */
        function BuyGoldReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyGoldReply Gold.
         * @member {number} Gold
         * @memberof pb.BuyGoldReply
         * @instance
         */
        BuyGoldReply.prototype.Gold = 0;

        /**
         * BuyGoldReply NextRemainTime.
         * @member {number} NextRemainTime
         * @memberof pb.BuyGoldReply
         * @instance
         */
        BuyGoldReply.prototype.NextRemainTime = 0;

        /**
         * Creates a new BuyGoldReply instance using the specified properties.
         * @function create
         * @memberof pb.BuyGoldReply
         * @static
         * @param {pb.IBuyGoldReply=} [properties] Properties to set
         * @returns {pb.BuyGoldReply} BuyGoldReply instance
         */
        BuyGoldReply.create = function create(properties) {
            return new BuyGoldReply(properties);
        };

        /**
         * Encodes the specified BuyGoldReply message. Does not implicitly {@link pb.BuyGoldReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyGoldReply
         * @static
         * @param {pb.IBuyGoldReply} message BuyGoldReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGoldReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            if (message.NextRemainTime != null && message.hasOwnProperty("NextRemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.NextRemainTime);
            return writer;
        };

        /**
         * Encodes the specified BuyGoldReply message, length delimited. Does not implicitly {@link pb.BuyGoldReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyGoldReply
         * @static
         * @param {pb.IBuyGoldReply} message BuyGoldReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGoldReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyGoldReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyGoldReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyGoldReply} BuyGoldReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGoldReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyGoldReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                case 2:
                    message.NextRemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyGoldReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyGoldReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyGoldReply} BuyGoldReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGoldReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyGoldReply message.
         * @function verify
         * @memberof pb.BuyGoldReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyGoldReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.NextRemainTime != null && message.hasOwnProperty("NextRemainTime"))
                if (!$util.isInteger(message.NextRemainTime))
                    return "NextRemainTime: integer expected";
            return null;
        };

        return BuyGoldReply;
    })();

    pb.SdkCreateOrderArg = (function() {

        /**
         * Properties of a SdkCreateOrderArg.
         * @memberof pb
         * @interface ISdkCreateOrderArg
         * @property {string|null} [GoodsID] SdkCreateOrderArg GoodsID
         */

        /**
         * Constructs a new SdkCreateOrderArg.
         * @memberof pb
         * @classdesc Represents a SdkCreateOrderArg.
         * @implements ISdkCreateOrderArg
         * @constructor
         * @param {pb.ISdkCreateOrderArg=} [properties] Properties to set
         */
        function SdkCreateOrderArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SdkCreateOrderArg GoodsID.
         * @member {string} GoodsID
         * @memberof pb.SdkCreateOrderArg
         * @instance
         */
        SdkCreateOrderArg.prototype.GoodsID = "";

        /**
         * Creates a new SdkCreateOrderArg instance using the specified properties.
         * @function create
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {pb.ISdkCreateOrderArg=} [properties] Properties to set
         * @returns {pb.SdkCreateOrderArg} SdkCreateOrderArg instance
         */
        SdkCreateOrderArg.create = function create(properties) {
            return new SdkCreateOrderArg(properties);
        };

        /**
         * Encodes the specified SdkCreateOrderArg message. Does not implicitly {@link pb.SdkCreateOrderArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {pb.ISdkCreateOrderArg} message SdkCreateOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkCreateOrderArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified SdkCreateOrderArg message, length delimited. Does not implicitly {@link pb.SdkCreateOrderArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {pb.ISdkCreateOrderArg} message SdkCreateOrderArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkCreateOrderArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkCreateOrderArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SdkCreateOrderArg} SdkCreateOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkCreateOrderArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SdkCreateOrderArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkCreateOrderArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SdkCreateOrderArg} SdkCreateOrderArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkCreateOrderArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkCreateOrderArg message.
         * @function verify
         * @memberof pb.SdkCreateOrderArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkCreateOrderArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            return null;
        };

        return SdkCreateOrderArg;
    })();

    pb.SdkCreateOrderReply = (function() {

        /**
         * Properties of a SdkCreateOrderReply.
         * @memberof pb
         * @interface ISdkCreateOrderReply
         * @property {string|null} [OrderID] SdkCreateOrderReply OrderID
         */

        /**
         * Constructs a new SdkCreateOrderReply.
         * @memberof pb
         * @classdesc Represents a SdkCreateOrderReply.
         * @implements ISdkCreateOrderReply
         * @constructor
         * @param {pb.ISdkCreateOrderReply=} [properties] Properties to set
         */
        function SdkCreateOrderReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SdkCreateOrderReply OrderID.
         * @member {string} OrderID
         * @memberof pb.SdkCreateOrderReply
         * @instance
         */
        SdkCreateOrderReply.prototype.OrderID = "";

        /**
         * Creates a new SdkCreateOrderReply instance using the specified properties.
         * @function create
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {pb.ISdkCreateOrderReply=} [properties] Properties to set
         * @returns {pb.SdkCreateOrderReply} SdkCreateOrderReply instance
         */
        SdkCreateOrderReply.create = function create(properties) {
            return new SdkCreateOrderReply(properties);
        };

        /**
         * Encodes the specified SdkCreateOrderReply message. Does not implicitly {@link pb.SdkCreateOrderReply.verify|verify} messages.
         * @function encode
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {pb.ISdkCreateOrderReply} message SdkCreateOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkCreateOrderReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.OrderID != null && message.hasOwnProperty("OrderID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.OrderID);
            return writer;
        };

        /**
         * Encodes the specified SdkCreateOrderReply message, length delimited. Does not implicitly {@link pb.SdkCreateOrderReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {pb.ISdkCreateOrderReply} message SdkCreateOrderReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkCreateOrderReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkCreateOrderReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SdkCreateOrderReply} SdkCreateOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkCreateOrderReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SdkCreateOrderReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.OrderID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkCreateOrderReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SdkCreateOrderReply} SdkCreateOrderReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkCreateOrderReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkCreateOrderReply message.
         * @function verify
         * @memberof pb.SdkCreateOrderReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkCreateOrderReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.OrderID != null && message.hasOwnProperty("OrderID"))
                if (!$util.isString(message.OrderID))
                    return "OrderID: string expected";
            return null;
        };

        return SdkCreateOrderReply;
    })();

    pb.SdkRechargeResult = (function() {

        /**
         * Properties of a SdkRechargeResult.
         * @memberof pb
         * @interface ISdkRechargeResult
         * @property {pb.SdkRechargeResult.RechargeErr|null} [Errcode] SdkRechargeResult Errcode
         * @property {pb.IBuyLimitGiftReply|null} [LimitGift] SdkRechargeResult LimitGift
         * @property {pb.IBuyJadeReply|null} [Jade] SdkRechargeResult Jade
         */

        /**
         * Constructs a new SdkRechargeResult.
         * @memberof pb
         * @classdesc Represents a SdkRechargeResult.
         * @implements ISdkRechargeResult
         * @constructor
         * @param {pb.ISdkRechargeResult=} [properties] Properties to set
         */
        function SdkRechargeResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SdkRechargeResult Errcode.
         * @member {pb.SdkRechargeResult.RechargeErr} Errcode
         * @memberof pb.SdkRechargeResult
         * @instance
         */
        SdkRechargeResult.prototype.Errcode = 0;

        /**
         * SdkRechargeResult LimitGift.
         * @member {pb.IBuyLimitGiftReply|null|undefined} LimitGift
         * @memberof pb.SdkRechargeResult
         * @instance
         */
        SdkRechargeResult.prototype.LimitGift = null;

        /**
         * SdkRechargeResult Jade.
         * @member {pb.IBuyJadeReply|null|undefined} Jade
         * @memberof pb.SdkRechargeResult
         * @instance
         */
        SdkRechargeResult.prototype.Jade = null;

        /**
         * Creates a new SdkRechargeResult instance using the specified properties.
         * @function create
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {pb.ISdkRechargeResult=} [properties] Properties to set
         * @returns {pb.SdkRechargeResult} SdkRechargeResult instance
         */
        SdkRechargeResult.create = function create(properties) {
            return new SdkRechargeResult(properties);
        };

        /**
         * Encodes the specified SdkRechargeResult message. Does not implicitly {@link pb.SdkRechargeResult.verify|verify} messages.
         * @function encode
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {pb.ISdkRechargeResult} message SdkRechargeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkRechargeResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Errcode != null && message.hasOwnProperty("Errcode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Errcode);
            if (message.LimitGift != null && message.hasOwnProperty("LimitGift"))
                $root.pb.BuyLimitGiftReply.encode(message.LimitGift, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                $root.pb.BuyJadeReply.encode(message.Jade, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SdkRechargeResult message, length delimited. Does not implicitly {@link pb.SdkRechargeResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {pb.ISdkRechargeResult} message SdkRechargeResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SdkRechargeResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SdkRechargeResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SdkRechargeResult} SdkRechargeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkRechargeResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SdkRechargeResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Errcode = reader.int32();
                    break;
                case 2:
                    message.LimitGift = $root.pb.BuyLimitGiftReply.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Jade = $root.pb.BuyJadeReply.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SdkRechargeResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SdkRechargeResult} SdkRechargeResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SdkRechargeResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SdkRechargeResult message.
         * @function verify
         * @memberof pb.SdkRechargeResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SdkRechargeResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Errcode != null && message.hasOwnProperty("Errcode"))
                switch (message.Errcode) {
                default:
                    return "Errcode: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.LimitGift != null && message.hasOwnProperty("LimitGift")) {
                var error = $root.pb.BuyLimitGiftReply.verify(message.LimitGift);
                if (error)
                    return "LimitGift." + error;
            }
            if (message.Jade != null && message.hasOwnProperty("Jade")) {
                var error = $root.pb.BuyJadeReply.verify(message.Jade);
                if (error)
                    return "Jade." + error;
            }
            return null;
        };

        /**
         * RechargeErr enum.
         * @name pb.SdkRechargeResult.RechargeErr
         * @enum {string}
         * @property {number} Success=0 Success value
         * @property {number} Fail=1 Fail value
         */
        SdkRechargeResult.RechargeErr = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Success"] = 0;
            values[valuesById[1] = "Fail"] = 1;
            return values;
        })();

        return SdkRechargeResult;
    })();

    pb.IosPrePayArg = (function() {

        /**
         * Properties of an IosPrePayArg.
         * @memberof pb
         * @interface IIosPrePayArg
         * @property {string|null} [GoodsID] IosPrePayArg GoodsID
         */

        /**
         * Constructs a new IosPrePayArg.
         * @memberof pb
         * @classdesc Represents an IosPrePayArg.
         * @implements IIosPrePayArg
         * @constructor
         * @param {pb.IIosPrePayArg=} [properties] Properties to set
         */
        function IosPrePayArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IosPrePayArg GoodsID.
         * @member {string} GoodsID
         * @memberof pb.IosPrePayArg
         * @instance
         */
        IosPrePayArg.prototype.GoodsID = "";

        /**
         * Creates a new IosPrePayArg instance using the specified properties.
         * @function create
         * @memberof pb.IosPrePayArg
         * @static
         * @param {pb.IIosPrePayArg=} [properties] Properties to set
         * @returns {pb.IosPrePayArg} IosPrePayArg instance
         */
        IosPrePayArg.create = function create(properties) {
            return new IosPrePayArg(properties);
        };

        /**
         * Encodes the specified IosPrePayArg message. Does not implicitly {@link pb.IosPrePayArg.verify|verify} messages.
         * @function encode
         * @memberof pb.IosPrePayArg
         * @static
         * @param {pb.IIosPrePayArg} message IosPrePayArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IosPrePayArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            return writer;
        };

        /**
         * Encodes the specified IosPrePayArg message, length delimited. Does not implicitly {@link pb.IosPrePayArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.IosPrePayArg
         * @static
         * @param {pb.IIosPrePayArg} message IosPrePayArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IosPrePayArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IosPrePayArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.IosPrePayArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.IosPrePayArg} IosPrePayArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IosPrePayArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.IosPrePayArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IosPrePayArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.IosPrePayArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.IosPrePayArg} IosPrePayArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IosPrePayArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IosPrePayArg message.
         * @function verify
         * @memberof pb.IosPrePayArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IosPrePayArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            return null;
        };

        return IosPrePayArg;
    })();

    pb.BuyLimitGiftByJadeArg = (function() {

        /**
         * Properties of a BuyLimitGiftByJadeArg.
         * @memberof pb
         * @interface IBuyLimitGiftByJadeArg
         * @property {string|null} [GiftID] BuyLimitGiftByJadeArg GiftID
         */

        /**
         * Constructs a new BuyLimitGiftByJadeArg.
         * @memberof pb
         * @classdesc Represents a BuyLimitGiftByJadeArg.
         * @implements IBuyLimitGiftByJadeArg
         * @constructor
         * @param {pb.IBuyLimitGiftByJadeArg=} [properties] Properties to set
         */
        function BuyLimitGiftByJadeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyLimitGiftByJadeArg GiftID.
         * @member {string} GiftID
         * @memberof pb.BuyLimitGiftByJadeArg
         * @instance
         */
        BuyLimitGiftByJadeArg.prototype.GiftID = "";

        /**
         * Creates a new BuyLimitGiftByJadeArg instance using the specified properties.
         * @function create
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {pb.IBuyLimitGiftByJadeArg=} [properties] Properties to set
         * @returns {pb.BuyLimitGiftByJadeArg} BuyLimitGiftByJadeArg instance
         */
        BuyLimitGiftByJadeArg.create = function create(properties) {
            return new BuyLimitGiftByJadeArg(properties);
        };

        /**
         * Encodes the specified BuyLimitGiftByJadeArg message. Does not implicitly {@link pb.BuyLimitGiftByJadeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {pb.IBuyLimitGiftByJadeArg} message BuyLimitGiftByJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftByJadeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GiftID);
            return writer;
        };

        /**
         * Encodes the specified BuyLimitGiftByJadeArg message, length delimited. Does not implicitly {@link pb.BuyLimitGiftByJadeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {pb.IBuyLimitGiftByJadeArg} message BuyLimitGiftByJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyLimitGiftByJadeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyLimitGiftByJadeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyLimitGiftByJadeArg} BuyLimitGiftByJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftByJadeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyLimitGiftByJadeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GiftID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyLimitGiftByJadeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyLimitGiftByJadeArg} BuyLimitGiftByJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyLimitGiftByJadeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyLimitGiftByJadeArg message.
         * @function verify
         * @memberof pb.BuyLimitGiftByJadeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyLimitGiftByJadeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GiftID != null && message.hasOwnProperty("GiftID"))
                if (!$util.isString(message.GiftID))
                    return "GiftID: string expected";
            return null;
        };

        return BuyLimitGiftByJadeArg;
    })();

    pb.GooglePlayRechargeArg = (function() {

        /**
         * Properties of a GooglePlayRechargeArg.
         * @memberof pb
         * @interface IGooglePlayRechargeArg
         * @property {string|null} [GoodsID] GooglePlayRechargeArg GoodsID
         * @property {string|null} [InappPurchaseData] GooglePlayRechargeArg InappPurchaseData
         * @property {string|null} [InappDataSignature] GooglePlayRechargeArg InappDataSignature
         * @property {number|null} [Money] GooglePlayRechargeArg Money
         * @property {string|null} [Currency] GooglePlayRechargeArg Currency
         */

        /**
         * Constructs a new GooglePlayRechargeArg.
         * @memberof pb
         * @classdesc Represents a GooglePlayRechargeArg.
         * @implements IGooglePlayRechargeArg
         * @constructor
         * @param {pb.IGooglePlayRechargeArg=} [properties] Properties to set
         */
        function GooglePlayRechargeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GooglePlayRechargeArg GoodsID.
         * @member {string} GoodsID
         * @memberof pb.GooglePlayRechargeArg
         * @instance
         */
        GooglePlayRechargeArg.prototype.GoodsID = "";

        /**
         * GooglePlayRechargeArg InappPurchaseData.
         * @member {string} InappPurchaseData
         * @memberof pb.GooglePlayRechargeArg
         * @instance
         */
        GooglePlayRechargeArg.prototype.InappPurchaseData = "";

        /**
         * GooglePlayRechargeArg InappDataSignature.
         * @member {string} InappDataSignature
         * @memberof pb.GooglePlayRechargeArg
         * @instance
         */
        GooglePlayRechargeArg.prototype.InappDataSignature = "";

        /**
         * GooglePlayRechargeArg Money.
         * @member {number} Money
         * @memberof pb.GooglePlayRechargeArg
         * @instance
         */
        GooglePlayRechargeArg.prototype.Money = 0;

        /**
         * GooglePlayRechargeArg Currency.
         * @member {string} Currency
         * @memberof pb.GooglePlayRechargeArg
         * @instance
         */
        GooglePlayRechargeArg.prototype.Currency = "";

        /**
         * Creates a new GooglePlayRechargeArg instance using the specified properties.
         * @function create
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {pb.IGooglePlayRechargeArg=} [properties] Properties to set
         * @returns {pb.GooglePlayRechargeArg} GooglePlayRechargeArg instance
         */
        GooglePlayRechargeArg.create = function create(properties) {
            return new GooglePlayRechargeArg(properties);
        };

        /**
         * Encodes the specified GooglePlayRechargeArg message. Does not implicitly {@link pb.GooglePlayRechargeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {pb.IGooglePlayRechargeArg} message GooglePlayRechargeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GooglePlayRechargeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.GoodsID);
            if (message.InappPurchaseData != null && message.hasOwnProperty("InappPurchaseData"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.InappPurchaseData);
            if (message.InappDataSignature != null && message.hasOwnProperty("InappDataSignature"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.InappDataSignature);
            if (message.Money != null && message.hasOwnProperty("Money"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Money);
            if (message.Currency != null && message.hasOwnProperty("Currency"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Currency);
            return writer;
        };

        /**
         * Encodes the specified GooglePlayRechargeArg message, length delimited. Does not implicitly {@link pb.GooglePlayRechargeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {pb.IGooglePlayRechargeArg} message GooglePlayRechargeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GooglePlayRechargeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GooglePlayRechargeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GooglePlayRechargeArg} GooglePlayRechargeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GooglePlayRechargeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GooglePlayRechargeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.GoodsID = reader.string();
                    break;
                case 2:
                    message.InappPurchaseData = reader.string();
                    break;
                case 3:
                    message.InappDataSignature = reader.string();
                    break;
                case 4:
                    message.Money = reader.int32();
                    break;
                case 5:
                    message.Currency = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GooglePlayRechargeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GooglePlayRechargeArg} GooglePlayRechargeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GooglePlayRechargeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GooglePlayRechargeArg message.
         * @function verify
         * @memberof pb.GooglePlayRechargeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GooglePlayRechargeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.GoodsID != null && message.hasOwnProperty("GoodsID"))
                if (!$util.isString(message.GoodsID))
                    return "GoodsID: string expected";
            if (message.InappPurchaseData != null && message.hasOwnProperty("InappPurchaseData"))
                if (!$util.isString(message.InappPurchaseData))
                    return "InappPurchaseData: string expected";
            if (message.InappDataSignature != null && message.hasOwnProperty("InappDataSignature"))
                if (!$util.isString(message.InappDataSignature))
                    return "InappDataSignature: string expected";
            if (message.Money != null && message.hasOwnProperty("Money"))
                if (!$util.isInteger(message.Money))
                    return "Money: integer expected";
            if (message.Currency != null && message.hasOwnProperty("Currency"))
                if (!$util.isString(message.Currency))
                    return "Currency: string expected";
            return null;
        };

        return GooglePlayRechargeArg;
    })();

    pb.BuyVipCardReply = (function() {

        /**
         * Properties of a BuyVipCardReply.
         * @memberof pb
         * @interface IBuyVipCardReply
         * @property {string|null} [HeadFrame] BuyVipCardReply HeadFrame
         * @property {number|null} [RemainTime] BuyVipCardReply RemainTime
         */

        /**
         * Constructs a new BuyVipCardReply.
         * @memberof pb
         * @classdesc Represents a BuyVipCardReply.
         * @implements IBuyVipCardReply
         * @constructor
         * @param {pb.IBuyVipCardReply=} [properties] Properties to set
         */
        function BuyVipCardReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyVipCardReply HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.BuyVipCardReply
         * @instance
         */
        BuyVipCardReply.prototype.HeadFrame = "";

        /**
         * BuyVipCardReply RemainTime.
         * @member {number} RemainTime
         * @memberof pb.BuyVipCardReply
         * @instance
         */
        BuyVipCardReply.prototype.RemainTime = 0;

        /**
         * Creates a new BuyVipCardReply instance using the specified properties.
         * @function create
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {pb.IBuyVipCardReply=} [properties] Properties to set
         * @returns {pb.BuyVipCardReply} BuyVipCardReply instance
         */
        BuyVipCardReply.create = function create(properties) {
            return new BuyVipCardReply(properties);
        };

        /**
         * Encodes the specified BuyVipCardReply message. Does not implicitly {@link pb.BuyVipCardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {pb.IBuyVipCardReply} message BuyVipCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyVipCardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HeadFrame);
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.RemainTime);
            return writer;
        };

        /**
         * Encodes the specified BuyVipCardReply message, length delimited. Does not implicitly {@link pb.BuyVipCardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {pb.IBuyVipCardReply} message BuyVipCardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyVipCardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyVipCardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BuyVipCardReply} BuyVipCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyVipCardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BuyVipCardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HeadFrame = reader.string();
                    break;
                case 2:
                    message.RemainTime = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyVipCardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BuyVipCardReply} BuyVipCardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyVipCardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyVipCardReply message.
         * @function verify
         * @memberof pb.BuyVipCardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyVipCardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.RemainTime != null && message.hasOwnProperty("RemainTime"))
                if (!$util.isInteger(message.RemainTime))
                    return "RemainTime: integer expected";
            return null;
        };

        return BuyVipCardReply;
    })();

    pb.TargetPlayer = (function() {

        /**
         * Properties of a TargetPlayer.
         * @memberof pb
         * @interface ITargetPlayer
         * @property {number|Long|null} [Uid] TargetPlayer Uid
         */

        /**
         * Constructs a new TargetPlayer.
         * @memberof pb
         * @classdesc Represents a TargetPlayer.
         * @implements ITargetPlayer
         * @constructor
         * @param {pb.ITargetPlayer=} [properties] Properties to set
         */
        function TargetPlayer(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetPlayer Uid.
         * @member {number|Long} Uid
         * @memberof pb.TargetPlayer
         * @instance
         */
        TargetPlayer.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new TargetPlayer instance using the specified properties.
         * @function create
         * @memberof pb.TargetPlayer
         * @static
         * @param {pb.ITargetPlayer=} [properties] Properties to set
         * @returns {pb.TargetPlayer} TargetPlayer instance
         */
        TargetPlayer.create = function create(properties) {
            return new TargetPlayer(properties);
        };

        /**
         * Encodes the specified TargetPlayer message. Does not implicitly {@link pb.TargetPlayer.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetPlayer
         * @static
         * @param {pb.ITargetPlayer} message TargetPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetPlayer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified TargetPlayer message, length delimited. Does not implicitly {@link pb.TargetPlayer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetPlayer
         * @static
         * @param {pb.ITargetPlayer} message TargetPlayer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetPlayer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetPlayer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetPlayer} TargetPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetPlayer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetPlayer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetPlayer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetPlayer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetPlayer} TargetPlayer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetPlayer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetPlayer message.
         * @function verify
         * @memberof pb.TargetPlayer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetPlayer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return TargetPlayer;
    })();

    pb.PlayerInfo = (function() {

        /**
         * Properties of a PlayerInfo.
         * @memberof pb
         * @interface IPlayerInfo
         * @property {string|null} [Name] PlayerInfo Name
         * @property {number|null} [PvpScore] PlayerInfo PvpScore
         * @property {string|null} [HeadImgUrl] PlayerInfo HeadImgUrl
         * @property {number|null} [BattleAmount] PlayerInfo BattleAmount
         * @property {number|null} [BattleWinAmount] PlayerInfo BattleWinAmount
         * @property {number|null} [FirstHandWinRate] PlayerInfo FirstHandWinRate
         * @property {number|null} [BackHandWinRate] PlayerInfo BackHandWinRate
         * @property {number|null} [RankScore] PlayerInfo RankScore
         * @property {Array.<pb.ISkinGCard>|null} [FavoriteCards] PlayerInfo FavoriteCards
         * @property {Array.<pb.ISkinGCard>|null} [FightCards] PlayerInfo FightCards
         * @property {boolean|null} [IsFriend] PlayerInfo IsFriend
         * @property {boolean|null} [IsWechatFriend] PlayerInfo IsWechatFriend
         * @property {boolean|null} [CanInviteBattle] PlayerInfo CanInviteBattle
         * @property {string|null} [Country] PlayerInfo Country
         * @property {string|null} [HeadFrame] PlayerInfo HeadFrame
         * @property {number|null} [CityID] PlayerInfo CityID
         * @property {pb.CampaignJob|null} [CityJob] PlayerInfo CityJob
         * @property {pb.CampaignJob|null} [CountryJob] PlayerInfo CountryJob
         * @property {string|null} [CampaignCountry] PlayerInfo CampaignCountry
         */

        /**
         * Constructs a new PlayerInfo.
         * @memberof pb
         * @classdesc Represents a PlayerInfo.
         * @implements IPlayerInfo
         * @constructor
         * @param {pb.IPlayerInfo=} [properties] Properties to set
         */
        function PlayerInfo(properties) {
            this.FavoriteCards = [];
            this.FightCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PlayerInfo Name.
         * @member {string} Name
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.Name = "";

        /**
         * PlayerInfo PvpScore.
         * @member {number} PvpScore
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.PvpScore = 0;

        /**
         * PlayerInfo HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.HeadImgUrl = "";

        /**
         * PlayerInfo BattleAmount.
         * @member {number} BattleAmount
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.BattleAmount = 0;

        /**
         * PlayerInfo BattleWinAmount.
         * @member {number} BattleWinAmount
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.BattleWinAmount = 0;

        /**
         * PlayerInfo FirstHandWinRate.
         * @member {number} FirstHandWinRate
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.FirstHandWinRate = 0;

        /**
         * PlayerInfo BackHandWinRate.
         * @member {number} BackHandWinRate
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.BackHandWinRate = 0;

        /**
         * PlayerInfo RankScore.
         * @member {number} RankScore
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.RankScore = 0;

        /**
         * PlayerInfo FavoriteCards.
         * @member {Array.<pb.ISkinGCard>} FavoriteCards
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.FavoriteCards = $util.emptyArray;

        /**
         * PlayerInfo FightCards.
         * @member {Array.<pb.ISkinGCard>} FightCards
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.FightCards = $util.emptyArray;

        /**
         * PlayerInfo IsFriend.
         * @member {boolean} IsFriend
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.IsFriend = false;

        /**
         * PlayerInfo IsWechatFriend.
         * @member {boolean} IsWechatFriend
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.IsWechatFriend = false;

        /**
         * PlayerInfo CanInviteBattle.
         * @member {boolean} CanInviteBattle
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.CanInviteBattle = false;

        /**
         * PlayerInfo Country.
         * @member {string} Country
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.Country = "";

        /**
         * PlayerInfo HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.HeadFrame = "";

        /**
         * PlayerInfo CityID.
         * @member {number} CityID
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.CityID = 0;

        /**
         * PlayerInfo CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.CityJob = 0;

        /**
         * PlayerInfo CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.CountryJob = 0;

        /**
         * PlayerInfo CampaignCountry.
         * @member {string} CampaignCountry
         * @memberof pb.PlayerInfo
         * @instance
         */
        PlayerInfo.prototype.CampaignCountry = "";

        /**
         * Creates a new PlayerInfo instance using the specified properties.
         * @function create
         * @memberof pb.PlayerInfo
         * @static
         * @param {pb.IPlayerInfo=} [properties] Properties to set
         * @returns {pb.PlayerInfo} PlayerInfo instance
         */
        PlayerInfo.create = function create(properties) {
            return new PlayerInfo(properties);
        };

        /**
         * Encodes the specified PlayerInfo message. Does not implicitly {@link pb.PlayerInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.PlayerInfo
         * @static
         * @param {pb.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PvpScore);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImgUrl);
            if (message.BattleAmount != null && message.hasOwnProperty("BattleAmount"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.BattleAmount);
            if (message.BattleWinAmount != null && message.hasOwnProperty("BattleWinAmount"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.BattleWinAmount);
            if (message.FirstHandWinRate != null && message.hasOwnProperty("FirstHandWinRate"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.FirstHandWinRate);
            if (message.BackHandWinRate != null && message.hasOwnProperty("BackHandWinRate"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.BackHandWinRate);
            if (message.RankScore != null && message.hasOwnProperty("RankScore"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.RankScore);
            if (message.FavoriteCards != null && message.FavoriteCards.length)
                for (var i = 0; i < message.FavoriteCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FavoriteCards[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.FightCards != null && message.FightCards.length)
                for (var i = 0; i < message.FightCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FightCards[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.IsFriend != null && message.hasOwnProperty("IsFriend"))
                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.IsFriend);
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.IsWechatFriend);
            if (message.CanInviteBattle != null && message.hasOwnProperty("CanInviteBattle"))
                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.CanInviteBattle);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 14, wireType 2 =*/114).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 15, wireType 2 =*/122).string(message.HeadFrame);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 16, wireType 0 =*/128).int32(message.CityID);
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 18, wireType 0 =*/144).int32(message.CountryJob);
            if (message.CampaignCountry != null && message.hasOwnProperty("CampaignCountry"))
                writer.uint32(/* id 19, wireType 2 =*/154).string(message.CampaignCountry);
            return writer;
        };

        /**
         * Encodes the specified PlayerInfo message, length delimited. Does not implicitly {@link pb.PlayerInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PlayerInfo
         * @static
         * @param {pb.IPlayerInfo} message PlayerInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PlayerInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PlayerInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PlayerInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.PvpScore = reader.int32();
                    break;
                case 3:
                    message.HeadImgUrl = reader.string();
                    break;
                case 4:
                    message.BattleAmount = reader.int32();
                    break;
                case 5:
                    message.BattleWinAmount = reader.int32();
                    break;
                case 6:
                    message.FirstHandWinRate = reader.int32();
                    break;
                case 7:
                    message.BackHandWinRate = reader.int32();
                    break;
                case 8:
                    message.RankScore = reader.int32();
                    break;
                case 9:
                    if (!(message.FavoriteCards && message.FavoriteCards.length))
                        message.FavoriteCards = [];
                    message.FavoriteCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.FightCards && message.FightCards.length))
                        message.FightCards = [];
                    message.FightCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.IsFriend = reader.bool();
                    break;
                case 12:
                    message.IsWechatFriend = reader.bool();
                    break;
                case 13:
                    message.CanInviteBattle = reader.bool();
                    break;
                case 14:
                    message.Country = reader.string();
                    break;
                case 15:
                    message.HeadFrame = reader.string();
                    break;
                case 16:
                    message.CityID = reader.int32();
                    break;
                case 17:
                    message.CityJob = reader.int32();
                    break;
                case 18:
                    message.CountryJob = reader.int32();
                    break;
                case 19:
                    message.CampaignCountry = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PlayerInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PlayerInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PlayerInfo} PlayerInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PlayerInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PlayerInfo message.
         * @function verify
         * @memberof pb.PlayerInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PlayerInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.BattleAmount != null && message.hasOwnProperty("BattleAmount"))
                if (!$util.isInteger(message.BattleAmount))
                    return "BattleAmount: integer expected";
            if (message.BattleWinAmount != null && message.hasOwnProperty("BattleWinAmount"))
                if (!$util.isInteger(message.BattleWinAmount))
                    return "BattleWinAmount: integer expected";
            if (message.FirstHandWinRate != null && message.hasOwnProperty("FirstHandWinRate"))
                if (!$util.isInteger(message.FirstHandWinRate))
                    return "FirstHandWinRate: integer expected";
            if (message.BackHandWinRate != null && message.hasOwnProperty("BackHandWinRate"))
                if (!$util.isInteger(message.BackHandWinRate))
                    return "BackHandWinRate: integer expected";
            if (message.RankScore != null && message.hasOwnProperty("RankScore"))
                if (!$util.isInteger(message.RankScore))
                    return "RankScore: integer expected";
            if (message.FavoriteCards != null && message.hasOwnProperty("FavoriteCards")) {
                if (!Array.isArray(message.FavoriteCards))
                    return "FavoriteCards: array expected";
                for (var i = 0; i < message.FavoriteCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FavoriteCards[i]);
                    if (error)
                        return "FavoriteCards." + error;
                }
            }
            if (message.FightCards != null && message.hasOwnProperty("FightCards")) {
                if (!Array.isArray(message.FightCards))
                    return "FightCards: array expected";
                for (var i = 0; i < message.FightCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FightCards[i]);
                    if (error)
                        return "FightCards." + error;
                }
            }
            if (message.IsFriend != null && message.hasOwnProperty("IsFriend"))
                if (typeof message.IsFriend !== "boolean")
                    return "IsFriend: boolean expected";
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                if (typeof message.IsWechatFriend !== "boolean")
                    return "IsWechatFriend: boolean expected";
            if (message.CanInviteBattle != null && message.hasOwnProperty("CanInviteBattle"))
                if (typeof message.CanInviteBattle !== "boolean")
                    return "CanInviteBattle: boolean expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CampaignCountry != null && message.hasOwnProperty("CampaignCountry"))
                if (!$util.isString(message.CampaignCountry))
                    return "CampaignCountry: string expected";
            return null;
        };

        return PlayerInfo;
    })();

    pb.FriendItem = (function() {

        /**
         * Properties of a FriendItem.
         * @memberof pb
         * @interface IFriendItem
         * @property {number|Long|null} [Uid] FriendItem Uid
         * @property {string|null} [Name] FriendItem Name
         * @property {number|null} [PvpScore] FriendItem PvpScore
         * @property {boolean|null} [IsOnline] FriendItem IsOnline
         * @property {boolean|null} [IsInBattle] FriendItem IsInBattle
         * @property {string|null} [HeadImgUrl] FriendItem HeadImgUrl
         * @property {number|null} [LastOnlineTime] FriendItem LastOnlineTime
         * @property {boolean|null} [IsWechatFriend] FriendItem IsWechatFriend
         * @property {number|null} [PvpCamp] FriendItem PvpCamp
         * @property {string|null} [Country] FriendItem Country
         * @property {string|null} [HeadFrame] FriendItem HeadFrame
         * @property {number|null} [RebornCnt] FriendItem RebornCnt
         */

        /**
         * Constructs a new FriendItem.
         * @memberof pb
         * @classdesc Represents a FriendItem.
         * @implements IFriendItem
         * @constructor
         * @param {pb.IFriendItem=} [properties] Properties to set
         */
        function FriendItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendItem Uid.
         * @member {number|Long} Uid
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FriendItem Name.
         * @member {string} Name
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.Name = "";

        /**
         * FriendItem PvpScore.
         * @member {number} PvpScore
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.PvpScore = 0;

        /**
         * FriendItem IsOnline.
         * @member {boolean} IsOnline
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.IsOnline = false;

        /**
         * FriendItem IsInBattle.
         * @member {boolean} IsInBattle
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.IsInBattle = false;

        /**
         * FriendItem HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.HeadImgUrl = "";

        /**
         * FriendItem LastOnlineTime.
         * @member {number} LastOnlineTime
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.LastOnlineTime = 0;

        /**
         * FriendItem IsWechatFriend.
         * @member {boolean} IsWechatFriend
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.IsWechatFriend = false;

        /**
         * FriendItem PvpCamp.
         * @member {number} PvpCamp
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.PvpCamp = 0;

        /**
         * FriendItem Country.
         * @member {string} Country
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.Country = "";

        /**
         * FriendItem HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.HeadFrame = "";

        /**
         * FriendItem RebornCnt.
         * @member {number} RebornCnt
         * @memberof pb.FriendItem
         * @instance
         */
        FriendItem.prototype.RebornCnt = 0;

        /**
         * Creates a new FriendItem instance using the specified properties.
         * @function create
         * @memberof pb.FriendItem
         * @static
         * @param {pb.IFriendItem=} [properties] Properties to set
         * @returns {pb.FriendItem} FriendItem instance
         */
        FriendItem.create = function create(properties) {
            return new FriendItem(properties);
        };

        /**
         * Encodes the specified FriendItem message. Does not implicitly {@link pb.FriendItem.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendItem
         * @static
         * @param {pb.IFriendItem} message FriendItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.IsOnline != null && message.hasOwnProperty("IsOnline"))
                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.IsOnline);
            if (message.IsInBattle != null && message.hasOwnProperty("IsInBattle"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsInBattle);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.HeadImgUrl);
            if (message.LastOnlineTime != null && message.hasOwnProperty("LastOnlineTime"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.LastOnlineTime);
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.IsWechatFriend);
            if (message.PvpCamp != null && message.hasOwnProperty("PvpCamp"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.PvpCamp);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.HeadFrame);
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.RebornCnt);
            return writer;
        };

        /**
         * Encodes the specified FriendItem message, length delimited. Does not implicitly {@link pb.FriendItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendItem
         * @static
         * @param {pb.IFriendItem} message FriendItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendItem} FriendItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.IsOnline = reader.bool();
                    break;
                case 5:
                    message.IsInBattle = reader.bool();
                    break;
                case 6:
                    message.HeadImgUrl = reader.string();
                    break;
                case 7:
                    message.LastOnlineTime = reader.int32();
                    break;
                case 8:
                    message.IsWechatFriend = reader.bool();
                    break;
                case 9:
                    message.PvpCamp = reader.int32();
                    break;
                case 10:
                    message.Country = reader.string();
                    break;
                case 11:
                    message.HeadFrame = reader.string();
                    break;
                case 12:
                    message.RebornCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendItem} FriendItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendItem message.
         * @function verify
         * @memberof pb.FriendItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.IsOnline != null && message.hasOwnProperty("IsOnline"))
                if (typeof message.IsOnline !== "boolean")
                    return "IsOnline: boolean expected";
            if (message.IsInBattle != null && message.hasOwnProperty("IsInBattle"))
                if (typeof message.IsInBattle !== "boolean")
                    return "IsInBattle: boolean expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.LastOnlineTime != null && message.hasOwnProperty("LastOnlineTime"))
                if (!$util.isInteger(message.LastOnlineTime))
                    return "LastOnlineTime: integer expected";
            if (message.IsWechatFriend != null && message.hasOwnProperty("IsWechatFriend"))
                if (typeof message.IsWechatFriend !== "boolean")
                    return "IsWechatFriend: boolean expected";
            if (message.PvpCamp != null && message.hasOwnProperty("PvpCamp"))
                if (!$util.isInteger(message.PvpCamp))
                    return "PvpCamp: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.RebornCnt != null && message.hasOwnProperty("RebornCnt"))
                if (!$util.isInteger(message.RebornCnt))
                    return "RebornCnt: integer expected";
            return null;
        };

        return FriendItem;
    })();

    pb.FriendList = (function() {

        /**
         * Properties of a FriendList.
         * @memberof pb
         * @interface IFriendList
         * @property {pb.IFriendItem|null} [LastOpponent] FriendList LastOpponent
         * @property {Array.<pb.IFriendItem>|null} [Friends] FriendList Friends
         */

        /**
         * Constructs a new FriendList.
         * @memberof pb
         * @classdesc Represents a FriendList.
         * @implements IFriendList
         * @constructor
         * @param {pb.IFriendList=} [properties] Properties to set
         */
        function FriendList(properties) {
            this.Friends = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendList LastOpponent.
         * @member {pb.IFriendItem|null|undefined} LastOpponent
         * @memberof pb.FriendList
         * @instance
         */
        FriendList.prototype.LastOpponent = null;

        /**
         * FriendList Friends.
         * @member {Array.<pb.IFriendItem>} Friends
         * @memberof pb.FriendList
         * @instance
         */
        FriendList.prototype.Friends = $util.emptyArray;

        /**
         * Creates a new FriendList instance using the specified properties.
         * @function create
         * @memberof pb.FriendList
         * @static
         * @param {pb.IFriendList=} [properties] Properties to set
         * @returns {pb.FriendList} FriendList instance
         */
        FriendList.create = function create(properties) {
            return new FriendList(properties);
        };

        /**
         * Encodes the specified FriendList message. Does not implicitly {@link pb.FriendList.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendList
         * @static
         * @param {pb.IFriendList} message FriendList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.LastOpponent != null && message.hasOwnProperty("LastOpponent"))
                $root.pb.FriendItem.encode(message.LastOpponent, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Friends != null && message.Friends.length)
                for (var i = 0; i < message.Friends.length; ++i)
                    $root.pb.FriendItem.encode(message.Friends[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FriendList message, length delimited. Does not implicitly {@link pb.FriendList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendList
         * @static
         * @param {pb.IFriendList} message FriendList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendList} FriendList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.LastOpponent = $root.pb.FriendItem.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.Friends && message.Friends.length))
                        message.Friends = [];
                    message.Friends.push($root.pb.FriendItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendList} FriendList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendList message.
         * @function verify
         * @memberof pb.FriendList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.LastOpponent != null && message.hasOwnProperty("LastOpponent")) {
                var error = $root.pb.FriendItem.verify(message.LastOpponent);
                if (error)
                    return "LastOpponent." + error;
            }
            if (message.Friends != null && message.hasOwnProperty("Friends")) {
                if (!Array.isArray(message.Friends))
                    return "Friends: array expected";
                for (var i = 0; i < message.Friends.length; ++i) {
                    var error = $root.pb.FriendItem.verify(message.Friends[i]);
                    if (error)
                        return "Friends." + error;
                }
            }
            return null;
        };

        return FriendList;
    })();

    pb.FriendApply = (function() {

        /**
         * Properties of a FriendApply.
         * @memberof pb
         * @interface IFriendApply
         * @property {number|Long|null} [Uid] FriendApply Uid
         * @property {string|null} [Name] FriendApply Name
         * @property {number|null} [PvpScore] FriendApply PvpScore
         * @property {string|null} [HeadImgUrl] FriendApply HeadImgUrl
         * @property {string|null} [Country] FriendApply Country
         * @property {string|null} [HeadFrame] FriendApply HeadFrame
         */

        /**
         * Constructs a new FriendApply.
         * @memberof pb
         * @classdesc Represents a FriendApply.
         * @implements IFriendApply
         * @constructor
         * @param {pb.IFriendApply=} [properties] Properties to set
         */
        function FriendApply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendApply Uid.
         * @member {number|Long} Uid
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FriendApply Name.
         * @member {string} Name
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.Name = "";

        /**
         * FriendApply PvpScore.
         * @member {number} PvpScore
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.PvpScore = 0;

        /**
         * FriendApply HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.HeadImgUrl = "";

        /**
         * FriendApply Country.
         * @member {string} Country
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.Country = "";

        /**
         * FriendApply HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.FriendApply
         * @instance
         */
        FriendApply.prototype.HeadFrame = "";

        /**
         * Creates a new FriendApply instance using the specified properties.
         * @function create
         * @memberof pb.FriendApply
         * @static
         * @param {pb.IFriendApply=} [properties] Properties to set
         * @returns {pb.FriendApply} FriendApply instance
         */
        FriendApply.create = function create(properties) {
            return new FriendApply(properties);
        };

        /**
         * Encodes the specified FriendApply message. Does not implicitly {@link pb.FriendApply.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendApply
         * @static
         * @param {pb.IFriendApply} message FriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.HeadImgUrl);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified FriendApply message, length delimited. Does not implicitly {@link pb.FriendApply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendApply
         * @static
         * @param {pb.IFriendApply} message FriendApply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendApply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendApply} FriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendApply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.HeadImgUrl = reader.string();
                    break;
                case 5:
                    message.Country = reader.string();
                    break;
                case 6:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendApply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendApply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendApply} FriendApply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendApply message.
         * @function verify
         * @memberof pb.FriendApply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendApply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return FriendApply;
    })();

    pb.FriendApplyList = (function() {

        /**
         * Properties of a FriendApplyList.
         * @memberof pb
         * @interface IFriendApplyList
         * @property {Array.<pb.IFriendApply>|null} [FriendApplys] FriendApplyList FriendApplys
         */

        /**
         * Constructs a new FriendApplyList.
         * @memberof pb
         * @classdesc Represents a FriendApplyList.
         * @implements IFriendApplyList
         * @constructor
         * @param {pb.IFriendApplyList=} [properties] Properties to set
         */
        function FriendApplyList(properties) {
            this.FriendApplys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendApplyList FriendApplys.
         * @member {Array.<pb.IFriendApply>} FriendApplys
         * @memberof pb.FriendApplyList
         * @instance
         */
        FriendApplyList.prototype.FriendApplys = $util.emptyArray;

        /**
         * Creates a new FriendApplyList instance using the specified properties.
         * @function create
         * @memberof pb.FriendApplyList
         * @static
         * @param {pb.IFriendApplyList=} [properties] Properties to set
         * @returns {pb.FriendApplyList} FriendApplyList instance
         */
        FriendApplyList.create = function create(properties) {
            return new FriendApplyList(properties);
        };

        /**
         * Encodes the specified FriendApplyList message. Does not implicitly {@link pb.FriendApplyList.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendApplyList
         * @static
         * @param {pb.IFriendApplyList} message FriendApplyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FriendApplys != null && message.FriendApplys.length)
                for (var i = 0; i < message.FriendApplys.length; ++i)
                    $root.pb.FriendApply.encode(message.FriendApplys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FriendApplyList message, length delimited. Does not implicitly {@link pb.FriendApplyList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendApplyList
         * @static
         * @param {pb.IFriendApplyList} message FriendApplyList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendApplyList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendApplyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendApplyList} FriendApplyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendApplyList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.FriendApplys && message.FriendApplys.length))
                        message.FriendApplys = [];
                    message.FriendApplys.push($root.pb.FriendApply.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendApplyList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendApplyList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendApplyList} FriendApplyList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendApplyList message.
         * @function verify
         * @memberof pb.FriendApplyList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendApplyList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FriendApplys != null && message.hasOwnProperty("FriendApplys")) {
                if (!Array.isArray(message.FriendApplys))
                    return "FriendApplys: array expected";
                for (var i = 0; i < message.FriendApplys.length; ++i) {
                    var error = $root.pb.FriendApply.verify(message.FriendApplys[i]);
                    if (error)
                        return "FriendApplys." + error;
                }
            }
            return null;
        };

        return FriendApplyList;
    })();

    pb.ReplyFriendApplyArg = (function() {

        /**
         * Properties of a ReplyFriendApplyArg.
         * @memberof pb
         * @interface IReplyFriendApplyArg
         * @property {number|Long|null} [Uid] ReplyFriendApplyArg Uid
         * @property {boolean|null} [IsAgree] ReplyFriendApplyArg IsAgree
         */

        /**
         * Constructs a new ReplyFriendApplyArg.
         * @memberof pb
         * @classdesc Represents a ReplyFriendApplyArg.
         * @implements IReplyFriendApplyArg
         * @constructor
         * @param {pb.IReplyFriendApplyArg=} [properties] Properties to set
         */
        function ReplyFriendApplyArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReplyFriendApplyArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.ReplyFriendApplyArg
         * @instance
         */
        ReplyFriendApplyArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReplyFriendApplyArg IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.ReplyFriendApplyArg
         * @instance
         */
        ReplyFriendApplyArg.prototype.IsAgree = false;

        /**
         * Creates a new ReplyFriendApplyArg instance using the specified properties.
         * @function create
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {pb.IReplyFriendApplyArg=} [properties] Properties to set
         * @returns {pb.ReplyFriendApplyArg} ReplyFriendApplyArg instance
         */
        ReplyFriendApplyArg.create = function create(properties) {
            return new ReplyFriendApplyArg(properties);
        };

        /**
         * Encodes the specified ReplyFriendApplyArg message. Does not implicitly {@link pb.ReplyFriendApplyArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {pb.IReplyFriendApplyArg} message ReplyFriendApplyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyFriendApplyArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsAgree);
            return writer;
        };

        /**
         * Encodes the specified ReplyFriendApplyArg message, length delimited. Does not implicitly {@link pb.ReplyFriendApplyArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {pb.IReplyFriendApplyArg} message ReplyFriendApplyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyFriendApplyArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplyFriendApplyArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ReplyFriendApplyArg} ReplyFriendApplyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyFriendApplyArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReplyFriendApplyArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.IsAgree = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplyFriendApplyArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ReplyFriendApplyArg} ReplyFriendApplyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyFriendApplyArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplyFriendApplyArg message.
         * @function verify
         * @memberof pb.ReplyFriendApplyArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplyFriendApplyArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            return null;
        };

        return ReplyFriendApplyArg;
    })();

    pb.FriendApplyNotifyArg = (function() {

        /**
         * Properties of a FriendApplyNotifyArg.
         * @memberof pb
         * @interface IFriendApplyNotifyArg
         * @property {string|null} [FromName] FriendApplyNotifyArg FromName
         * @property {boolean|null} [IsInvite] FriendApplyNotifyArg IsInvite
         */

        /**
         * Constructs a new FriendApplyNotifyArg.
         * @memberof pb
         * @classdesc Represents a FriendApplyNotifyArg.
         * @implements IFriendApplyNotifyArg
         * @constructor
         * @param {pb.IFriendApplyNotifyArg=} [properties] Properties to set
         */
        function FriendApplyNotifyArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendApplyNotifyArg FromName.
         * @member {string} FromName
         * @memberof pb.FriendApplyNotifyArg
         * @instance
         */
        FriendApplyNotifyArg.prototype.FromName = "";

        /**
         * FriendApplyNotifyArg IsInvite.
         * @member {boolean} IsInvite
         * @memberof pb.FriendApplyNotifyArg
         * @instance
         */
        FriendApplyNotifyArg.prototype.IsInvite = false;

        /**
         * Creates a new FriendApplyNotifyArg instance using the specified properties.
         * @function create
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {pb.IFriendApplyNotifyArg=} [properties] Properties to set
         * @returns {pb.FriendApplyNotifyArg} FriendApplyNotifyArg instance
         */
        FriendApplyNotifyArg.create = function create(properties) {
            return new FriendApplyNotifyArg(properties);
        };

        /**
         * Encodes the specified FriendApplyNotifyArg message. Does not implicitly {@link pb.FriendApplyNotifyArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {pb.IFriendApplyNotifyArg} message FriendApplyNotifyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyNotifyArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.FromName);
            if (message.IsInvite != null && message.hasOwnProperty("IsInvite"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsInvite);
            return writer;
        };

        /**
         * Encodes the specified FriendApplyNotifyArg message, length delimited. Does not implicitly {@link pb.FriendApplyNotifyArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {pb.IFriendApplyNotifyArg} message FriendApplyNotifyArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyNotifyArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendApplyNotifyArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendApplyNotifyArg} FriendApplyNotifyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyNotifyArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendApplyNotifyArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FromName = reader.string();
                    break;
                case 2:
                    message.IsInvite = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendApplyNotifyArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendApplyNotifyArg} FriendApplyNotifyArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyNotifyArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendApplyNotifyArg message.
         * @function verify
         * @memberof pb.FriendApplyNotifyArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendApplyNotifyArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FromName != null && message.hasOwnProperty("FromName"))
                if (!$util.isString(message.FromName))
                    return "FromName: string expected";
            if (message.IsInvite != null && message.hasOwnProperty("IsInvite"))
                if (typeof message.IsInvite !== "boolean")
                    return "IsInvite: boolean expected";
            return null;
        };

        return FriendApplyNotifyArg;
    })();

    pb.FriendApplyResult = (function() {

        /**
         * Properties of a FriendApplyResult.
         * @memberof pb
         * @interface IFriendApplyResult
         * @property {string|null} [Name] FriendApplyResult Name
         * @property {boolean|null} [IsAgree] FriendApplyResult IsAgree
         */

        /**
         * Constructs a new FriendApplyResult.
         * @memberof pb
         * @classdesc Represents a FriendApplyResult.
         * @implements IFriendApplyResult
         * @constructor
         * @param {pb.IFriendApplyResult=} [properties] Properties to set
         */
        function FriendApplyResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendApplyResult Name.
         * @member {string} Name
         * @memberof pb.FriendApplyResult
         * @instance
         */
        FriendApplyResult.prototype.Name = "";

        /**
         * FriendApplyResult IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.FriendApplyResult
         * @instance
         */
        FriendApplyResult.prototype.IsAgree = false;

        /**
         * Creates a new FriendApplyResult instance using the specified properties.
         * @function create
         * @memberof pb.FriendApplyResult
         * @static
         * @param {pb.IFriendApplyResult=} [properties] Properties to set
         * @returns {pb.FriendApplyResult} FriendApplyResult instance
         */
        FriendApplyResult.create = function create(properties) {
            return new FriendApplyResult(properties);
        };

        /**
         * Encodes the specified FriendApplyResult message. Does not implicitly {@link pb.FriendApplyResult.verify|verify} messages.
         * @function encode
         * @memberof pb.FriendApplyResult
         * @static
         * @param {pb.IFriendApplyResult} message FriendApplyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsAgree);
            return writer;
        };

        /**
         * Encodes the specified FriendApplyResult message, length delimited. Does not implicitly {@link pb.FriendApplyResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FriendApplyResult
         * @static
         * @param {pb.IFriendApplyResult} message FriendApplyResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendApplyResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendApplyResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FriendApplyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FriendApplyResult} FriendApplyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FriendApplyResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.IsAgree = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendApplyResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FriendApplyResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FriendApplyResult} FriendApplyResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendApplyResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendApplyResult message.
         * @function verify
         * @memberof pb.FriendApplyResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendApplyResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            return null;
        };

        return FriendApplyResult;
    })();

    pb.PrivateChatMsg = (function() {

        /**
         * Properties of a PrivateChatMsg.
         * @memberof pb
         * @interface IPrivateChatMsg
         * @property {number|null} [Time] PrivateChatMsg Time
         * @property {string|null} [Msg] PrivateChatMsg Msg
         */

        /**
         * Constructs a new PrivateChatMsg.
         * @memberof pb
         * @classdesc Represents a PrivateChatMsg.
         * @implements IPrivateChatMsg
         * @constructor
         * @param {pb.IPrivateChatMsg=} [properties] Properties to set
         */
        function PrivateChatMsg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateChatMsg Time.
         * @member {number} Time
         * @memberof pb.PrivateChatMsg
         * @instance
         */
        PrivateChatMsg.prototype.Time = 0;

        /**
         * PrivateChatMsg Msg.
         * @member {string} Msg
         * @memberof pb.PrivateChatMsg
         * @instance
         */
        PrivateChatMsg.prototype.Msg = "";

        /**
         * Creates a new PrivateChatMsg instance using the specified properties.
         * @function create
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {pb.IPrivateChatMsg=} [properties] Properties to set
         * @returns {pb.PrivateChatMsg} PrivateChatMsg instance
         */
        PrivateChatMsg.create = function create(properties) {
            return new PrivateChatMsg(properties);
        };

        /**
         * Encodes the specified PrivateChatMsg message. Does not implicitly {@link pb.PrivateChatMsg.verify|verify} messages.
         * @function encode
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {pb.IPrivateChatMsg} message PrivateChatMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatMsg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Time);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Msg);
            return writer;
        };

        /**
         * Encodes the specified PrivateChatMsg message, length delimited. Does not implicitly {@link pb.PrivateChatMsg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {pb.IPrivateChatMsg} message PrivateChatMsg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatMsg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateChatMsg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PrivateChatMsg} PrivateChatMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatMsg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PrivateChatMsg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Time = reader.int32();
                    break;
                case 2:
                    message.Msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateChatMsg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PrivateChatMsg} PrivateChatMsg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatMsg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateChatMsg message.
         * @function verify
         * @memberof pb.PrivateChatMsg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateChatMsg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            return null;
        };

        return PrivateChatMsg;
    })();

    pb.PrivateChatItem = (function() {

        /**
         * Properties of a PrivateChatItem.
         * @memberof pb
         * @interface IPrivateChatItem
         * @property {number|Long|null} [Uid] PrivateChatItem Uid
         * @property {string|null} [Name] PrivateChatItem Name
         * @property {string|null} [HeadImgUrl] PrivateChatItem HeadImgUrl
         * @property {Array.<pb.IPrivateChatMsg>|null} [Msgs] PrivateChatItem Msgs
         * @property {number|null} [ID] PrivateChatItem ID
         * @property {number|null} [PvpLevel] PrivateChatItem PvpLevel
         * @property {string|null} [Country] PrivateChatItem Country
         * @property {string|null} [HeadFrame] PrivateChatItem HeadFrame
         */

        /**
         * Constructs a new PrivateChatItem.
         * @memberof pb
         * @classdesc Represents a PrivateChatItem.
         * @implements IPrivateChatItem
         * @constructor
         * @param {pb.IPrivateChatItem=} [properties] Properties to set
         */
        function PrivateChatItem(properties) {
            this.Msgs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateChatItem Uid.
         * @member {number|Long} Uid
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * PrivateChatItem Name.
         * @member {string} Name
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.Name = "";

        /**
         * PrivateChatItem HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.HeadImgUrl = "";

        /**
         * PrivateChatItem Msgs.
         * @member {Array.<pb.IPrivateChatMsg>} Msgs
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.Msgs = $util.emptyArray;

        /**
         * PrivateChatItem ID.
         * @member {number} ID
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.ID = 0;

        /**
         * PrivateChatItem PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.PvpLevel = 0;

        /**
         * PrivateChatItem Country.
         * @member {string} Country
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.Country = "";

        /**
         * PrivateChatItem HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.PrivateChatItem
         * @instance
         */
        PrivateChatItem.prototype.HeadFrame = "";

        /**
         * Creates a new PrivateChatItem instance using the specified properties.
         * @function create
         * @memberof pb.PrivateChatItem
         * @static
         * @param {pb.IPrivateChatItem=} [properties] Properties to set
         * @returns {pb.PrivateChatItem} PrivateChatItem instance
         */
        PrivateChatItem.create = function create(properties) {
            return new PrivateChatItem(properties);
        };

        /**
         * Encodes the specified PrivateChatItem message. Does not implicitly {@link pb.PrivateChatItem.verify|verify} messages.
         * @function encode
         * @memberof pb.PrivateChatItem
         * @static
         * @param {pb.IPrivateChatItem} message PrivateChatItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImgUrl);
            if (message.Msgs != null && message.Msgs.length)
                for (var i = 0; i < message.Msgs.length; ++i)
                    $root.pb.PrivateChatMsg.encode(message.Msgs[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ID);
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.PvpLevel);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified PrivateChatItem message, length delimited. Does not implicitly {@link pb.PrivateChatItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PrivateChatItem
         * @static
         * @param {pb.IPrivateChatItem} message PrivateChatItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateChatItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PrivateChatItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PrivateChatItem} PrivateChatItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PrivateChatItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.HeadImgUrl = reader.string();
                    break;
                case 4:
                    if (!(message.Msgs && message.Msgs.length))
                        message.Msgs = [];
                    message.Msgs.push($root.pb.PrivateChatMsg.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.ID = reader.int32();
                    break;
                case 6:
                    message.PvpLevel = reader.int32();
                    break;
                case 7:
                    message.Country = reader.string();
                    break;
                case 8:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateChatItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PrivateChatItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PrivateChatItem} PrivateChatItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateChatItem message.
         * @function verify
         * @memberof pb.PrivateChatItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateChatItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.Msgs != null && message.hasOwnProperty("Msgs")) {
                if (!Array.isArray(message.Msgs))
                    return "Msgs: array expected";
                for (var i = 0; i < message.Msgs.length; ++i) {
                    var error = $root.pb.PrivateChatMsg.verify(message.Msgs[i]);
                    if (error)
                        return "Msgs." + error;
                }
            }
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return PrivateChatItem;
    })();

    pb.PrivateChatList = (function() {

        /**
         * Properties of a PrivateChatList.
         * @memberof pb
         * @interface IPrivateChatList
         * @property {Array.<pb.IPrivateChatItem>|null} [PrivateChatItems] PrivateChatList PrivateChatItems
         */

        /**
         * Constructs a new PrivateChatList.
         * @memberof pb
         * @classdesc Represents a PrivateChatList.
         * @implements IPrivateChatList
         * @constructor
         * @param {pb.IPrivateChatList=} [properties] Properties to set
         */
        function PrivateChatList(properties) {
            this.PrivateChatItems = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PrivateChatList PrivateChatItems.
         * @member {Array.<pb.IPrivateChatItem>} PrivateChatItems
         * @memberof pb.PrivateChatList
         * @instance
         */
        PrivateChatList.prototype.PrivateChatItems = $util.emptyArray;

        /**
         * Creates a new PrivateChatList instance using the specified properties.
         * @function create
         * @memberof pb.PrivateChatList
         * @static
         * @param {pb.IPrivateChatList=} [properties] Properties to set
         * @returns {pb.PrivateChatList} PrivateChatList instance
         */
        PrivateChatList.create = function create(properties) {
            return new PrivateChatList(properties);
        };

        /**
         * Encodes the specified PrivateChatList message. Does not implicitly {@link pb.PrivateChatList.verify|verify} messages.
         * @function encode
         * @memberof pb.PrivateChatList
         * @static
         * @param {pb.IPrivateChatList} message PrivateChatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.PrivateChatItems != null && message.PrivateChatItems.length)
                for (var i = 0; i < message.PrivateChatItems.length; ++i)
                    $root.pb.PrivateChatItem.encode(message.PrivateChatItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PrivateChatList message, length delimited. Does not implicitly {@link pb.PrivateChatList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.PrivateChatList
         * @static
         * @param {pb.IPrivateChatList} message PrivateChatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PrivateChatList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PrivateChatList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.PrivateChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.PrivateChatList} PrivateChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.PrivateChatList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.PrivateChatItems && message.PrivateChatItems.length))
                        message.PrivateChatItems = [];
                    message.PrivateChatItems.push($root.pb.PrivateChatItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PrivateChatList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.PrivateChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.PrivateChatList} PrivateChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PrivateChatList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PrivateChatList message.
         * @function verify
         * @memberof pb.PrivateChatList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PrivateChatList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.PrivateChatItems != null && message.hasOwnProperty("PrivateChatItems")) {
                if (!Array.isArray(message.PrivateChatItems))
                    return "PrivateChatItems: array expected";
                for (var i = 0; i < message.PrivateChatItems.length; ++i) {
                    var error = $root.pb.PrivateChatItem.verify(message.PrivateChatItems[i]);
                    if (error)
                        return "PrivateChatItems." + error;
                }
            }
            return null;
        };

        return PrivateChatList;
    })();

    pb.FetchPrivateChatArg = (function() {

        /**
         * Properties of a FetchPrivateChatArg.
         * @memberof pb
         * @interface IFetchPrivateChatArg
         * @property {number|null} [MaxID] FetchPrivateChatArg MaxID
         */

        /**
         * Constructs a new FetchPrivateChatArg.
         * @memberof pb
         * @classdesc Represents a FetchPrivateChatArg.
         * @implements IFetchPrivateChatArg
         * @constructor
         * @param {pb.IFetchPrivateChatArg=} [properties] Properties to set
         */
        function FetchPrivateChatArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchPrivateChatArg MaxID.
         * @member {number} MaxID
         * @memberof pb.FetchPrivateChatArg
         * @instance
         */
        FetchPrivateChatArg.prototype.MaxID = 0;

        /**
         * Creates a new FetchPrivateChatArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {pb.IFetchPrivateChatArg=} [properties] Properties to set
         * @returns {pb.FetchPrivateChatArg} FetchPrivateChatArg instance
         */
        FetchPrivateChatArg.create = function create(properties) {
            return new FetchPrivateChatArg(properties);
        };

        /**
         * Encodes the specified FetchPrivateChatArg message. Does not implicitly {@link pb.FetchPrivateChatArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {pb.IFetchPrivateChatArg} message FetchPrivateChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchPrivateChatArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.MaxID != null && message.hasOwnProperty("MaxID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.MaxID);
            return writer;
        };

        /**
         * Encodes the specified FetchPrivateChatArg message, length delimited. Does not implicitly {@link pb.FetchPrivateChatArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {pb.IFetchPrivateChatArg} message FetchPrivateChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchPrivateChatArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchPrivateChatArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchPrivateChatArg} FetchPrivateChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchPrivateChatArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchPrivateChatArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.MaxID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchPrivateChatArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchPrivateChatArg} FetchPrivateChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchPrivateChatArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchPrivateChatArg message.
         * @function verify
         * @memberof pb.FetchPrivateChatArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchPrivateChatArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.MaxID != null && message.hasOwnProperty("MaxID"))
                if (!$util.isInteger(message.MaxID))
                    return "MaxID: integer expected";
            return null;
        };

        return FetchPrivateChatArg;
    })();

    pb.SendPrivateChatArg = (function() {

        /**
         * Properties of a SendPrivateChatArg.
         * @memberof pb
         * @interface ISendPrivateChatArg
         * @property {number|Long|null} [ToUid] SendPrivateChatArg ToUid
         * @property {string|null} [Msg] SendPrivateChatArg Msg
         */

        /**
         * Constructs a new SendPrivateChatArg.
         * @memberof pb
         * @classdesc Represents a SendPrivateChatArg.
         * @implements ISendPrivateChatArg
         * @constructor
         * @param {pb.ISendPrivateChatArg=} [properties] Properties to set
         */
        function SendPrivateChatArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendPrivateChatArg ToUid.
         * @member {number|Long} ToUid
         * @memberof pb.SendPrivateChatArg
         * @instance
         */
        SendPrivateChatArg.prototype.ToUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SendPrivateChatArg Msg.
         * @member {string} Msg
         * @memberof pb.SendPrivateChatArg
         * @instance
         */
        SendPrivateChatArg.prototype.Msg = "";

        /**
         * Creates a new SendPrivateChatArg instance using the specified properties.
         * @function create
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {pb.ISendPrivateChatArg=} [properties] Properties to set
         * @returns {pb.SendPrivateChatArg} SendPrivateChatArg instance
         */
        SendPrivateChatArg.create = function create(properties) {
            return new SendPrivateChatArg(properties);
        };

        /**
         * Encodes the specified SendPrivateChatArg message. Does not implicitly {@link pb.SendPrivateChatArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {pb.ISendPrivateChatArg} message SendPrivateChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendPrivateChatArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ToUid != null && message.hasOwnProperty("ToUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ToUid);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Msg);
            return writer;
        };

        /**
         * Encodes the specified SendPrivateChatArg message, length delimited. Does not implicitly {@link pb.SendPrivateChatArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {pb.ISendPrivateChatArg} message SendPrivateChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendPrivateChatArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendPrivateChatArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SendPrivateChatArg} SendPrivateChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendPrivateChatArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SendPrivateChatArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ToUid = reader.uint64();
                    break;
                case 2:
                    message.Msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendPrivateChatArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SendPrivateChatArg} SendPrivateChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendPrivateChatArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendPrivateChatArg message.
         * @function verify
         * @memberof pb.SendPrivateChatArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendPrivateChatArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ToUid != null && message.hasOwnProperty("ToUid"))
                if (!$util.isInteger(message.ToUid) && !(message.ToUid && $util.isInteger(message.ToUid.low) && $util.isInteger(message.ToUid.high)))
                    return "ToUid: integer|Long expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            return null;
        };

        return SendPrivateChatArg;
    })();

    /**
     * ChatChannel enum.
     * @name pb.ChatChannel
     * @enum {string}
     * @property {number} World=0 World value
     * @property {number} CampaignCountry=1 CampaignCountry value
     */
    pb.ChatChannel = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "World"] = 0;
        values[valuesById[1] = "CampaignCountry"] = 1;
        return values;
    })();

    pb.TargetChatChannel = (function() {

        /**
         * Properties of a TargetChatChannel.
         * @memberof pb
         * @interface ITargetChatChannel
         * @property {pb.ChatChannel|null} [Channel] TargetChatChannel Channel
         */

        /**
         * Constructs a new TargetChatChannel.
         * @memberof pb
         * @classdesc Represents a TargetChatChannel.
         * @implements ITargetChatChannel
         * @constructor
         * @param {pb.ITargetChatChannel=} [properties] Properties to set
         */
        function TargetChatChannel(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TargetChatChannel Channel.
         * @member {pb.ChatChannel} Channel
         * @memberof pb.TargetChatChannel
         * @instance
         */
        TargetChatChannel.prototype.Channel = 0;

        /**
         * Creates a new TargetChatChannel instance using the specified properties.
         * @function create
         * @memberof pb.TargetChatChannel
         * @static
         * @param {pb.ITargetChatChannel=} [properties] Properties to set
         * @returns {pb.TargetChatChannel} TargetChatChannel instance
         */
        TargetChatChannel.create = function create(properties) {
            return new TargetChatChannel(properties);
        };

        /**
         * Encodes the specified TargetChatChannel message. Does not implicitly {@link pb.TargetChatChannel.verify|verify} messages.
         * @function encode
         * @memberof pb.TargetChatChannel
         * @static
         * @param {pb.ITargetChatChannel} message TargetChatChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetChatChannel.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Channel);
            return writer;
        };

        /**
         * Encodes the specified TargetChatChannel message, length delimited. Does not implicitly {@link pb.TargetChatChannel.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TargetChatChannel
         * @static
         * @param {pb.ITargetChatChannel} message TargetChatChannel message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TargetChatChannel.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TargetChatChannel message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TargetChatChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TargetChatChannel} TargetChatChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetChatChannel.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TargetChatChannel();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TargetChatChannel message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TargetChatChannel
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TargetChatChannel} TargetChatChannel
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TargetChatChannel.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TargetChatChannel message.
         * @function verify
         * @memberof pb.TargetChatChannel
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TargetChatChannel.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                switch (message.Channel) {
                default:
                    return "Channel: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        return TargetChatChannel;
    })();

    pb.ChatItem = (function() {

        /**
         * Properties of a ChatItem.
         * @memberof pb
         * @interface IChatItem
         * @property {number|Long|null} [Uid] ChatItem Uid
         * @property {string|null} [Name] ChatItem Name
         * @property {string|null} [HeadImgUrl] ChatItem HeadImgUrl
         * @property {number|null} [Time] ChatItem Time
         * @property {string|null} [Msg] ChatItem Msg
         * @property {number|null} [PvpLevel] ChatItem PvpLevel
         * @property {string|null} [Country] ChatItem Country
         * @property {string|null} [HeadFrame] ChatItem HeadFrame
         * @property {number|null} [CityID] ChatItem CityID
         * @property {pb.CampaignJob|null} [CityJob] ChatItem CityJob
         * @property {pb.CampaignJob|null} [CountryJob] ChatItem CountryJob
         */

        /**
         * Constructs a new ChatItem.
         * @memberof pb
         * @classdesc Represents a ChatItem.
         * @implements IChatItem
         * @constructor
         * @param {pb.IChatItem=} [properties] Properties to set
         */
        function ChatItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatItem Uid.
         * @member {number|Long} Uid
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ChatItem Name.
         * @member {string} Name
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.Name = "";

        /**
         * ChatItem HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.HeadImgUrl = "";

        /**
         * ChatItem Time.
         * @member {number} Time
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.Time = 0;

        /**
         * ChatItem Msg.
         * @member {string} Msg
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.Msg = "";

        /**
         * ChatItem PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.PvpLevel = 0;

        /**
         * ChatItem Country.
         * @member {string} Country
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.Country = "";

        /**
         * ChatItem HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.HeadFrame = "";

        /**
         * ChatItem CityID.
         * @member {number} CityID
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.CityID = 0;

        /**
         * ChatItem CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.CityJob = 0;

        /**
         * ChatItem CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.ChatItem
         * @instance
         */
        ChatItem.prototype.CountryJob = 0;

        /**
         * Creates a new ChatItem instance using the specified properties.
         * @function create
         * @memberof pb.ChatItem
         * @static
         * @param {pb.IChatItem=} [properties] Properties to set
         * @returns {pb.ChatItem} ChatItem instance
         */
        ChatItem.create = function create(properties) {
            return new ChatItem(properties);
        };

        /**
         * Encodes the specified ChatItem message. Does not implicitly {@link pb.ChatItem.verify|verify} messages.
         * @function encode
         * @memberof pb.ChatItem
         * @static
         * @param {pb.IChatItem} message ChatItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.HeadImgUrl);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Time);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Msg);
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.PvpLevel);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.HeadFrame);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.CityID);
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.CountryJob);
            return writer;
        };

        /**
         * Encodes the specified ChatItem message, length delimited. Does not implicitly {@link pb.ChatItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChatItem
         * @static
         * @param {pb.IChatItem} message ChatItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChatItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChatItem} ChatItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChatItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.HeadImgUrl = reader.string();
                    break;
                case 4:
                    message.Time = reader.int32();
                    break;
                case 5:
                    message.Msg = reader.string();
                    break;
                case 6:
                    message.PvpLevel = reader.int32();
                    break;
                case 7:
                    message.Country = reader.string();
                    break;
                case 8:
                    message.HeadFrame = reader.string();
                    break;
                case 9:
                    message.CityID = reader.int32();
                    break;
                case 10:
                    message.CityJob = reader.int32();
                    break;
                case 11:
                    message.CountryJob = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChatItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChatItem} ChatItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatItem message.
         * @function verify
         * @memberof pb.ChatItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        return ChatItem;
    })();

    pb.Chatlet = (function() {

        /**
         * Properties of a Chatlet.
         * @memberof pb
         * @interface IChatlet
         * @property {pb.Chatlet.TypeEnum|null} [Type] Chatlet Type
         * @property {Uint8Array|null} [Data] Chatlet Data
         */

        /**
         * Constructs a new Chatlet.
         * @memberof pb
         * @classdesc Represents a Chatlet.
         * @implements IChatlet
         * @constructor
         * @param {pb.IChatlet=} [properties] Properties to set
         */
        function Chatlet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chatlet Type.
         * @member {pb.Chatlet.TypeEnum} Type
         * @memberof pb.Chatlet
         * @instance
         */
        Chatlet.prototype.Type = 0;

        /**
         * Chatlet Data.
         * @member {Uint8Array} Data
         * @memberof pb.Chatlet
         * @instance
         */
        Chatlet.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new Chatlet instance using the specified properties.
         * @function create
         * @memberof pb.Chatlet
         * @static
         * @param {pb.IChatlet=} [properties] Properties to set
         * @returns {pb.Chatlet} Chatlet instance
         */
        Chatlet.create = function create(properties) {
            return new Chatlet(properties);
        };

        /**
         * Encodes the specified Chatlet message. Does not implicitly {@link pb.Chatlet.verify|verify} messages.
         * @function encode
         * @memberof pb.Chatlet
         * @static
         * @param {pb.IChatlet} message Chatlet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chatlet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Type != null && message.hasOwnProperty("Type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Type);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified Chatlet message, length delimited. Does not implicitly {@link pb.Chatlet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Chatlet
         * @static
         * @param {pb.IChatlet} message Chatlet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chatlet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chatlet message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Chatlet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Chatlet} Chatlet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chatlet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Chatlet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Type = reader.int32();
                    break;
                case 2:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chatlet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Chatlet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Chatlet} Chatlet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chatlet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chatlet message.
         * @function verify
         * @memberof pb.Chatlet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chatlet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Type != null && message.hasOwnProperty("Type"))
                switch (message.Type) {
                default:
                    return "Type: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        /**
         * TypeEnum enum.
         * @name pb.Chatlet.TypeEnum
         * @enum {string}
         * @property {number} Normal=0 Normal value
         * @property {number} CampaignNotice=1 CampaignNotice value
         */
        Chatlet.TypeEnum = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Normal"] = 0;
            values[valuesById[1] = "CampaignNotice"] = 1;
            return values;
        })();

        return Chatlet;
    })();

    pb.ChatList = (function() {

        /**
         * Properties of a ChatList.
         * @memberof pb
         * @interface IChatList
         * @property {Array.<pb.IChatlet>|null} [Chatlets] ChatList Chatlets
         */

        /**
         * Constructs a new ChatList.
         * @memberof pb
         * @classdesc Represents a ChatList.
         * @implements IChatList
         * @constructor
         * @param {pb.IChatList=} [properties] Properties to set
         */
        function ChatList(properties) {
            this.Chatlets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatList Chatlets.
         * @member {Array.<pb.IChatlet>} Chatlets
         * @memberof pb.ChatList
         * @instance
         */
        ChatList.prototype.Chatlets = $util.emptyArray;

        /**
         * Creates a new ChatList instance using the specified properties.
         * @function create
         * @memberof pb.ChatList
         * @static
         * @param {pb.IChatList=} [properties] Properties to set
         * @returns {pb.ChatList} ChatList instance
         */
        ChatList.create = function create(properties) {
            return new ChatList(properties);
        };

        /**
         * Encodes the specified ChatList message. Does not implicitly {@link pb.ChatList.verify|verify} messages.
         * @function encode
         * @memberof pb.ChatList
         * @static
         * @param {pb.IChatList} message ChatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Chatlets != null && message.Chatlets.length)
                for (var i = 0; i < message.Chatlets.length; ++i)
                    $root.pb.Chatlet.encode(message.Chatlets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChatList message, length delimited. Does not implicitly {@link pb.ChatList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChatList
         * @static
         * @param {pb.IChatList} message ChatList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChatList} ChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChatList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Chatlets && message.Chatlets.length))
                        message.Chatlets = [];
                    message.Chatlets.push($root.pb.Chatlet.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChatList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChatList} ChatList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatList message.
         * @function verify
         * @memberof pb.ChatList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Chatlets != null && message.hasOwnProperty("Chatlets")) {
                if (!Array.isArray(message.Chatlets))
                    return "Chatlets: array expected";
                for (var i = 0; i < message.Chatlets.length; ++i) {
                    var error = $root.pb.Chatlet.verify(message.Chatlets[i]);
                    if (error)
                        return "Chatlets." + error;
                }
            }
            return null;
        };

        return ChatList;
    })();

    pb.ChatItemList = (function() {

        /**
         * Properties of a ChatItemList.
         * @memberof pb
         * @interface IChatItemList
         * @property {Array.<pb.IChatItem>|null} [ChatItems] ChatItemList ChatItems
         */

        /**
         * Constructs a new ChatItemList.
         * @memberof pb
         * @classdesc Represents a ChatItemList.
         * @implements IChatItemList
         * @constructor
         * @param {pb.IChatItemList=} [properties] Properties to set
         */
        function ChatItemList(properties) {
            this.ChatItems = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatItemList ChatItems.
         * @member {Array.<pb.IChatItem>} ChatItems
         * @memberof pb.ChatItemList
         * @instance
         */
        ChatItemList.prototype.ChatItems = $util.emptyArray;

        /**
         * Creates a new ChatItemList instance using the specified properties.
         * @function create
         * @memberof pb.ChatItemList
         * @static
         * @param {pb.IChatItemList=} [properties] Properties to set
         * @returns {pb.ChatItemList} ChatItemList instance
         */
        ChatItemList.create = function create(properties) {
            return new ChatItemList(properties);
        };

        /**
         * Encodes the specified ChatItemList message. Does not implicitly {@link pb.ChatItemList.verify|verify} messages.
         * @function encode
         * @memberof pb.ChatItemList
         * @static
         * @param {pb.IChatItemList} message ChatItemList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatItemList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ChatItems != null && message.ChatItems.length)
                for (var i = 0; i < message.ChatItems.length; ++i)
                    $root.pb.ChatItem.encode(message.ChatItems[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChatItemList message, length delimited. Does not implicitly {@link pb.ChatItemList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChatItemList
         * @static
         * @param {pb.IChatItemList} message ChatItemList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatItemList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatItemList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChatItemList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChatItemList} ChatItemList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatItemList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChatItemList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ChatItems && message.ChatItems.length))
                        message.ChatItems = [];
                    message.ChatItems.push($root.pb.ChatItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatItemList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChatItemList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChatItemList} ChatItemList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatItemList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatItemList message.
         * @function verify
         * @memberof pb.ChatItemList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatItemList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ChatItems != null && message.hasOwnProperty("ChatItems")) {
                if (!Array.isArray(message.ChatItems))
                    return "ChatItems: array expected";
                for (var i = 0; i < message.ChatItems.length; ++i) {
                    var error = $root.pb.ChatItem.verify(message.ChatItems[i]);
                    if (error)
                        return "ChatItems." + error;
                }
            }
            return null;
        };

        return ChatItemList;
    })();

    pb.ChatNotify = (function() {

        /**
         * Properties of a ChatNotify.
         * @memberof pb
         * @interface IChatNotify
         * @property {pb.ChatChannel|null} [Channel] ChatNotify Channel
         * @property {pb.IChatlet|null} [Chat] ChatNotify Chat
         */

        /**
         * Constructs a new ChatNotify.
         * @memberof pb
         * @classdesc Represents a ChatNotify.
         * @implements IChatNotify
         * @constructor
         * @param {pb.IChatNotify=} [properties] Properties to set
         */
        function ChatNotify(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChatNotify Channel.
         * @member {pb.ChatChannel} Channel
         * @memberof pb.ChatNotify
         * @instance
         */
        ChatNotify.prototype.Channel = 0;

        /**
         * ChatNotify Chat.
         * @member {pb.IChatlet|null|undefined} Chat
         * @memberof pb.ChatNotify
         * @instance
         */
        ChatNotify.prototype.Chat = null;

        /**
         * Creates a new ChatNotify instance using the specified properties.
         * @function create
         * @memberof pb.ChatNotify
         * @static
         * @param {pb.IChatNotify=} [properties] Properties to set
         * @returns {pb.ChatNotify} ChatNotify instance
         */
        ChatNotify.create = function create(properties) {
            return new ChatNotify(properties);
        };

        /**
         * Encodes the specified ChatNotify message. Does not implicitly {@link pb.ChatNotify.verify|verify} messages.
         * @function encode
         * @memberof pb.ChatNotify
         * @static
         * @param {pb.IChatNotify} message ChatNotify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatNotify.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Channel);
            if (message.Chat != null && message.hasOwnProperty("Chat"))
                $root.pb.Chatlet.encode(message.Chat, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ChatNotify message, length delimited. Does not implicitly {@link pb.ChatNotify.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ChatNotify
         * @static
         * @param {pb.IChatNotify} message ChatNotify message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChatNotify.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChatNotify message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ChatNotify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ChatNotify} ChatNotify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatNotify.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ChatNotify();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.int32();
                    break;
                case 2:
                    message.Chat = $root.pb.Chatlet.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChatNotify message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ChatNotify
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ChatNotify} ChatNotify
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChatNotify.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChatNotify message.
         * @function verify
         * @memberof pb.ChatNotify
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChatNotify.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                switch (message.Channel) {
                default:
                    return "Channel: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Chat != null && message.hasOwnProperty("Chat")) {
                var error = $root.pb.Chatlet.verify(message.Chat);
                if (error)
                    return "Chat." + error;
            }
            return null;
        };

        return ChatNotify;
    })();

    pb.SendChatArg = (function() {

        /**
         * Properties of a SendChatArg.
         * @memberof pb
         * @interface ISendChatArg
         * @property {pb.ChatChannel|null} [Channel] SendChatArg Channel
         * @property {string|null} [Msg] SendChatArg Msg
         */

        /**
         * Constructs a new SendChatArg.
         * @memberof pb
         * @classdesc Represents a SendChatArg.
         * @implements ISendChatArg
         * @constructor
         * @param {pb.ISendChatArg=} [properties] Properties to set
         */
        function SendChatArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendChatArg Channel.
         * @member {pb.ChatChannel} Channel
         * @memberof pb.SendChatArg
         * @instance
         */
        SendChatArg.prototype.Channel = 0;

        /**
         * SendChatArg Msg.
         * @member {string} Msg
         * @memberof pb.SendChatArg
         * @instance
         */
        SendChatArg.prototype.Msg = "";

        /**
         * Creates a new SendChatArg instance using the specified properties.
         * @function create
         * @memberof pb.SendChatArg
         * @static
         * @param {pb.ISendChatArg=} [properties] Properties to set
         * @returns {pb.SendChatArg} SendChatArg instance
         */
        SendChatArg.create = function create(properties) {
            return new SendChatArg(properties);
        };

        /**
         * Encodes the specified SendChatArg message. Does not implicitly {@link pb.SendChatArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SendChatArg
         * @static
         * @param {pb.ISendChatArg} message SendChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendChatArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Channel);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Msg);
            return writer;
        };

        /**
         * Encodes the specified SendChatArg message, length delimited. Does not implicitly {@link pb.SendChatArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SendChatArg
         * @static
         * @param {pb.ISendChatArg} message SendChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendChatArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendChatArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SendChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SendChatArg} SendChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendChatArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SendChatArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.int32();
                    break;
                case 2:
                    message.Msg = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendChatArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SendChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SendChatArg} SendChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendChatArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendChatArg message.
         * @function verify
         * @memberof pb.SendChatArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendChatArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                switch (message.Channel) {
                default:
                    return "Channel: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            return null;
        };

        return SendChatArg;
    })();

    pb.BeInviteBattleArg = (function() {

        /**
         * Properties of a BeInviteBattleArg.
         * @memberof pb
         * @interface IBeInviteBattleArg
         * @property {number|Long|null} [Uid] BeInviteBattleArg Uid
         * @property {string|null} [Name] BeInviteBattleArg Name
         */

        /**
         * Constructs a new BeInviteBattleArg.
         * @memberof pb
         * @classdesc Represents a BeInviteBattleArg.
         * @implements IBeInviteBattleArg
         * @constructor
         * @param {pb.IBeInviteBattleArg=} [properties] Properties to set
         */
        function BeInviteBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeInviteBattleArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.BeInviteBattleArg
         * @instance
         */
        BeInviteBattleArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BeInviteBattleArg Name.
         * @member {string} Name
         * @memberof pb.BeInviteBattleArg
         * @instance
         */
        BeInviteBattleArg.prototype.Name = "";

        /**
         * Creates a new BeInviteBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {pb.IBeInviteBattleArg=} [properties] Properties to set
         * @returns {pb.BeInviteBattleArg} BeInviteBattleArg instance
         */
        BeInviteBattleArg.create = function create(properties) {
            return new BeInviteBattleArg(properties);
        };

        /**
         * Encodes the specified BeInviteBattleArg message. Does not implicitly {@link pb.BeInviteBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {pb.IBeInviteBattleArg} message BeInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeInviteBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified BeInviteBattleArg message, length delimited. Does not implicitly {@link pb.BeInviteBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {pb.IBeInviteBattleArg} message BeInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeInviteBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeInviteBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BeInviteBattleArg} BeInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeInviteBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BeInviteBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeInviteBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BeInviteBattleArg} BeInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeInviteBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeInviteBattleArg message.
         * @function verify
         * @memberof pb.BeInviteBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeInviteBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return BeInviteBattleArg;
    })();

    pb.ReplyInviteBattleArg = (function() {

        /**
         * Properties of a ReplyInviteBattleArg.
         * @memberof pb
         * @interface IReplyInviteBattleArg
         * @property {number|Long|null} [Uid] ReplyInviteBattleArg Uid
         * @property {boolean|null} [IsAgree] ReplyInviteBattleArg IsAgree
         */

        /**
         * Constructs a new ReplyInviteBattleArg.
         * @memberof pb
         * @classdesc Represents a ReplyInviteBattleArg.
         * @implements IReplyInviteBattleArg
         * @constructor
         * @param {pb.IReplyInviteBattleArg=} [properties] Properties to set
         */
        function ReplyInviteBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReplyInviteBattleArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.ReplyInviteBattleArg
         * @instance
         */
        ReplyInviteBattleArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ReplyInviteBattleArg IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.ReplyInviteBattleArg
         * @instance
         */
        ReplyInviteBattleArg.prototype.IsAgree = false;

        /**
         * Creates a new ReplyInviteBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {pb.IReplyInviteBattleArg=} [properties] Properties to set
         * @returns {pb.ReplyInviteBattleArg} ReplyInviteBattleArg instance
         */
        ReplyInviteBattleArg.create = function create(properties) {
            return new ReplyInviteBattleArg(properties);
        };

        /**
         * Encodes the specified ReplyInviteBattleArg message. Does not implicitly {@link pb.ReplyInviteBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {pb.IReplyInviteBattleArg} message ReplyInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyInviteBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsAgree);
            return writer;
        };

        /**
         * Encodes the specified ReplyInviteBattleArg message, length delimited. Does not implicitly {@link pb.ReplyInviteBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {pb.IReplyInviteBattleArg} message ReplyInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyInviteBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplyInviteBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ReplyInviteBattleArg} ReplyInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyInviteBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReplyInviteBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.IsAgree = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplyInviteBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ReplyInviteBattleArg} ReplyInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyInviteBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplyInviteBattleArg message.
         * @function verify
         * @memberof pb.ReplyInviteBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplyInviteBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            return null;
        };

        return ReplyInviteBattleArg;
    })();

    pb.InviteBattleResult = (function() {

        /**
         * Properties of an InviteBattleResult.
         * @memberof pb
         * @interface IInviteBattleResult
         * @property {pb.InviteBattleResult.InviteResult|null} [Result] InviteBattleResult Result
         */

        /**
         * Constructs a new InviteBattleResult.
         * @memberof pb
         * @classdesc Represents an InviteBattleResult.
         * @implements IInviteBattleResult
         * @constructor
         * @param {pb.IInviteBattleResult=} [properties] Properties to set
         */
        function InviteBattleResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteBattleResult Result.
         * @member {pb.InviteBattleResult.InviteResult} Result
         * @memberof pb.InviteBattleResult
         * @instance
         */
        InviteBattleResult.prototype.Result = 0;

        /**
         * Creates a new InviteBattleResult instance using the specified properties.
         * @function create
         * @memberof pb.InviteBattleResult
         * @static
         * @param {pb.IInviteBattleResult=} [properties] Properties to set
         * @returns {pb.InviteBattleResult} InviteBattleResult instance
         */
        InviteBattleResult.create = function create(properties) {
            return new InviteBattleResult(properties);
        };

        /**
         * Encodes the specified InviteBattleResult message. Does not implicitly {@link pb.InviteBattleResult.verify|verify} messages.
         * @function encode
         * @memberof pb.InviteBattleResult
         * @static
         * @param {pb.IInviteBattleResult} message InviteBattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteBattleResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            return writer;
        };

        /**
         * Encodes the specified InviteBattleResult message, length delimited. Does not implicitly {@link pb.InviteBattleResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.InviteBattleResult
         * @static
         * @param {pb.IInviteBattleResult} message InviteBattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteBattleResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteBattleResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.InviteBattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.InviteBattleResult} InviteBattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteBattleResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.InviteBattleResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteBattleResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.InviteBattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.InviteBattleResult} InviteBattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteBattleResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteBattleResult message.
         * @function verify
         * @memberof pb.InviteBattleResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteBattleResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                switch (message.Result) {
                default:
                    return "Result: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * InviteResult enum.
         * @name pb.InviteBattleResult.InviteResult
         * @enum {string}
         * @property {number} Agree=0 Agree value
         * @property {number} Refuse=1 Refuse value
         * @property {number} Timeout=2 Timeout value
         */
        InviteBattleResult.InviteResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "Agree"] = 0;
            values[valuesById[1] = "Refuse"] = 1;
            values[valuesById[2] = "Timeout"] = 2;
            return values;
        })();

        return InviteBattleResult;
    })();

    pb.CSendChatArg = (function() {

        /**
         * Properties of a CSendChatArg.
         * @memberof pb
         * @interface ICSendChatArg
         * @property {pb.ChatChannel|null} [Channel] CSendChatArg Channel
         * @property {string|null} [Msg] CSendChatArg Msg
         * @property {string|null} [Name] CSendChatArg Name
         * @property {string|null} [HeadImgUrl] CSendChatArg HeadImgUrl
         * @property {number|null} [PvpLevel] CSendChatArg PvpLevel
         * @property {string|null} [Country] CSendChatArg Country
         * @property {string|null} [HeadFrame] CSendChatArg HeadFrame
         * @property {number|null} [CountryID] CSendChatArg CountryID
         * @property {number|null} [CityID] CSendChatArg CityID
         * @property {pb.CampaignJob|null} [CityJob] CSendChatArg CityJob
         * @property {pb.CampaignJob|null} [CountryJob] CSendChatArg CountryJob
         */

        /**
         * Constructs a new CSendChatArg.
         * @memberof pb
         * @classdesc Represents a CSendChatArg.
         * @implements ICSendChatArg
         * @constructor
         * @param {pb.ICSendChatArg=} [properties] Properties to set
         */
        function CSendChatArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CSendChatArg Channel.
         * @member {pb.ChatChannel} Channel
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.Channel = 0;

        /**
         * CSendChatArg Msg.
         * @member {string} Msg
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.Msg = "";

        /**
         * CSendChatArg Name.
         * @member {string} Name
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.Name = "";

        /**
         * CSendChatArg HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.HeadImgUrl = "";

        /**
         * CSendChatArg PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.PvpLevel = 0;

        /**
         * CSendChatArg Country.
         * @member {string} Country
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.Country = "";

        /**
         * CSendChatArg HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.HeadFrame = "";

        /**
         * CSendChatArg CountryID.
         * @member {number} CountryID
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.CountryID = 0;

        /**
         * CSendChatArg CityID.
         * @member {number} CityID
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.CityID = 0;

        /**
         * CSendChatArg CityJob.
         * @member {pb.CampaignJob} CityJob
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.CityJob = 0;

        /**
         * CSendChatArg CountryJob.
         * @member {pb.CampaignJob} CountryJob
         * @memberof pb.CSendChatArg
         * @instance
         */
        CSendChatArg.prototype.CountryJob = 0;

        /**
         * Creates a new CSendChatArg instance using the specified properties.
         * @function create
         * @memberof pb.CSendChatArg
         * @static
         * @param {pb.ICSendChatArg=} [properties] Properties to set
         * @returns {pb.CSendChatArg} CSendChatArg instance
         */
        CSendChatArg.create = function create(properties) {
            return new CSendChatArg(properties);
        };

        /**
         * Encodes the specified CSendChatArg message. Does not implicitly {@link pb.CSendChatArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CSendChatArg
         * @static
         * @param {pb.ICSendChatArg} message CSendChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSendChatArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Channel);
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Msg);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.HeadImgUrl);
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.PvpLevel);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.Country);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.HeadFrame);
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.CountryID);
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.CityID);
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.CityJob);
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.CountryJob);
            return writer;
        };

        /**
         * Encodes the specified CSendChatArg message, length delimited. Does not implicitly {@link pb.CSendChatArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CSendChatArg
         * @static
         * @param {pb.ICSendChatArg} message CSendChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CSendChatArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CSendChatArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CSendChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CSendChatArg} CSendChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSendChatArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CSendChatArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.int32();
                    break;
                case 2:
                    message.Msg = reader.string();
                    break;
                case 3:
                    message.Name = reader.string();
                    break;
                case 4:
                    message.HeadImgUrl = reader.string();
                    break;
                case 5:
                    message.PvpLevel = reader.int32();
                    break;
                case 6:
                    message.Country = reader.string();
                    break;
                case 7:
                    message.HeadFrame = reader.string();
                    break;
                case 8:
                    message.CountryID = reader.uint32();
                    break;
                case 9:
                    message.CityID = reader.int32();
                    break;
                case 10:
                    message.CityJob = reader.int32();
                    break;
                case 11:
                    message.CountryJob = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CSendChatArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CSendChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CSendChatArg} CSendChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CSendChatArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CSendChatArg message.
         * @function verify
         * @memberof pb.CSendChatArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CSendChatArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                switch (message.Channel) {
                default:
                    return "Channel: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.Msg != null && message.hasOwnProperty("Msg"))
                if (!$util.isString(message.Msg))
                    return "Msg: string expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            if (message.CityID != null && message.hasOwnProperty("CityID"))
                if (!$util.isInteger(message.CityID))
                    return "CityID: integer expected";
            if (message.CityJob != null && message.hasOwnProperty("CityJob"))
                switch (message.CityJob) {
                default:
                    return "CityJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.CountryJob != null && message.hasOwnProperty("CountryJob"))
                switch (message.CountryJob) {
                default:
                    return "CountryJob: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            return null;
        };

        return CSendChatArg;
    })();

    pb.G2GReplyInviteBattleArg = (function() {

        /**
         * Properties of a G2GReplyInviteBattleArg.
         * @memberof pb
         * @interface IG2GReplyInviteBattleArg
         * @property {pb.IFighterData|null} [BeInviter] G2GReplyInviteBattleArg BeInviter
         * @property {boolean|null} [IsAgree] G2GReplyInviteBattleArg IsAgree
         * @property {number|Long|null} [TargetUid] G2GReplyInviteBattleArg TargetUid
         */

        /**
         * Constructs a new G2GReplyInviteBattleArg.
         * @memberof pb
         * @classdesc Represents a G2GReplyInviteBattleArg.
         * @implements IG2GReplyInviteBattleArg
         * @constructor
         * @param {pb.IG2GReplyInviteBattleArg=} [properties] Properties to set
         */
        function G2GReplyInviteBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2GReplyInviteBattleArg BeInviter.
         * @member {pb.IFighterData|null|undefined} BeInviter
         * @memberof pb.G2GReplyInviteBattleArg
         * @instance
         */
        G2GReplyInviteBattleArg.prototype.BeInviter = null;

        /**
         * G2GReplyInviteBattleArg IsAgree.
         * @member {boolean} IsAgree
         * @memberof pb.G2GReplyInviteBattleArg
         * @instance
         */
        G2GReplyInviteBattleArg.prototype.IsAgree = false;

        /**
         * G2GReplyInviteBattleArg TargetUid.
         * @member {number|Long} TargetUid
         * @memberof pb.G2GReplyInviteBattleArg
         * @instance
         */
        G2GReplyInviteBattleArg.prototype.TargetUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new G2GReplyInviteBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {pb.IG2GReplyInviteBattleArg=} [properties] Properties to set
         * @returns {pb.G2GReplyInviteBattleArg} G2GReplyInviteBattleArg instance
         */
        G2GReplyInviteBattleArg.create = function create(properties) {
            return new G2GReplyInviteBattleArg(properties);
        };

        /**
         * Encodes the specified G2GReplyInviteBattleArg message. Does not implicitly {@link pb.G2GReplyInviteBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {pb.IG2GReplyInviteBattleArg} message G2GReplyInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2GReplyInviteBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.BeInviter != null && message.hasOwnProperty("BeInviter"))
                $root.pb.FighterData.encode(message.BeInviter, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsAgree);
            if (message.TargetUid != null && message.hasOwnProperty("TargetUid"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.TargetUid);
            return writer;
        };

        /**
         * Encodes the specified G2GReplyInviteBattleArg message, length delimited. Does not implicitly {@link pb.G2GReplyInviteBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {pb.IG2GReplyInviteBattleArg} message G2GReplyInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2GReplyInviteBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2GReplyInviteBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.G2GReplyInviteBattleArg} G2GReplyInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2GReplyInviteBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.G2GReplyInviteBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.BeInviter = $root.pb.FighterData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.IsAgree = reader.bool();
                    break;
                case 3:
                    message.TargetUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2GReplyInviteBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.G2GReplyInviteBattleArg} G2GReplyInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2GReplyInviteBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2GReplyInviteBattleArg message.
         * @function verify
         * @memberof pb.G2GReplyInviteBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2GReplyInviteBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.BeInviter != null && message.hasOwnProperty("BeInviter")) {
                var error = $root.pb.FighterData.verify(message.BeInviter);
                if (error)
                    return "BeInviter." + error;
            }
            if (message.IsAgree != null && message.hasOwnProperty("IsAgree"))
                if (typeof message.IsAgree !== "boolean")
                    return "IsAgree: boolean expected";
            if (message.TargetUid != null && message.hasOwnProperty("TargetUid"))
                if (!$util.isInteger(message.TargetUid) && !(message.TargetUid && $util.isInteger(message.TargetUid.low) && $util.isInteger(message.TargetUid.high)))
                    return "TargetUid: integer|Long expected";
            return null;
        };

        return G2GReplyInviteBattleArg;
    })();

    pb.WxInviteFriend = (function() {

        /**
         * Properties of a WxInviteFriend.
         * @memberof pb
         * @interface IWxInviteFriend
         * @property {string|null} [HeadImgUrl] WxInviteFriend HeadImgUrl
         * @property {number|null} [PvpLevel] WxInviteFriend PvpLevel
         */

        /**
         * Constructs a new WxInviteFriend.
         * @memberof pb
         * @classdesc Represents a WxInviteFriend.
         * @implements IWxInviteFriend
         * @constructor
         * @param {pb.IWxInviteFriend=} [properties] Properties to set
         */
        function WxInviteFriend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxInviteFriend HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.WxInviteFriend
         * @instance
         */
        WxInviteFriend.prototype.HeadImgUrl = "";

        /**
         * WxInviteFriend PvpLevel.
         * @member {number} PvpLevel
         * @memberof pb.WxInviteFriend
         * @instance
         */
        WxInviteFriend.prototype.PvpLevel = 0;

        /**
         * Creates a new WxInviteFriend instance using the specified properties.
         * @function create
         * @memberof pb.WxInviteFriend
         * @static
         * @param {pb.IWxInviteFriend=} [properties] Properties to set
         * @returns {pb.WxInviteFriend} WxInviteFriend instance
         */
        WxInviteFriend.create = function create(properties) {
            return new WxInviteFriend(properties);
        };

        /**
         * Encodes the specified WxInviteFriend message. Does not implicitly {@link pb.WxInviteFriend.verify|verify} messages.
         * @function encode
         * @memberof pb.WxInviteFriend
         * @static
         * @param {pb.IWxInviteFriend} message WxInviteFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteFriend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.HeadImgUrl);
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.PvpLevel);
            return writer;
        };

        /**
         * Encodes the specified WxInviteFriend message, length delimited. Does not implicitly {@link pb.WxInviteFriend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxInviteFriend
         * @static
         * @param {pb.IWxInviteFriend} message WxInviteFriend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteFriend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxInviteFriend message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxInviteFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxInviteFriend} WxInviteFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteFriend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxInviteFriend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.HeadImgUrl = reader.string();
                    break;
                case 2:
                    message.PvpLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxInviteFriend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxInviteFriend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxInviteFriend} WxInviteFriend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteFriend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxInviteFriend message.
         * @function verify
         * @memberof pb.WxInviteFriend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxInviteFriend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.PvpLevel != null && message.hasOwnProperty("PvpLevel"))
                if (!$util.isInteger(message.PvpLevel))
                    return "PvpLevel: integer expected";
            return null;
        };

        return WxInviteFriend;
    })();

    pb.WxInviteReward = (function() {

        /**
         * Properties of a WxInviteReward.
         * @memberof pb
         * @interface IWxInviteReward
         * @property {number|null} [ID] WxInviteReward ID
         * @property {number|null} [CurCnt] WxInviteReward CurCnt
         * @property {number|null} [RewardCnt] WxInviteReward RewardCnt
         */

        /**
         * Constructs a new WxInviteReward.
         * @memberof pb
         * @classdesc Represents a WxInviteReward.
         * @implements IWxInviteReward
         * @constructor
         * @param {pb.IWxInviteReward=} [properties] Properties to set
         */
        function WxInviteReward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxInviteReward ID.
         * @member {number} ID
         * @memberof pb.WxInviteReward
         * @instance
         */
        WxInviteReward.prototype.ID = 0;

        /**
         * WxInviteReward CurCnt.
         * @member {number} CurCnt
         * @memberof pb.WxInviteReward
         * @instance
         */
        WxInviteReward.prototype.CurCnt = 0;

        /**
         * WxInviteReward RewardCnt.
         * @member {number} RewardCnt
         * @memberof pb.WxInviteReward
         * @instance
         */
        WxInviteReward.prototype.RewardCnt = 0;

        /**
         * Creates a new WxInviteReward instance using the specified properties.
         * @function create
         * @memberof pb.WxInviteReward
         * @static
         * @param {pb.IWxInviteReward=} [properties] Properties to set
         * @returns {pb.WxInviteReward} WxInviteReward instance
         */
        WxInviteReward.create = function create(properties) {
            return new WxInviteReward(properties);
        };

        /**
         * Encodes the specified WxInviteReward message. Does not implicitly {@link pb.WxInviteReward.verify|verify} messages.
         * @function encode
         * @memberof pb.WxInviteReward
         * @static
         * @param {pb.IWxInviteReward} message WxInviteReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteReward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurCnt);
            if (message.RewardCnt != null && message.hasOwnProperty("RewardCnt"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.RewardCnt);
            return writer;
        };

        /**
         * Encodes the specified WxInviteReward message, length delimited. Does not implicitly {@link pb.WxInviteReward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxInviteReward
         * @static
         * @param {pb.IWxInviteReward} message WxInviteReward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteReward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxInviteReward message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxInviteReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxInviteReward} WxInviteReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteReward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxInviteReward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.CurCnt = reader.int32();
                    break;
                case 3:
                    message.RewardCnt = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxInviteReward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxInviteReward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxInviteReward} WxInviteReward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteReward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxInviteReward message.
         * @function verify
         * @memberof pb.WxInviteReward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxInviteReward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.CurCnt != null && message.hasOwnProperty("CurCnt"))
                if (!$util.isInteger(message.CurCnt))
                    return "CurCnt: integer expected";
            if (message.RewardCnt != null && message.hasOwnProperty("RewardCnt"))
                if (!$util.isInteger(message.RewardCnt))
                    return "RewardCnt: integer expected";
            return null;
        };

        return WxInviteReward;
    })();

    pb.WxInviteFriendsReply = (function() {

        /**
         * Properties of a WxInviteFriendsReply.
         * @memberof pb
         * @interface IWxInviteFriendsReply
         * @property {Array.<pb.IWxInviteFriend>|null} [Friends] WxInviteFriendsReply Friends
         * @property {Array.<pb.IWxInviteReward>|null} [Rewards] WxInviteFriendsReply Rewards
         */

        /**
         * Constructs a new WxInviteFriendsReply.
         * @memberof pb
         * @classdesc Represents a WxInviteFriendsReply.
         * @implements IWxInviteFriendsReply
         * @constructor
         * @param {pb.IWxInviteFriendsReply=} [properties] Properties to set
         */
        function WxInviteFriendsReply(properties) {
            this.Friends = [];
            this.Rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxInviteFriendsReply Friends.
         * @member {Array.<pb.IWxInviteFriend>} Friends
         * @memberof pb.WxInviteFriendsReply
         * @instance
         */
        WxInviteFriendsReply.prototype.Friends = $util.emptyArray;

        /**
         * WxInviteFriendsReply Rewards.
         * @member {Array.<pb.IWxInviteReward>} Rewards
         * @memberof pb.WxInviteFriendsReply
         * @instance
         */
        WxInviteFriendsReply.prototype.Rewards = $util.emptyArray;

        /**
         * Creates a new WxInviteFriendsReply instance using the specified properties.
         * @function create
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {pb.IWxInviteFriendsReply=} [properties] Properties to set
         * @returns {pb.WxInviteFriendsReply} WxInviteFriendsReply instance
         */
        WxInviteFriendsReply.create = function create(properties) {
            return new WxInviteFriendsReply(properties);
        };

        /**
         * Encodes the specified WxInviteFriendsReply message. Does not implicitly {@link pb.WxInviteFriendsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {pb.IWxInviteFriendsReply} message WxInviteFriendsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteFriendsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Friends != null && message.Friends.length)
                for (var i = 0; i < message.Friends.length; ++i)
                    $root.pb.WxInviteFriend.encode(message.Friends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.Rewards != null && message.Rewards.length)
                for (var i = 0; i < message.Rewards.length; ++i)
                    $root.pb.WxInviteReward.encode(message.Rewards[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified WxInviteFriendsReply message, length delimited. Does not implicitly {@link pb.WxInviteFriendsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {pb.IWxInviteFriendsReply} message WxInviteFriendsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteFriendsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxInviteFriendsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxInviteFriendsReply} WxInviteFriendsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteFriendsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxInviteFriendsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Friends && message.Friends.length))
                        message.Friends = [];
                    message.Friends.push($root.pb.WxInviteFriend.decode(reader, reader.uint32()));
                    break;
                case 2:
                    if (!(message.Rewards && message.Rewards.length))
                        message.Rewards = [];
                    message.Rewards.push($root.pb.WxInviteReward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxInviteFriendsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxInviteFriendsReply} WxInviteFriendsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteFriendsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxInviteFriendsReply message.
         * @function verify
         * @memberof pb.WxInviteFriendsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxInviteFriendsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Friends != null && message.hasOwnProperty("Friends")) {
                if (!Array.isArray(message.Friends))
                    return "Friends: array expected";
                for (var i = 0; i < message.Friends.length; ++i) {
                    var error = $root.pb.WxInviteFriend.verify(message.Friends[i]);
                    if (error)
                        return "Friends." + error;
                }
            }
            if (message.Rewards != null && message.hasOwnProperty("Rewards")) {
                if (!Array.isArray(message.Rewards))
                    return "Rewards: array expected";
                for (var i = 0; i < message.Rewards.length; ++i) {
                    var error = $root.pb.WxInviteReward.verify(message.Rewards[i]);
                    if (error)
                        return "Rewards." + error;
                }
            }
            return null;
        };

        return WxInviteFriendsReply;
    })();

    pb.GetWxInviteRewardArg = (function() {

        /**
         * Properties of a GetWxInviteRewardArg.
         * @memberof pb
         * @interface IGetWxInviteRewardArg
         * @property {number|null} [ID] GetWxInviteRewardArg ID
         */

        /**
         * Constructs a new GetWxInviteRewardArg.
         * @memberof pb
         * @classdesc Represents a GetWxInviteRewardArg.
         * @implements IGetWxInviteRewardArg
         * @constructor
         * @param {pb.IGetWxInviteRewardArg=} [properties] Properties to set
         */
        function GetWxInviteRewardArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWxInviteRewardArg ID.
         * @member {number} ID
         * @memberof pb.GetWxInviteRewardArg
         * @instance
         */
        GetWxInviteRewardArg.prototype.ID = 0;

        /**
         * Creates a new GetWxInviteRewardArg instance using the specified properties.
         * @function create
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {pb.IGetWxInviteRewardArg=} [properties] Properties to set
         * @returns {pb.GetWxInviteRewardArg} GetWxInviteRewardArg instance
         */
        GetWxInviteRewardArg.create = function create(properties) {
            return new GetWxInviteRewardArg(properties);
        };

        /**
         * Encodes the specified GetWxInviteRewardArg message. Does not implicitly {@link pb.GetWxInviteRewardArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {pb.IGetWxInviteRewardArg} message GetWxInviteRewardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWxInviteRewardArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            return writer;
        };

        /**
         * Encodes the specified GetWxInviteRewardArg message, length delimited. Does not implicitly {@link pb.GetWxInviteRewardArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {pb.IGetWxInviteRewardArg} message GetWxInviteRewardArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWxInviteRewardArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWxInviteRewardArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetWxInviteRewardArg} GetWxInviteRewardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWxInviteRewardArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetWxInviteRewardArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWxInviteRewardArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetWxInviteRewardArg} GetWxInviteRewardArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWxInviteRewardArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWxInviteRewardArg message.
         * @function verify
         * @memberof pb.GetWxInviteRewardArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWxInviteRewardArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            return null;
        };

        return GetWxInviteRewardArg;
    })();

    pb.GetWxInviteRewardReply = (function() {

        /**
         * Properties of a GetWxInviteRewardReply.
         * @memberof pb
         * @interface IGetWxInviteRewardReply
         * @property {number|null} [Gold] GetWxInviteRewardReply Gold
         * @property {number|null} [Jade] GetWxInviteRewardReply Jade
         * @property {Array.<number>|null} [Cards] GetWxInviteRewardReply Cards
         */

        /**
         * Constructs a new GetWxInviteRewardReply.
         * @memberof pb
         * @classdesc Represents a GetWxInviteRewardReply.
         * @implements IGetWxInviteRewardReply
         * @constructor
         * @param {pb.IGetWxInviteRewardReply=} [properties] Properties to set
         */
        function GetWxInviteRewardReply(properties) {
            this.Cards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetWxInviteRewardReply Gold.
         * @member {number} Gold
         * @memberof pb.GetWxInviteRewardReply
         * @instance
         */
        GetWxInviteRewardReply.prototype.Gold = 0;

        /**
         * GetWxInviteRewardReply Jade.
         * @member {number} Jade
         * @memberof pb.GetWxInviteRewardReply
         * @instance
         */
        GetWxInviteRewardReply.prototype.Jade = 0;

        /**
         * GetWxInviteRewardReply Cards.
         * @member {Array.<number>} Cards
         * @memberof pb.GetWxInviteRewardReply
         * @instance
         */
        GetWxInviteRewardReply.prototype.Cards = $util.emptyArray;

        /**
         * Creates a new GetWxInviteRewardReply instance using the specified properties.
         * @function create
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {pb.IGetWxInviteRewardReply=} [properties] Properties to set
         * @returns {pb.GetWxInviteRewardReply} GetWxInviteRewardReply instance
         */
        GetWxInviteRewardReply.create = function create(properties) {
            return new GetWxInviteRewardReply(properties);
        };

        /**
         * Encodes the specified GetWxInviteRewardReply message. Does not implicitly {@link pb.GetWxInviteRewardReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {pb.IGetWxInviteRewardReply} message GetWxInviteRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWxInviteRewardReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Gold);
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Jade);
            if (message.Cards != null && message.Cards.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.Cards.length; ++i)
                    writer.uint32(message.Cards[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified GetWxInviteRewardReply message, length delimited. Does not implicitly {@link pb.GetWxInviteRewardReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {pb.IGetWxInviteRewardReply} message GetWxInviteRewardReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetWxInviteRewardReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetWxInviteRewardReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetWxInviteRewardReply} GetWxInviteRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWxInviteRewardReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetWxInviteRewardReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Gold = reader.int32();
                    break;
                case 2:
                    message.Jade = reader.int32();
                    break;
                case 3:
                    if (!(message.Cards && message.Cards.length))
                        message.Cards = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.Cards.push(reader.uint32());
                    } else
                        message.Cards.push(reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetWxInviteRewardReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetWxInviteRewardReply} GetWxInviteRewardReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetWxInviteRewardReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetWxInviteRewardReply message.
         * @function verify
         * @memberof pb.GetWxInviteRewardReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetWxInviteRewardReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Gold != null && message.hasOwnProperty("Gold"))
                if (!$util.isInteger(message.Gold))
                    return "Gold: integer expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            if (message.Cards != null && message.hasOwnProperty("Cards")) {
                if (!Array.isArray(message.Cards))
                    return "Cards: array expected";
                for (var i = 0; i < message.Cards.length; ++i)
                    if (!$util.isInteger(message.Cards[i]))
                        return "Cards: integer[] expected";
            }
            return null;
        };

        return GetWxInviteRewardReply;
    })();

    pb.SubscribeChatArg = (function() {

        /**
         * Properties of a SubscribeChatArg.
         * @memberof pb
         * @interface ISubscribeChatArg
         * @property {pb.ChatChannel|null} [Channel] SubscribeChatArg Channel
         * @property {number|null} [CountryID] SubscribeChatArg CountryID
         */

        /**
         * Constructs a new SubscribeChatArg.
         * @memberof pb
         * @classdesc Represents a SubscribeChatArg.
         * @implements ISubscribeChatArg
         * @constructor
         * @param {pb.ISubscribeChatArg=} [properties] Properties to set
         */
        function SubscribeChatArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SubscribeChatArg Channel.
         * @member {pb.ChatChannel} Channel
         * @memberof pb.SubscribeChatArg
         * @instance
         */
        SubscribeChatArg.prototype.Channel = 0;

        /**
         * SubscribeChatArg CountryID.
         * @member {number} CountryID
         * @memberof pb.SubscribeChatArg
         * @instance
         */
        SubscribeChatArg.prototype.CountryID = 0;

        /**
         * Creates a new SubscribeChatArg instance using the specified properties.
         * @function create
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {pb.ISubscribeChatArg=} [properties] Properties to set
         * @returns {pb.SubscribeChatArg} SubscribeChatArg instance
         */
        SubscribeChatArg.create = function create(properties) {
            return new SubscribeChatArg(properties);
        };

        /**
         * Encodes the specified SubscribeChatArg message. Does not implicitly {@link pb.SubscribeChatArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {pb.ISubscribeChatArg} message SubscribeChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeChatArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Channel);
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.CountryID);
            return writer;
        };

        /**
         * Encodes the specified SubscribeChatArg message, length delimited. Does not implicitly {@link pb.SubscribeChatArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {pb.ISubscribeChatArg} message SubscribeChatArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SubscribeChatArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SubscribeChatArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SubscribeChatArg} SubscribeChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeChatArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SubscribeChatArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Channel = reader.int32();
                    break;
                case 2:
                    message.CountryID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SubscribeChatArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SubscribeChatArg} SubscribeChatArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SubscribeChatArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SubscribeChatArg message.
         * @function verify
         * @memberof pb.SubscribeChatArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SubscribeChatArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Channel != null && message.hasOwnProperty("Channel"))
                switch (message.Channel) {
                default:
                    return "Channel: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.CountryID != null && message.hasOwnProperty("CountryID"))
                if (!$util.isInteger(message.CountryID))
                    return "CountryID: integer expected";
            return null;
        };

        return SubscribeChatArg;
    })();

    pb.SurveyInfo = (function() {

        /**
         * Properties of a SurveyInfo.
         * @memberof pb
         * @interface ISurveyInfo
         * @property {boolean|null} [IsComplete] SurveyInfo IsComplete
         * @property {boolean|null} [IsReward] SurveyInfo IsReward
         */

        /**
         * Constructs a new SurveyInfo.
         * @memberof pb
         * @classdesc Represents a SurveyInfo.
         * @implements ISurveyInfo
         * @constructor
         * @param {pb.ISurveyInfo=} [properties] Properties to set
         */
        function SurveyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurveyInfo IsComplete.
         * @member {boolean} IsComplete
         * @memberof pb.SurveyInfo
         * @instance
         */
        SurveyInfo.prototype.IsComplete = false;

        /**
         * SurveyInfo IsReward.
         * @member {boolean} IsReward
         * @memberof pb.SurveyInfo
         * @instance
         */
        SurveyInfo.prototype.IsReward = false;

        /**
         * Creates a new SurveyInfo instance using the specified properties.
         * @function create
         * @memberof pb.SurveyInfo
         * @static
         * @param {pb.ISurveyInfo=} [properties] Properties to set
         * @returns {pb.SurveyInfo} SurveyInfo instance
         */
        SurveyInfo.create = function create(properties) {
            return new SurveyInfo(properties);
        };

        /**
         * Encodes the specified SurveyInfo message. Does not implicitly {@link pb.SurveyInfo.verify|verify} messages.
         * @function encode
         * @memberof pb.SurveyInfo
         * @static
         * @param {pb.ISurveyInfo} message SurveyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurveyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsComplete != null && message.hasOwnProperty("IsComplete"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.IsComplete);
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.IsReward);
            return writer;
        };

        /**
         * Encodes the specified SurveyInfo message, length delimited. Does not implicitly {@link pb.SurveyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurveyInfo
         * @static
         * @param {pb.ISurveyInfo} message SurveyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurveyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurveyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurveyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurveyInfo} SurveyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurveyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurveyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.IsComplete = reader.bool();
                    break;
                case 2:
                    message.IsReward = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurveyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurveyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurveyInfo} SurveyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurveyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurveyInfo message.
         * @function verify
         * @memberof pb.SurveyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurveyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsComplete != null && message.hasOwnProperty("IsComplete"))
                if (typeof message.IsComplete !== "boolean")
                    return "IsComplete: boolean expected";
            if (message.IsReward != null && message.hasOwnProperty("IsReward"))
                if (typeof message.IsReward !== "boolean")
                    return "IsReward: boolean expected";
            return null;
        };

        return SurveyInfo;
    })();

    pb.Answer = (function() {

        /**
         * Properties of an Answer.
         * @memberof pb
         * @interface IAnswer
         * @property {number|null} [QuestionID] Answer QuestionID
         * @property {Array.<number>|null} [AnswerIDs] Answer AnswerIDs
         */

        /**
         * Constructs a new Answer.
         * @memberof pb
         * @classdesc Represents an Answer.
         * @implements IAnswer
         * @constructor
         * @param {pb.IAnswer=} [properties] Properties to set
         */
        function Answer(properties) {
            this.AnswerIDs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Answer QuestionID.
         * @member {number} QuestionID
         * @memberof pb.Answer
         * @instance
         */
        Answer.prototype.QuestionID = 0;

        /**
         * Answer AnswerIDs.
         * @member {Array.<number>} AnswerIDs
         * @memberof pb.Answer
         * @instance
         */
        Answer.prototype.AnswerIDs = $util.emptyArray;

        /**
         * Creates a new Answer instance using the specified properties.
         * @function create
         * @memberof pb.Answer
         * @static
         * @param {pb.IAnswer=} [properties] Properties to set
         * @returns {pb.Answer} Answer instance
         */
        Answer.create = function create(properties) {
            return new Answer(properties);
        };

        /**
         * Encodes the specified Answer message. Does not implicitly {@link pb.Answer.verify|verify} messages.
         * @function encode
         * @memberof pb.Answer
         * @static
         * @param {pb.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.QuestionID != null && message.hasOwnProperty("QuestionID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.QuestionID);
            if (message.AnswerIDs != null && message.AnswerIDs.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.AnswerIDs.length; ++i)
                    writer.int32(message.AnswerIDs[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified Answer message, length delimited. Does not implicitly {@link pb.Answer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.Answer
         * @static
         * @param {pb.IAnswer} message Answer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Answer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Answer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.Answer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.QuestionID = reader.int32();
                    break;
                case 2:
                    if (!(message.AnswerIDs && message.AnswerIDs.length))
                        message.AnswerIDs = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.AnswerIDs.push(reader.int32());
                    } else
                        message.AnswerIDs.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Answer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.Answer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.Answer} Answer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Answer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Answer message.
         * @function verify
         * @memberof pb.Answer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Answer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.QuestionID != null && message.hasOwnProperty("QuestionID"))
                if (!$util.isInteger(message.QuestionID))
                    return "QuestionID: integer expected";
            if (message.AnswerIDs != null && message.hasOwnProperty("AnswerIDs")) {
                if (!Array.isArray(message.AnswerIDs))
                    return "AnswerIDs: array expected";
                for (var i = 0; i < message.AnswerIDs.length; ++i)
                    if (!$util.isInteger(message.AnswerIDs[i]))
                        return "AnswerIDs: integer[] expected";
            }
            return null;
        };

        return Answer;
    })();

    pb.SurveyAnswer = (function() {

        /**
         * Properties of a SurveyAnswer.
         * @memberof pb
         * @interface ISurveyAnswer
         * @property {Array.<pb.IAnswer>|null} [Answers] SurveyAnswer Answers
         */

        /**
         * Constructs a new SurveyAnswer.
         * @memberof pb
         * @classdesc Represents a SurveyAnswer.
         * @implements ISurveyAnswer
         * @constructor
         * @param {pb.ISurveyAnswer=} [properties] Properties to set
         */
        function SurveyAnswer(properties) {
            this.Answers = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SurveyAnswer Answers.
         * @member {Array.<pb.IAnswer>} Answers
         * @memberof pb.SurveyAnswer
         * @instance
         */
        SurveyAnswer.prototype.Answers = $util.emptyArray;

        /**
         * Creates a new SurveyAnswer instance using the specified properties.
         * @function create
         * @memberof pb.SurveyAnswer
         * @static
         * @param {pb.ISurveyAnswer=} [properties] Properties to set
         * @returns {pb.SurveyAnswer} SurveyAnswer instance
         */
        SurveyAnswer.create = function create(properties) {
            return new SurveyAnswer(properties);
        };

        /**
         * Encodes the specified SurveyAnswer message. Does not implicitly {@link pb.SurveyAnswer.verify|verify} messages.
         * @function encode
         * @memberof pb.SurveyAnswer
         * @static
         * @param {pb.ISurveyAnswer} message SurveyAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurveyAnswer.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Answers != null && message.Answers.length)
                for (var i = 0; i < message.Answers.length; ++i)
                    $root.pb.Answer.encode(message.Answers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SurveyAnswer message, length delimited. Does not implicitly {@link pb.SurveyAnswer.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SurveyAnswer
         * @static
         * @param {pb.ISurveyAnswer} message SurveyAnswer message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SurveyAnswer.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SurveyAnswer message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SurveyAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SurveyAnswer} SurveyAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurveyAnswer.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SurveyAnswer();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Answers && message.Answers.length))
                        message.Answers = [];
                    message.Answers.push($root.pb.Answer.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SurveyAnswer message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SurveyAnswer
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SurveyAnswer} SurveyAnswer
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SurveyAnswer.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SurveyAnswer message.
         * @function verify
         * @memberof pb.SurveyAnswer
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SurveyAnswer.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Answers != null && message.hasOwnProperty("Answers")) {
                if (!Array.isArray(message.Answers))
                    return "Answers: array expected";
                for (var i = 0; i < message.Answers.length; ++i) {
                    var error = $root.pb.Answer.verify(message.Answers[i]);
                    if (error)
                        return "Answers." + error;
                }
            }
            return null;
        };

        return SurveyAnswer;
    })();

    pb.GetCampIDArg = (function() {

        /**
         * Properties of a GetCampIDArg.
         * @memberof pb
         * @interface IGetCampIDArg
         */

        /**
         * Constructs a new GetCampIDArg.
         * @memberof pb
         * @classdesc Represents a GetCampIDArg.
         * @implements IGetCampIDArg
         * @constructor
         * @param {pb.IGetCampIDArg=} [properties] Properties to set
         */
        function GetCampIDArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetCampIDArg instance using the specified properties.
         * @function create
         * @memberof pb.GetCampIDArg
         * @static
         * @param {pb.IGetCampIDArg=} [properties] Properties to set
         * @returns {pb.GetCampIDArg} GetCampIDArg instance
         */
        GetCampIDArg.create = function create(properties) {
            return new GetCampIDArg(properties);
        };

        /**
         * Encodes the specified GetCampIDArg message. Does not implicitly {@link pb.GetCampIDArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCampIDArg
         * @static
         * @param {pb.IGetCampIDArg} message GetCampIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCampIDArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetCampIDArg message, length delimited. Does not implicitly {@link pb.GetCampIDArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCampIDArg
         * @static
         * @param {pb.IGetCampIDArg} message GetCampIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCampIDArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCampIDArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCampIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCampIDArg} GetCampIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCampIDArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCampIDArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCampIDArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCampIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCampIDArg} GetCampIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCampIDArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCampIDArg message.
         * @function verify
         * @memberof pb.GetCampIDArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCampIDArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GetCampIDArg;
    })();

    pb.GetCampIDReply = (function() {

        /**
         * Properties of a GetCampIDReply.
         * @memberof pb
         * @interface IGetCampIDReply
         * @property {number|null} [CampID] GetCampIDReply CampID
         */

        /**
         * Constructs a new GetCampIDReply.
         * @memberof pb
         * @classdesc Represents a GetCampIDReply.
         * @implements IGetCampIDReply
         * @constructor
         * @param {pb.IGetCampIDReply=} [properties] Properties to set
         */
        function GetCampIDReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCampIDReply CampID.
         * @member {number} CampID
         * @memberof pb.GetCampIDReply
         * @instance
         */
        GetCampIDReply.prototype.CampID = 0;

        /**
         * Creates a new GetCampIDReply instance using the specified properties.
         * @function create
         * @memberof pb.GetCampIDReply
         * @static
         * @param {pb.IGetCampIDReply=} [properties] Properties to set
         * @returns {pb.GetCampIDReply} GetCampIDReply instance
         */
        GetCampIDReply.create = function create(properties) {
            return new GetCampIDReply(properties);
        };

        /**
         * Encodes the specified GetCampIDReply message. Does not implicitly {@link pb.GetCampIDReply.verify|verify} messages.
         * @function encode
         * @memberof pb.GetCampIDReply
         * @static
         * @param {pb.IGetCampIDReply} message GetCampIDReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCampIDReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CampID);
            return writer;
        };

        /**
         * Encodes the specified GetCampIDReply message, length delimited. Does not implicitly {@link pb.GetCampIDReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetCampIDReply
         * @static
         * @param {pb.IGetCampIDReply} message GetCampIDReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCampIDReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCampIDReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetCampIDReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetCampIDReply} GetCampIDReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCampIDReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetCampIDReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CampID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCampIDReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetCampIDReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetCampIDReply} GetCampIDReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCampIDReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCampIDReply message.
         * @function verify
         * @memberof pb.GetCampIDReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCampIDReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                if (!$util.isInteger(message.CampID))
                    return "CampID: integer expected";
            return null;
        };

        return GetCampIDReply;
    })();

    pb.SetCampIDArg = (function() {

        /**
         * Properties of a SetCampIDArg.
         * @memberof pb
         * @interface ISetCampIDArg
         * @property {number|null} [CampID] SetCampIDArg CampID
         */

        /**
         * Constructs a new SetCampIDArg.
         * @memberof pb
         * @classdesc Represents a SetCampIDArg.
         * @implements ISetCampIDArg
         * @constructor
         * @param {pb.ISetCampIDArg=} [properties] Properties to set
         */
        function SetCampIDArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetCampIDArg CampID.
         * @member {number} CampID
         * @memberof pb.SetCampIDArg
         * @instance
         */
        SetCampIDArg.prototype.CampID = 0;

        /**
         * Creates a new SetCampIDArg instance using the specified properties.
         * @function create
         * @memberof pb.SetCampIDArg
         * @static
         * @param {pb.ISetCampIDArg=} [properties] Properties to set
         * @returns {pb.SetCampIDArg} SetCampIDArg instance
         */
        SetCampIDArg.create = function create(properties) {
            return new SetCampIDArg(properties);
        };

        /**
         * Encodes the specified SetCampIDArg message. Does not implicitly {@link pb.SetCampIDArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SetCampIDArg
         * @static
         * @param {pb.ISetCampIDArg} message SetCampIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetCampIDArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CampID);
            return writer;
        };

        /**
         * Encodes the specified SetCampIDArg message, length delimited. Does not implicitly {@link pb.SetCampIDArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SetCampIDArg
         * @static
         * @param {pb.ISetCampIDArg} message SetCampIDArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetCampIDArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetCampIDArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SetCampIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SetCampIDArg} SetCampIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetCampIDArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SetCampIDArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CampID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetCampIDArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SetCampIDArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SetCampIDArg} SetCampIDArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetCampIDArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetCampIDArg message.
         * @function verify
         * @memberof pb.SetCampIDArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetCampIDArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                if (!$util.isInteger(message.CampID))
                    return "CampID: integer expected";
            return null;
        };

        return SetCampIDArg;
    })();

    pb.SetCampIDReply = (function() {

        /**
         * Properties of a SetCampIDReply.
         * @memberof pb
         * @interface ISetCampIDReply
         * @property {boolean|null} [ok] SetCampIDReply ok
         */

        /**
         * Constructs a new SetCampIDReply.
         * @memberof pb
         * @classdesc Represents a SetCampIDReply.
         * @implements ISetCampIDReply
         * @constructor
         * @param {pb.ISetCampIDReply=} [properties] Properties to set
         */
        function SetCampIDReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetCampIDReply ok.
         * @member {boolean} ok
         * @memberof pb.SetCampIDReply
         * @instance
         */
        SetCampIDReply.prototype.ok = false;

        /**
         * Creates a new SetCampIDReply instance using the specified properties.
         * @function create
         * @memberof pb.SetCampIDReply
         * @static
         * @param {pb.ISetCampIDReply=} [properties] Properties to set
         * @returns {pb.SetCampIDReply} SetCampIDReply instance
         */
        SetCampIDReply.create = function create(properties) {
            return new SetCampIDReply(properties);
        };

        /**
         * Encodes the specified SetCampIDReply message. Does not implicitly {@link pb.SetCampIDReply.verify|verify} messages.
         * @function encode
         * @memberof pb.SetCampIDReply
         * @static
         * @param {pb.ISetCampIDReply} message SetCampIDReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetCampIDReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ok != null && message.hasOwnProperty("ok"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ok);
            return writer;
        };

        /**
         * Encodes the specified SetCampIDReply message, length delimited. Does not implicitly {@link pb.SetCampIDReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SetCampIDReply
         * @static
         * @param {pb.ISetCampIDReply} message SetCampIDReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetCampIDReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetCampIDReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SetCampIDReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SetCampIDReply} SetCampIDReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetCampIDReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SetCampIDReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ok = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetCampIDReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SetCampIDReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SetCampIDReply} SetCampIDReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetCampIDReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetCampIDReply message.
         * @function verify
         * @memberof pb.SetCampIDReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetCampIDReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ok != null && message.hasOwnProperty("ok"))
                if (typeof message.ok !== "boolean")
                    return "ok: boolean expected";
            return null;
        };

        return SetCampIDReply;
    })();

    pb.StartTutorialBattleArg = (function() {

        /**
         * Properties of a StartTutorialBattleArg.
         * @memberof pb
         * @interface IStartTutorialBattleArg
         * @property {number|null} [CampID] StartTutorialBattleArg CampID
         */

        /**
         * Constructs a new StartTutorialBattleArg.
         * @memberof pb
         * @classdesc Represents a StartTutorialBattleArg.
         * @implements IStartTutorialBattleArg
         * @constructor
         * @param {pb.IStartTutorialBattleArg=} [properties] Properties to set
         */
        function StartTutorialBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartTutorialBattleArg CampID.
         * @member {number} CampID
         * @memberof pb.StartTutorialBattleArg
         * @instance
         */
        StartTutorialBattleArg.prototype.CampID = 0;

        /**
         * Creates a new StartTutorialBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {pb.IStartTutorialBattleArg=} [properties] Properties to set
         * @returns {pb.StartTutorialBattleArg} StartTutorialBattleArg instance
         */
        StartTutorialBattleArg.create = function create(properties) {
            return new StartTutorialBattleArg(properties);
        };

        /**
         * Encodes the specified StartTutorialBattleArg message. Does not implicitly {@link pb.StartTutorialBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {pb.IStartTutorialBattleArg} message StartTutorialBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartTutorialBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CampID);
            return writer;
        };

        /**
         * Encodes the specified StartTutorialBattleArg message, length delimited. Does not implicitly {@link pb.StartTutorialBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {pb.IStartTutorialBattleArg} message StartTutorialBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartTutorialBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartTutorialBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.StartTutorialBattleArg} StartTutorialBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartTutorialBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.StartTutorialBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CampID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartTutorialBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.StartTutorialBattleArg} StartTutorialBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartTutorialBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartTutorialBattleArg message.
         * @function verify
         * @memberof pb.StartTutorialBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartTutorialBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CampID != null && message.hasOwnProperty("CampID"))
                if (!$util.isInteger(message.CampID))
                    return "CampID: integer expected";
            return null;
        };

        return StartTutorialBattleArg;
    })();

    pb.StartTutorialBattleReply = (function() {

        /**
         * Properties of a StartTutorialBattleReply.
         * @memberof pb
         * @interface IStartTutorialBattleReply
         * @property {boolean|null} [ok] StartTutorialBattleReply ok
         */

        /**
         * Constructs a new StartTutorialBattleReply.
         * @memberof pb
         * @classdesc Represents a StartTutorialBattleReply.
         * @implements IStartTutorialBattleReply
         * @constructor
         * @param {pb.IStartTutorialBattleReply=} [properties] Properties to set
         */
        function StartTutorialBattleReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StartTutorialBattleReply ok.
         * @member {boolean} ok
         * @memberof pb.StartTutorialBattleReply
         * @instance
         */
        StartTutorialBattleReply.prototype.ok = false;

        /**
         * Creates a new StartTutorialBattleReply instance using the specified properties.
         * @function create
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {pb.IStartTutorialBattleReply=} [properties] Properties to set
         * @returns {pb.StartTutorialBattleReply} StartTutorialBattleReply instance
         */
        StartTutorialBattleReply.create = function create(properties) {
            return new StartTutorialBattleReply(properties);
        };

        /**
         * Encodes the specified StartTutorialBattleReply message. Does not implicitly {@link pb.StartTutorialBattleReply.verify|verify} messages.
         * @function encode
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {pb.IStartTutorialBattleReply} message StartTutorialBattleReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartTutorialBattleReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ok != null && message.hasOwnProperty("ok"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ok);
            return writer;
        };

        /**
         * Encodes the specified StartTutorialBattleReply message, length delimited. Does not implicitly {@link pb.StartTutorialBattleReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {pb.IStartTutorialBattleReply} message StartTutorialBattleReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StartTutorialBattleReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StartTutorialBattleReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.StartTutorialBattleReply} StartTutorialBattleReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartTutorialBattleReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.StartTutorialBattleReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ok = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StartTutorialBattleReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.StartTutorialBattleReply} StartTutorialBattleReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StartTutorialBattleReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StartTutorialBattleReply message.
         * @function verify
         * @memberof pb.StartTutorialBattleReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StartTutorialBattleReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ok != null && message.hasOwnProperty("ok"))
                if (typeof message.ok !== "boolean")
                    return "ok: boolean expected";
            return null;
        };

        return StartTutorialBattleReply;
    })();

    pb.TutorialFightEnd = (function() {

        /**
         * Properties of a TutorialFightEnd.
         * @memberof pb
         * @interface ITutorialFightEnd
         */

        /**
         * Constructs a new TutorialFightEnd.
         * @memberof pb
         * @classdesc Represents a TutorialFightEnd.
         * @implements ITutorialFightEnd
         * @constructor
         * @param {pb.ITutorialFightEnd=} [properties] Properties to set
         */
        function TutorialFightEnd(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TutorialFightEnd instance using the specified properties.
         * @function create
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {pb.ITutorialFightEnd=} [properties] Properties to set
         * @returns {pb.TutorialFightEnd} TutorialFightEnd instance
         */
        TutorialFightEnd.create = function create(properties) {
            return new TutorialFightEnd(properties);
        };

        /**
         * Encodes the specified TutorialFightEnd message. Does not implicitly {@link pb.TutorialFightEnd.verify|verify} messages.
         * @function encode
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {pb.ITutorialFightEnd} message TutorialFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TutorialFightEnd.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TutorialFightEnd message, length delimited. Does not implicitly {@link pb.TutorialFightEnd.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {pb.ITutorialFightEnd} message TutorialFightEnd message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TutorialFightEnd.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TutorialFightEnd message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TutorialFightEnd} TutorialFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TutorialFightEnd.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TutorialFightEnd();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TutorialFightEnd message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TutorialFightEnd} TutorialFightEnd
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TutorialFightEnd.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TutorialFightEnd message.
         * @function verify
         * @memberof pb.TutorialFightEnd
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TutorialFightEnd.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TutorialFightEnd;
    })();

    pb.GuideBattle = (function() {

        /**
         * Properties of a GuideBattle.
         * @memberof pb
         * @interface IGuideBattle
         * @property {pb.IFightDesk|null} [Desk] GuideBattle Desk
         * @property {number|null} [GuideBattleID] GuideBattle GuideBattleID
         */

        /**
         * Constructs a new GuideBattle.
         * @memberof pb
         * @classdesc Represents a GuideBattle.
         * @implements IGuideBattle
         * @constructor
         * @param {pb.IGuideBattle=} [properties] Properties to set
         */
        function GuideBattle(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GuideBattle Desk.
         * @member {pb.IFightDesk|null|undefined} Desk
         * @memberof pb.GuideBattle
         * @instance
         */
        GuideBattle.prototype.Desk = null;

        /**
         * GuideBattle GuideBattleID.
         * @member {number} GuideBattleID
         * @memberof pb.GuideBattle
         * @instance
         */
        GuideBattle.prototype.GuideBattleID = 0;

        /**
         * Creates a new GuideBattle instance using the specified properties.
         * @function create
         * @memberof pb.GuideBattle
         * @static
         * @param {pb.IGuideBattle=} [properties] Properties to set
         * @returns {pb.GuideBattle} GuideBattle instance
         */
        GuideBattle.create = function create(properties) {
            return new GuideBattle(properties);
        };

        /**
         * Encodes the specified GuideBattle message. Does not implicitly {@link pb.GuideBattle.verify|verify} messages.
         * @function encode
         * @memberof pb.GuideBattle
         * @static
         * @param {pb.IGuideBattle} message GuideBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideBattle.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Desk != null && message.hasOwnProperty("Desk"))
                $root.pb.FightDesk.encode(message.Desk, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.GuideBattleID != null && message.hasOwnProperty("GuideBattleID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.GuideBattleID);
            return writer;
        };

        /**
         * Encodes the specified GuideBattle message, length delimited. Does not implicitly {@link pb.GuideBattle.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GuideBattle
         * @static
         * @param {pb.IGuideBattle} message GuideBattle message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GuideBattle.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GuideBattle message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GuideBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GuideBattle} GuideBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideBattle.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GuideBattle();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Desk = $root.pb.FightDesk.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.GuideBattleID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GuideBattle message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GuideBattle
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GuideBattle} GuideBattle
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GuideBattle.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GuideBattle message.
         * @function verify
         * @memberof pb.GuideBattle
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GuideBattle.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Desk != null && message.hasOwnProperty("Desk")) {
                var error = $root.pb.FightDesk.verify(message.Desk);
                if (error)
                    return "Desk." + error;
            }
            if (message.GuideBattleID != null && message.hasOwnProperty("GuideBattleID"))
                if (!$util.isInteger(message.GuideBattleID))
                    return "GuideBattleID: integer expected";
            return null;
        };

        return GuideBattle;
    })();

    pb.VideoFighter = (function() {

        /**
         * Properties of a VideoFighter.
         * @memberof pb
         * @interface IVideoFighter
         * @property {string|null} [Name] VideoFighter Name
         * @property {number|Long|null} [Uid] VideoFighter Uid
         * @property {Array.<pb.ISkinGCard>|null} [FightCards] VideoFighter FightCards
         */

        /**
         * Constructs a new VideoFighter.
         * @memberof pb
         * @classdesc Represents a VideoFighter.
         * @implements IVideoFighter
         * @constructor
         * @param {pb.IVideoFighter=} [properties] Properties to set
         */
        function VideoFighter(properties) {
            this.FightCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoFighter Name.
         * @member {string} Name
         * @memberof pb.VideoFighter
         * @instance
         */
        VideoFighter.prototype.Name = "";

        /**
         * VideoFighter Uid.
         * @member {number|Long} Uid
         * @memberof pb.VideoFighter
         * @instance
         */
        VideoFighter.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoFighter FightCards.
         * @member {Array.<pb.ISkinGCard>} FightCards
         * @memberof pb.VideoFighter
         * @instance
         */
        VideoFighter.prototype.FightCards = $util.emptyArray;

        /**
         * Creates a new VideoFighter instance using the specified properties.
         * @function create
         * @memberof pb.VideoFighter
         * @static
         * @param {pb.IVideoFighter=} [properties] Properties to set
         * @returns {pb.VideoFighter} VideoFighter instance
         */
        VideoFighter.create = function create(properties) {
            return new VideoFighter(properties);
        };

        /**
         * Encodes the specified VideoFighter message. Does not implicitly {@link pb.VideoFighter.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoFighter
         * @static
         * @param {pb.IVideoFighter} message VideoFighter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoFighter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.Name);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.Uid);
            if (message.FightCards != null && message.FightCards.length)
                for (var i = 0; i < message.FightCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.FightCards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VideoFighter message, length delimited. Does not implicitly {@link pb.VideoFighter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoFighter
         * @static
         * @param {pb.IVideoFighter} message VideoFighter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoFighter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoFighter message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoFighter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoFighter} VideoFighter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoFighter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoFighter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Name = reader.string();
                    break;
                case 2:
                    message.Uid = reader.uint64();
                    break;
                case 3:
                    if (!(message.FightCards && message.FightCards.length))
                        message.FightCards = [];
                    message.FightCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoFighter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoFighter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoFighter} VideoFighter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoFighter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoFighter message.
         * @function verify
         * @memberof pb.VideoFighter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoFighter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.FightCards != null && message.hasOwnProperty("FightCards")) {
                if (!Array.isArray(message.FightCards))
                    return "FightCards: array expected";
                for (var i = 0; i < message.FightCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.FightCards[i]);
                    if (error)
                        return "FightCards." + error;
                }
            }
            return null;
        };

        return VideoFighter;
    })();

    pb.VideoItem = (function() {

        /**
         * Properties of a VideoItem.
         * @memberof pb
         * @interface IVideoItem
         * @property {number|Long|null} [VideoID] VideoItem VideoID
         * @property {pb.IVideoFighter|null} [Fighter1] VideoItem Fighter1
         * @property {pb.IVideoFighter|null} [Fighter2] VideoItem Fighter2
         * @property {number|Long|null} [WinnerUid] VideoItem WinnerUid
         * @property {number|null} [WatchTimes] VideoItem WatchTimes
         * @property {number|null} [Like] VideoItem Like
         * @property {number|null} [Time] VideoItem Time
         * @property {string|null} [SharePlayerName] VideoItem SharePlayerName
         * @property {boolean|null} [IsLike] VideoItem IsLike
         * @property {number|null} [CommentsAmount] VideoItem CommentsAmount
         * @property {string|null} [Name] VideoItem Name
         */

        /**
         * Constructs a new VideoItem.
         * @memberof pb
         * @classdesc Represents a VideoItem.
         * @implements IVideoItem
         * @constructor
         * @param {pb.IVideoItem=} [properties] Properties to set
         */
        function VideoItem(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoItem VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoItem Fighter1.
         * @member {pb.IVideoFighter|null|undefined} Fighter1
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.Fighter1 = null;

        /**
         * VideoItem Fighter2.
         * @member {pb.IVideoFighter|null|undefined} Fighter2
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.Fighter2 = null;

        /**
         * VideoItem WinnerUid.
         * @member {number|Long} WinnerUid
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.WinnerUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoItem WatchTimes.
         * @member {number} WatchTimes
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.WatchTimes = 0;

        /**
         * VideoItem Like.
         * @member {number} Like
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.Like = 0;

        /**
         * VideoItem Time.
         * @member {number} Time
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.Time = 0;

        /**
         * VideoItem SharePlayerName.
         * @member {string} SharePlayerName
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.SharePlayerName = "";

        /**
         * VideoItem IsLike.
         * @member {boolean} IsLike
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.IsLike = false;

        /**
         * VideoItem CommentsAmount.
         * @member {number} CommentsAmount
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.CommentsAmount = 0;

        /**
         * VideoItem Name.
         * @member {string} Name
         * @memberof pb.VideoItem
         * @instance
         */
        VideoItem.prototype.Name = "";

        /**
         * Creates a new VideoItem instance using the specified properties.
         * @function create
         * @memberof pb.VideoItem
         * @static
         * @param {pb.IVideoItem=} [properties] Properties to set
         * @returns {pb.VideoItem} VideoItem instance
         */
        VideoItem.create = function create(properties) {
            return new VideoItem(properties);
        };

        /**
         * Encodes the specified VideoItem message. Does not implicitly {@link pb.VideoItem.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoItem
         * @static
         * @param {pb.IVideoItem} message VideoItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoItem.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1"))
                $root.pb.VideoFighter.encode(message.Fighter1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2"))
                $root.pb.VideoFighter.encode(message.Fighter2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.WinnerUid != null && message.hasOwnProperty("WinnerUid"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.WinnerUid);
            if (message.WatchTimes != null && message.hasOwnProperty("WatchTimes"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.WatchTimes);
            if (message.Like != null && message.hasOwnProperty("Like"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.Like);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Time);
            if (message.SharePlayerName != null && message.hasOwnProperty("SharePlayerName"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.SharePlayerName);
            if (message.IsLike != null && message.hasOwnProperty("IsLike"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.IsLike);
            if (message.CommentsAmount != null && message.hasOwnProperty("CommentsAmount"))
                writer.uint32(/* id 10, wireType 0 =*/80).int32(message.CommentsAmount);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified VideoItem message, length delimited. Does not implicitly {@link pb.VideoItem.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoItem
         * @static
         * @param {pb.IVideoItem} message VideoItem message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoItem.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoItem message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoItem} VideoItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoItem.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoItem();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.Fighter1 = $root.pb.VideoFighter.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Fighter2 = $root.pb.VideoFighter.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.WinnerUid = reader.uint64();
                    break;
                case 5:
                    message.WatchTimes = reader.int32();
                    break;
                case 6:
                    message.Like = reader.int32();
                    break;
                case 7:
                    message.Time = reader.int32();
                    break;
                case 8:
                    message.SharePlayerName = reader.string();
                    break;
                case 9:
                    message.IsLike = reader.bool();
                    break;
                case 10:
                    message.CommentsAmount = reader.int32();
                    break;
                case 11:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoItem message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoItem
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoItem} VideoItem
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoItem.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoItem message.
         * @function verify
         * @memberof pb.VideoItem
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoItem.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1")) {
                var error = $root.pb.VideoFighter.verify(message.Fighter1);
                if (error)
                    return "Fighter1." + error;
            }
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2")) {
                var error = $root.pb.VideoFighter.verify(message.Fighter2);
                if (error)
                    return "Fighter2." + error;
            }
            if (message.WinnerUid != null && message.hasOwnProperty("WinnerUid"))
                if (!$util.isInteger(message.WinnerUid) && !(message.WinnerUid && $util.isInteger(message.WinnerUid.low) && $util.isInteger(message.WinnerUid.high)))
                    return "WinnerUid: integer|Long expected";
            if (message.WatchTimes != null && message.hasOwnProperty("WatchTimes"))
                if (!$util.isInteger(message.WatchTimes))
                    return "WatchTimes: integer expected";
            if (message.Like != null && message.hasOwnProperty("Like"))
                if (!$util.isInteger(message.Like))
                    return "Like: integer expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.SharePlayerName != null && message.hasOwnProperty("SharePlayerName"))
                if (!$util.isString(message.SharePlayerName))
                    return "SharePlayerName: string expected";
            if (message.IsLike != null && message.hasOwnProperty("IsLike"))
                if (typeof message.IsLike !== "boolean")
                    return "IsLike: boolean expected";
            if (message.CommentsAmount != null && message.hasOwnProperty("CommentsAmount"))
                if (!$util.isInteger(message.CommentsAmount))
                    return "CommentsAmount: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return VideoItem;
    })();

    pb.VideoList = (function() {

        /**
         * Properties of a VideoList.
         * @memberof pb
         * @interface IVideoList
         * @property {Array.<pb.IVideoItem>|null} [Videos] VideoList Videos
         */

        /**
         * Constructs a new VideoList.
         * @memberof pb
         * @classdesc Represents a VideoList.
         * @implements IVideoList
         * @constructor
         * @param {pb.IVideoList=} [properties] Properties to set
         */
        function VideoList(properties) {
            this.Videos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoList Videos.
         * @member {Array.<pb.IVideoItem>} Videos
         * @memberof pb.VideoList
         * @instance
         */
        VideoList.prototype.Videos = $util.emptyArray;

        /**
         * Creates a new VideoList instance using the specified properties.
         * @function create
         * @memberof pb.VideoList
         * @static
         * @param {pb.IVideoList=} [properties] Properties to set
         * @returns {pb.VideoList} VideoList instance
         */
        VideoList.create = function create(properties) {
            return new VideoList(properties);
        };

        /**
         * Encodes the specified VideoList message. Does not implicitly {@link pb.VideoList.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoList
         * @static
         * @param {pb.IVideoList} message VideoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoList.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Videos != null && message.Videos.length)
                for (var i = 0; i < message.Videos.length; ++i)
                    $root.pb.VideoItem.encode(message.Videos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified VideoList message, length delimited. Does not implicitly {@link pb.VideoList.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoList
         * @static
         * @param {pb.IVideoList} message VideoList message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoList.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoList message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoList} VideoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoList.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoList();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.Videos && message.Videos.length))
                        message.Videos = [];
                    message.Videos.push($root.pb.VideoItem.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoList message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoList
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoList} VideoList
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoList.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoList message.
         * @function verify
         * @memberof pb.VideoList
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoList.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Videos != null && message.hasOwnProperty("Videos")) {
                if (!Array.isArray(message.Videos))
                    return "Videos: array expected";
                for (var i = 0; i < message.Videos.length; ++i) {
                    var error = $root.pb.VideoItem.verify(message.Videos[i]);
                    if (error)
                        return "Videos." + error;
                }
            }
            return null;
        };

        return VideoList;
    })();

    pb.WatchVideoArg = (function() {

        /**
         * Properties of a WatchVideoArg.
         * @memberof pb
         * @interface IWatchVideoArg
         * @property {number|Long|null} [VideoID] WatchVideoArg VideoID
         */

        /**
         * Constructs a new WatchVideoArg.
         * @memberof pb
         * @classdesc Represents a WatchVideoArg.
         * @implements IWatchVideoArg
         * @constructor
         * @param {pb.IWatchVideoArg=} [properties] Properties to set
         */
        function WatchVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.WatchVideoArg
         * @instance
         */
        WatchVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new WatchVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.WatchVideoArg
         * @static
         * @param {pb.IWatchVideoArg=} [properties] Properties to set
         * @returns {pb.WatchVideoArg} WatchVideoArg instance
         */
        WatchVideoArg.create = function create(properties) {
            return new WatchVideoArg(properties);
        };

        /**
         * Encodes the specified WatchVideoArg message. Does not implicitly {@link pb.WatchVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchVideoArg
         * @static
         * @param {pb.IWatchVideoArg} message WatchVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            return writer;
        };

        /**
         * Encodes the specified WatchVideoArg message, length delimited. Does not implicitly {@link pb.WatchVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchVideoArg
         * @static
         * @param {pb.IWatchVideoArg} message WatchVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchVideoArg} WatchVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchVideoArg} WatchVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchVideoArg message.
         * @function verify
         * @memberof pb.WatchVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            return null;
        };

        return WatchVideoArg;
    })();

    pb.WatchVideoResp = (function() {

        /**
         * Properties of a WatchVideoResp.
         * @memberof pb
         * @interface IWatchVideoResp
         * @property {pb.IVideoBattleData|null} [VideoData] WatchVideoResp VideoData
         * @property {number|null} [CurWatchTimes] WatchVideoResp CurWatchTimes
         * @property {number|null} [CurLike] WatchVideoResp CurLike
         */

        /**
         * Constructs a new WatchVideoResp.
         * @memberof pb
         * @classdesc Represents a WatchVideoResp.
         * @implements IWatchVideoResp
         * @constructor
         * @param {pb.IWatchVideoResp=} [properties] Properties to set
         */
        function WatchVideoResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WatchVideoResp VideoData.
         * @member {pb.IVideoBattleData|null|undefined} VideoData
         * @memberof pb.WatchVideoResp
         * @instance
         */
        WatchVideoResp.prototype.VideoData = null;

        /**
         * WatchVideoResp CurWatchTimes.
         * @member {number} CurWatchTimes
         * @memberof pb.WatchVideoResp
         * @instance
         */
        WatchVideoResp.prototype.CurWatchTimes = 0;

        /**
         * WatchVideoResp CurLike.
         * @member {number} CurLike
         * @memberof pb.WatchVideoResp
         * @instance
         */
        WatchVideoResp.prototype.CurLike = 0;

        /**
         * Creates a new WatchVideoResp instance using the specified properties.
         * @function create
         * @memberof pb.WatchVideoResp
         * @static
         * @param {pb.IWatchVideoResp=} [properties] Properties to set
         * @returns {pb.WatchVideoResp} WatchVideoResp instance
         */
        WatchVideoResp.create = function create(properties) {
            return new WatchVideoResp(properties);
        };

        /**
         * Encodes the specified WatchVideoResp message. Does not implicitly {@link pb.WatchVideoResp.verify|verify} messages.
         * @function encode
         * @memberof pb.WatchVideoResp
         * @static
         * @param {pb.IWatchVideoResp} message WatchVideoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchVideoResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoData != null && message.hasOwnProperty("VideoData"))
                $root.pb.VideoBattleData.encode(message.VideoData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.CurWatchTimes != null && message.hasOwnProperty("CurWatchTimes"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurWatchTimes);
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.CurLike);
            return writer;
        };

        /**
         * Encodes the specified WatchVideoResp message, length delimited. Does not implicitly {@link pb.WatchVideoResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WatchVideoResp
         * @static
         * @param {pb.IWatchVideoResp} message WatchVideoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WatchVideoResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WatchVideoResp message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WatchVideoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WatchVideoResp} WatchVideoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchVideoResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WatchVideoResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoData = $root.pb.VideoBattleData.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.CurWatchTimes = reader.int32();
                    break;
                case 3:
                    message.CurLike = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WatchVideoResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WatchVideoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WatchVideoResp} WatchVideoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WatchVideoResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WatchVideoResp message.
         * @function verify
         * @memberof pb.WatchVideoResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WatchVideoResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoData != null && message.hasOwnProperty("VideoData")) {
                var error = $root.pb.VideoBattleData.verify(message.VideoData);
                if (error)
                    return "VideoData." + error;
            }
            if (message.CurWatchTimes != null && message.hasOwnProperty("CurWatchTimes"))
                if (!$util.isInteger(message.CurWatchTimes))
                    return "CurWatchTimes: integer expected";
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                if (!$util.isInteger(message.CurLike))
                    return "CurLike: integer expected";
            return null;
        };

        return WatchVideoResp;
    })();

    pb.FetchSelfVideoListArg = (function() {

        /**
         * Properties of a FetchSelfVideoListArg.
         * @memberof pb
         * @interface IFetchSelfVideoListArg
         * @property {number|null} [Page] FetchSelfVideoListArg Page
         */

        /**
         * Constructs a new FetchSelfVideoListArg.
         * @memberof pb
         * @classdesc Represents a FetchSelfVideoListArg.
         * @implements IFetchSelfVideoListArg
         * @constructor
         * @param {pb.IFetchSelfVideoListArg=} [properties] Properties to set
         */
        function FetchSelfVideoListArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchSelfVideoListArg Page.
         * @member {number} Page
         * @memberof pb.FetchSelfVideoListArg
         * @instance
         */
        FetchSelfVideoListArg.prototype.Page = 0;

        /**
         * Creates a new FetchSelfVideoListArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {pb.IFetchSelfVideoListArg=} [properties] Properties to set
         * @returns {pb.FetchSelfVideoListArg} FetchSelfVideoListArg instance
         */
        FetchSelfVideoListArg.create = function create(properties) {
            return new FetchSelfVideoListArg(properties);
        };

        /**
         * Encodes the specified FetchSelfVideoListArg message. Does not implicitly {@link pb.FetchSelfVideoListArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {pb.IFetchSelfVideoListArg} message FetchSelfVideoListArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchSelfVideoListArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Page != null && message.hasOwnProperty("Page"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Page);
            return writer;
        };

        /**
         * Encodes the specified FetchSelfVideoListArg message, length delimited. Does not implicitly {@link pb.FetchSelfVideoListArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {pb.IFetchSelfVideoListArg} message FetchSelfVideoListArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchSelfVideoListArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchSelfVideoListArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchSelfVideoListArg} FetchSelfVideoListArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchSelfVideoListArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchSelfVideoListArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Page = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchSelfVideoListArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchSelfVideoListArg} FetchSelfVideoListArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchSelfVideoListArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchSelfVideoListArg message.
         * @function verify
         * @memberof pb.FetchSelfVideoListArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchSelfVideoListArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Page != null && message.hasOwnProperty("Page"))
                if (!$util.isInteger(message.Page))
                    return "Page: integer expected";
            return null;
        };

        return FetchSelfVideoListArg;
    })();

    pb.LikeVideoArg = (function() {

        /**
         * Properties of a LikeVideoArg.
         * @memberof pb
         * @interface ILikeVideoArg
         * @property {number|Long|null} [VideoID] LikeVideoArg VideoID
         */

        /**
         * Constructs a new LikeVideoArg.
         * @memberof pb
         * @classdesc Represents a LikeVideoArg.
         * @implements ILikeVideoArg
         * @constructor
         * @param {pb.ILikeVideoArg=} [properties] Properties to set
         */
        function LikeVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.LikeVideoArg
         * @instance
         */
        LikeVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new LikeVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.LikeVideoArg
         * @static
         * @param {pb.ILikeVideoArg=} [properties] Properties to set
         * @returns {pb.LikeVideoArg} LikeVideoArg instance
         */
        LikeVideoArg.create = function create(properties) {
            return new LikeVideoArg(properties);
        };

        /**
         * Encodes the specified LikeVideoArg message. Does not implicitly {@link pb.LikeVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LikeVideoArg
         * @static
         * @param {pb.ILikeVideoArg} message LikeVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            return writer;
        };

        /**
         * Encodes the specified LikeVideoArg message, length delimited. Does not implicitly {@link pb.LikeVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LikeVideoArg
         * @static
         * @param {pb.ILikeVideoArg} message LikeVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LikeVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LikeVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LikeVideoArg} LikeVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LikeVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LikeVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LikeVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LikeVideoArg} LikeVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LikeVideoArg message.
         * @function verify
         * @memberof pb.LikeVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LikeVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            return null;
        };

        return LikeVideoArg;
    })();

    pb.LikeVideoResp = (function() {

        /**
         * Properties of a LikeVideoResp.
         * @memberof pb
         * @interface ILikeVideoResp
         * @property {number|null} [CurWatchTimes] LikeVideoResp CurWatchTimes
         * @property {number|null} [CurLike] LikeVideoResp CurLike
         */

        /**
         * Constructs a new LikeVideoResp.
         * @memberof pb
         * @classdesc Represents a LikeVideoResp.
         * @implements ILikeVideoResp
         * @constructor
         * @param {pb.ILikeVideoResp=} [properties] Properties to set
         */
        function LikeVideoResp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeVideoResp CurWatchTimes.
         * @member {number} CurWatchTimes
         * @memberof pb.LikeVideoResp
         * @instance
         */
        LikeVideoResp.prototype.CurWatchTimes = 0;

        /**
         * LikeVideoResp CurLike.
         * @member {number} CurLike
         * @memberof pb.LikeVideoResp
         * @instance
         */
        LikeVideoResp.prototype.CurLike = 0;

        /**
         * Creates a new LikeVideoResp instance using the specified properties.
         * @function create
         * @memberof pb.LikeVideoResp
         * @static
         * @param {pb.ILikeVideoResp=} [properties] Properties to set
         * @returns {pb.LikeVideoResp} LikeVideoResp instance
         */
        LikeVideoResp.create = function create(properties) {
            return new LikeVideoResp(properties);
        };

        /**
         * Encodes the specified LikeVideoResp message. Does not implicitly {@link pb.LikeVideoResp.verify|verify} messages.
         * @function encode
         * @memberof pb.LikeVideoResp
         * @static
         * @param {pb.ILikeVideoResp} message LikeVideoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoResp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CurWatchTimes != null && message.hasOwnProperty("CurWatchTimes"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurWatchTimes);
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurLike);
            return writer;
        };

        /**
         * Encodes the specified LikeVideoResp message, length delimited. Does not implicitly {@link pb.LikeVideoResp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LikeVideoResp
         * @static
         * @param {pb.ILikeVideoResp} message LikeVideoResp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoResp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LikeVideoResp message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LikeVideoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LikeVideoResp} LikeVideoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoResp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LikeVideoResp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CurWatchTimes = reader.int32();
                    break;
                case 2:
                    message.CurLike = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LikeVideoResp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LikeVideoResp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LikeVideoResp} LikeVideoResp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoResp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LikeVideoResp message.
         * @function verify
         * @memberof pb.LikeVideoResp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LikeVideoResp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CurWatchTimes != null && message.hasOwnProperty("CurWatchTimes"))
                if (!$util.isInteger(message.CurWatchTimes))
                    return "CurWatchTimes: integer expected";
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                if (!$util.isInteger(message.CurLike))
                    return "CurLike: integer expected";
            return null;
        };

        return LikeVideoResp;
    })();

    pb.ShareVideoArg = (function() {

        /**
         * Properties of a ShareVideoArg.
         * @memberof pb
         * @interface IShareVideoArg
         * @property {number|Long|null} [VideoID] ShareVideoArg VideoID
         * @property {string|null} [Name] ShareVideoArg Name
         */

        /**
         * Constructs a new ShareVideoArg.
         * @memberof pb
         * @classdesc Represents a ShareVideoArg.
         * @implements IShareVideoArg
         * @constructor
         * @param {pb.IShareVideoArg=} [properties] Properties to set
         */
        function ShareVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.ShareVideoArg
         * @instance
         */
        ShareVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ShareVideoArg Name.
         * @member {string} Name
         * @memberof pb.ShareVideoArg
         * @instance
         */
        ShareVideoArg.prototype.Name = "";

        /**
         * Creates a new ShareVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.ShareVideoArg
         * @static
         * @param {pb.IShareVideoArg=} [properties] Properties to set
         * @returns {pb.ShareVideoArg} ShareVideoArg instance
         */
        ShareVideoArg.create = function create(properties) {
            return new ShareVideoArg(properties);
        };

        /**
         * Encodes the specified ShareVideoArg message. Does not implicitly {@link pb.ShareVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ShareVideoArg
         * @static
         * @param {pb.IShareVideoArg} message ShareVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            return writer;
        };

        /**
         * Encodes the specified ShareVideoArg message, length delimited. Does not implicitly {@link pb.ShareVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ShareVideoArg
         * @static
         * @param {pb.IShareVideoArg} message ShareVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ShareVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ShareVideoArg} ShareVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShareVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ShareVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ShareVideoArg} ShareVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareVideoArg message.
         * @function verify
         * @memberof pb.ShareVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            return null;
        };

        return ShareVideoArg;
    })();

    pb.VideoFighterData = (function() {

        /**
         * Properties of a VideoFighterData.
         * @memberof pb
         * @interface IVideoFighterData
         * @property {number|Long|null} [Uid] VideoFighterData Uid
         * @property {string|null} [Name] VideoFighterData Name
         * @property {number|null} [PvpScore] VideoFighterData PvpScore
         * @property {number|null} [Camp] VideoFighterData Camp
         * @property {Array.<pb.ISkinGCard>|null} [HandCards] VideoFighterData HandCards
         * @property {boolean|null} [IsRobot] VideoFighterData IsRobot
         */

        /**
         * Constructs a new VideoFighterData.
         * @memberof pb
         * @classdesc Represents a VideoFighterData.
         * @implements IVideoFighterData
         * @constructor
         * @param {pb.IVideoFighterData=} [properties] Properties to set
         */
        function VideoFighterData(properties) {
            this.HandCards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoFighterData Uid.
         * @member {number|Long} Uid
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoFighterData Name.
         * @member {string} Name
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.Name = "";

        /**
         * VideoFighterData PvpScore.
         * @member {number} PvpScore
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.PvpScore = 0;

        /**
         * VideoFighterData Camp.
         * @member {number} Camp
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.Camp = 0;

        /**
         * VideoFighterData HandCards.
         * @member {Array.<pb.ISkinGCard>} HandCards
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.HandCards = $util.emptyArray;

        /**
         * VideoFighterData IsRobot.
         * @member {boolean} IsRobot
         * @memberof pb.VideoFighterData
         * @instance
         */
        VideoFighterData.prototype.IsRobot = false;

        /**
         * Creates a new VideoFighterData instance using the specified properties.
         * @function create
         * @memberof pb.VideoFighterData
         * @static
         * @param {pb.IVideoFighterData=} [properties] Properties to set
         * @returns {pb.VideoFighterData} VideoFighterData instance
         */
        VideoFighterData.create = function create(properties) {
            return new VideoFighterData(properties);
        };

        /**
         * Encodes the specified VideoFighterData message. Does not implicitly {@link pb.VideoFighterData.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoFighterData
         * @static
         * @param {pb.IVideoFighterData} message VideoFighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoFighterData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.PvpScore);
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Camp);
            if (message.HandCards != null && message.HandCards.length)
                for (var i = 0; i < message.HandCards.length; ++i)
                    $root.pb.SkinGCard.encode(message.HandCards[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.IsRobot);
            return writer;
        };

        /**
         * Encodes the specified VideoFighterData message, length delimited. Does not implicitly {@link pb.VideoFighterData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoFighterData
         * @static
         * @param {pb.IVideoFighterData} message VideoFighterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoFighterData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoFighterData message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoFighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoFighterData} VideoFighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoFighterData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoFighterData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.PvpScore = reader.int32();
                    break;
                case 4:
                    message.Camp = reader.int32();
                    break;
                case 5:
                    if (!(message.HandCards && message.HandCards.length))
                        message.HandCards = [];
                    message.HandCards.push($root.pb.SkinGCard.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.IsRobot = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoFighterData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoFighterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoFighterData} VideoFighterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoFighterData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoFighterData message.
         * @function verify
         * @memberof pb.VideoFighterData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoFighterData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.PvpScore != null && message.hasOwnProperty("PvpScore"))
                if (!$util.isInteger(message.PvpScore))
                    return "PvpScore: integer expected";
            if (message.Camp != null && message.hasOwnProperty("Camp"))
                if (!$util.isInteger(message.Camp))
                    return "Camp: integer expected";
            if (message.HandCards != null && message.hasOwnProperty("HandCards")) {
                if (!Array.isArray(message.HandCards))
                    return "HandCards: array expected";
                for (var i = 0; i < message.HandCards.length; ++i) {
                    var error = $root.pb.SkinGCard.verify(message.HandCards[i]);
                    if (error)
                        return "HandCards." + error;
                }
            }
            if (message.IsRobot != null && message.hasOwnProperty("IsRobot"))
                if (typeof message.IsRobot !== "boolean")
                    return "IsRobot: boolean expected";
            return null;
        };

        return VideoFighterData;
    })();

    pb.SaveVideoArg = (function() {

        /**
         * Properties of a SaveVideoArg.
         * @memberof pb
         * @interface ISaveVideoArg
         * @property {number|Long|null} [VideoID] SaveVideoArg VideoID
         * @property {pb.IVideoFighterData|null} [Fighter1] SaveVideoArg Fighter1
         * @property {pb.IVideoFighterData|null} [Fighter2] SaveVideoArg Fighter2
         * @property {number|Long|null} [Winner] SaveVideoArg Winner
         */

        /**
         * Constructs a new SaveVideoArg.
         * @memberof pb
         * @classdesc Represents a SaveVideoArg.
         * @implements ISaveVideoArg
         * @constructor
         * @param {pb.ISaveVideoArg=} [properties] Properties to set
         */
        function SaveVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SaveVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.SaveVideoArg
         * @instance
         */
        SaveVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * SaveVideoArg Fighter1.
         * @member {pb.IVideoFighterData|null|undefined} Fighter1
         * @memberof pb.SaveVideoArg
         * @instance
         */
        SaveVideoArg.prototype.Fighter1 = null;

        /**
         * SaveVideoArg Fighter2.
         * @member {pb.IVideoFighterData|null|undefined} Fighter2
         * @memberof pb.SaveVideoArg
         * @instance
         */
        SaveVideoArg.prototype.Fighter2 = null;

        /**
         * SaveVideoArg Winner.
         * @member {number|Long} Winner
         * @memberof pb.SaveVideoArg
         * @instance
         */
        SaveVideoArg.prototype.Winner = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new SaveVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.SaveVideoArg
         * @static
         * @param {pb.ISaveVideoArg=} [properties] Properties to set
         * @returns {pb.SaveVideoArg} SaveVideoArg instance
         */
        SaveVideoArg.create = function create(properties) {
            return new SaveVideoArg(properties);
        };

        /**
         * Encodes the specified SaveVideoArg message. Does not implicitly {@link pb.SaveVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.SaveVideoArg
         * @static
         * @param {pb.ISaveVideoArg} message SaveVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1"))
                $root.pb.VideoFighterData.encode(message.Fighter1, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2"))
                $root.pb.VideoFighterData.encode(message.Fighter2, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.Winner != null && message.hasOwnProperty("Winner"))
                writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.Winner);
            return writer;
        };

        /**
         * Encodes the specified SaveVideoArg message, length delimited. Does not implicitly {@link pb.SaveVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.SaveVideoArg
         * @static
         * @param {pb.ISaveVideoArg} message SaveVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SaveVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SaveVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.SaveVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.SaveVideoArg} SaveVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.SaveVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.Fighter1 = $root.pb.VideoFighterData.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.Fighter2 = $root.pb.VideoFighterData.decode(reader, reader.uint32());
                    break;
                case 4:
                    message.Winner = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SaveVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.SaveVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.SaveVideoArg} SaveVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SaveVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SaveVideoArg message.
         * @function verify
         * @memberof pb.SaveVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SaveVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.Fighter1 != null && message.hasOwnProperty("Fighter1")) {
                var error = $root.pb.VideoFighterData.verify(message.Fighter1);
                if (error)
                    return "Fighter1." + error;
            }
            if (message.Fighter2 != null && message.hasOwnProperty("Fighter2")) {
                var error = $root.pb.VideoFighterData.verify(message.Fighter2);
                if (error)
                    return "Fighter2." + error;
            }
            if (message.Winner != null && message.hasOwnProperty("Winner"))
                if (!$util.isInteger(message.Winner) && !(message.Winner && $util.isInteger(message.Winner.low) && $util.isInteger(message.Winner.high)))
                    return "Winner: integer|Long expected";
            return null;
        };

        return SaveVideoArg;
    })();

    pb.FetchVideoCommentsArg = (function() {

        /**
         * Properties of a FetchVideoCommentsArg.
         * @memberof pb
         * @interface IFetchVideoCommentsArg
         * @property {number|Long|null} [VideoID] FetchVideoCommentsArg VideoID
         * @property {number|null} [CurAmount] FetchVideoCommentsArg CurAmount
         */

        /**
         * Constructs a new FetchVideoCommentsArg.
         * @memberof pb
         * @classdesc Represents a FetchVideoCommentsArg.
         * @implements IFetchVideoCommentsArg
         * @constructor
         * @param {pb.IFetchVideoCommentsArg=} [properties] Properties to set
         */
        function FetchVideoCommentsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchVideoCommentsArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.FetchVideoCommentsArg
         * @instance
         */
        FetchVideoCommentsArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * FetchVideoCommentsArg CurAmount.
         * @member {number} CurAmount
         * @memberof pb.FetchVideoCommentsArg
         * @instance
         */
        FetchVideoCommentsArg.prototype.CurAmount = 0;

        /**
         * Creates a new FetchVideoCommentsArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {pb.IFetchVideoCommentsArg=} [properties] Properties to set
         * @returns {pb.FetchVideoCommentsArg} FetchVideoCommentsArg instance
         */
        FetchVideoCommentsArg.create = function create(properties) {
            return new FetchVideoCommentsArg(properties);
        };

        /**
         * Encodes the specified FetchVideoCommentsArg message. Does not implicitly {@link pb.FetchVideoCommentsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {pb.IFetchVideoCommentsArg} message FetchVideoCommentsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoCommentsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.CurAmount != null && message.hasOwnProperty("CurAmount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CurAmount);
            return writer;
        };

        /**
         * Encodes the specified FetchVideoCommentsArg message, length delimited. Does not implicitly {@link pb.FetchVideoCommentsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {pb.IFetchVideoCommentsArg} message FetchVideoCommentsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoCommentsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchVideoCommentsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchVideoCommentsArg} FetchVideoCommentsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoCommentsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchVideoCommentsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.CurAmount = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchVideoCommentsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchVideoCommentsArg} FetchVideoCommentsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoCommentsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchVideoCommentsArg message.
         * @function verify
         * @memberof pb.FetchVideoCommentsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchVideoCommentsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.CurAmount != null && message.hasOwnProperty("CurAmount"))
                if (!$util.isInteger(message.CurAmount))
                    return "CurAmount: integer expected";
            return null;
        };

        return FetchVideoCommentsArg;
    })();

    pb.VideoComments = (function() {

        /**
         * Properties of a VideoComments.
         * @memberof pb
         * @interface IVideoComments
         * @property {number|null} [ID] VideoComments ID
         * @property {string|null} [Name] VideoComments Name
         * @property {string|null} [Content] VideoComments Content
         * @property {number|null} [Like] VideoComments Like
         * @property {boolean|null} [IsLike] VideoComments IsLike
         * @property {string|null} [HeadImgUrl] VideoComments HeadImgUrl
         * @property {number|null} [Time] VideoComments Time
         * @property {string|null} [Country] VideoComments Country
         * @property {number|Long|null} [Uid] VideoComments Uid
         * @property {string|null} [HeadFrame] VideoComments HeadFrame
         */

        /**
         * Constructs a new VideoComments.
         * @memberof pb
         * @classdesc Represents a VideoComments.
         * @implements IVideoComments
         * @constructor
         * @param {pb.IVideoComments=} [properties] Properties to set
         */
        function VideoComments(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * VideoComments ID.
         * @member {number} ID
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.ID = 0;

        /**
         * VideoComments Name.
         * @member {string} Name
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Name = "";

        /**
         * VideoComments Content.
         * @member {string} Content
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Content = "";

        /**
         * VideoComments Like.
         * @member {number} Like
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Like = 0;

        /**
         * VideoComments IsLike.
         * @member {boolean} IsLike
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.IsLike = false;

        /**
         * VideoComments HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.HeadImgUrl = "";

        /**
         * VideoComments Time.
         * @member {number} Time
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Time = 0;

        /**
         * VideoComments Country.
         * @member {string} Country
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Country = "";

        /**
         * VideoComments Uid.
         * @member {number|Long} Uid
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * VideoComments HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.VideoComments
         * @instance
         */
        VideoComments.prototype.HeadFrame = "";

        /**
         * Creates a new VideoComments instance using the specified properties.
         * @function create
         * @memberof pb.VideoComments
         * @static
         * @param {pb.IVideoComments=} [properties] Properties to set
         * @returns {pb.VideoComments} VideoComments instance
         */
        VideoComments.create = function create(properties) {
            return new VideoComments(properties);
        };

        /**
         * Encodes the specified VideoComments message. Does not implicitly {@link pb.VideoComments.verify|verify} messages.
         * @function encode
         * @memberof pb.VideoComments
         * @static
         * @param {pb.IVideoComments} message VideoComments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoComments.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ID != null && message.hasOwnProperty("ID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ID);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Name);
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Content);
            if (message.Like != null && message.hasOwnProperty("Like"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.Like);
            if (message.IsLike != null && message.hasOwnProperty("IsLike"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.IsLike);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.HeadImgUrl);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.Time);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 8, wireType 2 =*/66).string(message.Country);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.Uid);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified VideoComments message, length delimited. Does not implicitly {@link pb.VideoComments.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.VideoComments
         * @static
         * @param {pb.IVideoComments} message VideoComments message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        VideoComments.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a VideoComments message from the specified reader or buffer.
         * @function decode
         * @memberof pb.VideoComments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.VideoComments} VideoComments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoComments.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.VideoComments();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ID = reader.int32();
                    break;
                case 2:
                    message.Name = reader.string();
                    break;
                case 3:
                    message.Content = reader.string();
                    break;
                case 4:
                    message.Like = reader.int32();
                    break;
                case 5:
                    message.IsLike = reader.bool();
                    break;
                case 6:
                    message.HeadImgUrl = reader.string();
                    break;
                case 7:
                    message.Time = reader.int32();
                    break;
                case 8:
                    message.Country = reader.string();
                    break;
                case 9:
                    message.Uid = reader.uint64();
                    break;
                case 10:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a VideoComments message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.VideoComments
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.VideoComments} VideoComments
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        VideoComments.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a VideoComments message.
         * @function verify
         * @memberof pb.VideoComments
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        VideoComments.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ID != null && message.hasOwnProperty("ID"))
                if (!$util.isInteger(message.ID))
                    return "ID: integer expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            if (message.Like != null && message.hasOwnProperty("Like"))
                if (!$util.isInteger(message.Like))
                    return "Like: integer expected";
            if (message.IsLike != null && message.hasOwnProperty("IsLike"))
                if (typeof message.IsLike !== "boolean")
                    return "IsLike: boolean expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return VideoComments;
    })();

    pb.FetchVideoCommentsReply = (function() {

        /**
         * Properties of a FetchVideoCommentsReply.
         * @memberof pb
         * @interface IFetchVideoCommentsReply
         * @property {Array.<pb.IVideoComments>|null} [CommentsList] FetchVideoCommentsReply CommentsList
         * @property {boolean|null} [HasMore] FetchVideoCommentsReply HasMore
         */

        /**
         * Constructs a new FetchVideoCommentsReply.
         * @memberof pb
         * @classdesc Represents a FetchVideoCommentsReply.
         * @implements IFetchVideoCommentsReply
         * @constructor
         * @param {pb.IFetchVideoCommentsReply=} [properties] Properties to set
         */
        function FetchVideoCommentsReply(properties) {
            this.CommentsList = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchVideoCommentsReply CommentsList.
         * @member {Array.<pb.IVideoComments>} CommentsList
         * @memberof pb.FetchVideoCommentsReply
         * @instance
         */
        FetchVideoCommentsReply.prototype.CommentsList = $util.emptyArray;

        /**
         * FetchVideoCommentsReply HasMore.
         * @member {boolean} HasMore
         * @memberof pb.FetchVideoCommentsReply
         * @instance
         */
        FetchVideoCommentsReply.prototype.HasMore = false;

        /**
         * Creates a new FetchVideoCommentsReply instance using the specified properties.
         * @function create
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {pb.IFetchVideoCommentsReply=} [properties] Properties to set
         * @returns {pb.FetchVideoCommentsReply} FetchVideoCommentsReply instance
         */
        FetchVideoCommentsReply.create = function create(properties) {
            return new FetchVideoCommentsReply(properties);
        };

        /**
         * Encodes the specified FetchVideoCommentsReply message. Does not implicitly {@link pb.FetchVideoCommentsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {pb.IFetchVideoCommentsReply} message FetchVideoCommentsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoCommentsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CommentsList != null && message.CommentsList.length)
                for (var i = 0; i < message.CommentsList.length; ++i)
                    $root.pb.VideoComments.encode(message.CommentsList[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.HasMore != null && message.hasOwnProperty("HasMore"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.HasMore);
            return writer;
        };

        /**
         * Encodes the specified FetchVideoCommentsReply message, length delimited. Does not implicitly {@link pb.FetchVideoCommentsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {pb.IFetchVideoCommentsReply} message FetchVideoCommentsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoCommentsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchVideoCommentsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchVideoCommentsReply} FetchVideoCommentsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoCommentsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchVideoCommentsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.CommentsList && message.CommentsList.length))
                        message.CommentsList = [];
                    message.CommentsList.push($root.pb.VideoComments.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.HasMore = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchVideoCommentsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchVideoCommentsReply} FetchVideoCommentsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoCommentsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchVideoCommentsReply message.
         * @function verify
         * @memberof pb.FetchVideoCommentsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchVideoCommentsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CommentsList != null && message.hasOwnProperty("CommentsList")) {
                if (!Array.isArray(message.CommentsList))
                    return "CommentsList: array expected";
                for (var i = 0; i < message.CommentsList.length; ++i) {
                    var error = $root.pb.VideoComments.verify(message.CommentsList[i]);
                    if (error)
                        return "CommentsList." + error;
                }
            }
            if (message.HasMore != null && message.hasOwnProperty("HasMore"))
                if (typeof message.HasMore !== "boolean")
                    return "HasMore: boolean expected";
            return null;
        };

        return FetchVideoCommentsReply;
    })();

    pb.LikeVideoCommentsArg = (function() {

        /**
         * Properties of a LikeVideoCommentsArg.
         * @memberof pb
         * @interface ILikeVideoCommentsArg
         * @property {number|Long|null} [VideoID] LikeVideoCommentsArg VideoID
         * @property {number|null} [CommentsID] LikeVideoCommentsArg CommentsID
         */

        /**
         * Constructs a new LikeVideoCommentsArg.
         * @memberof pb
         * @classdesc Represents a LikeVideoCommentsArg.
         * @implements ILikeVideoCommentsArg
         * @constructor
         * @param {pb.ILikeVideoCommentsArg=} [properties] Properties to set
         */
        function LikeVideoCommentsArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeVideoCommentsArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.LikeVideoCommentsArg
         * @instance
         */
        LikeVideoCommentsArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LikeVideoCommentsArg CommentsID.
         * @member {number} CommentsID
         * @memberof pb.LikeVideoCommentsArg
         * @instance
         */
        LikeVideoCommentsArg.prototype.CommentsID = 0;

        /**
         * Creates a new LikeVideoCommentsArg instance using the specified properties.
         * @function create
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {pb.ILikeVideoCommentsArg=} [properties] Properties to set
         * @returns {pb.LikeVideoCommentsArg} LikeVideoCommentsArg instance
         */
        LikeVideoCommentsArg.create = function create(properties) {
            return new LikeVideoCommentsArg(properties);
        };

        /**
         * Encodes the specified LikeVideoCommentsArg message. Does not implicitly {@link pb.LikeVideoCommentsArg.verify|verify} messages.
         * @function encode
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {pb.ILikeVideoCommentsArg} message LikeVideoCommentsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoCommentsArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.CommentsID != null && message.hasOwnProperty("CommentsID"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.CommentsID);
            return writer;
        };

        /**
         * Encodes the specified LikeVideoCommentsArg message, length delimited. Does not implicitly {@link pb.LikeVideoCommentsArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {pb.ILikeVideoCommentsArg} message LikeVideoCommentsArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoCommentsArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LikeVideoCommentsArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LikeVideoCommentsArg} LikeVideoCommentsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoCommentsArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LikeVideoCommentsArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.CommentsID = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LikeVideoCommentsArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LikeVideoCommentsArg} LikeVideoCommentsArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoCommentsArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LikeVideoCommentsArg message.
         * @function verify
         * @memberof pb.LikeVideoCommentsArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LikeVideoCommentsArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.CommentsID != null && message.hasOwnProperty("CommentsID"))
                if (!$util.isInteger(message.CommentsID))
                    return "CommentsID: integer expected";
            return null;
        };

        return LikeVideoCommentsArg;
    })();

    pb.LikeVideoCommentsReply = (function() {

        /**
         * Properties of a LikeVideoCommentsReply.
         * @memberof pb
         * @interface ILikeVideoCommentsReply
         * @property {number|null} [CurLike] LikeVideoCommentsReply CurLike
         */

        /**
         * Constructs a new LikeVideoCommentsReply.
         * @memberof pb
         * @classdesc Represents a LikeVideoCommentsReply.
         * @implements ILikeVideoCommentsReply
         * @constructor
         * @param {pb.ILikeVideoCommentsReply=} [properties] Properties to set
         */
        function LikeVideoCommentsReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LikeVideoCommentsReply CurLike.
         * @member {number} CurLike
         * @memberof pb.LikeVideoCommentsReply
         * @instance
         */
        LikeVideoCommentsReply.prototype.CurLike = 0;

        /**
         * Creates a new LikeVideoCommentsReply instance using the specified properties.
         * @function create
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {pb.ILikeVideoCommentsReply=} [properties] Properties to set
         * @returns {pb.LikeVideoCommentsReply} LikeVideoCommentsReply instance
         */
        LikeVideoCommentsReply.create = function create(properties) {
            return new LikeVideoCommentsReply(properties);
        };

        /**
         * Encodes the specified LikeVideoCommentsReply message. Does not implicitly {@link pb.LikeVideoCommentsReply.verify|verify} messages.
         * @function encode
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {pb.ILikeVideoCommentsReply} message LikeVideoCommentsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoCommentsReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CurLike);
            return writer;
        };

        /**
         * Encodes the specified LikeVideoCommentsReply message, length delimited. Does not implicitly {@link pb.LikeVideoCommentsReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {pb.ILikeVideoCommentsReply} message LikeVideoCommentsReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LikeVideoCommentsReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LikeVideoCommentsReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.LikeVideoCommentsReply} LikeVideoCommentsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoCommentsReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.LikeVideoCommentsReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CurLike = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LikeVideoCommentsReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.LikeVideoCommentsReply} LikeVideoCommentsReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LikeVideoCommentsReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LikeVideoCommentsReply message.
         * @function verify
         * @memberof pb.LikeVideoCommentsReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LikeVideoCommentsReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CurLike != null && message.hasOwnProperty("CurLike"))
                if (!$util.isInteger(message.CurLike))
                    return "CurLike: integer expected";
            return null;
        };

        return LikeVideoCommentsReply;
    })();

    pb.CommentsVideoArg = (function() {

        /**
         * Properties of a CommentsVideoArg.
         * @memberof pb
         * @interface ICommentsVideoArg
         * @property {number|Long|null} [VideoID] CommentsVideoArg VideoID
         * @property {string|null} [Content] CommentsVideoArg Content
         */

        /**
         * Constructs a new CommentsVideoArg.
         * @memberof pb
         * @classdesc Represents a CommentsVideoArg.
         * @implements ICommentsVideoArg
         * @constructor
         * @param {pb.ICommentsVideoArg=} [properties] Properties to set
         */
        function CommentsVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommentsVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.CommentsVideoArg
         * @instance
         */
        CommentsVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * CommentsVideoArg Content.
         * @member {string} Content
         * @memberof pb.CommentsVideoArg
         * @instance
         */
        CommentsVideoArg.prototype.Content = "";

        /**
         * Creates a new CommentsVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {pb.ICommentsVideoArg=} [properties] Properties to set
         * @returns {pb.CommentsVideoArg} CommentsVideoArg instance
         */
        CommentsVideoArg.create = function create(properties) {
            return new CommentsVideoArg(properties);
        };

        /**
         * Encodes the specified CommentsVideoArg message. Does not implicitly {@link pb.CommentsVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {pb.ICommentsVideoArg} message CommentsVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommentsVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Content);
            return writer;
        };

        /**
         * Encodes the specified CommentsVideoArg message, length delimited. Does not implicitly {@link pb.CommentsVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {pb.ICommentsVideoArg} message CommentsVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommentsVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommentsVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CommentsVideoArg} CommentsVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentsVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CommentsVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.Content = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommentsVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CommentsVideoArg} CommentsVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentsVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommentsVideoArg message.
         * @function verify
         * @memberof pb.CommentsVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommentsVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            return null;
        };

        return CommentsVideoArg;
    })();

    pb.CommentsVideoReply = (function() {

        /**
         * Properties of a CommentsVideoReply.
         * @memberof pb
         * @interface ICommentsVideoReply
         * @property {number|null} [CommentsID] CommentsVideoReply CommentsID
         * @property {number|null} [Time] CommentsVideoReply Time
         */

        /**
         * Constructs a new CommentsVideoReply.
         * @memberof pb
         * @classdesc Represents a CommentsVideoReply.
         * @implements ICommentsVideoReply
         * @constructor
         * @param {pb.ICommentsVideoReply=} [properties] Properties to set
         */
        function CommentsVideoReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CommentsVideoReply CommentsID.
         * @member {number} CommentsID
         * @memberof pb.CommentsVideoReply
         * @instance
         */
        CommentsVideoReply.prototype.CommentsID = 0;

        /**
         * CommentsVideoReply Time.
         * @member {number} Time
         * @memberof pb.CommentsVideoReply
         * @instance
         */
        CommentsVideoReply.prototype.Time = 0;

        /**
         * Creates a new CommentsVideoReply instance using the specified properties.
         * @function create
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {pb.ICommentsVideoReply=} [properties] Properties to set
         * @returns {pb.CommentsVideoReply} CommentsVideoReply instance
         */
        CommentsVideoReply.create = function create(properties) {
            return new CommentsVideoReply(properties);
        };

        /**
         * Encodes the specified CommentsVideoReply message. Does not implicitly {@link pb.CommentsVideoReply.verify|verify} messages.
         * @function encode
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {pb.ICommentsVideoReply} message CommentsVideoReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommentsVideoReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.CommentsID != null && message.hasOwnProperty("CommentsID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.CommentsID);
            if (message.Time != null && message.hasOwnProperty("Time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Time);
            return writer;
        };

        /**
         * Encodes the specified CommentsVideoReply message, length delimited. Does not implicitly {@link pb.CommentsVideoReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {pb.ICommentsVideoReply} message CommentsVideoReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CommentsVideoReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CommentsVideoReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CommentsVideoReply} CommentsVideoReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentsVideoReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CommentsVideoReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.CommentsID = reader.int32();
                    break;
                case 2:
                    message.Time = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CommentsVideoReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CommentsVideoReply} CommentsVideoReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CommentsVideoReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CommentsVideoReply message.
         * @function verify
         * @memberof pb.CommentsVideoReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CommentsVideoReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.CommentsID != null && message.hasOwnProperty("CommentsID"))
                if (!$util.isInteger(message.CommentsID))
                    return "CommentsID: integer expected";
            if (message.Time != null && message.hasOwnProperty("Time"))
                if (!$util.isInteger(message.Time))
                    return "Time: integer expected";
            return null;
        };

        return CommentsVideoReply;
    })();

    pb.GCommentsVideoArg = (function() {

        /**
         * Properties of a GCommentsVideoArg.
         * @memberof pb
         * @interface IGCommentsVideoArg
         * @property {number|Long|null} [VideoID] GCommentsVideoArg VideoID
         * @property {string|null} [Content] GCommentsVideoArg Content
         * @property {string|null} [Name] GCommentsVideoArg Name
         * @property {string|null} [HeadImgUrl] GCommentsVideoArg HeadImgUrl
         * @property {string|null} [Country] GCommentsVideoArg Country
         * @property {number|Long|null} [Uid] GCommentsVideoArg Uid
         * @property {string|null} [HeadFrame] GCommentsVideoArg HeadFrame
         */

        /**
         * Constructs a new GCommentsVideoArg.
         * @memberof pb
         * @classdesc Represents a GCommentsVideoArg.
         * @implements IGCommentsVideoArg
         * @constructor
         * @param {pb.IGCommentsVideoArg=} [properties] Properties to set
         */
        function GCommentsVideoArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GCommentsVideoArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GCommentsVideoArg Content.
         * @member {string} Content
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.Content = "";

        /**
         * GCommentsVideoArg Name.
         * @member {string} Name
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.Name = "";

        /**
         * GCommentsVideoArg HeadImgUrl.
         * @member {string} HeadImgUrl
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.HeadImgUrl = "";

        /**
         * GCommentsVideoArg Country.
         * @member {string} Country
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.Country = "";

        /**
         * GCommentsVideoArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * GCommentsVideoArg HeadFrame.
         * @member {string} HeadFrame
         * @memberof pb.GCommentsVideoArg
         * @instance
         */
        GCommentsVideoArg.prototype.HeadFrame = "";

        /**
         * Creates a new GCommentsVideoArg instance using the specified properties.
         * @function create
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {pb.IGCommentsVideoArg=} [properties] Properties to set
         * @returns {pb.GCommentsVideoArg} GCommentsVideoArg instance
         */
        GCommentsVideoArg.create = function create(properties) {
            return new GCommentsVideoArg(properties);
        };

        /**
         * Encodes the specified GCommentsVideoArg message. Does not implicitly {@link pb.GCommentsVideoArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {pb.IGCommentsVideoArg} message GCommentsVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCommentsVideoArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            if (message.Content != null && message.hasOwnProperty("Content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.Content);
            if (message.Name != null && message.hasOwnProperty("Name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.Name);
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.HeadImgUrl);
            if (message.Country != null && message.hasOwnProperty("Country"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.Country);
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.Uid);
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.HeadFrame);
            return writer;
        };

        /**
         * Encodes the specified GCommentsVideoArg message, length delimited. Does not implicitly {@link pb.GCommentsVideoArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {pb.IGCommentsVideoArg} message GCommentsVideoArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GCommentsVideoArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GCommentsVideoArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GCommentsVideoArg} GCommentsVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCommentsVideoArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GCommentsVideoArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                case 2:
                    message.Content = reader.string();
                    break;
                case 3:
                    message.Name = reader.string();
                    break;
                case 4:
                    message.HeadImgUrl = reader.string();
                    break;
                case 5:
                    message.Country = reader.string();
                    break;
                case 6:
                    message.Uid = reader.uint64();
                    break;
                case 7:
                    message.HeadFrame = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GCommentsVideoArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GCommentsVideoArg} GCommentsVideoArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GCommentsVideoArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GCommentsVideoArg message.
         * @function verify
         * @memberof pb.GCommentsVideoArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GCommentsVideoArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            if (message.Content != null && message.hasOwnProperty("Content"))
                if (!$util.isString(message.Content))
                    return "Content: string expected";
            if (message.Name != null && message.hasOwnProperty("Name"))
                if (!$util.isString(message.Name))
                    return "Name: string expected";
            if (message.HeadImgUrl != null && message.hasOwnProperty("HeadImgUrl"))
                if (!$util.isString(message.HeadImgUrl))
                    return "HeadImgUrl: string expected";
            if (message.Country != null && message.hasOwnProperty("Country"))
                if (!$util.isString(message.Country))
                    return "Country: string expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            if (message.HeadFrame != null && message.hasOwnProperty("HeadFrame"))
                if (!$util.isString(message.HeadFrame))
                    return "HeadFrame: string expected";
            return null;
        };

        return GCommentsVideoArg;
    })();

    pb.FetchVideoItemArg = (function() {

        /**
         * Properties of a FetchVideoItemArg.
         * @memberof pb
         * @interface IFetchVideoItemArg
         * @property {number|Long|null} [VideoID] FetchVideoItemArg VideoID
         */

        /**
         * Constructs a new FetchVideoItemArg.
         * @memberof pb
         * @classdesc Represents a FetchVideoItemArg.
         * @implements IFetchVideoItemArg
         * @constructor
         * @param {pb.IFetchVideoItemArg=} [properties] Properties to set
         */
        function FetchVideoItemArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FetchVideoItemArg VideoID.
         * @member {number|Long} VideoID
         * @memberof pb.FetchVideoItemArg
         * @instance
         */
        FetchVideoItemArg.prototype.VideoID = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new FetchVideoItemArg instance using the specified properties.
         * @function create
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {pb.IFetchVideoItemArg=} [properties] Properties to set
         * @returns {pb.FetchVideoItemArg} FetchVideoItemArg instance
         */
        FetchVideoItemArg.create = function create(properties) {
            return new FetchVideoItemArg(properties);
        };

        /**
         * Encodes the specified FetchVideoItemArg message. Does not implicitly {@link pb.FetchVideoItemArg.verify|verify} messages.
         * @function encode
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {pb.IFetchVideoItemArg} message FetchVideoItemArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoItemArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.VideoID);
            return writer;
        };

        /**
         * Encodes the specified FetchVideoItemArg message, length delimited. Does not implicitly {@link pb.FetchVideoItemArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {pb.IFetchVideoItemArg} message FetchVideoItemArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FetchVideoItemArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FetchVideoItemArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.FetchVideoItemArg} FetchVideoItemArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoItemArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.FetchVideoItemArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.VideoID = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FetchVideoItemArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.FetchVideoItemArg} FetchVideoItemArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FetchVideoItemArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FetchVideoItemArg message.
         * @function verify
         * @memberof pb.FetchVideoItemArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FetchVideoItemArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.VideoID != null && message.hasOwnProperty("VideoID"))
                if (!$util.isInteger(message.VideoID) && !(message.VideoID && $util.isInteger(message.VideoID.low) && $util.isInteger(message.VideoID.high)))
                    return "VideoID: integer|Long expected";
            return null;
        };

        return FetchVideoItemArg;
    })();

    pb.ReplyWxInviteBattleArg = (function() {

        /**
         * Properties of a ReplyWxInviteBattleArg.
         * @memberof pb
         * @interface IReplyWxInviteBattleArg
         * @property {number|Long|null} [Uid] ReplyWxInviteBattleArg Uid
         */

        /**
         * Constructs a new ReplyWxInviteBattleArg.
         * @memberof pb
         * @classdesc Represents a ReplyWxInviteBattleArg.
         * @implements IReplyWxInviteBattleArg
         * @constructor
         * @param {pb.IReplyWxInviteBattleArg=} [properties] Properties to set
         */
        function ReplyWxInviteBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReplyWxInviteBattleArg Uid.
         * @member {number|Long} Uid
         * @memberof pb.ReplyWxInviteBattleArg
         * @instance
         */
        ReplyWxInviteBattleArg.prototype.Uid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new ReplyWxInviteBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {pb.IReplyWxInviteBattleArg=} [properties] Properties to set
         * @returns {pb.ReplyWxInviteBattleArg} ReplyWxInviteBattleArg instance
         */
        ReplyWxInviteBattleArg.create = function create(properties) {
            return new ReplyWxInviteBattleArg(properties);
        };

        /**
         * Encodes the specified ReplyWxInviteBattleArg message. Does not implicitly {@link pb.ReplyWxInviteBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {pb.IReplyWxInviteBattleArg} message ReplyWxInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyWxInviteBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.Uid);
            return writer;
        };

        /**
         * Encodes the specified ReplyWxInviteBattleArg message, length delimited. Does not implicitly {@link pb.ReplyWxInviteBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {pb.IReplyWxInviteBattleArg} message ReplyWxInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReplyWxInviteBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReplyWxInviteBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ReplyWxInviteBattleArg} ReplyWxInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyWxInviteBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ReplyWxInviteBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Uid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReplyWxInviteBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ReplyWxInviteBattleArg} ReplyWxInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReplyWxInviteBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReplyWxInviteBattleArg message.
         * @function verify
         * @memberof pb.ReplyWxInviteBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReplyWxInviteBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Uid != null && message.hasOwnProperty("Uid"))
                if (!$util.isInteger(message.Uid) && !(message.Uid && $util.isInteger(message.Uid.low) && $util.isInteger(message.Uid.high)))
                    return "Uid: integer|Long expected";
            return null;
        };

        return ReplyWxInviteBattleArg;
    })();

    pb.WxInviteBattleResult = (function() {

        /**
         * Properties of a WxInviteBattleResult.
         * @memberof pb
         * @interface IWxInviteBattleResult
         * @property {pb.WxInviteBattleResult.WxInviteResult|null} [Result] WxInviteBattleResult Result
         */

        /**
         * Constructs a new WxInviteBattleResult.
         * @memberof pb
         * @classdesc Represents a WxInviteBattleResult.
         * @implements IWxInviteBattleResult
         * @constructor
         * @param {pb.IWxInviteBattleResult=} [properties] Properties to set
         */
        function WxInviteBattleResult(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxInviteBattleResult Result.
         * @member {pb.WxInviteBattleResult.WxInviteResult} Result
         * @memberof pb.WxInviteBattleResult
         * @instance
         */
        WxInviteBattleResult.prototype.Result = 0;

        /**
         * Creates a new WxInviteBattleResult instance using the specified properties.
         * @function create
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {pb.IWxInviteBattleResult=} [properties] Properties to set
         * @returns {pb.WxInviteBattleResult} WxInviteBattleResult instance
         */
        WxInviteBattleResult.create = function create(properties) {
            return new WxInviteBattleResult(properties);
        };

        /**
         * Encodes the specified WxInviteBattleResult message. Does not implicitly {@link pb.WxInviteBattleResult.verify|verify} messages.
         * @function encode
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {pb.IWxInviteBattleResult} message WxInviteBattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteBattleResult.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Result != null && message.hasOwnProperty("Result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Result);
            return writer;
        };

        /**
         * Encodes the specified WxInviteBattleResult message, length delimited. Does not implicitly {@link pb.WxInviteBattleResult.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {pb.IWxInviteBattleResult} message WxInviteBattleResult message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxInviteBattleResult.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxInviteBattleResult message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxInviteBattleResult} WxInviteBattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteBattleResult.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxInviteBattleResult();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Result = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxInviteBattleResult message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxInviteBattleResult} WxInviteBattleResult
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxInviteBattleResult.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxInviteBattleResult message.
         * @function verify
         * @memberof pb.WxInviteBattleResult
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxInviteBattleResult.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Result != null && message.hasOwnProperty("Result"))
                switch (message.Result) {
                default:
                    return "Result: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * WxInviteResult enum.
         * @name pb.WxInviteBattleResult.WxInviteResult
         * @enum {string}
         * @property {number} OK=0 OK value
         * @property {number} Timeout=1 Timeout value
         */
        WxInviteBattleResult.WxInviteResult = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "OK"] = 0;
            values[valuesById[1] = "Timeout"] = 1;
            return values;
        })();

        return WxInviteBattleResult;
    })();

    pb.GetShareTreasureArg = (function() {

        /**
         * Properties of a GetShareTreasureArg.
         * @memberof pb
         * @interface IGetShareTreasureArg
         * @property {number|null} [Hid] GetShareTreasureArg Hid
         */

        /**
         * Constructs a new GetShareTreasureArg.
         * @memberof pb
         * @classdesc Represents a GetShareTreasureArg.
         * @implements IGetShareTreasureArg
         * @constructor
         * @param {pb.IGetShareTreasureArg=} [properties] Properties to set
         */
        function GetShareTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetShareTreasureArg Hid.
         * @member {number} Hid
         * @memberof pb.GetShareTreasureArg
         * @instance
         */
        GetShareTreasureArg.prototype.Hid = 0;

        /**
         * Creates a new GetShareTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {pb.IGetShareTreasureArg=} [properties] Properties to set
         * @returns {pb.GetShareTreasureArg} GetShareTreasureArg instance
         */
        GetShareTreasureArg.create = function create(properties) {
            return new GetShareTreasureArg(properties);
        };

        /**
         * Encodes the specified GetShareTreasureArg message. Does not implicitly {@link pb.GetShareTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {pb.IGetShareTreasureArg} message GetShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShareTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Hid != null && message.hasOwnProperty("Hid"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Hid);
            return writer;
        };

        /**
         * Encodes the specified GetShareTreasureArg message, length delimited. Does not implicitly {@link pb.GetShareTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {pb.IGetShareTreasureArg} message GetShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetShareTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetShareTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.GetShareTreasureArg} GetShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShareTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.GetShareTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Hid = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetShareTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.GetShareTreasureArg} GetShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetShareTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetShareTreasureArg message.
         * @function verify
         * @memberof pb.GetShareTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetShareTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Hid != null && message.hasOwnProperty("Hid"))
                if (!$util.isInteger(message.Hid))
                    return "Hid: integer expected";
            return null;
        };

        return GetShareTreasureArg;
    })();

    pb.ShareTreasureArg = (function() {

        /**
         * Properties of a ShareTreasureArg.
         * @memberof pb
         * @interface IShareTreasureArg
         * @property {number|null} [TreasureID] ShareTreasureArg TreasureID
         * @property {string|null} [WxGroupID] ShareTreasureArg WxGroupID
         */

        /**
         * Constructs a new ShareTreasureArg.
         * @memberof pb
         * @classdesc Represents a ShareTreasureArg.
         * @implements IShareTreasureArg
         * @constructor
         * @param {pb.IShareTreasureArg=} [properties] Properties to set
         */
        function ShareTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareTreasureArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.ShareTreasureArg
         * @instance
         */
        ShareTreasureArg.prototype.TreasureID = 0;

        /**
         * ShareTreasureArg WxGroupID.
         * @member {string} WxGroupID
         * @memberof pb.ShareTreasureArg
         * @instance
         */
        ShareTreasureArg.prototype.WxGroupID = "";

        /**
         * Creates a new ShareTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {pb.IShareTreasureArg=} [properties] Properties to set
         * @returns {pb.ShareTreasureArg} ShareTreasureArg instance
         */
        ShareTreasureArg.create = function create(properties) {
            return new ShareTreasureArg(properties);
        };

        /**
         * Encodes the specified ShareTreasureArg message. Does not implicitly {@link pb.ShareTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {pb.IShareTreasureArg} message ShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.WxGroupID);
            return writer;
        };

        /**
         * Encodes the specified ShareTreasureArg message, length delimited. Does not implicitly {@link pb.ShareTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {pb.IShareTreasureArg} message ShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ShareTreasureArg} ShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                case 2:
                    message.WxGroupID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShareTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ShareTreasureArg} ShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareTreasureArg message.
         * @function verify
         * @memberof pb.ShareTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                if (!$util.isString(message.WxGroupID))
                    return "WxGroupID: string expected";
            return null;
        };

        return ShareTreasureArg;
    })();

    pb.HelpShareTreasureArg = (function() {

        /**
         * Properties of a HelpShareTreasureArg.
         * @memberof pb
         * @interface IHelpShareTreasureArg
         * @property {number|Long|null} [ShareUid] HelpShareTreasureArg ShareUid
         * @property {number|null} [TreasureID] HelpShareTreasureArg TreasureID
         */

        /**
         * Constructs a new HelpShareTreasureArg.
         * @memberof pb
         * @classdesc Represents a HelpShareTreasureArg.
         * @implements IHelpShareTreasureArg
         * @constructor
         * @param {pb.IHelpShareTreasureArg=} [properties] Properties to set
         */
        function HelpShareTreasureArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelpShareTreasureArg ShareUid.
         * @member {number|Long} ShareUid
         * @memberof pb.HelpShareTreasureArg
         * @instance
         */
        HelpShareTreasureArg.prototype.ShareUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * HelpShareTreasureArg TreasureID.
         * @member {number} TreasureID
         * @memberof pb.HelpShareTreasureArg
         * @instance
         */
        HelpShareTreasureArg.prototype.TreasureID = 0;

        /**
         * Creates a new HelpShareTreasureArg instance using the specified properties.
         * @function create
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {pb.IHelpShareTreasureArg=} [properties] Properties to set
         * @returns {pb.HelpShareTreasureArg} HelpShareTreasureArg instance
         */
        HelpShareTreasureArg.create = function create(properties) {
            return new HelpShareTreasureArg(properties);
        };

        /**
         * Encodes the specified HelpShareTreasureArg message. Does not implicitly {@link pb.HelpShareTreasureArg.verify|verify} messages.
         * @function encode
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {pb.IHelpShareTreasureArg} message HelpShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpShareTreasureArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ShareUid);
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.TreasureID);
            return writer;
        };

        /**
         * Encodes the specified HelpShareTreasureArg message, length delimited. Does not implicitly {@link pb.HelpShareTreasureArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {pb.IHelpShareTreasureArg} message HelpShareTreasureArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpShareTreasureArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelpShareTreasureArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HelpShareTreasureArg} HelpShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpShareTreasureArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HelpShareTreasureArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareUid = reader.uint64();
                    break;
                case 2:
                    message.TreasureID = reader.uint32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelpShareTreasureArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HelpShareTreasureArg} HelpShareTreasureArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpShareTreasureArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelpShareTreasureArg message.
         * @function verify
         * @memberof pb.HelpShareTreasureArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelpShareTreasureArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                if (!$util.isInteger(message.ShareUid) && !(message.ShareUid && $util.isInteger(message.ShareUid.low) && $util.isInteger(message.ShareUid.high)))
                    return "ShareUid: integer|Long expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            return null;
        };

        return HelpShareTreasureArg;
    })();

    pb.TreasureBeHelp = (function() {

        /**
         * Properties of a TreasureBeHelp.
         * @memberof pb
         * @interface ITreasureBeHelp
         * @property {number|null} [TreasureID] TreasureBeHelp TreasureID
         * @property {number|null} [OpenTimeout] TreasureBeHelp OpenTimeout
         */

        /**
         * Constructs a new TreasureBeHelp.
         * @memberof pb
         * @classdesc Represents a TreasureBeHelp.
         * @implements ITreasureBeHelp
         * @constructor
         * @param {pb.ITreasureBeHelp=} [properties] Properties to set
         */
        function TreasureBeHelp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TreasureBeHelp TreasureID.
         * @member {number} TreasureID
         * @memberof pb.TreasureBeHelp
         * @instance
         */
        TreasureBeHelp.prototype.TreasureID = 0;

        /**
         * TreasureBeHelp OpenTimeout.
         * @member {number} OpenTimeout
         * @memberof pb.TreasureBeHelp
         * @instance
         */
        TreasureBeHelp.prototype.OpenTimeout = 0;

        /**
         * Creates a new TreasureBeHelp instance using the specified properties.
         * @function create
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {pb.ITreasureBeHelp=} [properties] Properties to set
         * @returns {pb.TreasureBeHelp} TreasureBeHelp instance
         */
        TreasureBeHelp.create = function create(properties) {
            return new TreasureBeHelp(properties);
        };

        /**
         * Encodes the specified TreasureBeHelp message. Does not implicitly {@link pb.TreasureBeHelp.verify|verify} messages.
         * @function encode
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {pb.ITreasureBeHelp} message TreasureBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureBeHelp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.TreasureID);
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.OpenTimeout);
            return writer;
        };

        /**
         * Encodes the specified TreasureBeHelp message, length delimited. Does not implicitly {@link pb.TreasureBeHelp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {pb.ITreasureBeHelp} message TreasureBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TreasureBeHelp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TreasureBeHelp message from the specified reader or buffer.
         * @function decode
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.TreasureBeHelp} TreasureBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureBeHelp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.TreasureBeHelp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.TreasureID = reader.uint32();
                    break;
                case 2:
                    message.OpenTimeout = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TreasureBeHelp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.TreasureBeHelp} TreasureBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TreasureBeHelp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TreasureBeHelp message.
         * @function verify
         * @memberof pb.TreasureBeHelp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TreasureBeHelp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.TreasureID != null && message.hasOwnProperty("TreasureID"))
                if (!$util.isInteger(message.TreasureID))
                    return "TreasureID: integer expected";
            if (message.OpenTimeout != null && message.hasOwnProperty("OpenTimeout"))
                if (!$util.isInteger(message.OpenTimeout))
                    return "OpenTimeout: integer expected";
            return null;
        };

        return TreasureBeHelp;
    })();

    pb.BattleLoseBeHelp = (function() {

        /**
         * Properties of a BattleLoseBeHelp.
         * @memberof pb
         * @interface IBattleLoseBeHelp
         * @property {number|null} [AddStar] BattleLoseBeHelp AddStar
         */

        /**
         * Constructs a new BattleLoseBeHelp.
         * @memberof pb
         * @classdesc Represents a BattleLoseBeHelp.
         * @implements IBattleLoseBeHelp
         * @constructor
         * @param {pb.IBattleLoseBeHelp=} [properties] Properties to set
         */
        function BattleLoseBeHelp(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleLoseBeHelp AddStar.
         * @member {number} AddStar
         * @memberof pb.BattleLoseBeHelp
         * @instance
         */
        BattleLoseBeHelp.prototype.AddStar = 0;

        /**
         * Creates a new BattleLoseBeHelp instance using the specified properties.
         * @function create
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {pb.IBattleLoseBeHelp=} [properties] Properties to set
         * @returns {pb.BattleLoseBeHelp} BattleLoseBeHelp instance
         */
        BattleLoseBeHelp.create = function create(properties) {
            return new BattleLoseBeHelp(properties);
        };

        /**
         * Encodes the specified BattleLoseBeHelp message. Does not implicitly {@link pb.BattleLoseBeHelp.verify|verify} messages.
         * @function encode
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {pb.IBattleLoseBeHelp} message BattleLoseBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleLoseBeHelp.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.AddStar != null && message.hasOwnProperty("AddStar"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.AddStar);
            return writer;
        };

        /**
         * Encodes the specified BattleLoseBeHelp message, length delimited. Does not implicitly {@link pb.BattleLoseBeHelp.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {pb.IBattleLoseBeHelp} message BattleLoseBeHelp message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleLoseBeHelp.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleLoseBeHelp message from the specified reader or buffer.
         * @function decode
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.BattleLoseBeHelp} BattleLoseBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleLoseBeHelp.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.BattleLoseBeHelp();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.AddStar = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleLoseBeHelp message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.BattleLoseBeHelp} BattleLoseBeHelp
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleLoseBeHelp.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleLoseBeHelp message.
         * @function verify
         * @memberof pb.BattleLoseBeHelp
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleLoseBeHelp.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.AddStar != null && message.hasOwnProperty("AddStar"))
                if (!$util.isInteger(message.AddStar))
                    return "AddStar: integer expected";
            return null;
        };

        return BattleLoseBeHelp;
    })();

    pb.ShareBattleLoseArg = (function() {

        /**
         * Properties of a ShareBattleLoseArg.
         * @memberof pb
         * @interface IShareBattleLoseArg
         * @property {string|null} [WxGroupID] ShareBattleLoseArg WxGroupID
         */

        /**
         * Constructs a new ShareBattleLoseArg.
         * @memberof pb
         * @classdesc Represents a ShareBattleLoseArg.
         * @implements IShareBattleLoseArg
         * @constructor
         * @param {pb.IShareBattleLoseArg=} [properties] Properties to set
         */
        function ShareBattleLoseArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ShareBattleLoseArg WxGroupID.
         * @member {string} WxGroupID
         * @memberof pb.ShareBattleLoseArg
         * @instance
         */
        ShareBattleLoseArg.prototype.WxGroupID = "";

        /**
         * Creates a new ShareBattleLoseArg instance using the specified properties.
         * @function create
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {pb.IShareBattleLoseArg=} [properties] Properties to set
         * @returns {pb.ShareBattleLoseArg} ShareBattleLoseArg instance
         */
        ShareBattleLoseArg.create = function create(properties) {
            return new ShareBattleLoseArg(properties);
        };

        /**
         * Encodes the specified ShareBattleLoseArg message. Does not implicitly {@link pb.ShareBattleLoseArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {pb.IShareBattleLoseArg} message ShareBattleLoseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareBattleLoseArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.WxGroupID);
            return writer;
        };

        /**
         * Encodes the specified ShareBattleLoseArg message, length delimited. Does not implicitly {@link pb.ShareBattleLoseArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {pb.IShareBattleLoseArg} message ShareBattleLoseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ShareBattleLoseArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ShareBattleLoseArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ShareBattleLoseArg} ShareBattleLoseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareBattleLoseArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ShareBattleLoseArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.WxGroupID = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ShareBattleLoseArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ShareBattleLoseArg} ShareBattleLoseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ShareBattleLoseArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ShareBattleLoseArg message.
         * @function verify
         * @memberof pb.ShareBattleLoseArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ShareBattleLoseArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                if (!$util.isString(message.WxGroupID))
                    return "WxGroupID: string expected";
            return null;
        };

        return ShareBattleLoseArg;
    })();

    pb.WxExamineState = (function() {

        /**
         * Properties of a WxExamineState.
         * @memberof pb
         * @interface IWxExamineState
         * @property {boolean|null} [IsExamined] WxExamineState IsExamined
         */

        /**
         * Constructs a new WxExamineState.
         * @memberof pb
         * @classdesc Represents a WxExamineState.
         * @implements IWxExamineState
         * @constructor
         * @param {pb.IWxExamineState=} [properties] Properties to set
         */
        function WxExamineState(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxExamineState IsExamined.
         * @member {boolean} IsExamined
         * @memberof pb.WxExamineState
         * @instance
         */
        WxExamineState.prototype.IsExamined = false;

        /**
         * Creates a new WxExamineState instance using the specified properties.
         * @function create
         * @memberof pb.WxExamineState
         * @static
         * @param {pb.IWxExamineState=} [properties] Properties to set
         * @returns {pb.WxExamineState} WxExamineState instance
         */
        WxExamineState.create = function create(properties) {
            return new WxExamineState(properties);
        };

        /**
         * Encodes the specified WxExamineState message. Does not implicitly {@link pb.WxExamineState.verify|verify} messages.
         * @function encode
         * @memberof pb.WxExamineState
         * @static
         * @param {pb.IWxExamineState} message WxExamineState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxExamineState.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.IsExamined != null && message.hasOwnProperty("IsExamined"))
                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.IsExamined);
            return writer;
        };

        /**
         * Encodes the specified WxExamineState message, length delimited. Does not implicitly {@link pb.WxExamineState.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxExamineState
         * @static
         * @param {pb.IWxExamineState} message WxExamineState message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxExamineState.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxExamineState message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxExamineState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxExamineState} WxExamineState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxExamineState.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxExamineState();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10:
                    message.IsExamined = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxExamineState message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxExamineState
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxExamineState} WxExamineState
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxExamineState.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxExamineState message.
         * @function verify
         * @memberof pb.WxExamineState
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxExamineState.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.IsExamined != null && message.hasOwnProperty("IsExamined"))
                if (typeof message.IsExamined !== "boolean")
                    return "IsExamined: boolean expected";
            return null;
        };

        return WxExamineState;
    })();

    pb.HelpShareBattleLoseArg = (function() {

        /**
         * Properties of a HelpShareBattleLoseArg.
         * @memberof pb
         * @interface IHelpShareBattleLoseArg
         * @property {number|Long|null} [ShareUid] HelpShareBattleLoseArg ShareUid
         */

        /**
         * Constructs a new HelpShareBattleLoseArg.
         * @memberof pb
         * @classdesc Represents a HelpShareBattleLoseArg.
         * @implements IHelpShareBattleLoseArg
         * @constructor
         * @param {pb.IHelpShareBattleLoseArg=} [properties] Properties to set
         */
        function HelpShareBattleLoseArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HelpShareBattleLoseArg ShareUid.
         * @member {number|Long} ShareUid
         * @memberof pb.HelpShareBattleLoseArg
         * @instance
         */
        HelpShareBattleLoseArg.prototype.ShareUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * Creates a new HelpShareBattleLoseArg instance using the specified properties.
         * @function create
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {pb.IHelpShareBattleLoseArg=} [properties] Properties to set
         * @returns {pb.HelpShareBattleLoseArg} HelpShareBattleLoseArg instance
         */
        HelpShareBattleLoseArg.create = function create(properties) {
            return new HelpShareBattleLoseArg(properties);
        };

        /**
         * Encodes the specified HelpShareBattleLoseArg message. Does not implicitly {@link pb.HelpShareBattleLoseArg.verify|verify} messages.
         * @function encode
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {pb.IHelpShareBattleLoseArg} message HelpShareBattleLoseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpShareBattleLoseArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.ShareUid);
            return writer;
        };

        /**
         * Encodes the specified HelpShareBattleLoseArg message, length delimited. Does not implicitly {@link pb.HelpShareBattleLoseArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {pb.IHelpShareBattleLoseArg} message HelpShareBattleLoseArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HelpShareBattleLoseArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HelpShareBattleLoseArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.HelpShareBattleLoseArg} HelpShareBattleLoseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpShareBattleLoseArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.HelpShareBattleLoseArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareUid = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HelpShareBattleLoseArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.HelpShareBattleLoseArg} HelpShareBattleLoseArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HelpShareBattleLoseArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HelpShareBattleLoseArg message.
         * @function verify
         * @memberof pb.HelpShareBattleLoseArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HelpShareBattleLoseArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                if (!$util.isInteger(message.ShareUid) && !(message.ShareUid && $util.isInteger(message.ShareUid.low) && $util.isInteger(message.ShareUid.high)))
                    return "ShareUid: integer|Long expected";
            return null;
        };

        return HelpShareBattleLoseArg;
    })();

    pb.WxgameShareArg = (function() {

        /**
         * Properties of a WxgameShareArg.
         * @memberof pb
         * @interface IWxgameShareArg
         * @property {number|null} [ShareID] WxgameShareArg ShareID
         * @property {number|null} [ShareType] WxgameShareArg ShareType
         * @property {string|null} [WxGroupID] WxgameShareArg WxGroupID
         * @property {Uint8Array|null} [Data] WxgameShareArg Data
         */

        /**
         * Constructs a new WxgameShareArg.
         * @memberof pb
         * @classdesc Represents a WxgameShareArg.
         * @implements IWxgameShareArg
         * @constructor
         * @param {pb.IWxgameShareArg=} [properties] Properties to set
         */
        function WxgameShareArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxgameShareArg ShareID.
         * @member {number} ShareID
         * @memberof pb.WxgameShareArg
         * @instance
         */
        WxgameShareArg.prototype.ShareID = 0;

        /**
         * WxgameShareArg ShareType.
         * @member {number} ShareType
         * @memberof pb.WxgameShareArg
         * @instance
         */
        WxgameShareArg.prototype.ShareType = 0;

        /**
         * WxgameShareArg WxGroupID.
         * @member {string} WxGroupID
         * @memberof pb.WxgameShareArg
         * @instance
         */
        WxgameShareArg.prototype.WxGroupID = "";

        /**
         * WxgameShareArg Data.
         * @member {Uint8Array} Data
         * @memberof pb.WxgameShareArg
         * @instance
         */
        WxgameShareArg.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new WxgameShareArg instance using the specified properties.
         * @function create
         * @memberof pb.WxgameShareArg
         * @static
         * @param {pb.IWxgameShareArg=} [properties] Properties to set
         * @returns {pb.WxgameShareArg} WxgameShareArg instance
         */
        WxgameShareArg.create = function create(properties) {
            return new WxgameShareArg(properties);
        };

        /**
         * Encodes the specified WxgameShareArg message. Does not implicitly {@link pb.WxgameShareArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WxgameShareArg
         * @static
         * @param {pb.IWxgameShareArg} message WxgameShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxgameShareArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareID);
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ShareType);
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.WxGroupID);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified WxgameShareArg message, length delimited. Does not implicitly {@link pb.WxgameShareArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxgameShareArg
         * @static
         * @param {pb.IWxgameShareArg} message WxgameShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxgameShareArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxgameShareArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxgameShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxgameShareArg} WxgameShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxgameShareArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxgameShareArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareID = reader.int32();
                    break;
                case 2:
                    message.ShareType = reader.int32();
                    break;
                case 3:
                    message.WxGroupID = reader.string();
                    break;
                case 4:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxgameShareArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxgameShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxgameShareArg} WxgameShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxgameShareArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxgameShareArg message.
         * @function verify
         * @memberof pb.WxgameShareArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxgameShareArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                if (!$util.isInteger(message.ShareID))
                    return "ShareID: integer expected";
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                if (!$util.isInteger(message.ShareType))
                    return "ShareType: integer expected";
            if (message.WxGroupID != null && message.hasOwnProperty("WxGroupID"))
                if (!$util.isString(message.WxGroupID))
                    return "WxGroupID: string expected";
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        return WxgameShareArg;
    })();

    pb.ClickWxgameShareArg = (function() {

        /**
         * Properties of a ClickWxgameShareArg.
         * @memberof pb
         * @interface IClickWxgameShareArg
         * @property {number|null} [ShareID] ClickWxgameShareArg ShareID
         * @property {number|Long|null} [ShareUid] ClickWxgameShareArg ShareUid
         * @property {number|null} [ShareType] ClickWxgameShareArg ShareType
         * @property {Uint8Array|null} [Data] ClickWxgameShareArg Data
         */

        /**
         * Constructs a new ClickWxgameShareArg.
         * @memberof pb
         * @classdesc Represents a ClickWxgameShareArg.
         * @implements IClickWxgameShareArg
         * @constructor
         * @param {pb.IClickWxgameShareArg=} [properties] Properties to set
         */
        function ClickWxgameShareArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClickWxgameShareArg ShareID.
         * @member {number} ShareID
         * @memberof pb.ClickWxgameShareArg
         * @instance
         */
        ClickWxgameShareArg.prototype.ShareID = 0;

        /**
         * ClickWxgameShareArg ShareUid.
         * @member {number|Long} ShareUid
         * @memberof pb.ClickWxgameShareArg
         * @instance
         */
        ClickWxgameShareArg.prototype.ShareUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * ClickWxgameShareArg ShareType.
         * @member {number} ShareType
         * @memberof pb.ClickWxgameShareArg
         * @instance
         */
        ClickWxgameShareArg.prototype.ShareType = 0;

        /**
         * ClickWxgameShareArg Data.
         * @member {Uint8Array} Data
         * @memberof pb.ClickWxgameShareArg
         * @instance
         */
        ClickWxgameShareArg.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new ClickWxgameShareArg instance using the specified properties.
         * @function create
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {pb.IClickWxgameShareArg=} [properties] Properties to set
         * @returns {pb.ClickWxgameShareArg} ClickWxgameShareArg instance
         */
        ClickWxgameShareArg.create = function create(properties) {
            return new ClickWxgameShareArg(properties);
        };

        /**
         * Encodes the specified ClickWxgameShareArg message. Does not implicitly {@link pb.ClickWxgameShareArg.verify|verify} messages.
         * @function encode
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {pb.IClickWxgameShareArg} message ClickWxgameShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClickWxgameShareArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareID);
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.ShareUid);
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ShareType);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified ClickWxgameShareArg message, length delimited. Does not implicitly {@link pb.ClickWxgameShareArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {pb.IClickWxgameShareArg} message ClickWxgameShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClickWxgameShareArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClickWxgameShareArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.ClickWxgameShareArg} ClickWxgameShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClickWxgameShareArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.ClickWxgameShareArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareID = reader.int32();
                    break;
                case 2:
                    message.ShareUid = reader.uint64();
                    break;
                case 3:
                    message.ShareType = reader.int32();
                    break;
                case 4:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClickWxgameShareArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.ClickWxgameShareArg} ClickWxgameShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClickWxgameShareArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClickWxgameShareArg message.
         * @function verify
         * @memberof pb.ClickWxgameShareArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClickWxgameShareArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                if (!$util.isInteger(message.ShareID))
                    return "ShareID: integer expected";
            if (message.ShareUid != null && message.hasOwnProperty("ShareUid"))
                if (!$util.isInteger(message.ShareUid) && !(message.ShareUid && $util.isInteger(message.ShareUid.low) && $util.isInteger(message.ShareUid.high)))
                    return "ShareUid: integer|Long expected";
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                if (!$util.isInteger(message.ShareType))
                    return "ShareType: integer expected";
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        return ClickWxgameShareArg;
    })();

    pb.WxShareAddJadeArg = (function() {

        /**
         * Properties of a WxShareAddJadeArg.
         * @memberof pb
         * @interface IWxShareAddJadeArg
         * @property {number|null} [ShareTime] WxShareAddJadeArg ShareTime
         * @property {string|null} [PlayerName] WxShareAddJadeArg PlayerName
         */

        /**
         * Constructs a new WxShareAddJadeArg.
         * @memberof pb
         * @classdesc Represents a WxShareAddJadeArg.
         * @implements IWxShareAddJadeArg
         * @constructor
         * @param {pb.IWxShareAddJadeArg=} [properties] Properties to set
         */
        function WxShareAddJadeArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxShareAddJadeArg ShareTime.
         * @member {number} ShareTime
         * @memberof pb.WxShareAddJadeArg
         * @instance
         */
        WxShareAddJadeArg.prototype.ShareTime = 0;

        /**
         * WxShareAddJadeArg PlayerName.
         * @member {string} PlayerName
         * @memberof pb.WxShareAddJadeArg
         * @instance
         */
        WxShareAddJadeArg.prototype.PlayerName = "";

        /**
         * Creates a new WxShareAddJadeArg instance using the specified properties.
         * @function create
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {pb.IWxShareAddJadeArg=} [properties] Properties to set
         * @returns {pb.WxShareAddJadeArg} WxShareAddJadeArg instance
         */
        WxShareAddJadeArg.create = function create(properties) {
            return new WxShareAddJadeArg(properties);
        };

        /**
         * Encodes the specified WxShareAddJadeArg message. Does not implicitly {@link pb.WxShareAddJadeArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {pb.IWxShareAddJadeArg} message WxShareAddJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareAddJadeArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareTime != null && message.hasOwnProperty("ShareTime"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareTime);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified WxShareAddJadeArg message, length delimited. Does not implicitly {@link pb.WxShareAddJadeArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {pb.IWxShareAddJadeArg} message WxShareAddJadeArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareAddJadeArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxShareAddJadeArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxShareAddJadeArg} WxShareAddJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareAddJadeArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxShareAddJadeArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareTime = reader.int32();
                    break;
                case 2:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxShareAddJadeArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxShareAddJadeArg} WxShareAddJadeArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareAddJadeArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxShareAddJadeArg message.
         * @function verify
         * @memberof pb.WxShareAddJadeArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxShareAddJadeArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareTime != null && message.hasOwnProperty("ShareTime"))
                if (!$util.isInteger(message.ShareTime))
                    return "ShareTime: integer expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return WxShareAddJadeArg;
    })();

    pb.CancelWxShareArg = (function() {

        /**
         * Properties of a CancelWxShareArg.
         * @memberof pb
         * @interface ICancelWxShareArg
         * @property {number|null} [ShareID] CancelWxShareArg ShareID
         * @property {number|null} [ShareType] CancelWxShareArg ShareType
         */

        /**
         * Constructs a new CancelWxShareArg.
         * @memberof pb
         * @classdesc Represents a CancelWxShareArg.
         * @implements ICancelWxShareArg
         * @constructor
         * @param {pb.ICancelWxShareArg=} [properties] Properties to set
         */
        function CancelWxShareArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancelWxShareArg ShareID.
         * @member {number} ShareID
         * @memberof pb.CancelWxShareArg
         * @instance
         */
        CancelWxShareArg.prototype.ShareID = 0;

        /**
         * CancelWxShareArg ShareType.
         * @member {number} ShareType
         * @memberof pb.CancelWxShareArg
         * @instance
         */
        CancelWxShareArg.prototype.ShareType = 0;

        /**
         * Creates a new CancelWxShareArg instance using the specified properties.
         * @function create
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {pb.ICancelWxShareArg=} [properties] Properties to set
         * @returns {pb.CancelWxShareArg} CancelWxShareArg instance
         */
        CancelWxShareArg.create = function create(properties) {
            return new CancelWxShareArg(properties);
        };

        /**
         * Encodes the specified CancelWxShareArg message. Does not implicitly {@link pb.CancelWxShareArg.verify|verify} messages.
         * @function encode
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {pb.ICancelWxShareArg} message CancelWxShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelWxShareArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareID);
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ShareType);
            return writer;
        };

        /**
         * Encodes the specified CancelWxShareArg message, length delimited. Does not implicitly {@link pb.CancelWxShareArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {pb.ICancelWxShareArg} message CancelWxShareArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancelWxShareArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancelWxShareArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.CancelWxShareArg} CancelWxShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelWxShareArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.CancelWxShareArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareID = reader.int32();
                    break;
                case 2:
                    message.ShareType = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancelWxShareArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.CancelWxShareArg} CancelWxShareArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancelWxShareArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancelWxShareArg message.
         * @function verify
         * @memberof pb.CancelWxShareArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancelWxShareArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareID != null && message.hasOwnProperty("ShareID"))
                if (!$util.isInteger(message.ShareID))
                    return "ShareID: integer expected";
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                if (!$util.isInteger(message.ShareType))
                    return "ShareType: integer expected";
            return null;
        };

        return CancelWxShareArg;
    })();

    pb.WxShareBeHelpArg = (function() {

        /**
         * Properties of a WxShareBeHelpArg.
         * @memberof pb
         * @interface IWxShareBeHelpArg
         * @property {number|null} [ShareType] WxShareBeHelpArg ShareType
         * @property {Uint8Array|null} [Data] WxShareBeHelpArg Data
         */

        /**
         * Constructs a new WxShareBeHelpArg.
         * @memberof pb
         * @classdesc Represents a WxShareBeHelpArg.
         * @implements IWxShareBeHelpArg
         * @constructor
         * @param {pb.IWxShareBeHelpArg=} [properties] Properties to set
         */
        function WxShareBeHelpArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxShareBeHelpArg ShareType.
         * @member {number} ShareType
         * @memberof pb.WxShareBeHelpArg
         * @instance
         */
        WxShareBeHelpArg.prototype.ShareType = 0;

        /**
         * WxShareBeHelpArg Data.
         * @member {Uint8Array} Data
         * @memberof pb.WxShareBeHelpArg
         * @instance
         */
        WxShareBeHelpArg.prototype.Data = $util.newBuffer([]);

        /**
         * Creates a new WxShareBeHelpArg instance using the specified properties.
         * @function create
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {pb.IWxShareBeHelpArg=} [properties] Properties to set
         * @returns {pb.WxShareBeHelpArg} WxShareBeHelpArg instance
         */
        WxShareBeHelpArg.create = function create(properties) {
            return new WxShareBeHelpArg(properties);
        };

        /**
         * Encodes the specified WxShareBeHelpArg message. Does not implicitly {@link pb.WxShareBeHelpArg.verify|verify} messages.
         * @function encode
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {pb.IWxShareBeHelpArg} message WxShareBeHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareBeHelpArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ShareType);
            if (message.Data != null && message.hasOwnProperty("Data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.Data);
            return writer;
        };

        /**
         * Encodes the specified WxShareBeHelpArg message, length delimited. Does not implicitly {@link pb.WxShareBeHelpArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {pb.IWxShareBeHelpArg} message WxShareBeHelpArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareBeHelpArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxShareBeHelpArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxShareBeHelpArg} WxShareBeHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareBeHelpArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxShareBeHelpArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ShareType = reader.int32();
                    break;
                case 2:
                    message.Data = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxShareBeHelpArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxShareBeHelpArg} WxShareBeHelpArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareBeHelpArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxShareBeHelpArg message.
         * @function verify
         * @memberof pb.WxShareBeHelpArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxShareBeHelpArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ShareType != null && message.hasOwnProperty("ShareType"))
                if (!$util.isInteger(message.ShareType))
                    return "ShareType: integer expected";
            if (message.Data != null && message.hasOwnProperty("Data"))
                if (!(message.Data && typeof message.Data.length === "number" || $util.isString(message.Data)))
                    return "Data: buffer expected";
            return null;
        };

        return WxShareBeHelpArg;
    })();

    pb.IosShareReply = (function() {

        /**
         * Properties of an IosShareReply.
         * @memberof pb
         * @interface IIosShareReply
         * @property {number|null} [Jade] IosShareReply Jade
         * @property {number|null} [Bowlder] IosShareReply Bowlder
         */

        /**
         * Constructs a new IosShareReply.
         * @memberof pb
         * @classdesc Represents an IosShareReply.
         * @implements IIosShareReply
         * @constructor
         * @param {pb.IIosShareReply=} [properties] Properties to set
         */
        function IosShareReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * IosShareReply Jade.
         * @member {number} Jade
         * @memberof pb.IosShareReply
         * @instance
         */
        IosShareReply.prototype.Jade = 0;

        /**
         * IosShareReply Bowlder.
         * @member {number} Bowlder
         * @memberof pb.IosShareReply
         * @instance
         */
        IosShareReply.prototype.Bowlder = 0;

        /**
         * Creates a new IosShareReply instance using the specified properties.
         * @function create
         * @memberof pb.IosShareReply
         * @static
         * @param {pb.IIosShareReply=} [properties] Properties to set
         * @returns {pb.IosShareReply} IosShareReply instance
         */
        IosShareReply.create = function create(properties) {
            return new IosShareReply(properties);
        };

        /**
         * Encodes the specified IosShareReply message. Does not implicitly {@link pb.IosShareReply.verify|verify} messages.
         * @function encode
         * @memberof pb.IosShareReply
         * @static
         * @param {pb.IIosShareReply} message IosShareReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IosShareReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Jade);
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Bowlder);
            return writer;
        };

        /**
         * Encodes the specified IosShareReply message, length delimited. Does not implicitly {@link pb.IosShareReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.IosShareReply
         * @static
         * @param {pb.IIosShareReply} message IosShareReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        IosShareReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an IosShareReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.IosShareReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.IosShareReply} IosShareReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IosShareReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.IosShareReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Jade = reader.int32();
                    break;
                case 2:
                    message.Bowlder = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an IosShareReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.IosShareReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.IosShareReply} IosShareReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        IosShareReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an IosShareReply message.
         * @function verify
         * @memberof pb.IosShareReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        IosShareReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                if (!$util.isInteger(message.Bowlder))
                    return "Bowlder: integer expected";
            return null;
        };

        return IosShareReply;
    })();

    pb.WxShareAddJadeReply = (function() {

        /**
         * Properties of a WxShareAddJadeReply.
         * @memberof pb
         * @interface IWxShareAddJadeReply
         * @property {number|null} [Jade] WxShareAddJadeReply Jade
         * @property {number|null} [Bowlder] WxShareAddJadeReply Bowlder
         * @property {string|null} [PlayerName] WxShareAddJadeReply PlayerName
         */

        /**
         * Constructs a new WxShareAddJadeReply.
         * @memberof pb
         * @classdesc Represents a WxShareAddJadeReply.
         * @implements IWxShareAddJadeReply
         * @constructor
         * @param {pb.IWxShareAddJadeReply=} [properties] Properties to set
         */
        function WxShareAddJadeReply(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WxShareAddJadeReply Jade.
         * @member {number} Jade
         * @memberof pb.WxShareAddJadeReply
         * @instance
         */
        WxShareAddJadeReply.prototype.Jade = 0;

        /**
         * WxShareAddJadeReply Bowlder.
         * @member {number} Bowlder
         * @memberof pb.WxShareAddJadeReply
         * @instance
         */
        WxShareAddJadeReply.prototype.Bowlder = 0;

        /**
         * WxShareAddJadeReply PlayerName.
         * @member {string} PlayerName
         * @memberof pb.WxShareAddJadeReply
         * @instance
         */
        WxShareAddJadeReply.prototype.PlayerName = "";

        /**
         * Creates a new WxShareAddJadeReply instance using the specified properties.
         * @function create
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {pb.IWxShareAddJadeReply=} [properties] Properties to set
         * @returns {pb.WxShareAddJadeReply} WxShareAddJadeReply instance
         */
        WxShareAddJadeReply.create = function create(properties) {
            return new WxShareAddJadeReply(properties);
        };

        /**
         * Encodes the specified WxShareAddJadeReply message. Does not implicitly {@link pb.WxShareAddJadeReply.verify|verify} messages.
         * @function encode
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {pb.IWxShareAddJadeReply} message WxShareAddJadeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareAddJadeReply.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.Jade);
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.Bowlder);
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.PlayerName);
            return writer;
        };

        /**
         * Encodes the specified WxShareAddJadeReply message, length delimited. Does not implicitly {@link pb.WxShareAddJadeReply.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {pb.IWxShareAddJadeReply} message WxShareAddJadeReply message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WxShareAddJadeReply.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WxShareAddJadeReply message from the specified reader or buffer.
         * @function decode
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.WxShareAddJadeReply} WxShareAddJadeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareAddJadeReply.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.WxShareAddJadeReply();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.Jade = reader.int32();
                    break;
                case 2:
                    message.Bowlder = reader.int32();
                    break;
                case 3:
                    message.PlayerName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WxShareAddJadeReply message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.WxShareAddJadeReply} WxShareAddJadeReply
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WxShareAddJadeReply.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WxShareAddJadeReply message.
         * @function verify
         * @memberof pb.WxShareAddJadeReply
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WxShareAddJadeReply.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.Jade != null && message.hasOwnProperty("Jade"))
                if (!$util.isInteger(message.Jade))
                    return "Jade: integer expected";
            if (message.Bowlder != null && message.hasOwnProperty("Bowlder"))
                if (!$util.isInteger(message.Bowlder))
                    return "Bowlder: integer expected";
            if (message.PlayerName != null && message.hasOwnProperty("PlayerName"))
                if (!$util.isString(message.PlayerName))
                    return "PlayerName: string expected";
            return null;
        };

        return WxShareAddJadeReply;
    })();

    pb.G2GReplyWxInviteBattleArg = (function() {

        /**
         * Properties of a G2GReplyWxInviteBattleArg.
         * @memberof pb
         * @interface IG2GReplyWxInviteBattleArg
         * @property {number|Long|null} [InviteUid] G2GReplyWxInviteBattleArg InviteUid
         * @property {pb.IFighterData|null} [BeInviter] G2GReplyWxInviteBattleArg BeInviter
         */

        /**
         * Constructs a new G2GReplyWxInviteBattleArg.
         * @memberof pb
         * @classdesc Represents a G2GReplyWxInviteBattleArg.
         * @implements IG2GReplyWxInviteBattleArg
         * @constructor
         * @param {pb.IG2GReplyWxInviteBattleArg=} [properties] Properties to set
         */
        function G2GReplyWxInviteBattleArg(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * G2GReplyWxInviteBattleArg InviteUid.
         * @member {number|Long} InviteUid
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @instance
         */
        G2GReplyWxInviteBattleArg.prototype.InviteUid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * G2GReplyWxInviteBattleArg BeInviter.
         * @member {pb.IFighterData|null|undefined} BeInviter
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @instance
         */
        G2GReplyWxInviteBattleArg.prototype.BeInviter = null;

        /**
         * Creates a new G2GReplyWxInviteBattleArg instance using the specified properties.
         * @function create
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {pb.IG2GReplyWxInviteBattleArg=} [properties] Properties to set
         * @returns {pb.G2GReplyWxInviteBattleArg} G2GReplyWxInviteBattleArg instance
         */
        G2GReplyWxInviteBattleArg.create = function create(properties) {
            return new G2GReplyWxInviteBattleArg(properties);
        };

        /**
         * Encodes the specified G2GReplyWxInviteBattleArg message. Does not implicitly {@link pb.G2GReplyWxInviteBattleArg.verify|verify} messages.
         * @function encode
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {pb.IG2GReplyWxInviteBattleArg} message G2GReplyWxInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2GReplyWxInviteBattleArg.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.InviteUid != null && message.hasOwnProperty("InviteUid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.InviteUid);
            if (message.BeInviter != null && message.hasOwnProperty("BeInviter"))
                $root.pb.FighterData.encode(message.BeInviter, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified G2GReplyWxInviteBattleArg message, length delimited. Does not implicitly {@link pb.G2GReplyWxInviteBattleArg.verify|verify} messages.
         * @function encodeDelimited
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {pb.IG2GReplyWxInviteBattleArg} message G2GReplyWxInviteBattleArg message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        G2GReplyWxInviteBattleArg.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a G2GReplyWxInviteBattleArg message from the specified reader or buffer.
         * @function decode
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {pb.G2GReplyWxInviteBattleArg} G2GReplyWxInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2GReplyWxInviteBattleArg.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.pb.G2GReplyWxInviteBattleArg();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.InviteUid = reader.uint64();
                    break;
                case 2:
                    message.BeInviter = $root.pb.FighterData.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a G2GReplyWxInviteBattleArg message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {pb.G2GReplyWxInviteBattleArg} G2GReplyWxInviteBattleArg
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        G2GReplyWxInviteBattleArg.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a G2GReplyWxInviteBattleArg message.
         * @function verify
         * @memberof pb.G2GReplyWxInviteBattleArg
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        G2GReplyWxInviteBattleArg.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.InviteUid != null && message.hasOwnProperty("InviteUid"))
                if (!$util.isInteger(message.InviteUid) && !(message.InviteUid && $util.isInteger(message.InviteUid.low) && $util.isInteger(message.InviteUid.high)))
                    return "InviteUid: integer|Long expected";
            if (message.BeInviter != null && message.hasOwnProperty("BeInviter")) {
                var error = $root.pb.FighterData.verify(message.BeInviter);
                if (error)
                    return "BeInviter." + error;
            }
            return null;
        };

        return G2GReplyWxInviteBattleArg;
    })();

    return pb;
})();